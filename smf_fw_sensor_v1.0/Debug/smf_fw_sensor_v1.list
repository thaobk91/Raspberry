
smf_fw_sensor_v1.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000c350  08000190  08000190  00010190  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000ff8  0800c4e0  0800c4e0  0001c4e0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  0800d4d8  0800d4d8  0001d4d8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000004  0800d4e0  0800d4e0  0001d4e0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000004  0800d4e4  0800d4e4  0001d4e4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         000006cc  20000000  0800d4e8  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          000086b0  200006cc  0800dbb4  000206cc  2**2
                  ALLOC
  8 ._user_heap_stack 00000600  20008d7c  0800dbb4  00028d7c  2**0
                  ALLOC
  9 .ARM.attributes 00000030  00000000  00000000  000206cc  2**0
                  CONTENTS, READONLY
 10 .debug_info   00037676  00000000  00000000  000206fc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 000075c5  00000000  00000000  00057d72  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00014b17  00000000  00000000  0005f337  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_aranges 00001be0  00000000  00000000  00073e50  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 000023c0  00000000  00000000  00075a30  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   00010e26  00000000  00000000  00077df0  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    00009e27  00000000  00000000  00088c16  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .comment      0000007c  00000000  00000000  00092a3d  2**0
                  CONTENTS, READONLY
 18 .debug_frame  000062a0  00000000  00000000  00092abc  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000190 <__do_global_dtors_aux>:
 8000190:	b510      	push	{r4, lr}
 8000192:	4c05      	ldr	r4, [pc, #20]	; (80001a8 <__do_global_dtors_aux+0x18>)
 8000194:	7823      	ldrb	r3, [r4, #0]
 8000196:	b933      	cbnz	r3, 80001a6 <__do_global_dtors_aux+0x16>
 8000198:	4b04      	ldr	r3, [pc, #16]	; (80001ac <__do_global_dtors_aux+0x1c>)
 800019a:	b113      	cbz	r3, 80001a2 <__do_global_dtors_aux+0x12>
 800019c:	4804      	ldr	r0, [pc, #16]	; (80001b0 <__do_global_dtors_aux+0x20>)
 800019e:	f3af 8000 	nop.w
 80001a2:	2301      	movs	r3, #1
 80001a4:	7023      	strb	r3, [r4, #0]
 80001a6:	bd10      	pop	{r4, pc}
 80001a8:	200006cc 	.word	0x200006cc
 80001ac:	00000000 	.word	0x00000000
 80001b0:	0800c4c8 	.word	0x0800c4c8

080001b4 <frame_dummy>:
 80001b4:	b508      	push	{r3, lr}
 80001b6:	4b03      	ldr	r3, [pc, #12]	; (80001c4 <frame_dummy+0x10>)
 80001b8:	b11b      	cbz	r3, 80001c2 <frame_dummy+0xe>
 80001ba:	4903      	ldr	r1, [pc, #12]	; (80001c8 <frame_dummy+0x14>)
 80001bc:	4803      	ldr	r0, [pc, #12]	; (80001cc <frame_dummy+0x18>)
 80001be:	f3af 8000 	nop.w
 80001c2:	bd08      	pop	{r3, pc}
 80001c4:	00000000 	.word	0x00000000
 80001c8:	200006d0 	.word	0x200006d0
 80001cc:	0800c4c8 	.word	0x0800c4c8

080001d0 <strcmp>:
 80001d0:	f810 2b01 	ldrb.w	r2, [r0], #1
 80001d4:	f811 3b01 	ldrb.w	r3, [r1], #1
 80001d8:	2a01      	cmp	r2, #1
 80001da:	bf28      	it	cs
 80001dc:	429a      	cmpcs	r2, r3
 80001de:	d0f7      	beq.n	80001d0 <strcmp>
 80001e0:	1ad0      	subs	r0, r2, r3
 80001e2:	4770      	bx	lr

080001e4 <strlen>:
 80001e4:	4603      	mov	r3, r0
 80001e6:	f813 2b01 	ldrb.w	r2, [r3], #1
 80001ea:	2a00      	cmp	r2, #0
 80001ec:	d1fb      	bne.n	80001e6 <strlen+0x2>
 80001ee:	1a18      	subs	r0, r3, r0
 80001f0:	3801      	subs	r0, #1
 80001f2:	4770      	bx	lr
	...

08000200 <memchr>:
 8000200:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000204:	2a10      	cmp	r2, #16
 8000206:	db2b      	blt.n	8000260 <memchr+0x60>
 8000208:	f010 0f07 	tst.w	r0, #7
 800020c:	d008      	beq.n	8000220 <memchr+0x20>
 800020e:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000212:	3a01      	subs	r2, #1
 8000214:	428b      	cmp	r3, r1
 8000216:	d02d      	beq.n	8000274 <memchr+0x74>
 8000218:	f010 0f07 	tst.w	r0, #7
 800021c:	b342      	cbz	r2, 8000270 <memchr+0x70>
 800021e:	d1f6      	bne.n	800020e <memchr+0xe>
 8000220:	b4f0      	push	{r4, r5, r6, r7}
 8000222:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8000226:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800022a:	f022 0407 	bic.w	r4, r2, #7
 800022e:	f07f 0700 	mvns.w	r7, #0
 8000232:	2300      	movs	r3, #0
 8000234:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8000238:	3c08      	subs	r4, #8
 800023a:	ea85 0501 	eor.w	r5, r5, r1
 800023e:	ea86 0601 	eor.w	r6, r6, r1
 8000242:	fa85 f547 	uadd8	r5, r5, r7
 8000246:	faa3 f587 	sel	r5, r3, r7
 800024a:	fa86 f647 	uadd8	r6, r6, r7
 800024e:	faa5 f687 	sel	r6, r5, r7
 8000252:	b98e      	cbnz	r6, 8000278 <memchr+0x78>
 8000254:	d1ee      	bne.n	8000234 <memchr+0x34>
 8000256:	bcf0      	pop	{r4, r5, r6, r7}
 8000258:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800025c:	f002 0207 	and.w	r2, r2, #7
 8000260:	b132      	cbz	r2, 8000270 <memchr+0x70>
 8000262:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000266:	3a01      	subs	r2, #1
 8000268:	ea83 0301 	eor.w	r3, r3, r1
 800026c:	b113      	cbz	r3, 8000274 <memchr+0x74>
 800026e:	d1f8      	bne.n	8000262 <memchr+0x62>
 8000270:	2000      	movs	r0, #0
 8000272:	4770      	bx	lr
 8000274:	3801      	subs	r0, #1
 8000276:	4770      	bx	lr
 8000278:	2d00      	cmp	r5, #0
 800027a:	bf06      	itte	eq
 800027c:	4635      	moveq	r5, r6
 800027e:	3803      	subeq	r0, #3
 8000280:	3807      	subne	r0, #7
 8000282:	f015 0f01 	tst.w	r5, #1
 8000286:	d107      	bne.n	8000298 <memchr+0x98>
 8000288:	3001      	adds	r0, #1
 800028a:	f415 7f80 	tst.w	r5, #256	; 0x100
 800028e:	bf02      	ittt	eq
 8000290:	3001      	addeq	r0, #1
 8000292:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 8000296:	3001      	addeq	r0, #1
 8000298:	bcf0      	pop	{r4, r5, r6, r7}
 800029a:	3801      	subs	r0, #1
 800029c:	4770      	bx	lr
 800029e:	bf00      	nop

080002a0 <__aeabi_drsub>:
 80002a0:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 80002a4:	e002      	b.n	80002ac <__adddf3>
 80002a6:	bf00      	nop

080002a8 <__aeabi_dsub>:
 80002a8:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

080002ac <__adddf3>:
 80002ac:	b530      	push	{r4, r5, lr}
 80002ae:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80002b2:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80002b6:	ea94 0f05 	teq	r4, r5
 80002ba:	bf08      	it	eq
 80002bc:	ea90 0f02 	teqeq	r0, r2
 80002c0:	bf1f      	itttt	ne
 80002c2:	ea54 0c00 	orrsne.w	ip, r4, r0
 80002c6:	ea55 0c02 	orrsne.w	ip, r5, r2
 80002ca:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 80002ce:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80002d2:	f000 80e2 	beq.w	800049a <__adddf3+0x1ee>
 80002d6:	ea4f 5454 	mov.w	r4, r4, lsr #21
 80002da:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 80002de:	bfb8      	it	lt
 80002e0:	426d      	neglt	r5, r5
 80002e2:	dd0c      	ble.n	80002fe <__adddf3+0x52>
 80002e4:	442c      	add	r4, r5
 80002e6:	ea80 0202 	eor.w	r2, r0, r2
 80002ea:	ea81 0303 	eor.w	r3, r1, r3
 80002ee:	ea82 0000 	eor.w	r0, r2, r0
 80002f2:	ea83 0101 	eor.w	r1, r3, r1
 80002f6:	ea80 0202 	eor.w	r2, r0, r2
 80002fa:	ea81 0303 	eor.w	r3, r1, r3
 80002fe:	2d36      	cmp	r5, #54	; 0x36
 8000300:	bf88      	it	hi
 8000302:	bd30      	pophi	{r4, r5, pc}
 8000304:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000308:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800030c:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8000310:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8000314:	d002      	beq.n	800031c <__adddf3+0x70>
 8000316:	4240      	negs	r0, r0
 8000318:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800031c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8000320:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000324:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000328:	d002      	beq.n	8000330 <__adddf3+0x84>
 800032a:	4252      	negs	r2, r2
 800032c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000330:	ea94 0f05 	teq	r4, r5
 8000334:	f000 80a7 	beq.w	8000486 <__adddf3+0x1da>
 8000338:	f1a4 0401 	sub.w	r4, r4, #1
 800033c:	f1d5 0e20 	rsbs	lr, r5, #32
 8000340:	db0d      	blt.n	800035e <__adddf3+0xb2>
 8000342:	fa02 fc0e 	lsl.w	ip, r2, lr
 8000346:	fa22 f205 	lsr.w	r2, r2, r5
 800034a:	1880      	adds	r0, r0, r2
 800034c:	f141 0100 	adc.w	r1, r1, #0
 8000350:	fa03 f20e 	lsl.w	r2, r3, lr
 8000354:	1880      	adds	r0, r0, r2
 8000356:	fa43 f305 	asr.w	r3, r3, r5
 800035a:	4159      	adcs	r1, r3
 800035c:	e00e      	b.n	800037c <__adddf3+0xd0>
 800035e:	f1a5 0520 	sub.w	r5, r5, #32
 8000362:	f10e 0e20 	add.w	lr, lr, #32
 8000366:	2a01      	cmp	r2, #1
 8000368:	fa03 fc0e 	lsl.w	ip, r3, lr
 800036c:	bf28      	it	cs
 800036e:	f04c 0c02 	orrcs.w	ip, ip, #2
 8000372:	fa43 f305 	asr.w	r3, r3, r5
 8000376:	18c0      	adds	r0, r0, r3
 8000378:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 800037c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000380:	d507      	bpl.n	8000392 <__adddf3+0xe6>
 8000382:	f04f 0e00 	mov.w	lr, #0
 8000386:	f1dc 0c00 	rsbs	ip, ip, #0
 800038a:	eb7e 0000 	sbcs.w	r0, lr, r0
 800038e:	eb6e 0101 	sbc.w	r1, lr, r1
 8000392:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 8000396:	d31b      	bcc.n	80003d0 <__adddf3+0x124>
 8000398:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 800039c:	d30c      	bcc.n	80003b8 <__adddf3+0x10c>
 800039e:	0849      	lsrs	r1, r1, #1
 80003a0:	ea5f 0030 	movs.w	r0, r0, rrx
 80003a4:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80003a8:	f104 0401 	add.w	r4, r4, #1
 80003ac:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80003b0:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 80003b4:	f080 809a 	bcs.w	80004ec <__adddf3+0x240>
 80003b8:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 80003bc:	bf08      	it	eq
 80003be:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80003c2:	f150 0000 	adcs.w	r0, r0, #0
 80003c6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80003ca:	ea41 0105 	orr.w	r1, r1, r5
 80003ce:	bd30      	pop	{r4, r5, pc}
 80003d0:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 80003d4:	4140      	adcs	r0, r0
 80003d6:	eb41 0101 	adc.w	r1, r1, r1
 80003da:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80003de:	f1a4 0401 	sub.w	r4, r4, #1
 80003e2:	d1e9      	bne.n	80003b8 <__adddf3+0x10c>
 80003e4:	f091 0f00 	teq	r1, #0
 80003e8:	bf04      	itt	eq
 80003ea:	4601      	moveq	r1, r0
 80003ec:	2000      	moveq	r0, #0
 80003ee:	fab1 f381 	clz	r3, r1
 80003f2:	bf08      	it	eq
 80003f4:	3320      	addeq	r3, #32
 80003f6:	f1a3 030b 	sub.w	r3, r3, #11
 80003fa:	f1b3 0220 	subs.w	r2, r3, #32
 80003fe:	da0c      	bge.n	800041a <__adddf3+0x16e>
 8000400:	320c      	adds	r2, #12
 8000402:	dd08      	ble.n	8000416 <__adddf3+0x16a>
 8000404:	f102 0c14 	add.w	ip, r2, #20
 8000408:	f1c2 020c 	rsb	r2, r2, #12
 800040c:	fa01 f00c 	lsl.w	r0, r1, ip
 8000410:	fa21 f102 	lsr.w	r1, r1, r2
 8000414:	e00c      	b.n	8000430 <__adddf3+0x184>
 8000416:	f102 0214 	add.w	r2, r2, #20
 800041a:	bfd8      	it	le
 800041c:	f1c2 0c20 	rsble	ip, r2, #32
 8000420:	fa01 f102 	lsl.w	r1, r1, r2
 8000424:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000428:	bfdc      	itt	le
 800042a:	ea41 010c 	orrle.w	r1, r1, ip
 800042e:	4090      	lslle	r0, r2
 8000430:	1ae4      	subs	r4, r4, r3
 8000432:	bfa2      	ittt	ge
 8000434:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000438:	4329      	orrge	r1, r5
 800043a:	bd30      	popge	{r4, r5, pc}
 800043c:	ea6f 0404 	mvn.w	r4, r4
 8000440:	3c1f      	subs	r4, #31
 8000442:	da1c      	bge.n	800047e <__adddf3+0x1d2>
 8000444:	340c      	adds	r4, #12
 8000446:	dc0e      	bgt.n	8000466 <__adddf3+0x1ba>
 8000448:	f104 0414 	add.w	r4, r4, #20
 800044c:	f1c4 0220 	rsb	r2, r4, #32
 8000450:	fa20 f004 	lsr.w	r0, r0, r4
 8000454:	fa01 f302 	lsl.w	r3, r1, r2
 8000458:	ea40 0003 	orr.w	r0, r0, r3
 800045c:	fa21 f304 	lsr.w	r3, r1, r4
 8000460:	ea45 0103 	orr.w	r1, r5, r3
 8000464:	bd30      	pop	{r4, r5, pc}
 8000466:	f1c4 040c 	rsb	r4, r4, #12
 800046a:	f1c4 0220 	rsb	r2, r4, #32
 800046e:	fa20 f002 	lsr.w	r0, r0, r2
 8000472:	fa01 f304 	lsl.w	r3, r1, r4
 8000476:	ea40 0003 	orr.w	r0, r0, r3
 800047a:	4629      	mov	r1, r5
 800047c:	bd30      	pop	{r4, r5, pc}
 800047e:	fa21 f004 	lsr.w	r0, r1, r4
 8000482:	4629      	mov	r1, r5
 8000484:	bd30      	pop	{r4, r5, pc}
 8000486:	f094 0f00 	teq	r4, #0
 800048a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 800048e:	bf06      	itte	eq
 8000490:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 8000494:	3401      	addeq	r4, #1
 8000496:	3d01      	subne	r5, #1
 8000498:	e74e      	b.n	8000338 <__adddf3+0x8c>
 800049a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800049e:	bf18      	it	ne
 80004a0:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80004a4:	d029      	beq.n	80004fa <__adddf3+0x24e>
 80004a6:	ea94 0f05 	teq	r4, r5
 80004aa:	bf08      	it	eq
 80004ac:	ea90 0f02 	teqeq	r0, r2
 80004b0:	d005      	beq.n	80004be <__adddf3+0x212>
 80004b2:	ea54 0c00 	orrs.w	ip, r4, r0
 80004b6:	bf04      	itt	eq
 80004b8:	4619      	moveq	r1, r3
 80004ba:	4610      	moveq	r0, r2
 80004bc:	bd30      	pop	{r4, r5, pc}
 80004be:	ea91 0f03 	teq	r1, r3
 80004c2:	bf1e      	ittt	ne
 80004c4:	2100      	movne	r1, #0
 80004c6:	2000      	movne	r0, #0
 80004c8:	bd30      	popne	{r4, r5, pc}
 80004ca:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 80004ce:	d105      	bne.n	80004dc <__adddf3+0x230>
 80004d0:	0040      	lsls	r0, r0, #1
 80004d2:	4149      	adcs	r1, r1
 80004d4:	bf28      	it	cs
 80004d6:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 80004da:	bd30      	pop	{r4, r5, pc}
 80004dc:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 80004e0:	bf3c      	itt	cc
 80004e2:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 80004e6:	bd30      	popcc	{r4, r5, pc}
 80004e8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80004ec:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 80004f0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80004f4:	f04f 0000 	mov.w	r0, #0
 80004f8:	bd30      	pop	{r4, r5, pc}
 80004fa:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80004fe:	bf1a      	itte	ne
 8000500:	4619      	movne	r1, r3
 8000502:	4610      	movne	r0, r2
 8000504:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8000508:	bf1c      	itt	ne
 800050a:	460b      	movne	r3, r1
 800050c:	4602      	movne	r2, r0
 800050e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000512:	bf06      	itte	eq
 8000514:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000518:	ea91 0f03 	teqeq	r1, r3
 800051c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8000520:	bd30      	pop	{r4, r5, pc}
 8000522:	bf00      	nop

08000524 <__aeabi_ui2d>:
 8000524:	f090 0f00 	teq	r0, #0
 8000528:	bf04      	itt	eq
 800052a:	2100      	moveq	r1, #0
 800052c:	4770      	bxeq	lr
 800052e:	b530      	push	{r4, r5, lr}
 8000530:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000534:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000538:	f04f 0500 	mov.w	r5, #0
 800053c:	f04f 0100 	mov.w	r1, #0
 8000540:	e750      	b.n	80003e4 <__adddf3+0x138>
 8000542:	bf00      	nop

08000544 <__aeabi_i2d>:
 8000544:	f090 0f00 	teq	r0, #0
 8000548:	bf04      	itt	eq
 800054a:	2100      	moveq	r1, #0
 800054c:	4770      	bxeq	lr
 800054e:	b530      	push	{r4, r5, lr}
 8000550:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000554:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000558:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 800055c:	bf48      	it	mi
 800055e:	4240      	negmi	r0, r0
 8000560:	f04f 0100 	mov.w	r1, #0
 8000564:	e73e      	b.n	80003e4 <__adddf3+0x138>
 8000566:	bf00      	nop

08000568 <__aeabi_f2d>:
 8000568:	0042      	lsls	r2, r0, #1
 800056a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 800056e:	ea4f 0131 	mov.w	r1, r1, rrx
 8000572:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8000576:	bf1f      	itttt	ne
 8000578:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 800057c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8000580:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 8000584:	4770      	bxne	lr
 8000586:	f092 0f00 	teq	r2, #0
 800058a:	bf14      	ite	ne
 800058c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8000590:	4770      	bxeq	lr
 8000592:	b530      	push	{r4, r5, lr}
 8000594:	f44f 7460 	mov.w	r4, #896	; 0x380
 8000598:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800059c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80005a0:	e720      	b.n	80003e4 <__adddf3+0x138>
 80005a2:	bf00      	nop

080005a4 <__aeabi_ul2d>:
 80005a4:	ea50 0201 	orrs.w	r2, r0, r1
 80005a8:	bf08      	it	eq
 80005aa:	4770      	bxeq	lr
 80005ac:	b530      	push	{r4, r5, lr}
 80005ae:	f04f 0500 	mov.w	r5, #0
 80005b2:	e00a      	b.n	80005ca <__aeabi_l2d+0x16>

080005b4 <__aeabi_l2d>:
 80005b4:	ea50 0201 	orrs.w	r2, r0, r1
 80005b8:	bf08      	it	eq
 80005ba:	4770      	bxeq	lr
 80005bc:	b530      	push	{r4, r5, lr}
 80005be:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 80005c2:	d502      	bpl.n	80005ca <__aeabi_l2d+0x16>
 80005c4:	4240      	negs	r0, r0
 80005c6:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80005ca:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80005ce:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80005d2:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 80005d6:	f43f aedc 	beq.w	8000392 <__adddf3+0xe6>
 80005da:	f04f 0203 	mov.w	r2, #3
 80005de:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80005e2:	bf18      	it	ne
 80005e4:	3203      	addne	r2, #3
 80005e6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80005ea:	bf18      	it	ne
 80005ec:	3203      	addne	r2, #3
 80005ee:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 80005f2:	f1c2 0320 	rsb	r3, r2, #32
 80005f6:	fa00 fc03 	lsl.w	ip, r0, r3
 80005fa:	fa20 f002 	lsr.w	r0, r0, r2
 80005fe:	fa01 fe03 	lsl.w	lr, r1, r3
 8000602:	ea40 000e 	orr.w	r0, r0, lr
 8000606:	fa21 f102 	lsr.w	r1, r1, r2
 800060a:	4414      	add	r4, r2
 800060c:	e6c1      	b.n	8000392 <__adddf3+0xe6>
 800060e:	bf00      	nop

08000610 <__aeabi_dmul>:
 8000610:	b570      	push	{r4, r5, r6, lr}
 8000612:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000616:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800061a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800061e:	bf1d      	ittte	ne
 8000620:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000624:	ea94 0f0c 	teqne	r4, ip
 8000628:	ea95 0f0c 	teqne	r5, ip
 800062c:	f000 f8de 	bleq	80007ec <__aeabi_dmul+0x1dc>
 8000630:	442c      	add	r4, r5
 8000632:	ea81 0603 	eor.w	r6, r1, r3
 8000636:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 800063a:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 800063e:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 8000642:	bf18      	it	ne
 8000644:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8000648:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800064c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8000650:	d038      	beq.n	80006c4 <__aeabi_dmul+0xb4>
 8000652:	fba0 ce02 	umull	ip, lr, r0, r2
 8000656:	f04f 0500 	mov.w	r5, #0
 800065a:	fbe1 e502 	umlal	lr, r5, r1, r2
 800065e:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 8000662:	fbe0 e503 	umlal	lr, r5, r0, r3
 8000666:	f04f 0600 	mov.w	r6, #0
 800066a:	fbe1 5603 	umlal	r5, r6, r1, r3
 800066e:	f09c 0f00 	teq	ip, #0
 8000672:	bf18      	it	ne
 8000674:	f04e 0e01 	orrne.w	lr, lr, #1
 8000678:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 800067c:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 8000680:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 8000684:	d204      	bcs.n	8000690 <__aeabi_dmul+0x80>
 8000686:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 800068a:	416d      	adcs	r5, r5
 800068c:	eb46 0606 	adc.w	r6, r6, r6
 8000690:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 8000694:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 8000698:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 800069c:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 80006a0:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 80006a4:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80006a8:	bf88      	it	hi
 80006aa:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80006ae:	d81e      	bhi.n	80006ee <__aeabi_dmul+0xde>
 80006b0:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 80006b4:	bf08      	it	eq
 80006b6:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 80006ba:	f150 0000 	adcs.w	r0, r0, #0
 80006be:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80006c2:	bd70      	pop	{r4, r5, r6, pc}
 80006c4:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 80006c8:	ea46 0101 	orr.w	r1, r6, r1
 80006cc:	ea40 0002 	orr.w	r0, r0, r2
 80006d0:	ea81 0103 	eor.w	r1, r1, r3
 80006d4:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 80006d8:	bfc2      	ittt	gt
 80006da:	ebd4 050c 	rsbsgt	r5, r4, ip
 80006de:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80006e2:	bd70      	popgt	{r4, r5, r6, pc}
 80006e4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80006e8:	f04f 0e00 	mov.w	lr, #0
 80006ec:	3c01      	subs	r4, #1
 80006ee:	f300 80ab 	bgt.w	8000848 <__aeabi_dmul+0x238>
 80006f2:	f114 0f36 	cmn.w	r4, #54	; 0x36
 80006f6:	bfde      	ittt	le
 80006f8:	2000      	movle	r0, #0
 80006fa:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 80006fe:	bd70      	pople	{r4, r5, r6, pc}
 8000700:	f1c4 0400 	rsb	r4, r4, #0
 8000704:	3c20      	subs	r4, #32
 8000706:	da35      	bge.n	8000774 <__aeabi_dmul+0x164>
 8000708:	340c      	adds	r4, #12
 800070a:	dc1b      	bgt.n	8000744 <__aeabi_dmul+0x134>
 800070c:	f104 0414 	add.w	r4, r4, #20
 8000710:	f1c4 0520 	rsb	r5, r4, #32
 8000714:	fa00 f305 	lsl.w	r3, r0, r5
 8000718:	fa20 f004 	lsr.w	r0, r0, r4
 800071c:	fa01 f205 	lsl.w	r2, r1, r5
 8000720:	ea40 0002 	orr.w	r0, r0, r2
 8000724:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8000728:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800072c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000730:	fa21 f604 	lsr.w	r6, r1, r4
 8000734:	eb42 0106 	adc.w	r1, r2, r6
 8000738:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800073c:	bf08      	it	eq
 800073e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000742:	bd70      	pop	{r4, r5, r6, pc}
 8000744:	f1c4 040c 	rsb	r4, r4, #12
 8000748:	f1c4 0520 	rsb	r5, r4, #32
 800074c:	fa00 f304 	lsl.w	r3, r0, r4
 8000750:	fa20 f005 	lsr.w	r0, r0, r5
 8000754:	fa01 f204 	lsl.w	r2, r1, r4
 8000758:	ea40 0002 	orr.w	r0, r0, r2
 800075c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000760:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000764:	f141 0100 	adc.w	r1, r1, #0
 8000768:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800076c:	bf08      	it	eq
 800076e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000772:	bd70      	pop	{r4, r5, r6, pc}
 8000774:	f1c4 0520 	rsb	r5, r4, #32
 8000778:	fa00 f205 	lsl.w	r2, r0, r5
 800077c:	ea4e 0e02 	orr.w	lr, lr, r2
 8000780:	fa20 f304 	lsr.w	r3, r0, r4
 8000784:	fa01 f205 	lsl.w	r2, r1, r5
 8000788:	ea43 0302 	orr.w	r3, r3, r2
 800078c:	fa21 f004 	lsr.w	r0, r1, r4
 8000790:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000794:	fa21 f204 	lsr.w	r2, r1, r4
 8000798:	ea20 0002 	bic.w	r0, r0, r2
 800079c:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 80007a0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80007a4:	bf08      	it	eq
 80007a6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80007aa:	bd70      	pop	{r4, r5, r6, pc}
 80007ac:	f094 0f00 	teq	r4, #0
 80007b0:	d10f      	bne.n	80007d2 <__aeabi_dmul+0x1c2>
 80007b2:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 80007b6:	0040      	lsls	r0, r0, #1
 80007b8:	eb41 0101 	adc.w	r1, r1, r1
 80007bc:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80007c0:	bf08      	it	eq
 80007c2:	3c01      	subeq	r4, #1
 80007c4:	d0f7      	beq.n	80007b6 <__aeabi_dmul+0x1a6>
 80007c6:	ea41 0106 	orr.w	r1, r1, r6
 80007ca:	f095 0f00 	teq	r5, #0
 80007ce:	bf18      	it	ne
 80007d0:	4770      	bxne	lr
 80007d2:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 80007d6:	0052      	lsls	r2, r2, #1
 80007d8:	eb43 0303 	adc.w	r3, r3, r3
 80007dc:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 80007e0:	bf08      	it	eq
 80007e2:	3d01      	subeq	r5, #1
 80007e4:	d0f7      	beq.n	80007d6 <__aeabi_dmul+0x1c6>
 80007e6:	ea43 0306 	orr.w	r3, r3, r6
 80007ea:	4770      	bx	lr
 80007ec:	ea94 0f0c 	teq	r4, ip
 80007f0:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80007f4:	bf18      	it	ne
 80007f6:	ea95 0f0c 	teqne	r5, ip
 80007fa:	d00c      	beq.n	8000816 <__aeabi_dmul+0x206>
 80007fc:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000800:	bf18      	it	ne
 8000802:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000806:	d1d1      	bne.n	80007ac <__aeabi_dmul+0x19c>
 8000808:	ea81 0103 	eor.w	r1, r1, r3
 800080c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000810:	f04f 0000 	mov.w	r0, #0
 8000814:	bd70      	pop	{r4, r5, r6, pc}
 8000816:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800081a:	bf06      	itte	eq
 800081c:	4610      	moveq	r0, r2
 800081e:	4619      	moveq	r1, r3
 8000820:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000824:	d019      	beq.n	800085a <__aeabi_dmul+0x24a>
 8000826:	ea94 0f0c 	teq	r4, ip
 800082a:	d102      	bne.n	8000832 <__aeabi_dmul+0x222>
 800082c:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8000830:	d113      	bne.n	800085a <__aeabi_dmul+0x24a>
 8000832:	ea95 0f0c 	teq	r5, ip
 8000836:	d105      	bne.n	8000844 <__aeabi_dmul+0x234>
 8000838:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 800083c:	bf1c      	itt	ne
 800083e:	4610      	movne	r0, r2
 8000840:	4619      	movne	r1, r3
 8000842:	d10a      	bne.n	800085a <__aeabi_dmul+0x24a>
 8000844:	ea81 0103 	eor.w	r1, r1, r3
 8000848:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800084c:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000850:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000854:	f04f 0000 	mov.w	r0, #0
 8000858:	bd70      	pop	{r4, r5, r6, pc}
 800085a:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800085e:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 8000862:	bd70      	pop	{r4, r5, r6, pc}

08000864 <__aeabi_ddiv>:
 8000864:	b570      	push	{r4, r5, r6, lr}
 8000866:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800086a:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800086e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8000872:	bf1d      	ittte	ne
 8000874:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000878:	ea94 0f0c 	teqne	r4, ip
 800087c:	ea95 0f0c 	teqne	r5, ip
 8000880:	f000 f8a7 	bleq	80009d2 <__aeabi_ddiv+0x16e>
 8000884:	eba4 0405 	sub.w	r4, r4, r5
 8000888:	ea81 0e03 	eor.w	lr, r1, r3
 800088c:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000890:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8000894:	f000 8088 	beq.w	80009a8 <__aeabi_ddiv+0x144>
 8000898:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800089c:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 80008a0:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 80008a4:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 80008a8:	ea4f 2202 	mov.w	r2, r2, lsl #8
 80008ac:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 80008b0:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 80008b4:	ea4f 2600 	mov.w	r6, r0, lsl #8
 80008b8:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 80008bc:	429d      	cmp	r5, r3
 80008be:	bf08      	it	eq
 80008c0:	4296      	cmpeq	r6, r2
 80008c2:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 80008c6:	f504 7440 	add.w	r4, r4, #768	; 0x300
 80008ca:	d202      	bcs.n	80008d2 <__aeabi_ddiv+0x6e>
 80008cc:	085b      	lsrs	r3, r3, #1
 80008ce:	ea4f 0232 	mov.w	r2, r2, rrx
 80008d2:	1ab6      	subs	r6, r6, r2
 80008d4:	eb65 0503 	sbc.w	r5, r5, r3
 80008d8:	085b      	lsrs	r3, r3, #1
 80008da:	ea4f 0232 	mov.w	r2, r2, rrx
 80008de:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80008e2:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 80008e6:	ebb6 0e02 	subs.w	lr, r6, r2
 80008ea:	eb75 0e03 	sbcs.w	lr, r5, r3
 80008ee:	bf22      	ittt	cs
 80008f0:	1ab6      	subcs	r6, r6, r2
 80008f2:	4675      	movcs	r5, lr
 80008f4:	ea40 000c 	orrcs.w	r0, r0, ip
 80008f8:	085b      	lsrs	r3, r3, #1
 80008fa:	ea4f 0232 	mov.w	r2, r2, rrx
 80008fe:	ebb6 0e02 	subs.w	lr, r6, r2
 8000902:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000906:	bf22      	ittt	cs
 8000908:	1ab6      	subcs	r6, r6, r2
 800090a:	4675      	movcs	r5, lr
 800090c:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000910:	085b      	lsrs	r3, r3, #1
 8000912:	ea4f 0232 	mov.w	r2, r2, rrx
 8000916:	ebb6 0e02 	subs.w	lr, r6, r2
 800091a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800091e:	bf22      	ittt	cs
 8000920:	1ab6      	subcs	r6, r6, r2
 8000922:	4675      	movcs	r5, lr
 8000924:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000928:	085b      	lsrs	r3, r3, #1
 800092a:	ea4f 0232 	mov.w	r2, r2, rrx
 800092e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000932:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000936:	bf22      	ittt	cs
 8000938:	1ab6      	subcs	r6, r6, r2
 800093a:	4675      	movcs	r5, lr
 800093c:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000940:	ea55 0e06 	orrs.w	lr, r5, r6
 8000944:	d018      	beq.n	8000978 <__aeabi_ddiv+0x114>
 8000946:	ea4f 1505 	mov.w	r5, r5, lsl #4
 800094a:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 800094e:	ea4f 1606 	mov.w	r6, r6, lsl #4
 8000952:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8000956:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 800095a:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800095e:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 8000962:	d1c0      	bne.n	80008e6 <__aeabi_ddiv+0x82>
 8000964:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000968:	d10b      	bne.n	8000982 <__aeabi_ddiv+0x11e>
 800096a:	ea41 0100 	orr.w	r1, r1, r0
 800096e:	f04f 0000 	mov.w	r0, #0
 8000972:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 8000976:	e7b6      	b.n	80008e6 <__aeabi_ddiv+0x82>
 8000978:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800097c:	bf04      	itt	eq
 800097e:	4301      	orreq	r1, r0
 8000980:	2000      	moveq	r0, #0
 8000982:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8000986:	bf88      	it	hi
 8000988:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800098c:	f63f aeaf 	bhi.w	80006ee <__aeabi_dmul+0xde>
 8000990:	ebb5 0c03 	subs.w	ip, r5, r3
 8000994:	bf04      	itt	eq
 8000996:	ebb6 0c02 	subseq.w	ip, r6, r2
 800099a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800099e:	f150 0000 	adcs.w	r0, r0, #0
 80009a2:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80009a6:	bd70      	pop	{r4, r5, r6, pc}
 80009a8:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 80009ac:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 80009b0:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 80009b4:	bfc2      	ittt	gt
 80009b6:	ebd4 050c 	rsbsgt	r5, r4, ip
 80009ba:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80009be:	bd70      	popgt	{r4, r5, r6, pc}
 80009c0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80009c4:	f04f 0e00 	mov.w	lr, #0
 80009c8:	3c01      	subs	r4, #1
 80009ca:	e690      	b.n	80006ee <__aeabi_dmul+0xde>
 80009cc:	ea45 0e06 	orr.w	lr, r5, r6
 80009d0:	e68d      	b.n	80006ee <__aeabi_dmul+0xde>
 80009d2:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80009d6:	ea94 0f0c 	teq	r4, ip
 80009da:	bf08      	it	eq
 80009dc:	ea95 0f0c 	teqeq	r5, ip
 80009e0:	f43f af3b 	beq.w	800085a <__aeabi_dmul+0x24a>
 80009e4:	ea94 0f0c 	teq	r4, ip
 80009e8:	d10a      	bne.n	8000a00 <__aeabi_ddiv+0x19c>
 80009ea:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80009ee:	f47f af34 	bne.w	800085a <__aeabi_dmul+0x24a>
 80009f2:	ea95 0f0c 	teq	r5, ip
 80009f6:	f47f af25 	bne.w	8000844 <__aeabi_dmul+0x234>
 80009fa:	4610      	mov	r0, r2
 80009fc:	4619      	mov	r1, r3
 80009fe:	e72c      	b.n	800085a <__aeabi_dmul+0x24a>
 8000a00:	ea95 0f0c 	teq	r5, ip
 8000a04:	d106      	bne.n	8000a14 <__aeabi_ddiv+0x1b0>
 8000a06:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000a0a:	f43f aefd 	beq.w	8000808 <__aeabi_dmul+0x1f8>
 8000a0e:	4610      	mov	r0, r2
 8000a10:	4619      	mov	r1, r3
 8000a12:	e722      	b.n	800085a <__aeabi_dmul+0x24a>
 8000a14:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000a18:	bf18      	it	ne
 8000a1a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000a1e:	f47f aec5 	bne.w	80007ac <__aeabi_dmul+0x19c>
 8000a22:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8000a26:	f47f af0d 	bne.w	8000844 <__aeabi_dmul+0x234>
 8000a2a:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8000a2e:	f47f aeeb 	bne.w	8000808 <__aeabi_dmul+0x1f8>
 8000a32:	e712      	b.n	800085a <__aeabi_dmul+0x24a>

08000a34 <__gedf2>:
 8000a34:	f04f 3cff 	mov.w	ip, #4294967295
 8000a38:	e006      	b.n	8000a48 <__cmpdf2+0x4>
 8000a3a:	bf00      	nop

08000a3c <__ledf2>:
 8000a3c:	f04f 0c01 	mov.w	ip, #1
 8000a40:	e002      	b.n	8000a48 <__cmpdf2+0x4>
 8000a42:	bf00      	nop

08000a44 <__cmpdf2>:
 8000a44:	f04f 0c01 	mov.w	ip, #1
 8000a48:	f84d cd04 	str.w	ip, [sp, #-4]!
 8000a4c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000a50:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000a54:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000a58:	bf18      	it	ne
 8000a5a:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 8000a5e:	d01b      	beq.n	8000a98 <__cmpdf2+0x54>
 8000a60:	b001      	add	sp, #4
 8000a62:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 8000a66:	bf0c      	ite	eq
 8000a68:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 8000a6c:	ea91 0f03 	teqne	r1, r3
 8000a70:	bf02      	ittt	eq
 8000a72:	ea90 0f02 	teqeq	r0, r2
 8000a76:	2000      	moveq	r0, #0
 8000a78:	4770      	bxeq	lr
 8000a7a:	f110 0f00 	cmn.w	r0, #0
 8000a7e:	ea91 0f03 	teq	r1, r3
 8000a82:	bf58      	it	pl
 8000a84:	4299      	cmppl	r1, r3
 8000a86:	bf08      	it	eq
 8000a88:	4290      	cmpeq	r0, r2
 8000a8a:	bf2c      	ite	cs
 8000a8c:	17d8      	asrcs	r0, r3, #31
 8000a8e:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 8000a92:	f040 0001 	orr.w	r0, r0, #1
 8000a96:	4770      	bx	lr
 8000a98:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000a9c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000aa0:	d102      	bne.n	8000aa8 <__cmpdf2+0x64>
 8000aa2:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8000aa6:	d107      	bne.n	8000ab8 <__cmpdf2+0x74>
 8000aa8:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000aac:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000ab0:	d1d6      	bne.n	8000a60 <__cmpdf2+0x1c>
 8000ab2:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8000ab6:	d0d3      	beq.n	8000a60 <__cmpdf2+0x1c>
 8000ab8:	f85d 0b04 	ldr.w	r0, [sp], #4
 8000abc:	4770      	bx	lr
 8000abe:	bf00      	nop

08000ac0 <__aeabi_cdrcmple>:
 8000ac0:	4684      	mov	ip, r0
 8000ac2:	4610      	mov	r0, r2
 8000ac4:	4662      	mov	r2, ip
 8000ac6:	468c      	mov	ip, r1
 8000ac8:	4619      	mov	r1, r3
 8000aca:	4663      	mov	r3, ip
 8000acc:	e000      	b.n	8000ad0 <__aeabi_cdcmpeq>
 8000ace:	bf00      	nop

08000ad0 <__aeabi_cdcmpeq>:
 8000ad0:	b501      	push	{r0, lr}
 8000ad2:	f7ff ffb7 	bl	8000a44 <__cmpdf2>
 8000ad6:	2800      	cmp	r0, #0
 8000ad8:	bf48      	it	mi
 8000ada:	f110 0f00 	cmnmi.w	r0, #0
 8000ade:	bd01      	pop	{r0, pc}

08000ae0 <__aeabi_dcmpeq>:
 8000ae0:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000ae4:	f7ff fff4 	bl	8000ad0 <__aeabi_cdcmpeq>
 8000ae8:	bf0c      	ite	eq
 8000aea:	2001      	moveq	r0, #1
 8000aec:	2000      	movne	r0, #0
 8000aee:	f85d fb08 	ldr.w	pc, [sp], #8
 8000af2:	bf00      	nop

08000af4 <__aeabi_dcmplt>:
 8000af4:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000af8:	f7ff ffea 	bl	8000ad0 <__aeabi_cdcmpeq>
 8000afc:	bf34      	ite	cc
 8000afe:	2001      	movcc	r0, #1
 8000b00:	2000      	movcs	r0, #0
 8000b02:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b06:	bf00      	nop

08000b08 <__aeabi_dcmple>:
 8000b08:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b0c:	f7ff ffe0 	bl	8000ad0 <__aeabi_cdcmpeq>
 8000b10:	bf94      	ite	ls
 8000b12:	2001      	movls	r0, #1
 8000b14:	2000      	movhi	r0, #0
 8000b16:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b1a:	bf00      	nop

08000b1c <__aeabi_dcmpge>:
 8000b1c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b20:	f7ff ffce 	bl	8000ac0 <__aeabi_cdrcmple>
 8000b24:	bf94      	ite	ls
 8000b26:	2001      	movls	r0, #1
 8000b28:	2000      	movhi	r0, #0
 8000b2a:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b2e:	bf00      	nop

08000b30 <__aeabi_dcmpgt>:
 8000b30:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b34:	f7ff ffc4 	bl	8000ac0 <__aeabi_cdrcmple>
 8000b38:	bf34      	ite	cc
 8000b3a:	2001      	movcc	r0, #1
 8000b3c:	2000      	movcs	r0, #0
 8000b3e:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b42:	bf00      	nop

08000b44 <__aeabi_dcmpun>:
 8000b44:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000b48:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000b4c:	d102      	bne.n	8000b54 <__aeabi_dcmpun+0x10>
 8000b4e:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8000b52:	d10a      	bne.n	8000b6a <__aeabi_dcmpun+0x26>
 8000b54:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000b58:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000b5c:	d102      	bne.n	8000b64 <__aeabi_dcmpun+0x20>
 8000b5e:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8000b62:	d102      	bne.n	8000b6a <__aeabi_dcmpun+0x26>
 8000b64:	f04f 0000 	mov.w	r0, #0
 8000b68:	4770      	bx	lr
 8000b6a:	f04f 0001 	mov.w	r0, #1
 8000b6e:	4770      	bx	lr

08000b70 <__aeabi_d2iz>:
 8000b70:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000b74:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8000b78:	d215      	bcs.n	8000ba6 <__aeabi_d2iz+0x36>
 8000b7a:	d511      	bpl.n	8000ba0 <__aeabi_d2iz+0x30>
 8000b7c:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8000b80:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8000b84:	d912      	bls.n	8000bac <__aeabi_d2iz+0x3c>
 8000b86:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000b8a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000b8e:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8000b92:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000b96:	fa23 f002 	lsr.w	r0, r3, r2
 8000b9a:	bf18      	it	ne
 8000b9c:	4240      	negne	r0, r0
 8000b9e:	4770      	bx	lr
 8000ba0:	f04f 0000 	mov.w	r0, #0
 8000ba4:	4770      	bx	lr
 8000ba6:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8000baa:	d105      	bne.n	8000bb8 <__aeabi_d2iz+0x48>
 8000bac:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 8000bb0:	bf08      	it	eq
 8000bb2:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8000bb6:	4770      	bx	lr
 8000bb8:	f04f 0000 	mov.w	r0, #0
 8000bbc:	4770      	bx	lr
 8000bbe:	bf00      	nop

08000bc0 <__aeabi_d2f>:
 8000bc0:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000bc4:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 8000bc8:	bf24      	itt	cs
 8000bca:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 8000bce:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 8000bd2:	d90d      	bls.n	8000bf0 <__aeabi_d2f+0x30>
 8000bd4:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000bd8:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8000bdc:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8000be0:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 8000be4:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8000be8:	bf08      	it	eq
 8000bea:	f020 0001 	biceq.w	r0, r0, #1
 8000bee:	4770      	bx	lr
 8000bf0:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 8000bf4:	d121      	bne.n	8000c3a <__aeabi_d2f+0x7a>
 8000bf6:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 8000bfa:	bfbc      	itt	lt
 8000bfc:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 8000c00:	4770      	bxlt	lr
 8000c02:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000c06:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8000c0a:	f1c2 0218 	rsb	r2, r2, #24
 8000c0e:	f1c2 0c20 	rsb	ip, r2, #32
 8000c12:	fa10 f30c 	lsls.w	r3, r0, ip
 8000c16:	fa20 f002 	lsr.w	r0, r0, r2
 8000c1a:	bf18      	it	ne
 8000c1c:	f040 0001 	orrne.w	r0, r0, #1
 8000c20:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000c24:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8000c28:	fa03 fc0c 	lsl.w	ip, r3, ip
 8000c2c:	ea40 000c 	orr.w	r0, r0, ip
 8000c30:	fa23 f302 	lsr.w	r3, r3, r2
 8000c34:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000c38:	e7cc      	b.n	8000bd4 <__aeabi_d2f+0x14>
 8000c3a:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8000c3e:	d107      	bne.n	8000c50 <__aeabi_d2f+0x90>
 8000c40:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8000c44:	bf1e      	ittt	ne
 8000c46:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 8000c4a:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 8000c4e:	4770      	bxne	lr
 8000c50:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 8000c54:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000c58:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000c5c:	4770      	bx	lr
 8000c5e:	bf00      	nop

08000c60 <__aeabi_uldivmod>:
 8000c60:	b953      	cbnz	r3, 8000c78 <__aeabi_uldivmod+0x18>
 8000c62:	b94a      	cbnz	r2, 8000c78 <__aeabi_uldivmod+0x18>
 8000c64:	2900      	cmp	r1, #0
 8000c66:	bf08      	it	eq
 8000c68:	2800      	cmpeq	r0, #0
 8000c6a:	bf1c      	itt	ne
 8000c6c:	f04f 31ff 	movne.w	r1, #4294967295
 8000c70:	f04f 30ff 	movne.w	r0, #4294967295
 8000c74:	f000 b97a 	b.w	8000f6c <__aeabi_idiv0>
 8000c78:	f1ad 0c08 	sub.w	ip, sp, #8
 8000c7c:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000c80:	f000 f806 	bl	8000c90 <__udivmoddi4>
 8000c84:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000c88:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000c8c:	b004      	add	sp, #16
 8000c8e:	4770      	bx	lr

08000c90 <__udivmoddi4>:
 8000c90:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000c94:	468c      	mov	ip, r1
 8000c96:	460d      	mov	r5, r1
 8000c98:	4604      	mov	r4, r0
 8000c9a:	9e08      	ldr	r6, [sp, #32]
 8000c9c:	2b00      	cmp	r3, #0
 8000c9e:	d151      	bne.n	8000d44 <__udivmoddi4+0xb4>
 8000ca0:	428a      	cmp	r2, r1
 8000ca2:	4617      	mov	r7, r2
 8000ca4:	d96d      	bls.n	8000d82 <__udivmoddi4+0xf2>
 8000ca6:	fab2 fe82 	clz	lr, r2
 8000caa:	f1be 0f00 	cmp.w	lr, #0
 8000cae:	d00b      	beq.n	8000cc8 <__udivmoddi4+0x38>
 8000cb0:	f1ce 0c20 	rsb	ip, lr, #32
 8000cb4:	fa01 f50e 	lsl.w	r5, r1, lr
 8000cb8:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000cbc:	fa02 f70e 	lsl.w	r7, r2, lr
 8000cc0:	ea4c 0c05 	orr.w	ip, ip, r5
 8000cc4:	fa00 f40e 	lsl.w	r4, r0, lr
 8000cc8:	ea4f 4a17 	mov.w	sl, r7, lsr #16
 8000ccc:	0c25      	lsrs	r5, r4, #16
 8000cce:	fbbc f8fa 	udiv	r8, ip, sl
 8000cd2:	fa1f f987 	uxth.w	r9, r7
 8000cd6:	fb0a cc18 	mls	ip, sl, r8, ip
 8000cda:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
 8000cde:	fb08 f309 	mul.w	r3, r8, r9
 8000ce2:	42ab      	cmp	r3, r5
 8000ce4:	d90a      	bls.n	8000cfc <__udivmoddi4+0x6c>
 8000ce6:	19ed      	adds	r5, r5, r7
 8000ce8:	f108 32ff 	add.w	r2, r8, #4294967295
 8000cec:	f080 8123 	bcs.w	8000f36 <__udivmoddi4+0x2a6>
 8000cf0:	42ab      	cmp	r3, r5
 8000cf2:	f240 8120 	bls.w	8000f36 <__udivmoddi4+0x2a6>
 8000cf6:	f1a8 0802 	sub.w	r8, r8, #2
 8000cfa:	443d      	add	r5, r7
 8000cfc:	1aed      	subs	r5, r5, r3
 8000cfe:	b2a4      	uxth	r4, r4
 8000d00:	fbb5 f0fa 	udiv	r0, r5, sl
 8000d04:	fb0a 5510 	mls	r5, sl, r0, r5
 8000d08:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 8000d0c:	fb00 f909 	mul.w	r9, r0, r9
 8000d10:	45a1      	cmp	r9, r4
 8000d12:	d909      	bls.n	8000d28 <__udivmoddi4+0x98>
 8000d14:	19e4      	adds	r4, r4, r7
 8000d16:	f100 33ff 	add.w	r3, r0, #4294967295
 8000d1a:	f080 810a 	bcs.w	8000f32 <__udivmoddi4+0x2a2>
 8000d1e:	45a1      	cmp	r9, r4
 8000d20:	f240 8107 	bls.w	8000f32 <__udivmoddi4+0x2a2>
 8000d24:	3802      	subs	r0, #2
 8000d26:	443c      	add	r4, r7
 8000d28:	eba4 0409 	sub.w	r4, r4, r9
 8000d2c:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
 8000d30:	2100      	movs	r1, #0
 8000d32:	2e00      	cmp	r6, #0
 8000d34:	d061      	beq.n	8000dfa <__udivmoddi4+0x16a>
 8000d36:	fa24 f40e 	lsr.w	r4, r4, lr
 8000d3a:	2300      	movs	r3, #0
 8000d3c:	6034      	str	r4, [r6, #0]
 8000d3e:	6073      	str	r3, [r6, #4]
 8000d40:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000d44:	428b      	cmp	r3, r1
 8000d46:	d907      	bls.n	8000d58 <__udivmoddi4+0xc8>
 8000d48:	2e00      	cmp	r6, #0
 8000d4a:	d054      	beq.n	8000df6 <__udivmoddi4+0x166>
 8000d4c:	2100      	movs	r1, #0
 8000d4e:	e886 0021 	stmia.w	r6, {r0, r5}
 8000d52:	4608      	mov	r0, r1
 8000d54:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000d58:	fab3 f183 	clz	r1, r3
 8000d5c:	2900      	cmp	r1, #0
 8000d5e:	f040 808e 	bne.w	8000e7e <__udivmoddi4+0x1ee>
 8000d62:	42ab      	cmp	r3, r5
 8000d64:	d302      	bcc.n	8000d6c <__udivmoddi4+0xdc>
 8000d66:	4282      	cmp	r2, r0
 8000d68:	f200 80fa 	bhi.w	8000f60 <__udivmoddi4+0x2d0>
 8000d6c:	1a84      	subs	r4, r0, r2
 8000d6e:	eb65 0503 	sbc.w	r5, r5, r3
 8000d72:	2001      	movs	r0, #1
 8000d74:	46ac      	mov	ip, r5
 8000d76:	2e00      	cmp	r6, #0
 8000d78:	d03f      	beq.n	8000dfa <__udivmoddi4+0x16a>
 8000d7a:	e886 1010 	stmia.w	r6, {r4, ip}
 8000d7e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000d82:	b912      	cbnz	r2, 8000d8a <__udivmoddi4+0xfa>
 8000d84:	2701      	movs	r7, #1
 8000d86:	fbb7 f7f2 	udiv	r7, r7, r2
 8000d8a:	fab7 fe87 	clz	lr, r7
 8000d8e:	f1be 0f00 	cmp.w	lr, #0
 8000d92:	d134      	bne.n	8000dfe <__udivmoddi4+0x16e>
 8000d94:	1beb      	subs	r3, r5, r7
 8000d96:	0c3a      	lsrs	r2, r7, #16
 8000d98:	fa1f fc87 	uxth.w	ip, r7
 8000d9c:	2101      	movs	r1, #1
 8000d9e:	fbb3 f8f2 	udiv	r8, r3, r2
 8000da2:	0c25      	lsrs	r5, r4, #16
 8000da4:	fb02 3318 	mls	r3, r2, r8, r3
 8000da8:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 8000dac:	fb0c f308 	mul.w	r3, ip, r8
 8000db0:	42ab      	cmp	r3, r5
 8000db2:	d907      	bls.n	8000dc4 <__udivmoddi4+0x134>
 8000db4:	19ed      	adds	r5, r5, r7
 8000db6:	f108 30ff 	add.w	r0, r8, #4294967295
 8000dba:	d202      	bcs.n	8000dc2 <__udivmoddi4+0x132>
 8000dbc:	42ab      	cmp	r3, r5
 8000dbe:	f200 80d1 	bhi.w	8000f64 <__udivmoddi4+0x2d4>
 8000dc2:	4680      	mov	r8, r0
 8000dc4:	1aed      	subs	r5, r5, r3
 8000dc6:	b2a3      	uxth	r3, r4
 8000dc8:	fbb5 f0f2 	udiv	r0, r5, r2
 8000dcc:	fb02 5510 	mls	r5, r2, r0, r5
 8000dd0:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
 8000dd4:	fb0c fc00 	mul.w	ip, ip, r0
 8000dd8:	45a4      	cmp	ip, r4
 8000dda:	d907      	bls.n	8000dec <__udivmoddi4+0x15c>
 8000ddc:	19e4      	adds	r4, r4, r7
 8000dde:	f100 33ff 	add.w	r3, r0, #4294967295
 8000de2:	d202      	bcs.n	8000dea <__udivmoddi4+0x15a>
 8000de4:	45a4      	cmp	ip, r4
 8000de6:	f200 80b8 	bhi.w	8000f5a <__udivmoddi4+0x2ca>
 8000dea:	4618      	mov	r0, r3
 8000dec:	eba4 040c 	sub.w	r4, r4, ip
 8000df0:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
 8000df4:	e79d      	b.n	8000d32 <__udivmoddi4+0xa2>
 8000df6:	4631      	mov	r1, r6
 8000df8:	4630      	mov	r0, r6
 8000dfa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000dfe:	f1ce 0420 	rsb	r4, lr, #32
 8000e02:	fa05 f30e 	lsl.w	r3, r5, lr
 8000e06:	fa07 f70e 	lsl.w	r7, r7, lr
 8000e0a:	fa20 f804 	lsr.w	r8, r0, r4
 8000e0e:	0c3a      	lsrs	r2, r7, #16
 8000e10:	fa25 f404 	lsr.w	r4, r5, r4
 8000e14:	ea48 0803 	orr.w	r8, r8, r3
 8000e18:	fbb4 f1f2 	udiv	r1, r4, r2
 8000e1c:	ea4f 4518 	mov.w	r5, r8, lsr #16
 8000e20:	fb02 4411 	mls	r4, r2, r1, r4
 8000e24:	fa1f fc87 	uxth.w	ip, r7
 8000e28:	ea45 4504 	orr.w	r5, r5, r4, lsl #16
 8000e2c:	fb01 f30c 	mul.w	r3, r1, ip
 8000e30:	42ab      	cmp	r3, r5
 8000e32:	fa00 f40e 	lsl.w	r4, r0, lr
 8000e36:	d909      	bls.n	8000e4c <__udivmoddi4+0x1bc>
 8000e38:	19ed      	adds	r5, r5, r7
 8000e3a:	f101 30ff 	add.w	r0, r1, #4294967295
 8000e3e:	f080 808a 	bcs.w	8000f56 <__udivmoddi4+0x2c6>
 8000e42:	42ab      	cmp	r3, r5
 8000e44:	f240 8087 	bls.w	8000f56 <__udivmoddi4+0x2c6>
 8000e48:	3902      	subs	r1, #2
 8000e4a:	443d      	add	r5, r7
 8000e4c:	1aeb      	subs	r3, r5, r3
 8000e4e:	fa1f f588 	uxth.w	r5, r8
 8000e52:	fbb3 f0f2 	udiv	r0, r3, r2
 8000e56:	fb02 3310 	mls	r3, r2, r0, r3
 8000e5a:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 8000e5e:	fb00 f30c 	mul.w	r3, r0, ip
 8000e62:	42ab      	cmp	r3, r5
 8000e64:	d907      	bls.n	8000e76 <__udivmoddi4+0x1e6>
 8000e66:	19ed      	adds	r5, r5, r7
 8000e68:	f100 38ff 	add.w	r8, r0, #4294967295
 8000e6c:	d26f      	bcs.n	8000f4e <__udivmoddi4+0x2be>
 8000e6e:	42ab      	cmp	r3, r5
 8000e70:	d96d      	bls.n	8000f4e <__udivmoddi4+0x2be>
 8000e72:	3802      	subs	r0, #2
 8000e74:	443d      	add	r5, r7
 8000e76:	1aeb      	subs	r3, r5, r3
 8000e78:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 8000e7c:	e78f      	b.n	8000d9e <__udivmoddi4+0x10e>
 8000e7e:	f1c1 0720 	rsb	r7, r1, #32
 8000e82:	fa22 f807 	lsr.w	r8, r2, r7
 8000e86:	408b      	lsls	r3, r1
 8000e88:	fa05 f401 	lsl.w	r4, r5, r1
 8000e8c:	ea48 0303 	orr.w	r3, r8, r3
 8000e90:	fa20 fe07 	lsr.w	lr, r0, r7
 8000e94:	ea4f 4c13 	mov.w	ip, r3, lsr #16
 8000e98:	40fd      	lsrs	r5, r7
 8000e9a:	ea4e 0e04 	orr.w	lr, lr, r4
 8000e9e:	fbb5 f9fc 	udiv	r9, r5, ip
 8000ea2:	ea4f 441e 	mov.w	r4, lr, lsr #16
 8000ea6:	fb0c 5519 	mls	r5, ip, r9, r5
 8000eaa:	fa1f f883 	uxth.w	r8, r3
 8000eae:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
 8000eb2:	fb09 f408 	mul.w	r4, r9, r8
 8000eb6:	42ac      	cmp	r4, r5
 8000eb8:	fa02 f201 	lsl.w	r2, r2, r1
 8000ebc:	fa00 fa01 	lsl.w	sl, r0, r1
 8000ec0:	d908      	bls.n	8000ed4 <__udivmoddi4+0x244>
 8000ec2:	18ed      	adds	r5, r5, r3
 8000ec4:	f109 30ff 	add.w	r0, r9, #4294967295
 8000ec8:	d243      	bcs.n	8000f52 <__udivmoddi4+0x2c2>
 8000eca:	42ac      	cmp	r4, r5
 8000ecc:	d941      	bls.n	8000f52 <__udivmoddi4+0x2c2>
 8000ece:	f1a9 0902 	sub.w	r9, r9, #2
 8000ed2:	441d      	add	r5, r3
 8000ed4:	1b2d      	subs	r5, r5, r4
 8000ed6:	fa1f fe8e 	uxth.w	lr, lr
 8000eda:	fbb5 f0fc 	udiv	r0, r5, ip
 8000ede:	fb0c 5510 	mls	r5, ip, r0, r5
 8000ee2:	ea4e 4405 	orr.w	r4, lr, r5, lsl #16
 8000ee6:	fb00 f808 	mul.w	r8, r0, r8
 8000eea:	45a0      	cmp	r8, r4
 8000eec:	d907      	bls.n	8000efe <__udivmoddi4+0x26e>
 8000eee:	18e4      	adds	r4, r4, r3
 8000ef0:	f100 35ff 	add.w	r5, r0, #4294967295
 8000ef4:	d229      	bcs.n	8000f4a <__udivmoddi4+0x2ba>
 8000ef6:	45a0      	cmp	r8, r4
 8000ef8:	d927      	bls.n	8000f4a <__udivmoddi4+0x2ba>
 8000efa:	3802      	subs	r0, #2
 8000efc:	441c      	add	r4, r3
 8000efe:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 8000f02:	eba4 0408 	sub.w	r4, r4, r8
 8000f06:	fba0 8902 	umull	r8, r9, r0, r2
 8000f0a:	454c      	cmp	r4, r9
 8000f0c:	46c6      	mov	lr, r8
 8000f0e:	464d      	mov	r5, r9
 8000f10:	d315      	bcc.n	8000f3e <__udivmoddi4+0x2ae>
 8000f12:	d012      	beq.n	8000f3a <__udivmoddi4+0x2aa>
 8000f14:	b156      	cbz	r6, 8000f2c <__udivmoddi4+0x29c>
 8000f16:	ebba 030e 	subs.w	r3, sl, lr
 8000f1a:	eb64 0405 	sbc.w	r4, r4, r5
 8000f1e:	fa04 f707 	lsl.w	r7, r4, r7
 8000f22:	40cb      	lsrs	r3, r1
 8000f24:	431f      	orrs	r7, r3
 8000f26:	40cc      	lsrs	r4, r1
 8000f28:	6037      	str	r7, [r6, #0]
 8000f2a:	6074      	str	r4, [r6, #4]
 8000f2c:	2100      	movs	r1, #0
 8000f2e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000f32:	4618      	mov	r0, r3
 8000f34:	e6f8      	b.n	8000d28 <__udivmoddi4+0x98>
 8000f36:	4690      	mov	r8, r2
 8000f38:	e6e0      	b.n	8000cfc <__udivmoddi4+0x6c>
 8000f3a:	45c2      	cmp	sl, r8
 8000f3c:	d2ea      	bcs.n	8000f14 <__udivmoddi4+0x284>
 8000f3e:	ebb8 0e02 	subs.w	lr, r8, r2
 8000f42:	eb69 0503 	sbc.w	r5, r9, r3
 8000f46:	3801      	subs	r0, #1
 8000f48:	e7e4      	b.n	8000f14 <__udivmoddi4+0x284>
 8000f4a:	4628      	mov	r0, r5
 8000f4c:	e7d7      	b.n	8000efe <__udivmoddi4+0x26e>
 8000f4e:	4640      	mov	r0, r8
 8000f50:	e791      	b.n	8000e76 <__udivmoddi4+0x1e6>
 8000f52:	4681      	mov	r9, r0
 8000f54:	e7be      	b.n	8000ed4 <__udivmoddi4+0x244>
 8000f56:	4601      	mov	r1, r0
 8000f58:	e778      	b.n	8000e4c <__udivmoddi4+0x1bc>
 8000f5a:	3802      	subs	r0, #2
 8000f5c:	443c      	add	r4, r7
 8000f5e:	e745      	b.n	8000dec <__udivmoddi4+0x15c>
 8000f60:	4608      	mov	r0, r1
 8000f62:	e708      	b.n	8000d76 <__udivmoddi4+0xe6>
 8000f64:	f1a8 0802 	sub.w	r8, r8, #2
 8000f68:	443d      	add	r5, r7
 8000f6a:	e72b      	b.n	8000dc4 <__udivmoddi4+0x134>

08000f6c <__aeabi_idiv0>:
 8000f6c:	4770      	bx	lr
 8000f6e:	bf00      	nop

08000f70 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority  Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000f70:	b538      	push	{r3, r4, r5, lr}
  HAL_StatusTypeDef  status = HAL_OK;

  /*Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock/1000UL) != 0U)
 8000f72:	4b0a      	ldr	r3, [pc, #40]	; (8000f9c <HAL_InitTick+0x2c>)
{
 8000f74:	4605      	mov	r5, r0
  if (HAL_SYSTICK_Config(SystemCoreClock/1000UL) != 0U)
 8000f76:	6818      	ldr	r0, [r3, #0]
 8000f78:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8000f7c:	fbb0 f0f3 	udiv	r0, r0, r3
 8000f80:	f000 fda2 	bl	8001ac8 <HAL_SYSTICK_Config>
 8000f84:	4604      	mov	r4, r0
 8000f86:	b938      	cbnz	r0, 8000f98 <HAL_InitTick+0x28>
    status = HAL_ERROR;
  }
  else
  {
    /*Configure the SysTick IRQ priority */
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0);
 8000f88:	4602      	mov	r2, r0
 8000f8a:	4629      	mov	r1, r5
 8000f8c:	f04f 30ff 	mov.w	r0, #4294967295
 8000f90:	f000 fd5a 	bl	8001a48 <HAL_NVIC_SetPriority>
 8000f94:	4620      	mov	r0, r4
 8000f96:	bd38      	pop	{r3, r4, r5, pc}
    status = HAL_ERROR;
 8000f98:	2001      	movs	r0, #1
  }

  /* Return function status */
  return status;
}
 8000f9a:	bd38      	pop	{r3, r4, r5, pc}
 8000f9c:	20000058 	.word	0x20000058

08000fa0 <HAL_Init>:
{
 8000fa0:	b510      	push	{r4, lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8000fa2:	2003      	movs	r0, #3
 8000fa4:	f000 fd3e 	bl	8001a24 <HAL_NVIC_SetPriorityGrouping>
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 8000fa8:	200f      	movs	r0, #15
 8000faa:	f7ff ffe1 	bl	8000f70 <HAL_InitTick>
 8000fae:	4604      	mov	r4, r0
 8000fb0:	b918      	cbnz	r0, 8000fba <HAL_Init+0x1a>
    HAL_MspInit();
 8000fb2:	f006 f96d 	bl	8007290 <HAL_MspInit>
}
 8000fb6:	4620      	mov	r0, r4
 8000fb8:	bd10      	pop	{r4, pc}
    status = HAL_ERROR;
 8000fba:	2401      	movs	r4, #1
 8000fbc:	e7fb      	b.n	8000fb6 <HAL_Init+0x16>
	...

08000fc0 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
 8000fc0:	4a02      	ldr	r2, [pc, #8]	; (8000fcc <HAL_IncTick+0xc>)
 8000fc2:	6813      	ldr	r3, [r2, #0]
 8000fc4:	3301      	adds	r3, #1
 8000fc6:	6013      	str	r3, [r2, #0]
 8000fc8:	4770      	bx	lr
 8000fca:	bf00      	nop
 8000fcc:	200084fc 	.word	0x200084fc

08000fd0 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8000fd0:	4b01      	ldr	r3, [pc, #4]	; (8000fd8 <HAL_GetTick+0x8>)
 8000fd2:	6818      	ldr	r0, [r3, #0]
}
 8000fd4:	4770      	bx	lr
 8000fd6:	bf00      	nop
 8000fd8:	200084fc 	.word	0x200084fc

08000fdc <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8000fdc:	b538      	push	{r3, r4, r5, lr}
 8000fde:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8000fe0:	f7ff fff6 	bl	8000fd0 <HAL_GetTick>
  uint32_t wait = Delay;

  /* Add a period to guaranty minimum wait */
  if (wait < HAL_MAX_DELAY)
 8000fe4:	1c63      	adds	r3, r4, #1
  uint32_t tickstart = HAL_GetTick();
 8000fe6:	4605      	mov	r5, r0
  {
    wait++;
 8000fe8:	bf18      	it	ne
 8000fea:	3401      	addne	r4, #1
  }

  while((HAL_GetTick() - tickstart) < wait)
 8000fec:	f7ff fff0 	bl	8000fd0 <HAL_GetTick>
 8000ff0:	1b40      	subs	r0, r0, r5
 8000ff2:	4284      	cmp	r4, r0
 8000ff4:	d8fa      	bhi.n	8000fec <HAL_Delay+0x10>
  {
  }
}
 8000ff6:	bd38      	pop	{r3, r4, r5, pc}

08000ff8 <HAL_GetUIDw0>:
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw0(void)
{
  return(READ_REG(*((uint32_t *)UID_BASE)));
}
 8000ff8:	4b01      	ldr	r3, [pc, #4]	; (8001000 <HAL_GetUIDw0+0x8>)
 8000ffa:	6818      	ldr	r0, [r3, #0]
 8000ffc:	4770      	bx	lr
 8000ffe:	bf00      	nop
 8001000:	1fff7590 	.word	0x1fff7590

08001004 <HAL_GetUIDw1>:
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw1(void)
{
  return(READ_REG(*((uint32_t *)(UID_BASE + 4U))));
}
 8001004:	4b01      	ldr	r3, [pc, #4]	; (800100c <HAL_GetUIDw1+0x8>)
 8001006:	6818      	ldr	r0, [r3, #0]
 8001008:	4770      	bx	lr
 800100a:	bf00      	nop
 800100c:	1fff7594 	.word	0x1fff7594

08001010 <HAL_GetUIDw2>:
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw2(void)
{
  return(READ_REG(*((uint32_t *)(UID_BASE + 8U))));
}
 8001010:	4b01      	ldr	r3, [pc, #4]	; (8001018 <HAL_GetUIDw2+0x8>)
 8001012:	6818      	ldr	r0, [r3, #0]
 8001014:	4770      	bx	lr
 8001016:	bf00      	nop
 8001018:	1fff7598 	.word	0x1fff7598

0800101c <LL_ADC_SetChannelSamplingTime>:
  *             can be replaced by 3.5 ADC clock cycles.
  *             Refer to function @ref LL_ADC_SetSamplingTimeCommonConfig().
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetChannelSamplingTime(ADC_TypeDef *ADCx, uint32_t Channel, uint32_t SamplingTime)
{
 800101c:	b530      	push	{r4, r5, lr}
  /* Set bits with content of parameter "SamplingTime" with bits position     */
  /* in register and register position depending on parameter "Channel".      */
  /* Parameter "Channel" is used with masks because containing                */
  /* other bits reserved for other purpose.                                   */
  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 800101e:	0dcc      	lsrs	r4, r1, #23
 8001020:	f004 0404 	and.w	r4, r4, #4
 8001024:	3014      	adds	r0, #20
  
  MODIFY_REG(*preg,
 8001026:	f3c1 5104 	ubfx	r1, r1, #20, #5
 800102a:	2307      	movs	r3, #7
 800102c:	fa03 f501 	lsl.w	r5, r3, r1
 8001030:	5823      	ldr	r3, [r4, r0]
 8001032:	fa02 f101 	lsl.w	r1, r2, r1
 8001036:	ea23 0305 	bic.w	r3, r3, r5
 800103a:	4319      	orrs	r1, r3
 800103c:	5021      	str	r1, [r4, r0]
 800103e:	bd30      	pop	{r4, r5, pc}

08001040 <LL_ADC_IsEnabled>:
  * @param  ADCx ADC instance
  * @retval 0: ADC is disabled, 1: ADC is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsEnabled(ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8001040:	6880      	ldr	r0, [r0, #8]
}
 8001042:	f000 0001 	and.w	r0, r0, #1
 8001046:	4770      	bx	lr

08001048 <LL_ADC_REG_IsConversionOngoing>:
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group regular.
  */
__STATIC_INLINE uint32_t LL_ADC_REG_IsConversionOngoing(ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8001048:	6880      	ldr	r0, [r0, #8]
}
 800104a:	f3c0 0080 	ubfx	r0, r0, #2, #1
 800104e:	4770      	bx	lr

08001050 <HAL_ADC_Init>:
  *         without  disabling the other ADCs.
  * @param hadc ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef* hadc)
{
 8001050:	b537      	push	{r0, r1, r2, r4, r5, lr}
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  uint32_t tmpCFGR;
  uint32_t tmp_adc_reg_is_conversion_on_going;
  __IO uint32_t wait_loop_index = 0;
 8001052:	2300      	movs	r3, #0
 8001054:	9301      	str	r3, [sp, #4]
  uint32_t tmp_adc_is_conversion_on_going_regular;
  uint32_t tmp_adc_is_conversion_on_going_injected;
  
  /* Check ADC handle */
  if(hadc == NULL)
 8001056:	4604      	mov	r4, r0
 8001058:	2800      	cmp	r0, #0
 800105a:	f000 8085 	beq.w	8001168 <HAL_ADC_Init+0x118>
  /* DISCEN and CONT bits cannot be set at the same time */
  assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (hadc->Init.ContinuousConvMode == ENABLE)));
  
  /* Actions performed only if ADC is coming from state reset:                */
  /* - Initialization of ADC MSP                                              */
  if(hadc->State == HAL_ADC_STATE_RESET)
 800105e:	6d45      	ldr	r5, [r0, #84]	; 0x54
 8001060:	b925      	cbnz	r5, 800106c <HAL_ADC_Init+0x1c>
    
    /* Init the low level hardware */
    hadc->MspInitCallback(hadc);
#else
    /* Init the low level hardware */
    HAL_ADC_MspInit(hadc);
 8001062:	f006 f935 	bl	80072d0 <HAL_ADC_MspInit>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
    
    /* Set ADC error code to none */
    ADC_CLEAR_ERRORCODE(hadc);
 8001066:	65a5      	str	r5, [r4, #88]	; 0x58
    
    /* Initialize Lock */
    hadc->Lock = HAL_UNLOCKED;
 8001068:	f884 5050 	strb.w	r5, [r4, #80]	; 0x50
  }
  
  /* - Exit from deep-power-down mode and ADC voltage regulator enable        */
  if(LL_ADC_IsDeepPowerDownEnabled(hadc->Instance) != 0UL)
 800106c:	6820      	ldr	r0, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_DEEPPWD) == (ADC_CR_DEEPPWD)) ? 1UL : 0UL);
 800106e:	6883      	ldr	r3, [r0, #8]
 8001070:	009b      	lsls	r3, r3, #2
 8001072:	d47b      	bmi.n	800116c <HAL_ADC_Init+0x11c>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 8001074:	6883      	ldr	r3, [r0, #8]
 8001076:	00dd      	lsls	r5, r3, #3
 8001078:	d57f      	bpl.n	800117a <HAL_ADC_Init+0x12a>
 800107a:	6883      	ldr	r3, [r0, #8]
 800107c:	00d9      	lsls	r1, r3, #3
 800107e:	f140 808a 	bpl.w	8001196 <HAL_ADC_Init+0x146>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8001082:	2100      	movs	r1, #0
  
  /* Configuration of ADC parameters if previous preliminary actions are      */ 
  /* correctly completed and if there is no conversion on going on regular    */
  /* group (ADC may already be enabled at this point if HAL_ADC_Init() is     */
  /* called to update a parameter on the fly).                                */
  tmp_adc_reg_is_conversion_on_going = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 8001084:	f7ff ffe0 	bl	8001048 <LL_ADC_REG_IsConversionOngoing>
  
  if(   ((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 8001088:	6d63      	ldr	r3, [r4, #84]	; 0x54
 800108a:	f013 0f10 	tst.w	r3, #16
     && (tmp_adc_reg_is_conversion_on_going == 0UL)
    )
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 800108e:	6d63      	ldr	r3, [r4, #84]	; 0x54
  if(   ((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 8001090:	d167      	bne.n	8001162 <HAL_ADC_Init+0x112>
     && (tmp_adc_reg_is_conversion_on_going == 0UL)
 8001092:	2800      	cmp	r0, #0
 8001094:	d165      	bne.n	8001162 <HAL_ADC_Init+0x112>
    ADC_STATE_CLR_SET(hadc->State,
 8001096:	f423 7381 	bic.w	r3, r3, #258	; 0x102
 800109a:	f043 0302 	orr.w	r3, r3, #2
 800109e:	6563      	str	r3, [r4, #84]	; 0x54
    /* Configuration of common ADC parameters                                 */
    
    /* Parameters update conditioned to ADC state:                            */
    /* Parameters that can be updated only when ADC is disabled:              */
    /*  - clock configuration                                                 */
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 80010a0:	6820      	ldr	r0, [r4, #0]
 80010a2:	f7ff ffcd 	bl	8001040 <LL_ADC_IsEnabled>
 80010a6:	b998      	cbnz	r0, 80010d0 <HAL_ADC_Init+0x80>
    {
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 80010a8:	4852      	ldr	r0, [pc, #328]	; (80011f4 <HAL_ADC_Init+0x1a4>)
 80010aa:	f7ff ffc9 	bl	8001040 <LL_ADC_IsEnabled>
 80010ae:	4603      	mov	r3, r0
 80010b0:	4851      	ldr	r0, [pc, #324]	; (80011f8 <HAL_ADC_Init+0x1a8>)
 80010b2:	f7ff ffc5 	bl	8001040 <LL_ADC_IsEnabled>
 80010b6:	4303      	orrs	r3, r0
 80010b8:	4850      	ldr	r0, [pc, #320]	; (80011fc <HAL_ADC_Init+0x1ac>)
 80010ba:	f7ff ffc1 	bl	8001040 <LL_ADC_IsEnabled>
 80010be:	4303      	orrs	r3, r0
 80010c0:	d106      	bne.n	80010d0 <HAL_ADC_Init+0x80>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_CKMODE | ADC_CCR_PRESC, CommonClock);
 80010c2:	4a4f      	ldr	r2, [pc, #316]	; (8001200 <HAL_ADC_Init+0x1b0>)
 80010c4:	6860      	ldr	r0, [r4, #4]
 80010c6:	6893      	ldr	r3, [r2, #8]
 80010c8:	f423 137c 	bic.w	r3, r3, #4128768	; 0x3f0000
 80010cc:	4303      	orrs	r3, r0
 80010ce:	6093      	str	r3, [r2, #8]
    /*  - overrun                                  Init.Overrun               */
    /*  - discontinuous mode                       Init.DiscontinuousConvMode */
    /*  - discontinuous mode channel count         Init.NbrOfDiscConversion   */
    tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
                hadc->Init.Overrun                                                     |
                hadc->Init.DataAlign                                                   |
 80010d0:	68e0      	ldr	r0, [r4, #12]
 80010d2:	6b63      	ldr	r3, [r4, #52]	; 0x34
                hadc->Init.Resolution                                                  |
                ADC_CFGR_REG_DISCONTINUOUS((uint32_t)hadc->Init.DiscontinuousConvMode)  );
 80010d4:	f894 2020 	ldrb.w	r2, [r4, #32]
                hadc->Init.DataAlign                                                   |
 80010d8:	4303      	orrs	r3, r0
 80010da:	68a0      	ldr	r0, [r4, #8]
 80010dc:	4303      	orrs	r3, r0
    tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
 80010de:	7e60      	ldrb	r0, [r4, #25]
    
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 80010e0:	2a01      	cmp	r2, #1
                hadc->Init.DataAlign                                                   |
 80010e2:	ea43 3340 	orr.w	r3, r3, r0, lsl #13
    tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
 80010e6:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
    {
      tmpCFGR |= ADC_CFGR_DISCONTINUOUS_NUM(hadc->Init.NbrOfDiscConversion);
 80010ea:	bf02      	ittt	eq
 80010ec:	6a62      	ldreq	r2, [r4, #36]	; 0x24
 80010ee:	f102 32ff 	addeq.w	r2, r2, #4294967295
 80010f2:	ea43 4342 	orreq.w	r3, r3, r2, lsl #17
    /* Enable external trigger if trigger selection is different of software  */
    /* start.                                                                 */
    /* Note: This configuration keeps the hardware feature of parameter       */
    /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
    /*       software start.                                                  */
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 80010f6:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80010f8:	b122      	cbz	r2, 8001104 <HAL_ADC_Init+0xb4>
    {
      tmpCFGR |= (  (hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
                  | hadc->Init.ExternalTrigConvEdge
 80010fa:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
      tmpCFGR |= (  (hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 80010fc:	f402 7270 	and.w	r2, r2, #960	; 0x3c0
                  | hadc->Init.ExternalTrigConvEdge
 8001100:	4302      	orrs	r2, r0
      tmpCFGR |= (  (hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 8001102:	4313      	orrs	r3, r2
                 );
    }
    
    /* Update Configuration Register CFGR */
    MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_1, tmpCFGR); 
 8001104:	6820      	ldr	r0, [r4, #0]
 8001106:	4a3f      	ldr	r2, [pc, #252]	; (8001204 <HAL_ADC_Init+0x1b4>)
 8001108:	68c5      	ldr	r5, [r0, #12]
 800110a:	402a      	ands	r2, r5
 800110c:	4313      	orrs	r3, r2
 800110e:	60c3      	str	r3, [r0, #12]
    /* Parameters that can be updated when ADC is disabled or enabled without */
    /* conversion on going on regular and injected groups:                    */
    /*  - DMA continuous request          Init.DMAContinuousRequests          */
    /*  - LowPowerAutoWait feature        Init.LowPowerAutoWait               */
    /*  - Oversampling parameters         Init.Oversampling                   */
    tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 8001110:	f7ff ff9a 	bl	8001048 <LL_ADC_REG_IsConversionOngoing>
    tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
 8001114:	6823      	ldr	r3, [r4, #0]
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group injected.
  */
__STATIC_INLINE uint32_t LL_ADC_INJ_IsConversionOngoing(ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 8001116:	689a      	ldr	r2, [r3, #8]
 8001118:	0712      	lsls	r2, r2, #28
 800111a:	d546      	bpl.n	80011aa <HAL_ADC_Init+0x15a>
    /*   Note: Scan mode is not present by hardware on this device, but       */
    /*   emulated by software for alignment over all STM32 devices.           */
    /* - if scan mode is enabled, regular channels sequence length is set to  */
    /*   parameter "NbrOfConversion".                                         */

    if (hadc->Init.ScanConvMode == ADC_SCAN_ENABLE)
 800111c:	6922      	ldr	r2, [r4, #16]
 800111e:	2a01      	cmp	r2, #1
    {
      /* Set number of ranks in regular group sequencer */
      MODIFY_REG(hadc->Instance->SQR1, ADC_SQR1_L, (hadc->Init.NbrOfConversion - (uint8_t)1));
 8001120:	bf05      	ittet	eq
 8001122:	6b18      	ldreq	r0, [r3, #48]	; 0x30
 8001124:	69e2      	ldreq	r2, [r4, #28]
    }
    else
    {
      CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L);
 8001126:	6b1a      	ldrne	r2, [r3, #48]	; 0x30
      MODIFY_REG(hadc->Instance->SQR1, ADC_SQR1_L, (hadc->Init.NbrOfConversion - (uint8_t)1));
 8001128:	f102 32ff 	addeq.w	r2, r2, #4294967295
 800112c:	bf06      	itte	eq
 800112e:	f020 000f 	biceq.w	r0, r0, #15
 8001132:	4302      	orreq	r2, r0
      CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L);
 8001134:	f022 020f 	bicne.w	r2, r2, #15
 8001138:	631a      	str	r2, [r3, #48]	; 0x30
    }
    
    /* Initialize the ADC state */
    /* Clear HAL_ADC_STATE_BUSY_INTERNAL bit, set HAL_ADC_STATE_READY bit */
    ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL, HAL_ADC_STATE_READY);
 800113a:	6d63      	ldr	r3, [r4, #84]	; 0x54
 800113c:	f023 0303 	bic.w	r3, r3, #3
 8001140:	f043 0301 	orr.w	r3, r3, #1
 8001144:	6563      	str	r3, [r4, #84]	; 0x54
    tmp_hal_status = HAL_ERROR;
  }
  
  /* Return function status */
  return tmp_hal_status;
}
 8001146:	4608      	mov	r0, r1
 8001148:	b003      	add	sp, #12
 800114a:	bd30      	pop	{r4, r5, pc}
      wait_loop_index--;
 800114c:	9b01      	ldr	r3, [sp, #4]
 800114e:	3b01      	subs	r3, #1
 8001150:	9301      	str	r3, [sp, #4]
    while(wait_loop_index != 0UL)
 8001152:	9b01      	ldr	r3, [sp, #4]
 8001154:	2b00      	cmp	r3, #0
 8001156:	d1f9      	bne.n	800114c <HAL_ADC_Init+0xfc>
 8001158:	e78f      	b.n	800107a <HAL_ADC_Init+0x2a>
        CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_ROVSE);
 800115a:	691a      	ldr	r2, [r3, #16]
 800115c:	f022 0201 	bic.w	r2, r2, #1
 8001160:	e045      	b.n	80011ee <HAL_ADC_Init+0x19e>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8001162:	f043 0310 	orr.w	r3, r3, #16
 8001166:	6563      	str	r3, [r4, #84]	; 0x54
    return HAL_ERROR;
 8001168:	2101      	movs	r1, #1
 800116a:	e7ec      	b.n	8001146 <HAL_ADC_Init+0xf6>
  CLEAR_BIT(ADCx->CR, (ADC_CR_DEEPPWD | ADC_CR_BITS_PROPERTY_RS));
 800116c:	6883      	ldr	r3, [r0, #8]
 800116e:	f023 4320 	bic.w	r3, r3, #2684354560	; 0xa0000000
 8001172:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8001176:	6083      	str	r3, [r0, #8]
 8001178:	e77c      	b.n	8001074 <HAL_ADC_Init+0x24>
  MODIFY_REG(ADCx->CR,
 800117a:	6883      	ldr	r3, [r0, #8]
    wait_loop_index = ((LL_ADC_DELAY_INTERNAL_REGUL_STAB_US / 10UL) * (SystemCoreClock / (100000UL * 2UL)));
 800117c:	4a22      	ldr	r2, [pc, #136]	; (8001208 <HAL_ADC_Init+0x1b8>)
 800117e:	f023 4310 	bic.w	r3, r3, #2415919104	; 0x90000000
 8001182:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8001186:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800118a:	6083      	str	r3, [r0, #8]
 800118c:	4b1f      	ldr	r3, [pc, #124]	; (800120c <HAL_ADC_Init+0x1bc>)
 800118e:	681b      	ldr	r3, [r3, #0]
 8001190:	fbb3 f3f2 	udiv	r3, r3, r2
 8001194:	e7dc      	b.n	8001150 <HAL_ADC_Init+0x100>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8001196:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8001198:	f043 0310 	orr.w	r3, r3, #16
 800119c:	6563      	str	r3, [r4, #84]	; 0x54
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 800119e:	6da3      	ldr	r3, [r4, #88]	; 0x58
 80011a0:	f043 0301 	orr.w	r3, r3, #1
 80011a4:	65a3      	str	r3, [r4, #88]	; 0x58
    tmp_hal_status = HAL_ERROR;
 80011a6:	2101      	movs	r1, #1
 80011a8:	e76c      	b.n	8001084 <HAL_ADC_Init+0x34>
    if (   (tmp_adc_is_conversion_on_going_regular == 0UL)
 80011aa:	2800      	cmp	r0, #0
 80011ac:	d1b6      	bne.n	800111c <HAL_ADC_Init+0xcc>
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);
 80011ae:	68d8      	ldr	r0, [r3, #12]
                  ADC_CFGR_DMACONTREQ((uint32_t)hadc->Init.DMAContinuousRequests)  );
 80011b0:	f894 2030 	ldrb.w	r2, [r4, #48]	; 0x30
                  ADC_CFGR_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)        |
 80011b4:	7e25      	ldrb	r5, [r4, #24]
                  ADC_CFGR_DMACONTREQ((uint32_t)hadc->Init.DMAContinuousRequests)  );
 80011b6:	0052      	lsls	r2, r2, #1
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);
 80011b8:	f420 4080 	bic.w	r0, r0, #16384	; 0x4000
      tmpCFGR = ( ADC_CFGR_DFSDM(hadc)                                            |
 80011bc:	ea42 3285 	orr.w	r2, r2, r5, lsl #14
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);
 80011c0:	f020 0002 	bic.w	r0, r0, #2
 80011c4:	4302      	orrs	r2, r0
 80011c6:	60da      	str	r2, [r3, #12]
      if (hadc->Init.OversamplingMode == ENABLE)
 80011c8:	f894 2038 	ldrb.w	r2, [r4, #56]	; 0x38
 80011cc:	2a01      	cmp	r2, #1
 80011ce:	d1c4      	bne.n	800115a <HAL_ADC_Init+0x10a>
        MODIFY_REG(hadc->Instance->CFGR2,
 80011d0:	6c25      	ldr	r5, [r4, #64]	; 0x40
 80011d2:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 80011d4:	6918      	ldr	r0, [r3, #16]
 80011d6:	432a      	orrs	r2, r5
 80011d8:	6c65      	ldr	r5, [r4, #68]	; 0x44
 80011da:	f042 0201 	orr.w	r2, r2, #1
 80011de:	432a      	orrs	r2, r5
 80011e0:	6ca5      	ldr	r5, [r4, #72]	; 0x48
 80011e2:	f420 60ff 	bic.w	r0, r0, #2040	; 0x7f8
 80011e6:	432a      	orrs	r2, r5
 80011e8:	f020 0004 	bic.w	r0, r0, #4
 80011ec:	4302      	orrs	r2, r0
        CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_ROVSE);
 80011ee:	611a      	str	r2, [r3, #16]
 80011f0:	e794      	b.n	800111c <HAL_ADC_Init+0xcc>
 80011f2:	bf00      	nop
 80011f4:	50040000 	.word	0x50040000
 80011f8:	50040100 	.word	0x50040100
 80011fc:	50040200 	.word	0x50040200
 8001200:	50040300 	.word	0x50040300
 8001204:	fff0c007 	.word	0xfff0c007
 8001208:	00030d40 	.word	0x00030d40
 800120c:	20000058 	.word	0x20000058

08001210 <HAL_ADC_PollForConversion>:
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_DUAL));
 8001210:	4b38      	ldr	r3, [pc, #224]	; (80012f4 <HAL_ADC_PollForConversion+0xe4>)
  * @param hadc ADC handle
  * @param Timeout Timeout value in millisecond.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_PollForConversion(ADC_HandleTypeDef* hadc, uint32_t Timeout)
{
 8001212:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
  
  /* If end of conversion selected to end of sequence conversions */
  if (hadc->Init.EOCSelection == ADC_EOC_SEQ_CONV)
 8001216:	6945      	ldr	r5, [r0, #20]
 8001218:	689e      	ldr	r6, [r3, #8]
 800121a:	2d08      	cmp	r5, #8
{
 800121c:	4604      	mov	r4, r0
 800121e:	460f      	mov	r7, r1
 8001220:	f006 061f 	and.w	r6, r6, #31
  if (hadc->Init.EOCSelection == ADC_EOC_SEQ_CONV)
 8001224:	d017      	beq.n	8001256 <HAL_ADC_PollForConversion+0x46>
    /* Particular case is ADC configured in DMA mode and ADC sequencer with   */
    /* several ranks and polling for end of each conversion.                  */
    /* For code simplicity sake, this particular case is generalized to       */
    /* ADC configured in DMA mode and and polling for end of each conversion. */
#if defined(ADC_MULTIMODE_SUPPORT)
    if (    (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
 8001226:	2e09      	cmp	r6, #9
 8001228:	d810      	bhi.n	800124c <HAL_ADC_PollForConversion+0x3c>
 800122a:	f240 2221 	movw	r2, #545	; 0x221
 800122e:	40f2      	lsrs	r2, r6
 8001230:	07d1      	lsls	r1, r2, #31
 8001232:	d50b      	bpl.n	800124c <HAL_ADC_PollForConversion+0x3c>
         || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_SIMULT)
         || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_ALTERN)
       )
    {
      /* Check ADC DMA mode in independent mode on ADC group regular */
      if(READ_BIT(hadc->Instance->CFGR, ADC_CFGR_DMAEN) != 0UL)
 8001234:	6803      	ldr	r3, [r0, #0]
 8001236:	68db      	ldr	r3, [r3, #12]
 8001238:	f013 0f01 	tst.w	r3, #1
      }
    }
    else
    {
      /* Check ADC DMA mode in multimode on ADC group regular */
      if (LL_ADC_GetMultiDMATransfer(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) != LL_ADC_MULTI_REG_DMA_EACH_ADC)
 800123c:	d00a      	beq.n	8001254 <HAL_ADC_PollForConversion+0x44>
      {
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 800123e:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8001240:	f043 0320 	orr.w	r3, r3, #32
 8001244:	6563      	str	r3, [r4, #84]	; 0x54
        return HAL_ERROR;
 8001246:	2001      	movs	r0, #1
 8001248:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_MDMA | ADC_CCR_DMACFG));
 800124c:	689b      	ldr	r3, [r3, #8]
      if (LL_ADC_GetMultiDMATransfer(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) != LL_ADC_MULTI_REG_DMA_EACH_ADC)
 800124e:	f413 4f60 	tst.w	r3, #57344	; 0xe000
 8001252:	e7f3      	b.n	800123c <HAL_ADC_PollForConversion+0x2c>
        tmp_Flag_End = (ADC_FLAG_EOC);
 8001254:	2504      	movs	r5, #4
    }
#endif
  }
  
  /* Get tick count */
  tickstart = HAL_GetTick();
 8001256:	f7ff febb 	bl	8000fd0 <HAL_GetTick>
 800125a:	4680      	mov	r8, r0
  
  /* Wait until End of unitary conversion or sequence conversions flag is raised */
  while((hadc->Instance->ISR & tmp_Flag_End) == 0UL)
 800125c:	6823      	ldr	r3, [r4, #0]
 800125e:	681a      	ldr	r2, [r3, #0]
 8001260:	4215      	tst	r5, r2
 8001262:	d021      	beq.n	80012a8 <HAL_ADC_PollForConversion+0x98>
      }
    }
  }
  
  /* Update ADC state machine */
  SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
 8001264:	6d62      	ldr	r2, [r4, #84]	; 0x54
 8001266:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800126a:	6562      	str	r2, [r4, #84]	; 0x54
  return ((READ_BIT(ADCx->CFGR, ADC_CFGR_EXTEN) == (LL_ADC_REG_TRIG_SOFTWARE & ADC_CFGR_EXTEN)) ? 1UL : 0UL);
 800126c:	68da      	ldr	r2, [r3, #12]
 800126e:	f412 6f40 	tst.w	r2, #3072	; 0xc00
 8001272:	d10f      	bne.n	8001294 <HAL_ADC_PollForConversion+0x84>
  
  /* Determine whether any further conversion upcoming on group regular       */
  /* by external trigger, continuous mode or scan sequence on going.          */
  if(   (LL_ADC_REG_IsTriggerSourceSWStart(hadc->Instance) != 0UL)
     && (hadc->Init.ContinuousConvMode == DISABLE)
 8001274:	7e62      	ldrb	r2, [r4, #25]
 8001276:	b96a      	cbnz	r2, 8001294 <HAL_ADC_PollForConversion+0x84>
    )
  {
    /* Check whether end of sequence is reached */
    if( __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOS) )
 8001278:	681a      	ldr	r2, [r3, #0]
 800127a:	0710      	lsls	r0, r2, #28
 800127c:	d50a      	bpl.n	8001294 <HAL_ADC_PollForConversion+0x84>
    {
      /* Set ADC state */
      CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);
 800127e:	6d62      	ldr	r2, [r4, #84]	; 0x54
 8001280:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8001284:	6562      	str	r2, [r4, #84]	; 0x54
      
      if ((hadc->State & HAL_ADC_STATE_INJ_BUSY) == 0UL)
 8001286:	6d62      	ldr	r2, [r4, #84]	; 0x54
 8001288:	04d1      	lsls	r1, r2, #19
      {
        SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 800128a:	bf5e      	ittt	pl
 800128c:	6d62      	ldrpl	r2, [r4, #84]	; 0x54
 800128e:	f042 0201 	orrpl.w	r2, r2, #1
 8001292:	6562      	strpl	r2, [r4, #84]	; 0x54
  
  /* Get relevant register CFGR in ADC instance of ADC master or slave        */
  /* in function of multimode state (for devices with multimode               */
  /* available).                                                              */
#if defined(ADC_MULTIMODE_SUPPORT)
  if (    (__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
 8001294:	4a18      	ldr	r2, [pc, #96]	; (80012f8 <HAL_ADC_PollForConversion+0xe8>)
 8001296:	4293      	cmp	r3, r2
 8001298:	d021      	beq.n	80012de <HAL_ADC_PollForConversion+0xce>
       || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_SIMULT)
       || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_ALTERN)
     )
  {
    /* Retrieve handle ADC CFGR register */
    tmp_cfgr = READ_REG(hadc->Instance->CFGR);
 800129a:	68d8      	ldr	r0, [r3, #12]
  /* Retrieve handle ADC CFGR register */
  tmp_cfgr = READ_REG(hadc->Instance->CFGR);
#endif
  
  /* Clear polled flag */
  if (tmp_Flag_End == ADC_FLAG_EOS)
 800129c:	2d08      	cmp	r5, #8
 800129e:	d117      	bne.n	80012d0 <HAL_ADC_PollForConversion+0xc0>
  {
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOS);  
 80012a0:	601d      	str	r5, [r3, #0]
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS));
    }
  }
  
  /* Return function status */
  return HAL_OK;
 80012a2:	2000      	movs	r0, #0
 80012a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if(Timeout != HAL_MAX_DELAY)
 80012a8:	1c7a      	adds	r2, r7, #1
 80012aa:	d0d8      	beq.n	800125e <HAL_ADC_PollForConversion+0x4e>
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0UL))
 80012ac:	f7ff fe90 	bl	8000fd0 <HAL_GetTick>
 80012b0:	eba0 0008 	sub.w	r0, r0, r8
 80012b4:	4287      	cmp	r7, r0
 80012b6:	d301      	bcc.n	80012bc <HAL_ADC_PollForConversion+0xac>
 80012b8:	2f00      	cmp	r7, #0
 80012ba:	d1cf      	bne.n	800125c <HAL_ADC_PollForConversion+0x4c>
        SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
 80012bc:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80012be:	f043 0304 	orr.w	r3, r3, #4
 80012c2:	6563      	str	r3, [r4, #84]	; 0x54
        __HAL_UNLOCK(hadc);
 80012c4:	2300      	movs	r3, #0
 80012c6:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
        return HAL_TIMEOUT;
 80012ca:	2003      	movs	r0, #3
 80012cc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (READ_BIT(tmp_cfgr, ADC_CFGR_AUTDLY) == 0UL)
 80012d0:	f410 4080 	ands.w	r0, r0, #16384	; 0x4000
 80012d4:	d1e5      	bne.n	80012a2 <HAL_ADC_PollForConversion+0x92>
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS));
 80012d6:	220c      	movs	r2, #12
 80012d8:	601a      	str	r2, [r3, #0]
 80012da:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
       || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
 80012de:	2e09      	cmp	r6, #9
 80012e0:	d805      	bhi.n	80012ee <HAL_ADC_PollForConversion+0xde>
 80012e2:	f240 2221 	movw	r2, #545	; 0x221
 80012e6:	fa22 f606 	lsr.w	r6, r2, r6
 80012ea:	07f2      	lsls	r2, r6, #31
 80012ec:	d4d5      	bmi.n	800129a <HAL_ADC_PollForConversion+0x8a>
    tmp_cfgr = READ_REG(tmpADC_Master->CFGR);
 80012ee:	4a03      	ldr	r2, [pc, #12]	; (80012fc <HAL_ADC_PollForConversion+0xec>)
 80012f0:	68d0      	ldr	r0, [r2, #12]
 80012f2:	e7d3      	b.n	800129c <HAL_ADC_PollForConversion+0x8c>
 80012f4:	50040300 	.word	0x50040300
 80012f8:	50040100 	.word	0x50040100
 80012fc:	50040000 	.word	0x50040000

08001300 <HAL_ADC_GetValue>:

  /* Note: EOC flag is not cleared here by software because automatically     */
  /*       cleared by hardware when reading register DR.                      */
  
  /* Return ADC converted value */ 
  return hadc->Instance->DR;
 8001300:	6803      	ldr	r3, [r0, #0]
 8001302:	6c18      	ldr	r0, [r3, #64]	; 0x40
}
 8001304:	4770      	bx	lr
	...

08001308 <HAL_ADC_ConfigChannel>:
  * @param hadc ADC handle
  * @param sConfig Structure of ADC channel assigned to ADC group regular.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef* hadc, ADC_ChannelConfTypeDef* sConfig)
{
 8001308:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  uint32_t tmpOffsetShifted;
  uint32_t tmp_config_internal_channel;
  __IO uint32_t wait_loop_index = 0;
 800130a:	2300      	movs	r3, #0
 800130c:	9301      	str	r3, [sp, #4]
  {
    assert_param(IS_ADC_DIFF_CHANNEL(hadc, sConfig->Channel));
  }
  
  /* Process locked */
  __HAL_LOCK(hadc);
 800130e:	f890 3050 	ldrb.w	r3, [r0, #80]	; 0x50
 8001312:	2b01      	cmp	r3, #1
{
 8001314:	4605      	mov	r5, r0
 8001316:	460c      	mov	r4, r1
  __HAL_LOCK(hadc);
 8001318:	f000 8187 	beq.w	800162a <HAL_ADC_ConfigChannel+0x322>
 800131c:	2301      	movs	r3, #1
 800131e:	f880 3050 	strb.w	r3, [r0, #80]	; 0x50
  /* Parameters update conditioned to ADC state:                              */
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on regular group:                                    */
  /*  - Channel number                                                        */
  /*  - Channel rank                                                          */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 8001322:	6800      	ldr	r0, [r0, #0]
 8001324:	f7ff fe90 	bl	8001048 <LL_ADC_REG_IsConversionOngoing>
 8001328:	2800      	cmp	r0, #0
 800132a:	f040 8178 	bne.w	800161e <HAL_ADC_ConfigChannel+0x316>
    /* Correspondence for compatibility with legacy definition of             */
    /* sequencer ranks in direct number format. This correspondence can       */
    /* be done only on ranks 1 to 5 due to literal values.                    */
    /* Note: Sequencer ranks in direct number format are no more used         */
    /*       and are detected by activating USE_FULL_ASSERT feature.          */
    if (sConfig->Rank <= 5U)
 800132e:	684b      	ldr	r3, [r1, #4]
 8001330:	2b05      	cmp	r3, #5
 8001332:	d808      	bhi.n	8001346 <HAL_ADC_ConfigChannel+0x3e>
    {
      switch (sConfig->Rank)
 8001334:	3b02      	subs	r3, #2
 8001336:	2b03      	cmp	r3, #3
 8001338:	d865      	bhi.n	8001406 <HAL_ADC_ConfigChannel+0xfe>
 800133a:	e8df f003 	tbb	[pc, r3]
 800133e:	5d02      	.short	0x5d02
 8001340:	615f      	.short	0x615f
      {
        case 2U: sConfig->Rank = ADC_REGULAR_RANK_2; break;
 8001342:	230c      	movs	r3, #12
        case 3U: sConfig->Rank = ADC_REGULAR_RANK_3; break;
        case 4U: sConfig->Rank = ADC_REGULAR_RANK_4; break;
        case 5U: sConfig->Rank = ADC_REGULAR_RANK_5; break;
        /* case 1U */
        default: sConfig->Rank = ADC_REGULAR_RANK_1; break;
 8001344:	6063      	str	r3, [r4, #4]
      }
    }
    #endif
    
    /* Set ADC group regular sequence: channel on the selected scan sequence rank */
    LL_ADC_REG_SetSequencerRanks(hadc->Instance, sConfig->Rank, sConfig->Channel);
 8001346:	6861      	ldr	r1, [r4, #4]
 8001348:	6828      	ldr	r0, [r5, #0]
  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1, ((Rank & ADC_REG_SQRX_REGOFFSET_MASK) >> ADC_SQRX_REGOFFSET_POS));
 800134a:	098e      	lsrs	r6, r1, #6
 800134c:	f100 0730 	add.w	r7, r0, #48	; 0x30
 8001350:	f006 060c 	and.w	r6, r6, #12
  MODIFY_REG(*preg,
 8001354:	f001 011f 	and.w	r1, r1, #31
 8001358:	231f      	movs	r3, #31
 800135a:	fa03 f201 	lsl.w	r2, r3, r1
 800135e:	59f3      	ldr	r3, [r6, r7]
 8001360:	ea23 0302 	bic.w	r3, r3, r2
 8001364:	6822      	ldr	r2, [r4, #0]
 8001366:	f3c2 6284 	ubfx	r2, r2, #26, #5
 800136a:	408a      	lsls	r2, r1
 800136c:	4313      	orrs	r3, r2
 800136e:	51f3      	str	r3, [r6, r7]
    /* Parameters update conditioned to ADC state:                              */
    /* Parameters that can be updated when ADC is disabled or enabled without   */
    /* conversion on going on regular group:                                    */
    /*  - Channel sampling time                                                 */
    /*  - Channel offset                                                        */
    tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 8001370:	f7ff fe6a 	bl	8001048 <LL_ADC_REG_IsConversionOngoing>
    tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
 8001374:	682b      	ldr	r3, [r5, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 8001376:	689a      	ldr	r2, [r3, #8]
 8001378:	0711      	lsls	r1, r2, #28
 800137a:	f140 8158 	bpl.w	800162e <HAL_ADC_ConfigChannel+0x326>
    }
    
    /* Parameters update conditioned to ADC state:                              */
    /* Parameters that can be updated only when ADC is disabled:                */
    /*  - Single or differential mode                                           */
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 800137e:	6828      	ldr	r0, [r5, #0]
 8001380:	f7ff fe5e 	bl	8001040 <LL_ADC_IsEnabled>
 8001384:	2800      	cmp	r0, #0
 8001386:	f040 80d7 	bne.w	8001538 <HAL_ADC_ConfigChannel+0x230>
    {
      /* Set mode single-ended or differential input of the selected ADC channel */
      LL_ADC_SetChannelSingleDiff(hadc->Instance, sConfig->Channel, sConfig->SingleDiff);
 800138a:	68e6      	ldr	r6, [r4, #12]
 800138c:	6828      	ldr	r0, [r5, #0]
 800138e:	6823      	ldr	r3, [r4, #0]
  MODIFY_REG(ADCx->DIFSEL,
 8001390:	4ac3      	ldr	r2, [pc, #780]	; (80016a0 <HAL_ADC_ConfigChannel+0x398>)
 8001392:	f8d0 10b0 	ldr.w	r1, [r0, #176]	; 0xb0
 8001396:	f006 0e18 	and.w	lr, r6, #24
 800139a:	f3c3 0712 	ubfx	r7, r3, #0, #19
 800139e:	fa22 f20e 	lsr.w	r2, r2, lr
 80013a2:	401a      	ands	r2, r3
 80013a4:	ea21 0107 	bic.w	r1, r1, r7
 80013a8:	430a      	orrs	r2, r1
 80013aa:	f8c0 20b0 	str.w	r2, [r0, #176]	; 0xb0
      
      /* Configuration of differential mode */
      if (sConfig->SingleDiff == ADC_DIFFERENTIAL_ENDED)
 80013ae:	4abd      	ldr	r2, [pc, #756]	; (80016a4 <HAL_ADC_ConfigChannel+0x39c>)
 80013b0:	4296      	cmp	r6, r2
 80013b2:	f040 80c1 	bne.w	8001538 <HAL_ADC_ConfigChannel+0x230>
      {
        /* Set sampling time of the selected ADC channel */
        /* Note: ADC channel number masked with value "0x1F" to ensure shift value within 32 bits range */
        LL_ADC_SetChannelSamplingTime(hadc->Instance, __LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel) + 1UL) & 0x1FUL), sConfig->SamplingTime);
 80013b6:	2f00      	cmp	r7, #0
 80013b8:	f040 8093 	bne.w	80014e2 <HAL_ADC_ConfigChannel+0x1da>
 80013bc:	0e9e      	lsrs	r6, r3, #26
 80013be:	3601      	adds	r6, #1
 80013c0:	f006 021f 	and.w	r2, r6, #31
 80013c4:	2a09      	cmp	r2, #9
 80013c6:	f04f 0101 	mov.w	r1, #1
 80013ca:	ea4f 6686 	mov.w	r6, r6, lsl #26
 80013ce:	f240 80a2 	bls.w	8001516 <HAL_ADC_ConfigChannel+0x20e>
 80013d2:	f006 46f8 	and.w	r6, r6, #2080374784	; 0x7c000000
 80013d6:	4091      	lsls	r1, r2
 80013d8:	ea41 0206 	orr.w	r2, r1, r6
 80013dc:	2f00      	cmp	r7, #0
 80013de:	f040 80cb 	bne.w	8001578 <HAL_ADC_ConfigChannel+0x270>
 80013e2:	0e9b      	lsrs	r3, r3, #26
 80013e4:	3301      	adds	r3, #1
 80013e6:	f003 031f 	and.w	r3, r3, #31
 80013ea:	eb03 0143 	add.w	r1, r3, r3, lsl #1
 80013ee:	391e      	subs	r1, #30
 80013f0:	0509      	lsls	r1, r1, #20
 80013f2:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
 80013f6:	e09b      	b.n	8001530 <HAL_ADC_ConfigChannel+0x228>
        case 3U: sConfig->Rank = ADC_REGULAR_RANK_3; break;
 80013f8:	2312      	movs	r3, #18
 80013fa:	e7a3      	b.n	8001344 <HAL_ADC_ConfigChannel+0x3c>
        case 4U: sConfig->Rank = ADC_REGULAR_RANK_4; break;
 80013fc:	2318      	movs	r3, #24
 80013fe:	e7a1      	b.n	8001344 <HAL_ADC_ConfigChannel+0x3c>
        case 5U: sConfig->Rank = ADC_REGULAR_RANK_5; break;
 8001400:	f44f 7380 	mov.w	r3, #256	; 0x100
 8001404:	e79e      	b.n	8001344 <HAL_ADC_ConfigChannel+0x3c>
        default: sConfig->Rank = ADC_REGULAR_RANK_1; break;
 8001406:	2306      	movs	r3, #6
 8001408:	e79c      	b.n	8001344 <HAL_ADC_ConfigChannel+0x3c>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 800140a:	f8de 1060 	ldr.w	r1, [lr, #96]	; 0x60
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 800140e:	f3c3 0012 	ubfx	r0, r3, #0, #19
 8001412:	f3c1 6784 	ubfx	r7, r1, #26, #5
 8001416:	f10e 0664 	add.w	r6, lr, #100	; 0x64
 800141a:	2800      	cmp	r0, #0
 800141c:	d13a      	bne.n	8001494 <HAL_ADC_ConfigChannel+0x18c>
 800141e:	f3c3 6084 	ubfx	r0, r3, #26, #5
 8001422:	4287      	cmp	r7, r0
 8001424:	f040 8128 	bne.w	8001678 <HAL_ADC_ConfigChannel+0x370>
  MODIFY_REG(*preg,
 8001428:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800142c:	f8ce 1060 	str.w	r1, [lr, #96]	; 0x60
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8001430:	6823      	ldr	r3, [r4, #0]
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8001432:	f8de 1064 	ldr.w	r1, [lr, #100]	; 0x64
 8001436:	f3c3 0712 	ubfx	r7, r3, #0, #19
 800143a:	f3c1 6084 	ubfx	r0, r1, #26, #5
 800143e:	bb9f      	cbnz	r7, 80014a8 <HAL_ADC_ConfigChannel+0x1a0>
 8001440:	f3c3 6384 	ubfx	r3, r3, #26, #5
 8001444:	4283      	cmp	r3, r0
 8001446:	f040 811c 	bne.w	8001682 <HAL_ADC_ConfigChannel+0x37a>
  MODIFY_REG(*preg,
 800144a:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800144e:	6031      	str	r1, [r6, #0]
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8001450:	6823      	ldr	r3, [r4, #0]
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8001452:	6891      	ldr	r1, [r2, #8]
 8001454:	f3c3 0712 	ubfx	r7, r3, #0, #19
  register const uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8001458:	f102 0608 	add.w	r6, r2, #8
 800145c:	f3c1 6084 	ubfx	r0, r1, #26, #5
 8001460:	bb77      	cbnz	r7, 80014c0 <HAL_ADC_ConfigChannel+0x1b8>
 8001462:	f3c3 6384 	ubfx	r3, r3, #26, #5
 8001466:	4283      	cmp	r3, r0
 8001468:	f040 8112 	bne.w	8001690 <HAL_ADC_ConfigChannel+0x388>
  MODIFY_REG(*preg,
 800146c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8001470:	6031      	str	r1, [r6, #0]
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8001472:	6823      	ldr	r3, [r4, #0]
  register const uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8001474:	f102 000c 	add.w	r0, r2, #12
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8001478:	68d2      	ldr	r2, [r2, #12]
 800147a:	f3c3 0612 	ubfx	r6, r3, #0, #19
 800147e:	f3c2 6184 	ubfx	r1, r2, #26, #5
 8001482:	bb4e      	cbnz	r6, 80014d8 <HAL_ADC_ConfigChannel+0x1d0>
 8001484:	f3c3 6384 	ubfx	r3, r3, #26, #5
 8001488:	428b      	cmp	r3, r1
  MODIFY_REG(*preg,
 800148a:	bf04      	itt	eq
 800148c:	f022 4200 	biceq.w	r2, r2, #2147483648	; 0x80000000
 8001490:	6002      	streq	r2, [r0, #0]
 8001492:	e774      	b.n	800137e <HAL_ADC_ConfigChannel+0x76>
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001494:	fa93 f0a3 	rbit	r0, r3
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8001498:	fab0 f080 	clz	r0, r0
 800149c:	4287      	cmp	r7, r0
 800149e:	d0c3      	beq.n	8001428 <HAL_ADC_ConfigChannel+0x120>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 80014a0:	f8de 1064 	ldr.w	r1, [lr, #100]	; 0x64
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 80014a4:	f3c1 6084 	ubfx	r0, r1, #26, #5
 80014a8:	fa93 f3a3 	rbit	r3, r3
 80014ac:	fab3 f383 	clz	r3, r3
 80014b0:	4283      	cmp	r3, r0
 80014b2:	d0ca      	beq.n	800144a <HAL_ADC_ConfigChannel+0x142>
 80014b4:	6891      	ldr	r1, [r2, #8]
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 80014b6:	6823      	ldr	r3, [r4, #0]
  register const uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 80014b8:	f102 0608 	add.w	r6, r2, #8
 80014bc:	f3c1 6084 	ubfx	r0, r1, #26, #5
 80014c0:	fa93 f3a3 	rbit	r3, r3
 80014c4:	fab3 f383 	clz	r3, r3
 80014c8:	4283      	cmp	r3, r0
 80014ca:	d0cf      	beq.n	800146c <HAL_ADC_ConfigChannel+0x164>
 80014cc:	f102 000c 	add.w	r0, r2, #12
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 80014d0:	68d2      	ldr	r2, [r2, #12]
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 80014d2:	6823      	ldr	r3, [r4, #0]
 80014d4:	f3c2 6184 	ubfx	r1, r2, #26, #5
 80014d8:	fa93 f3a3 	rbit	r3, r3
 80014dc:	fab3 f383 	clz	r3, r3
 80014e0:	e7d2      	b.n	8001488 <HAL_ADC_ConfigChannel+0x180>
 80014e2:	fa93 f2a3 	rbit	r2, r3
        LL_ADC_SetChannelSamplingTime(hadc->Instance, __LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel) + 1UL) & 0x1FUL), sConfig->SamplingTime);
 80014e6:	fab2 f282 	clz	r2, r2
 80014ea:	3201      	adds	r2, #1
 80014ec:	f002 021f 	and.w	r2, r2, #31
 80014f0:	2a09      	cmp	r2, #9
 80014f2:	d830      	bhi.n	8001556 <HAL_ADC_ConfigChannel+0x24e>
 80014f4:	fa93 f6a3 	rbit	r6, r3
 80014f8:	fab6 f686 	clz	r6, r6
 80014fc:	3601      	adds	r6, #1
 80014fe:	06b6      	lsls	r6, r6, #26
 8001500:	f006 46f8 	and.w	r6, r6, #2080374784	; 0x7c000000
 8001504:	fa93 f1a3 	rbit	r1, r3
 8001508:	fab1 f181 	clz	r1, r1
 800150c:	3101      	adds	r1, #1
 800150e:	f001 021f 	and.w	r2, r1, #31
 8001512:	2101      	movs	r1, #1
 8001514:	e001      	b.n	800151a <HAL_ADC_ConfigChannel+0x212>
 8001516:	f006 46f8 	and.w	r6, r6, #2080374784	; 0x7c000000
 800151a:	4091      	lsls	r1, r2
 800151c:	ea41 0206 	orr.w	r2, r1, r6
 8001520:	b9a7      	cbnz	r7, 800154c <HAL_ADC_ConfigChannel+0x244>
 8001522:	0e99      	lsrs	r1, r3, #26
 8001524:	3101      	adds	r1, #1
 8001526:	f001 011f 	and.w	r1, r1, #31
 800152a:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 800152e:	0509      	lsls	r1, r1, #20
 8001530:	4311      	orrs	r1, r2
 8001532:	68a2      	ldr	r2, [r4, #8]
 8001534:	f7ff fd72 	bl	800101c <LL_ADC_SetChannelSamplingTime>
    /* If internal channel selected, enable dedicated internal buffers and    */
    /* paths.                                                                 */
    /* Note: these internal measurement paths can be disabled using           */
    /* HAL_ADC_DeInit().                                                      */
    
    if(__LL_ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
 8001538:	6822      	ldr	r2, [r4, #0]
 800153a:	4b5b      	ldr	r3, [pc, #364]	; (80016a8 <HAL_ADC_ConfigChannel+0x3a0>)
 800153c:	421a      	tst	r2, r3
 800153e:	d120      	bne.n	8001582 <HAL_ADC_ConfigChannel+0x27a>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8001540:	2000      	movs	r0, #0
    
    tmp_hal_status = HAL_ERROR;
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8001542:	2300      	movs	r3, #0
 8001544:	f885 3050 	strb.w	r3, [r5, #80]	; 0x50
  
  /* Return function status */
  return tmp_hal_status;
}
 8001548:	b003      	add	sp, #12
 800154a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800154c:	fa93 f1a3 	rbit	r1, r3
        LL_ADC_SetChannelSamplingTime(hadc->Instance, __LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel) + 1UL) & 0x1FUL), sConfig->SamplingTime);
 8001550:	fab1 f181 	clz	r1, r1
 8001554:	e7e6      	b.n	8001524 <HAL_ADC_ConfigChannel+0x21c>
 8001556:	fa93 f2a3 	rbit	r2, r3
 800155a:	fab2 f282 	clz	r2, r2
 800155e:	3201      	adds	r2, #1
 8001560:	0692      	lsls	r2, r2, #26
 8001562:	f002 46f8 	and.w	r6, r2, #2080374784	; 0x7c000000
 8001566:	fa93 f1a3 	rbit	r1, r3
 800156a:	fab1 f181 	clz	r1, r1
 800156e:	3101      	adds	r1, #1
 8001570:	f001 021f 	and.w	r2, r1, #31
 8001574:	2101      	movs	r1, #1
 8001576:	e72e      	b.n	80013d6 <HAL_ADC_ConfigChannel+0xce>
 8001578:	fa93 f3a3 	rbit	r3, r3
 800157c:	fab3 f383 	clz	r3, r3
 8001580:	e730      	b.n	80013e4 <HAL_ADC_ConfigChannel+0xdc>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 8001582:	494a      	ldr	r1, [pc, #296]	; (80016ac <HAL_ADC_ConfigChannel+0x3a4>)
      if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_TEMPSENSOR) == 0UL))
 8001584:	4b4a      	ldr	r3, [pc, #296]	; (80016b0 <HAL_ADC_ConfigChannel+0x3a8>)
 8001586:	6888      	ldr	r0, [r1, #8]
 8001588:	429a      	cmp	r2, r3
 800158a:	f000 76e0 	and.w	r6, r0, #29360128	; 0x1c00000
 800158e:	460c      	mov	r4, r1
 8001590:	d11e      	bne.n	80015d0 <HAL_ADC_ConfigChannel+0x2c8>
 8001592:	0202      	lsls	r2, r0, #8
 8001594:	d4d4      	bmi.n	8001540 <HAL_ADC_ConfigChannel+0x238>
        if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc)) 
 8001596:	682b      	ldr	r3, [r5, #0]
 8001598:	4a46      	ldr	r2, [pc, #280]	; (80016b4 <HAL_ADC_ConfigChannel+0x3ac>)
 800159a:	4293      	cmp	r3, r2
 800159c:	d003      	beq.n	80015a6 <HAL_ADC_ConfigChannel+0x29e>
 800159e:	f502 7200 	add.w	r2, r2, #512	; 0x200
 80015a2:	4293      	cmp	r3, r2
 80015a4:	d1cc      	bne.n	8001540 <HAL_ADC_ConfigChannel+0x238>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 80015a6:	68a3      	ldr	r3, [r4, #8]
          wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * (SystemCoreClock / (100000UL * 2UL)));
 80015a8:	4a43      	ldr	r2, [pc, #268]	; (80016b8 <HAL_ADC_ConfigChannel+0x3b0>)
 80015aa:	f023 73e0 	bic.w	r3, r3, #29360128	; 0x1c00000
 80015ae:	4333      	orrs	r3, r6
 80015b0:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 80015b4:	60a3      	str	r3, [r4, #8]
 80015b6:	4b41      	ldr	r3, [pc, #260]	; (80016bc <HAL_ADC_ConfigChannel+0x3b4>)
 80015b8:	681b      	ldr	r3, [r3, #0]
 80015ba:	fbb3 f2f2 	udiv	r2, r3, r2
 80015be:	230c      	movs	r3, #12
 80015c0:	4353      	muls	r3, r2
            wait_loop_index--;
 80015c2:	9301      	str	r3, [sp, #4]
          while(wait_loop_index != 0UL)
 80015c4:	9b01      	ldr	r3, [sp, #4]
 80015c6:	2b00      	cmp	r3, #0
 80015c8:	d0ba      	beq.n	8001540 <HAL_ADC_ConfigChannel+0x238>
            wait_loop_index--;
 80015ca:	9b01      	ldr	r3, [sp, #4]
 80015cc:	3b01      	subs	r3, #1
 80015ce:	e7f8      	b.n	80015c2 <HAL_ADC_ConfigChannel+0x2ba>
      else if ((sConfig->Channel == ADC_CHANNEL_VBAT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
 80015d0:	4b3b      	ldr	r3, [pc, #236]	; (80016c0 <HAL_ADC_ConfigChannel+0x3b8>)
 80015d2:	429a      	cmp	r2, r3
 80015d4:	d111      	bne.n	80015fa <HAL_ADC_ConfigChannel+0x2f2>
 80015d6:	01c3      	lsls	r3, r0, #7
 80015d8:	d4b2      	bmi.n	8001540 <HAL_ADC_ConfigChannel+0x238>
        if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
 80015da:	682b      	ldr	r3, [r5, #0]
 80015dc:	4a35      	ldr	r2, [pc, #212]	; (80016b4 <HAL_ADC_ConfigChannel+0x3ac>)
 80015de:	4293      	cmp	r3, r2
 80015e0:	d003      	beq.n	80015ea <HAL_ADC_ConfigChannel+0x2e2>
 80015e2:	f502 7200 	add.w	r2, r2, #512	; 0x200
 80015e6:	4293      	cmp	r3, r2
 80015e8:	d1aa      	bne.n	8001540 <HAL_ADC_ConfigChannel+0x238>
 80015ea:	68a3      	ldr	r3, [r4, #8]
 80015ec:	f023 73e0 	bic.w	r3, r3, #29360128	; 0x1c00000
 80015f0:	4333      	orrs	r3, r6
 80015f2:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80015f6:	60a3      	str	r3, [r4, #8]
 80015f8:	e7a2      	b.n	8001540 <HAL_ADC_ConfigChannel+0x238>
      else if ((sConfig->Channel == ADC_CHANNEL_VREFINT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VREFINT) == 0UL))
 80015fa:	4b32      	ldr	r3, [pc, #200]	; (80016c4 <HAL_ADC_ConfigChannel+0x3bc>)
 80015fc:	429a      	cmp	r2, r3
 80015fe:	d19f      	bne.n	8001540 <HAL_ADC_ConfigChannel+0x238>
 8001600:	f410 0080 	ands.w	r0, r0, #4194304	; 0x400000
 8001604:	d19c      	bne.n	8001540 <HAL_ADC_ConfigChannel+0x238>
        if (ADC_VREFINT_INSTANCE(hadc))
 8001606:	682a      	ldr	r2, [r5, #0]
 8001608:	4b2a      	ldr	r3, [pc, #168]	; (80016b4 <HAL_ADC_ConfigChannel+0x3ac>)
 800160a:	429a      	cmp	r2, r3
 800160c:	d198      	bne.n	8001540 <HAL_ADC_ConfigChannel+0x238>
 800160e:	688b      	ldr	r3, [r1, #8]
 8001610:	f023 73e0 	bic.w	r3, r3, #29360128	; 0x1c00000
 8001614:	4333      	orrs	r3, r6
 8001616:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 800161a:	608b      	str	r3, [r1, #8]
 800161c:	e791      	b.n	8001542 <HAL_ADC_ConfigChannel+0x23a>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 800161e:	6d6a      	ldr	r2, [r5, #84]	; 0x54
 8001620:	f042 0220 	orr.w	r2, r2, #32
 8001624:	656a      	str	r2, [r5, #84]	; 0x54
    tmp_hal_status = HAL_ERROR;
 8001626:	4618      	mov	r0, r3
 8001628:	e78b      	b.n	8001542 <HAL_ADC_ConfigChannel+0x23a>
  __HAL_LOCK(hadc);
 800162a:	2002      	movs	r0, #2
 800162c:	e78c      	b.n	8001548 <HAL_ADC_ConfigChannel+0x240>
    if (   (tmp_adc_is_conversion_on_going_regular == 0UL)
 800162e:	2800      	cmp	r0, #0
 8001630:	f47f aea5 	bne.w	800137e <HAL_ADC_ConfigChannel+0x76>
      LL_ADC_SetChannelSamplingTime(hadc->Instance, sConfig->Channel, sConfig->SamplingTime);
 8001634:	68a2      	ldr	r2, [r4, #8]
 8001636:	6821      	ldr	r1, [r4, #0]
 8001638:	4618      	mov	r0, r3
 800163a:	f7ff fcef 	bl	800101c <LL_ADC_SetChannelSamplingTime>
      if(sConfig->OffsetNumber != ADC_OFFSET_NONE)
 800163e:	6926      	ldr	r6, [r4, #16]
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, sConfig->Offset);
 8001640:	f8d5 e000 	ldr.w	lr, [r5]
 8001644:	6823      	ldr	r3, [r4, #0]
 8001646:	f8de 100c 	ldr.w	r1, [lr, #12]
      if(sConfig->OffsetNumber != ADC_OFFSET_NONE)
 800164a:	2e04      	cmp	r6, #4
 800164c:	f10e 0260 	add.w	r2, lr, #96	; 0x60
 8001650:	f43f aedb 	beq.w	800140a <HAL_ADC_ConfigChannel+0x102>
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, sConfig->Offset);
 8001654:	f3c1 01c1 	ubfx	r1, r1, #3, #2
 8001658:	0048      	lsls	r0, r1, #1
 800165a:	6961      	ldr	r1, [r4, #20]
  MODIFY_REG(*preg,
 800165c:	f003 43f8 	and.w	r3, r3, #2080374784	; 0x7c000000
 8001660:	4081      	lsls	r1, r0
 8001662:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8001666:	4319      	orrs	r1, r3
 8001668:	f852 0026 	ldr.w	r0, [r2, r6, lsl #2]
 800166c:	4b16      	ldr	r3, [pc, #88]	; (80016c8 <HAL_ADC_ConfigChannel+0x3c0>)
 800166e:	4003      	ands	r3, r0
 8001670:	4319      	orrs	r1, r3
 8001672:	f842 1026 	str.w	r1, [r2, r6, lsl #2]
 8001676:	e682      	b.n	800137e <HAL_ADC_ConfigChannel+0x76>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8001678:	f8de 1064 	ldr.w	r1, [lr, #100]	; 0x64
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 800167c:	f3c1 6084 	ubfx	r0, r1, #26, #5
 8001680:	e6de      	b.n	8001440 <HAL_ADC_ConfigChannel+0x138>
 8001682:	6891      	ldr	r1, [r2, #8]
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8001684:	6823      	ldr	r3, [r4, #0]
  register const uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8001686:	f102 0608 	add.w	r6, r2, #8
 800168a:	f3c1 6084 	ubfx	r0, r1, #26, #5
 800168e:	e6e8      	b.n	8001462 <HAL_ADC_ConfigChannel+0x15a>
 8001690:	f102 000c 	add.w	r0, r2, #12
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8001694:	68d2      	ldr	r2, [r2, #12]
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8001696:	6823      	ldr	r3, [r4, #0]
 8001698:	f3c2 6184 	ubfx	r1, r2, #26, #5
 800169c:	e6f2      	b.n	8001484 <HAL_ADC_ConfigChannel+0x17c>
 800169e:	bf00      	nop
 80016a0:	0007ffff 	.word	0x0007ffff
 80016a4:	407f0000 	.word	0x407f0000
 80016a8:	80080000 	.word	0x80080000
 80016ac:	50040300 	.word	0x50040300
 80016b0:	c7520000 	.word	0xc7520000
 80016b4:	50040000 	.word	0x50040000
 80016b8:	00030d40 	.word	0x00030d40
 80016bc:	20000058 	.word	0x20000058
 80016c0:	cb840000 	.word	0xcb840000
 80016c4:	80000001 	.word	0x80000001
 80016c8:	03fff000 	.word	0x03fff000

080016cc <HAL_ADC_GetState>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
  
  /* Return ADC handle state */
  return hadc->State;
 80016cc:	6d40      	ldr	r0, [r0, #84]	; 0x54
}
 80016ce:	4770      	bx	lr

080016d0 <ADC_ConversionStop>:
  *            @arg @ref ADC_INJECTED_GROUP          ADC injected conversion type.
  *            @arg @ref ADC_REGULAR_INJECTED_GROUP  ADC regular and injected conversion type.
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_ConversionStop(ADC_HandleTypeDef* hadc, uint32_t ConversionGroup)
{
 80016d0:	b570      	push	{r4, r5, r6, lr}
 80016d2:	4604      	mov	r4, r0
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
  assert_param(IS_ADC_CONVERSION_GROUP(ConversionGroup));
  
  /* Verification if ADC is not already stopped (on regular and injected      */
  /* groups) to bypass this function if not needed.                           */
  tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 80016d4:	6800      	ldr	r0, [r0, #0]
 80016d6:	f7ff fcb7 	bl	8001048 <LL_ADC_REG_IsConversionOngoing>
  tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
 80016da:	6823      	ldr	r3, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 80016dc:	689a      	ldr	r2, [r3, #8]
 80016de:	0715      	lsls	r5, r2, #28
 80016e0:	d542      	bpl.n	8001768 <ADC_ConversionStop+0x98>
    /* auto-delay mode.                                                       */
    /* In auto-injection mode, regular group stop ADC_CR_ADSTP is used (not   */
    /* injected group stop ADC_CR_JADSTP).                                    */
    /* Procedure to be followed: Wait until JEOS=1, clear JEOS, set ADSTP=1   */
    /* (see reference manual).                                                */
    if (    ((hadc->Instance->CFGR & ADC_CFGR_JAUTO) != 0UL)
 80016e2:	68da      	ldr	r2, [r3, #12]
 80016e4:	0192      	lsls	r2, r2, #6
 80016e6:	d523      	bpl.n	8001730 <ADC_ConversionStop+0x60>
         && (hadc->Init.ContinuousConvMode == ENABLE)
         && (hadc->Init.LowPowerAutoWait == ENABLE)
 80016e8:	8b20      	ldrh	r0, [r4, #24]
 80016ea:	f240 1201 	movw	r2, #257	; 0x101
 80016ee:	4290      	cmp	r0, r2
 80016f0:	d11e      	bne.n	8001730 <ADC_ConversionStop+0x60>
 80016f2:	4a29      	ldr	r2, [pc, #164]	; (8001798 <ADC_ConversionStop+0xc8>)
    {
      /* Use stop of regular group */
      conversion_group_reassigned = ADC_REGULAR_GROUP;
      
      /* Wait until JEOS=1 (maximum Timeout: 4 injected conversions) */
      while(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOS) == 0UL)
 80016f4:	6819      	ldr	r1, [r3, #0]
 80016f6:	064e      	lsls	r6, r1, #25
 80016f8:	d50e      	bpl.n	8001718 <ADC_ConversionStop+0x48>
        }
        Conversion_Timeout_CPU_cycles ++;
      }
      
      /* Clear JEOS */
      __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JEOS);
 80016fa:	2240      	movs	r2, #64	; 0x40
 80016fc:	601a      	str	r2, [r3, #0]
      conversion_group_reassigned = ADC_REGULAR_GROUP;
 80016fe:	2101      	movs	r1, #1
    
    /* Stop potential conversion on going on ADC group regular */
    if (conversion_group_reassigned != ADC_INJECTED_GROUP)
    {
      /* Software is allowed to set ADSTP only when ADSTART=1 and ADDIS=0 */
      if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) != 0UL)
 8001700:	4618      	mov	r0, r3
 8001702:	f7ff fca1 	bl	8001048 <LL_ADC_REG_IsConversionOngoing>
 8001706:	b118      	cbz	r0, 8001710 <ADC_ConversionStop+0x40>
      {
        if (LL_ADC_IsDisableOngoing(hadc->Instance) == 0UL)
 8001708:	6822      	ldr	r2, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADDIS) == (ADC_CR_ADDIS)) ? 1UL : 0UL);
 800170a:	6893      	ldr	r3, [r2, #8]
 800170c:	079d      	lsls	r5, r3, #30
 800170e:	d52e      	bpl.n	800176e <ADC_ConversionStop+0x9e>
        }
      }
    }
    
    /* Stop potential conversion on going on ADC group injected */
    if (conversion_group_reassigned != ADC_REGULAR_GROUP)
 8001710:	2901      	cmp	r1, #1
 8001712:	d10f      	bne.n	8001734 <ADC_ConversionStop+0x64>
    case ADC_INJECTED_GROUP:
        tmp_ADC_CR_ADSTART_JADSTART = ADC_CR_JADSTART;
        break;
    /* Case ADC_REGULAR_GROUP only*/
    default:
        tmp_ADC_CR_ADSTART_JADSTART = ADC_CR_ADSTART;
 8001714:	2504      	movs	r5, #4
        break;
 8001716:	e018      	b.n	800174a <ADC_ConversionStop+0x7a>
        if (Conversion_Timeout_CPU_cycles >= (ADC_CONVERSION_TIME_MAX_CPU_CYCLES * 4UL))
 8001718:	3a01      	subs	r2, #1
 800171a:	d1eb      	bne.n	80016f4 <ADC_ConversionStop+0x24>
    while((hadc->Instance->CR & tmp_ADC_CR_ADSTART_JADSTART) != 0UL)
    {
      if((HAL_GetTick()-tickstart) > ADC_STOP_CONVERSION_TIMEOUT)
      {
        /* Update ADC state machine to error */
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 800171c:	6d63      	ldr	r3, [r4, #84]	; 0x54
 800171e:	f043 0310 	orr.w	r3, r3, #16
 8001722:	6563      	str	r3, [r4, #84]	; 0x54
        
        /* Set ADC error code to ADC IP internal error */
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8001724:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8001726:	f043 0301 	orr.w	r3, r3, #1
 800172a:	65a3      	str	r3, [r4, #88]	; 0x58
        
        return HAL_ERROR;
 800172c:	2001      	movs	r0, #1
 800172e:	bd70      	pop	{r4, r5, r6, pc}
    if (conversion_group_reassigned != ADC_INJECTED_GROUP)
 8001730:	2902      	cmp	r1, #2
 8001732:	d1e5      	bne.n	8001700 <ADC_ConversionStop+0x30>
      if (LL_ADC_INJ_IsConversionOngoing(hadc->Instance) != 0UL)
 8001734:	6822      	ldr	r2, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 8001736:	6893      	ldr	r3, [r2, #8]
 8001738:	0718      	lsls	r0, r3, #28
 800173a:	d421      	bmi.n	8001780 <ADC_ConversionStop+0xb0>
    switch(conversion_group_reassigned)
 800173c:	2902      	cmp	r1, #2
 800173e:	d003      	beq.n	8001748 <ADC_ConversionStop+0x78>
 8001740:	2903      	cmp	r1, #3
 8001742:	d1e7      	bne.n	8001714 <ADC_ConversionStop+0x44>
        tmp_ADC_CR_ADSTART_JADSTART = (ADC_CR_ADSTART | ADC_CR_JADSTART);
 8001744:	250c      	movs	r5, #12
 8001746:	e000      	b.n	800174a <ADC_ConversionStop+0x7a>
        tmp_ADC_CR_ADSTART_JADSTART = ADC_CR_JADSTART;
 8001748:	2508      	movs	r5, #8
    tickstart = HAL_GetTick();
 800174a:	f7ff fc41 	bl	8000fd0 <HAL_GetTick>
 800174e:	4606      	mov	r6, r0
    while((hadc->Instance->CR & tmp_ADC_CR_ADSTART_JADSTART) != 0UL)
 8001750:	6823      	ldr	r3, [r4, #0]
 8001752:	689b      	ldr	r3, [r3, #8]
 8001754:	421d      	tst	r5, r3
 8001756:	d101      	bne.n	800175c <ADC_ConversionStop+0x8c>
    }
    
  }
  
  /* Return HAL status */
  return HAL_OK;
 8001758:	2000      	movs	r0, #0
 800175a:	bd70      	pop	{r4, r5, r6, pc}
      if((HAL_GetTick()-tickstart) > ADC_STOP_CONVERSION_TIMEOUT)
 800175c:	f7ff fc38 	bl	8000fd0 <HAL_GetTick>
 8001760:	1b80      	subs	r0, r0, r6
 8001762:	2805      	cmp	r0, #5
 8001764:	d9f4      	bls.n	8001750 <ADC_ConversionStop+0x80>
 8001766:	e7d9      	b.n	800171c <ADC_ConversionStop+0x4c>
  if (   (tmp_adc_is_conversion_on_going_regular != 0UL)
 8001768:	2800      	cmp	r0, #0
 800176a:	d1ba      	bne.n	80016e2 <ADC_ConversionStop+0x12>
 800176c:	e7f4      	b.n	8001758 <ADC_ConversionStop+0x88>
  MODIFY_REG(ADCx->CR,
 800176e:	6893      	ldr	r3, [r2, #8]
 8001770:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8001774:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8001778:	f043 0310 	orr.w	r3, r3, #16
 800177c:	6093      	str	r3, [r2, #8]
 800177e:	e7c7      	b.n	8001710 <ADC_ConversionStop+0x40>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADDIS) == (ADC_CR_ADDIS)) ? 1UL : 0UL);
 8001780:	6893      	ldr	r3, [r2, #8]
 8001782:	079b      	lsls	r3, r3, #30
 8001784:	d4da      	bmi.n	800173c <ADC_ConversionStop+0x6c>
  MODIFY_REG(ADCx->CR,
 8001786:	6893      	ldr	r3, [r2, #8]
 8001788:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800178c:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8001790:	f043 0320 	orr.w	r3, r3, #32
 8001794:	6093      	str	r3, [r2, #8]
 8001796:	e7d1      	b.n	800173c <ADC_ConversionStop+0x6c>
 8001798:	a3400001 	.word	0xa3400001

0800179c <ADC_Enable>:
  *         and voltage regulator must be enabled (done into HAL_ADC_Init()).
  * @param hadc ADC handle
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_Enable(ADC_HandleTypeDef* hadc)
{
 800179c:	b570      	push	{r4, r5, r6, lr}
 800179e:	4604      	mov	r4, r0
  
  /* ADC enable and wait for ADC ready (in case of ADC is disabled or         */
  /* enabling phase not yet completed: flag ADC ready not yet set).           */
  /* Timeout implemented to not be stuck if ADC cannot be enabled (possible   */
  /* causes: ADC clock not running, ...).                                     */
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 80017a0:	6800      	ldr	r0, [r0, #0]
 80017a2:	f7ff fc4d 	bl	8001040 <LL_ADC_IsEnabled>
 80017a6:	b108      	cbz	r0, 80017ac <ADC_Enable+0x10>
      }
    }
  }
   
  /* Return HAL status */
  return HAL_OK;
 80017a8:	2000      	movs	r0, #0
 80017aa:	bd70      	pop	{r4, r5, r6, pc}
    if ((hadc->Instance->CR & (ADC_CR_ADCAL | ADC_CR_JADSTP | ADC_CR_ADSTP | ADC_CR_JADSTART | ADC_CR_ADSTART | ADC_CR_ADDIS | ADC_CR_ADEN)) != 0UL)
 80017ac:	6822      	ldr	r2, [r4, #0]
 80017ae:	4b15      	ldr	r3, [pc, #84]	; (8001804 <ADC_Enable+0x68>)
 80017b0:	6891      	ldr	r1, [r2, #8]
 80017b2:	4219      	tst	r1, r3
 80017b4:	d009      	beq.n	80017ca <ADC_Enable+0x2e>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 80017b6:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80017b8:	f043 0310 	orr.w	r3, r3, #16
 80017bc:	6563      	str	r3, [r4, #84]	; 0x54
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 80017be:	6da3      	ldr	r3, [r4, #88]	; 0x58
 80017c0:	f043 0301 	orr.w	r3, r3, #1
 80017c4:	65a3      	str	r3, [r4, #88]	; 0x58
        return HAL_ERROR;
 80017c6:	2001      	movs	r0, #1
 80017c8:	bd70      	pop	{r4, r5, r6, pc}
  MODIFY_REG(ADCx->CR,
 80017ca:	6893      	ldr	r3, [r2, #8]
 80017cc:	4d0e      	ldr	r5, [pc, #56]	; (8001808 <ADC_Enable+0x6c>)
 80017ce:	402b      	ands	r3, r5
 80017d0:	f043 0301 	orr.w	r3, r3, #1
 80017d4:	6093      	str	r3, [r2, #8]
    tickstart = HAL_GetTick();
 80017d6:	f7ff fbfb 	bl	8000fd0 <HAL_GetTick>
 80017da:	4606      	mov	r6, r0
    while(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
 80017dc:	6820      	ldr	r0, [r4, #0]
 80017de:	6803      	ldr	r3, [r0, #0]
 80017e0:	07db      	lsls	r3, r3, #31
 80017e2:	d4e1      	bmi.n	80017a8 <ADC_Enable+0xc>
      if(LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 80017e4:	f7ff fc2c 	bl	8001040 <LL_ADC_IsEnabled>
 80017e8:	b928      	cbnz	r0, 80017f6 <ADC_Enable+0x5a>
        LL_ADC_Enable(hadc->Instance);
 80017ea:	6822      	ldr	r2, [r4, #0]
 80017ec:	6893      	ldr	r3, [r2, #8]
 80017ee:	402b      	ands	r3, r5
 80017f0:	f043 0301 	orr.w	r3, r3, #1
 80017f4:	6093      	str	r3, [r2, #8]
      if((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
 80017f6:	f7ff fbeb 	bl	8000fd0 <HAL_GetTick>
 80017fa:	1b80      	subs	r0, r0, r6
 80017fc:	2802      	cmp	r0, #2
 80017fe:	d9ed      	bls.n	80017dc <ADC_Enable+0x40>
 8001800:	e7d9      	b.n	80017b6 <ADC_Enable+0x1a>
 8001802:	bf00      	nop
 8001804:	8000003f 	.word	0x8000003f
 8001808:	7fffffc0 	.word	0x7fffffc0

0800180c <HAL_ADC_Start>:
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_DUAL));
 800180c:	4b35      	ldr	r3, [pc, #212]	; (80018e4 <HAL_ADC_Start+0xd8>)
{
 800180e:	b570      	push	{r4, r5, r6, lr}
 8001810:	4604      	mov	r4, r0
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 8001812:	6800      	ldr	r0, [r0, #0]
 8001814:	689e      	ldr	r6, [r3, #8]
 8001816:	f7ff fc17 	bl	8001048 <LL_ADC_REG_IsConversionOngoing>
 800181a:	4605      	mov	r5, r0
 800181c:	2800      	cmp	r0, #0
 800181e:	d15a      	bne.n	80018d6 <HAL_ADC_Start+0xca>
    __HAL_LOCK(hadc);
 8001820:	f894 3050 	ldrb.w	r3, [r4, #80]	; 0x50
 8001824:	2b01      	cmp	r3, #1
 8001826:	d056      	beq.n	80018d6 <HAL_ADC_Start+0xca>
 8001828:	2301      	movs	r3, #1
 800182a:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
    tmp_hal_status = ADC_Enable(hadc);
 800182e:	4620      	mov	r0, r4
 8001830:	f7ff ffb4 	bl	800179c <ADC_Enable>
    if (tmp_hal_status == HAL_OK)
 8001834:	2800      	cmp	r0, #0
 8001836:	d14b      	bne.n	80018d0 <HAL_ADC_Start+0xc4>
      ADC_STATE_CLR_SET(hadc->State,
 8001838:	6d63      	ldr	r3, [r4, #84]	; 0x54
      if (    (__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
 800183a:	4a2b      	ldr	r2, [pc, #172]	; (80018e8 <HAL_ADC_Start+0xdc>)
      ADC_STATE_CLR_SET(hadc->State,
 800183c:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 8001840:	f023 0301 	bic.w	r3, r3, #1
 8001844:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8001848:	6563      	str	r3, [r4, #84]	; 0x54
      if (    (__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
 800184a:	6823      	ldr	r3, [r4, #0]
 800184c:	4293      	cmp	r3, r2
 800184e:	f006 061f 	and.w	r6, r6, #31
 8001852:	d042      	beq.n	80018da <HAL_ADC_Start+0xce>
 8001854:	461d      	mov	r5, r3
        CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
 8001856:	6d62      	ldr	r2, [r4, #84]	; 0x54
 8001858:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 800185c:	6562      	str	r2, [r4, #84]	; 0x54
      if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
 800185e:	6d62      	ldr	r2, [r4, #84]	; 0x54
 8001860:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
        CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
 8001864:	bf1c      	itt	ne
 8001866:	6da2      	ldrne	r2, [r4, #88]	; 0x58
 8001868:	f022 0206 	bicne.w	r2, r2, #6
        ADC_CLEAR_ERRORCODE(hadc); 
 800186c:	65a2      	str	r2, [r4, #88]	; 0x58
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 800186e:	221c      	movs	r2, #28
 8001870:	601a      	str	r2, [r3, #0]
      if (    (__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
 8001872:	42ab      	cmp	r3, r5
      __HAL_UNLOCK(hadc);
 8001874:	f04f 0200 	mov.w	r2, #0
 8001878:	f884 2050 	strb.w	r2, [r4, #80]	; 0x50
      if (    (__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
 800187c:	d008      	beq.n	8001890 <HAL_ADC_Start+0x84>
           || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
 800187e:	2e09      	cmp	r6, #9
 8001880:	bf9d      	ittte	ls
 8001882:	f240 2221 	movwls	r2, #545	; 0x221
 8001886:	40f2      	lsrls	r2, r6
 8001888:	43d2      	mvnls	r2, r2
 800188a:	2201      	movhi	r2, #1
 800188c:	07d1      	lsls	r1, r2, #31
 800188e:	d411      	bmi.n	80018b4 <HAL_ADC_Start+0xa8>
        if (READ_BIT(hadc->Instance->CFGR, ADC_CFGR_JAUTO) != 0UL)
 8001890:	68da      	ldr	r2, [r3, #12]
 8001892:	0192      	lsls	r2, r2, #6
          ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
 8001894:	bf41      	itttt	mi
 8001896:	6d62      	ldrmi	r2, [r4, #84]	; 0x54
 8001898:	f422 5240 	bicmi.w	r2, r2, #12288	; 0x3000
 800189c:	f442 5280 	orrmi.w	r2, r2, #4096	; 0x1000
 80018a0:	6562      	strmi	r2, [r4, #84]	; 0x54
  MODIFY_REG(ADCx->CR,
 80018a2:	689a      	ldr	r2, [r3, #8]
 80018a4:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 80018a8:	f022 023f 	bic.w	r2, r2, #63	; 0x3f
 80018ac:	f042 0204 	orr.w	r2, r2, #4
 80018b0:	609a      	str	r2, [r3, #8]
 80018b2:	bd70      	pop	{r4, r5, r6, pc}
        SET_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
 80018b4:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80018b6:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80018ba:	6563      	str	r3, [r4, #84]	; 0x54
        if (READ_BIT(tmpADC_Master->CFGR, ADC_CFGR_JAUTO) != 0UL)
 80018bc:	68eb      	ldr	r3, [r5, #12]
 80018be:	019b      	lsls	r3, r3, #6
 80018c0:	d50f      	bpl.n	80018e2 <HAL_ADC_Start+0xd6>
          ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);
 80018c2:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80018c4:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 80018c8:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 80018cc:	6563      	str	r3, [r4, #84]	; 0x54
 80018ce:	bd70      	pop	{r4, r5, r6, pc}
      __HAL_UNLOCK(hadc);
 80018d0:	f884 5050 	strb.w	r5, [r4, #80]	; 0x50
 80018d4:	bd70      	pop	{r4, r5, r6, pc}
    tmp_hal_status = HAL_BUSY;
 80018d6:	2002      	movs	r0, #2
 80018d8:	bd70      	pop	{r4, r5, r6, pc}
      if (    (__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
 80018da:	4d04      	ldr	r5, [pc, #16]	; (80018ec <HAL_ADC_Start+0xe0>)
           || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
 80018dc:	2e00      	cmp	r6, #0
 80018de:	d0ba      	beq.n	8001856 <HAL_ADC_Start+0x4a>
 80018e0:	e7bd      	b.n	800185e <HAL_ADC_Start+0x52>
}
 80018e2:	bd70      	pop	{r4, r5, r6, pc}
 80018e4:	50040300 	.word	0x50040300
 80018e8:	50040100 	.word	0x50040100
 80018ec:	50040000 	.word	0x50040000

080018f0 <ADC_Disable>:
  *         stopped.
  * @param hadc ADC handle
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_Disable(ADC_HandleTypeDef* hadc)
{
 80018f0:	b538      	push	{r3, r4, r5, lr}
 80018f2:	4604      	mov	r4, r0
  uint32_t tickstart;
  const uint32_t tmp_adc_is_disable_on_going = LL_ADC_IsDisableOngoing(hadc->Instance);
 80018f4:	6800      	ldr	r0, [r0, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADDIS) == (ADC_CR_ADDIS)) ? 1UL : 0UL);
 80018f6:	6883      	ldr	r3, [r0, #8]
 80018f8:	f003 0302 	and.w	r3, r3, #2
  
  /* Verification if ADC is not already disabled:                             */
  /* Note: forbidden to disable ADC (set bit ADC_CR_ADDIS) if ADC is already  */
  /*       disabled.                                                          */
  if (   (LL_ADC_IsEnabled(hadc->Instance) != 0UL)
 80018fc:	f7ff fba0 	bl	8001040 <LL_ADC_IsEnabled>
 8001900:	b908      	cbnz	r0, 8001906 <ADC_Disable+0x16>
      }
    }
  }
  
  /* Return HAL status */
  return HAL_OK;
 8001902:	2000      	movs	r0, #0
 8001904:	bd38      	pop	{r3, r4, r5, pc}
      && (tmp_adc_is_disable_on_going == 0UL)
 8001906:	2b00      	cmp	r3, #0
 8001908:	d1fb      	bne.n	8001902 <ADC_Disable+0x12>
    if((hadc->Instance->CR & (ADC_CR_JADSTART | ADC_CR_ADSTART | ADC_CR_ADEN)) == ADC_CR_ADEN)
 800190a:	6822      	ldr	r2, [r4, #0]
 800190c:	6893      	ldr	r3, [r2, #8]
 800190e:	f003 030d 	and.w	r3, r3, #13
 8001912:	2b01      	cmp	r3, #1
 8001914:	d115      	bne.n	8001942 <ADC_Disable+0x52>
  MODIFY_REG(ADCx->CR,
 8001916:	6893      	ldr	r3, [r2, #8]
 8001918:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800191c:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8001920:	f043 0302 	orr.w	r3, r3, #2
 8001924:	6093      	str	r3, [r2, #8]
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOSMP | ADC_FLAG_RDY));
 8001926:	2303      	movs	r3, #3
 8001928:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
 800192a:	f7ff fb51 	bl	8000fd0 <HAL_GetTick>
 800192e:	4605      	mov	r5, r0
    while((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
 8001930:	6823      	ldr	r3, [r4, #0]
 8001932:	689b      	ldr	r3, [r3, #8]
 8001934:	07db      	lsls	r3, r3, #31
 8001936:	d5e4      	bpl.n	8001902 <ADC_Disable+0x12>
      if((HAL_GetTick() - tickstart) > ADC_DISABLE_TIMEOUT)
 8001938:	f7ff fb4a 	bl	8000fd0 <HAL_GetTick>
 800193c:	1b40      	subs	r0, r0, r5
 800193e:	2802      	cmp	r0, #2
 8001940:	d9f6      	bls.n	8001930 <ADC_Disable+0x40>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8001942:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8001944:	f043 0310 	orr.w	r3, r3, #16
 8001948:	6563      	str	r3, [r4, #84]	; 0x54
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 800194a:	6da3      	ldr	r3, [r4, #88]	; 0x58
 800194c:	f043 0301 	orr.w	r3, r3, #1
 8001950:	65a3      	str	r3, [r4, #88]	; 0x58
        return HAL_ERROR;
 8001952:	2001      	movs	r0, #1
 8001954:	bd38      	pop	{r3, r4, r5, pc}

08001956 <HAL_ADC_Stop>:
  __HAL_LOCK(hadc);
 8001956:	f890 3050 	ldrb.w	r3, [r0, #80]	; 0x50
 800195a:	2b01      	cmp	r3, #1
{
 800195c:	b510      	push	{r4, lr}
 800195e:	4604      	mov	r4, r0
  __HAL_LOCK(hadc);
 8001960:	d016      	beq.n	8001990 <HAL_ADC_Stop+0x3a>
 8001962:	2301      	movs	r3, #1
 8001964:	f880 3050 	strb.w	r3, [r0, #80]	; 0x50
  tmp_hal_status = ADC_ConversionStop(hadc, ADC_REGULAR_INJECTED_GROUP);
 8001968:	2103      	movs	r1, #3
 800196a:	f7ff feb1 	bl	80016d0 <ADC_ConversionStop>
  if (tmp_hal_status == HAL_OK)
 800196e:	b958      	cbnz	r0, 8001988 <HAL_ADC_Stop+0x32>
    tmp_hal_status = ADC_Disable(hadc);
 8001970:	4620      	mov	r0, r4
 8001972:	f7ff ffbd 	bl	80018f0 <ADC_Disable>
    if (tmp_hal_status == HAL_OK)
 8001976:	b938      	cbnz	r0, 8001988 <HAL_ADC_Stop+0x32>
      ADC_STATE_CLR_SET(hadc->State,
 8001978:	6d63      	ldr	r3, [r4, #84]	; 0x54
 800197a:	f423 5388 	bic.w	r3, r3, #4352	; 0x1100
 800197e:	f023 0301 	bic.w	r3, r3, #1
 8001982:	f043 0301 	orr.w	r3, r3, #1
 8001986:	6563      	str	r3, [r4, #84]	; 0x54
  __HAL_UNLOCK(hadc);
 8001988:	2300      	movs	r3, #0
 800198a:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
  return tmp_hal_status;
 800198e:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hadc);
 8001990:	2002      	movs	r0, #2
}
 8001992:	bd10      	pop	{r4, pc}

08001994 <HAL_ADCEx_Calibration_Start>:
  *           @arg @ref ADC_SINGLE_ENDED       Channel in mode input single ended
  *           @arg @ref ADC_DIFFERENTIAL_ENDED Channel in mode input differential ended
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_Calibration_Start(ADC_HandleTypeDef* hadc, uint32_t SingleDiff)
{
 8001994:	b537      	push	{r0, r1, r2, r4, r5, lr}
  HAL_StatusTypeDef tmp_hal_status;
  __IO uint32_t wait_loop_index = 0UL;
 8001996:	2300      	movs	r3, #0
 8001998:	9301      	str	r3, [sp, #4]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
  assert_param(IS_ADC_SINGLE_DIFFERENTIAL(SingleDiff));
  
  /* Process locked */
  __HAL_LOCK(hadc);
 800199a:	f890 3050 	ldrb.w	r3, [r0, #80]	; 0x50
 800199e:	2b01      	cmp	r3, #1
{
 80019a0:	4604      	mov	r4, r0
 80019a2:	460d      	mov	r5, r1
  __HAL_LOCK(hadc);
 80019a4:	d034      	beq.n	8001a10 <HAL_ADCEx_Calibration_Start+0x7c>
 80019a6:	2301      	movs	r3, #1
 80019a8:	f880 3050 	strb.w	r3, [r0, #80]	; 0x50
  
  /* Calibration prerequisite: ADC must be disabled. */
  
  /* Disable the ADC (if not already disabled) */
  tmp_hal_status = ADC_Disable(hadc);
 80019ac:	f7ff ffa0 	bl	80018f0 <ADC_Disable>
  
  /* Check if ADC is effectively disabled */
  if (tmp_hal_status == HAL_OK)
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State, 
 80019b0:	6d63      	ldr	r3, [r4, #84]	; 0x54
  if (tmp_hal_status == HAL_OK)
 80019b2:	bb30      	cbnz	r0, 8001a02 <HAL_ADCEx_Calibration_Start+0x6e>
    ADC_STATE_CLR_SET(hadc->State, 
 80019b4:	f423 5388 	bic.w	r3, r3, #4352	; 0x1100
 80019b8:	f023 0302 	bic.w	r3, r3, #2
 80019bc:	f043 0302 	orr.w	r3, r3, #2
 80019c0:	6563      	str	r3, [r4, #84]	; 0x54
                      HAL_ADC_STATE_BUSY_INTERNAL);

    

    /* Select calibration mode single ended or differential ended */
    MODIFY_REG(hadc->Instance->CR, ADC_CR_ADCALDIF, SingleDiff);
 80019c2:	6823      	ldr	r3, [r4, #0]
    
    /* Wait for calibration completion */
    while(LL_ADC_IsCalibrationOnGoing(hadc->Instance) != 0UL)
    {
      wait_loop_index++;
      if (wait_loop_index >= ADC_CALIBRATION_TIMEOUT)
 80019c4:	4916      	ldr	r1, [pc, #88]	; (8001a20 <HAL_ADCEx_Calibration_Start+0x8c>)
    MODIFY_REG(hadc->Instance->CR, ADC_CR_ADCALDIF, SingleDiff);
 80019c6:	689a      	ldr	r2, [r3, #8]
 80019c8:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
 80019cc:	432a      	orrs	r2, r5
 80019ce:	609a      	str	r2, [r3, #8]
    SET_BIT(hadc->Instance->CR, ADC_CR_ADCAL);
 80019d0:	689a      	ldr	r2, [r3, #8]
 80019d2:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 80019d6:	609a      	str	r2, [r3, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADCAL) == (ADC_CR_ADCAL)) ? 1UL : 0UL);
 80019d8:	689a      	ldr	r2, [r3, #8]
 80019da:	2a00      	cmp	r2, #0
 80019dc:	da1a      	bge.n	8001a14 <HAL_ADCEx_Calibration_Start+0x80>
      wait_loop_index++;
 80019de:	9a01      	ldr	r2, [sp, #4]
 80019e0:	3201      	adds	r2, #1
 80019e2:	9201      	str	r2, [sp, #4]
      if (wait_loop_index >= ADC_CALIBRATION_TIMEOUT)
 80019e4:	9a01      	ldr	r2, [sp, #4]
 80019e6:	428a      	cmp	r2, r1
 80019e8:	d9f6      	bls.n	80019d8 <HAL_ADCEx_Calibration_Start+0x44>
      {
        /* Update ADC state machine to error */
        ADC_STATE_CLR_SET(hadc->State,
 80019ea:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80019ec:	f023 0312 	bic.w	r3, r3, #18
 80019f0:	f043 0310 	orr.w	r3, r3, #16
 80019f4:	6563      	str	r3, [r4, #84]	; 0x54
                          HAL_ADC_STATE_BUSY_INTERNAL,
                          HAL_ADC_STATE_ERROR_INTERNAL);
        
        /* Process unlocked */
        __HAL_UNLOCK(hadc);
 80019f6:	2300      	movs	r3, #0
 80019f8:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
        
        return HAL_ERROR;
 80019fc:	2001      	movs	r0, #1
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
  
  /* Return function status */
  return tmp_hal_status;
}
 80019fe:	b003      	add	sp, #12
 8001a00:	bd30      	pop	{r4, r5, pc}
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8001a02:	f043 0310 	orr.w	r3, r3, #16
 8001a06:	6563      	str	r3, [r4, #84]	; 0x54
  __HAL_UNLOCK(hadc);
 8001a08:	2300      	movs	r3, #0
 8001a0a:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
  return tmp_hal_status;
 8001a0e:	e7f6      	b.n	80019fe <HAL_ADCEx_Calibration_Start+0x6a>
  __HAL_LOCK(hadc);
 8001a10:	2002      	movs	r0, #2
 8001a12:	e7f4      	b.n	80019fe <HAL_ADCEx_Calibration_Start+0x6a>
    ADC_STATE_CLR_SET(hadc->State,
 8001a14:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8001a16:	f023 0303 	bic.w	r3, r3, #3
 8001a1a:	f043 0301 	orr.w	r3, r3, #1
 8001a1e:	e7f2      	b.n	8001a06 <HAL_ADCEx_Calibration_Start+0x72>
 8001a20:	000487ff 	.word	0x000487ff

08001a24 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8001a24:	4a07      	ldr	r2, [pc, #28]	; (8001a44 <HAL_NVIC_SetPriorityGrouping+0x20>)
 8001a26:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8001a28:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8001a2c:	041b      	lsls	r3, r3, #16
 8001a2e:	0c1b      	lsrs	r3, r3, #16
 8001a30:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
 8001a34:	0200      	lsls	r0, r0, #8
 8001a36:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8001a3a:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
  reg_value  =  (reg_value                                   |
 8001a3e:	4303      	orrs	r3, r0
  SCB->AIRCR =  reg_value;
 8001a40:	60d3      	str	r3, [r2, #12]
 8001a42:	4770      	bx	lr
 8001a44:	e000ed00 	.word	0xe000ed00

08001a48 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8001a48:	4b17      	ldr	r3, [pc, #92]	; (8001aa8 <HAL_NVIC_SetPriority+0x60>)
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8001a4a:	b530      	push	{r4, r5, lr}
 8001a4c:	68dc      	ldr	r4, [r3, #12]
 8001a4e:	f3c4 2402 	ubfx	r4, r4, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8001a52:	f1c4 0307 	rsb	r3, r4, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8001a56:	1d25      	adds	r5, r4, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8001a58:	2b04      	cmp	r3, #4
 8001a5a:	bf28      	it	cs
 8001a5c:	2304      	movcs	r3, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8001a5e:	2d06      	cmp	r5, #6

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001a60:	f04f 0501 	mov.w	r5, #1
 8001a64:	fa05 f303 	lsl.w	r3, r5, r3
 8001a68:	f103 33ff 	add.w	r3, r3, #4294967295
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8001a6c:	bf8c      	ite	hi
 8001a6e:	3c03      	subhi	r4, #3
 8001a70:	2400      	movls	r4, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001a72:	4019      	ands	r1, r3
 8001a74:	40a1      	lsls	r1, r4
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8001a76:	fa05 f404 	lsl.w	r4, r5, r4
 8001a7a:	3c01      	subs	r4, #1
 8001a7c:	4022      	ands	r2, r4
  if ((int32_t)(IRQn) < 0)
 8001a7e:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001a80:	ea42 0201 	orr.w	r2, r2, r1
 8001a84:	ea4f 1202 	mov.w	r2, r2, lsl #4
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001a88:	bfaf      	iteee	ge
 8001a8a:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001a8e:	f000 000f 	andlt.w	r0, r0, #15
 8001a92:	4b06      	ldrlt	r3, [pc, #24]	; (8001aac <HAL_NVIC_SetPriority+0x64>)
 8001a94:	b2d2      	uxtblt	r2, r2
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001a96:	bfa5      	ittet	ge
 8001a98:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
 8001a9c:	b2d2      	uxtbge	r2, r2
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001a9e:	541a      	strblt	r2, [r3, r0]
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001aa0:	f880 2300 	strbge.w	r2, [r0, #768]	; 0x300
 8001aa4:	bd30      	pop	{r4, r5, pc}
 8001aa6:	bf00      	nop
 8001aa8:	e000ed00 	.word	0xe000ed00
 8001aac:	e000ed14 	.word	0xe000ed14

08001ab0 <HAL_NVIC_EnableIRQ>:
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8001ab0:	0942      	lsrs	r2, r0, #5
 8001ab2:	2301      	movs	r3, #1
 8001ab4:	f000 001f 	and.w	r0, r0, #31
 8001ab8:	fa03 f000 	lsl.w	r0, r3, r0
 8001abc:	4b01      	ldr	r3, [pc, #4]	; (8001ac4 <HAL_NVIC_EnableIRQ+0x14>)
 8001abe:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
 8001ac2:	4770      	bx	lr
 8001ac4:	e000e100 	.word	0xe000e100

08001ac8 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8001ac8:	3801      	subs	r0, #1
 8001aca:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8001ace:	d20a      	bcs.n	8001ae6 <HAL_SYSTICK_Config+0x1e>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8001ad0:	4b06      	ldr	r3, [pc, #24]	; (8001aec <HAL_SYSTICK_Config+0x24>)
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001ad2:	4a07      	ldr	r2, [pc, #28]	; (8001af0 <HAL_SYSTICK_Config+0x28>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8001ad4:	6058      	str	r0, [r3, #4]
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001ad6:	21f0      	movs	r1, #240	; 0xf0
 8001ad8:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8001adc:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8001ade:	2207      	movs	r2, #7
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8001ae0:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8001ae2:	601a      	str	r2, [r3, #0]
 8001ae4:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 8001ae6:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 8001ae8:	4770      	bx	lr
 8001aea:	bf00      	nop
 8001aec:	e000e010 	.word	0xe000e010
 8001af0:	e000ed00 	.word	0xe000ed00

08001af4 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8001af4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001af8:	b085      	sub	sp, #20
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8001afa:	680b      	ldr	r3, [r1, #0]
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001afc:	f8df 81a8 	ldr.w	r8, [pc, #424]	; 8001ca8 <HAL_GPIO_Init+0x1b4>
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
        SYSCFG->EXTICR[position >> 2u] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 8001b00:	4c67      	ldr	r4, [pc, #412]	; (8001ca0 <HAL_GPIO_Init+0x1ac>)
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8001b02:	9301      	str	r3, [sp, #4]
  uint32_t position = 0x00u;
 8001b04:	2300      	movs	r3, #0
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8001b06:	9a01      	ldr	r2, [sp, #4]
 8001b08:	40da      	lsrs	r2, r3
 8001b0a:	d102      	bne.n	8001b12 <HAL_GPIO_Init+0x1e>
      }
    }

    position++;
  }
}
 8001b0c:	b005      	add	sp, #20
 8001b0e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
 8001b12:	2601      	movs	r6, #1
    if (iocurrent != 0x00u)
 8001b14:	9a01      	ldr	r2, [sp, #4]
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
 8001b16:	409e      	lsls	r6, r3
    if (iocurrent != 0x00u)
 8001b18:	ea12 0e06 	ands.w	lr, r2, r6
 8001b1c:	f000 80b1 	beq.w	8001c82 <HAL_GPIO_Init+0x18e>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8001b20:	684a      	ldr	r2, [r1, #4]
 8001b22:	f022 0710 	bic.w	r7, r2, #16
 8001b26:	2f02      	cmp	r7, #2
 8001b28:	d116      	bne.n	8001b58 <HAL_GPIO_Init+0x64>
        temp = GPIOx->AFR[position >> 3u];
 8001b2a:	ea4f 09d3 	mov.w	r9, r3, lsr #3
 8001b2e:	eb00 0989 	add.w	r9, r0, r9, lsl #2
        temp &= ~(0xFu << ((position & 0x07u) * 4u));
 8001b32:	f003 0a07 	and.w	sl, r3, #7
        temp = GPIOx->AFR[position >> 3u];
 8001b36:	f8d9 5020 	ldr.w	r5, [r9, #32]
        temp &= ~(0xFu << ((position & 0x07u) * 4u));
 8001b3a:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 8001b3e:	f04f 0c0f 	mov.w	ip, #15
 8001b42:	fa0c fc0a 	lsl.w	ip, ip, sl
 8001b46:	ea25 0c0c 	bic.w	ip, r5, ip
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * 4u));
 8001b4a:	690d      	ldr	r5, [r1, #16]
 8001b4c:	fa05 f50a 	lsl.w	r5, r5, sl
 8001b50:	ea45 050c 	orr.w	r5, r5, ip
        GPIOx->AFR[position >> 3u] = temp;
 8001b54:	f8c9 5020 	str.w	r5, [r9, #32]
 8001b58:	ea4f 0c43 	mov.w	ip, r3, lsl #1
      temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
 8001b5c:	2503      	movs	r5, #3
      temp = GPIOx->MODER;
 8001b5e:	f8d0 b000 	ldr.w	fp, [r0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
 8001b62:	fa05 f50c 	lsl.w	r5, r5, ip
 8001b66:	43ed      	mvns	r5, r5
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
 8001b68:	f002 0a03 	and.w	sl, r2, #3
      temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
 8001b6c:	ea0b 0b05 	and.w	fp, fp, r5
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
 8001b70:	fa0a f90c 	lsl.w	r9, sl, ip
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001b74:	3f01      	subs	r7, #1
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
 8001b76:	ea49 090b 	orr.w	r9, r9, fp
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001b7a:	2f01      	cmp	r7, #1
      GPIOx->MODER = temp;
 8001b7c:	f8c0 9000 	str.w	r9, [r0]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001b80:	d811      	bhi.n	8001ba6 <HAL_GPIO_Init+0xb2>
        temp = GPIOx->OSPEEDR;
 8001b82:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2u));
 8001b84:	ea05 0907 	and.w	r9, r5, r7
        temp |= (GPIO_Init->Speed << (position * 2u));
 8001b88:	68cf      	ldr	r7, [r1, #12]
 8001b8a:	fa07 f70c 	lsl.w	r7, r7, ip
 8001b8e:	ea47 0709 	orr.w	r7, r7, r9
        GPIOx->OSPEEDR = temp;
 8001b92:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
 8001b94:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 8001b96:	ea27 0906 	bic.w	r9, r7, r6
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4u) << position);
 8001b9a:	f3c2 1700 	ubfx	r7, r2, #4, #1
 8001b9e:	409f      	lsls	r7, r3
 8001ba0:	ea47 0709 	orr.w	r7, r7, r9
        GPIOx->OTYPER = temp;
 8001ba4:	6047      	str	r7, [r0, #4]
      if((GPIO_Init->Mode & GPIO_MODE_ANALOG) == GPIO_MODE_ANALOG)
 8001ba6:	f1ba 0f03 	cmp.w	sl, #3
 8001baa:	d107      	bne.n	8001bbc <HAL_GPIO_Init+0xc8>
        temp = GPIOx->ASCR;
 8001bac:	6ac7      	ldr	r7, [r0, #44]	; 0x2c
        temp &= ~(GPIO_ASCR_ASC0 << position) ;
 8001bae:	ea27 0606 	bic.w	r6, r7, r6
        temp |= (((GPIO_Init->Mode & ANALOG_MODE) >> 3) << position);
 8001bb2:	f3c2 07c0 	ubfx	r7, r2, #3, #1
 8001bb6:	409f      	lsls	r7, r3
 8001bb8:	433e      	orrs	r6, r7
        GPIOx->ASCR = temp;
 8001bba:	62c6      	str	r6, [r0, #44]	; 0x2c
      temp = GPIOx->PUPDR;
 8001bbc:	68c6      	ldr	r6, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2u));
 8001bbe:	4035      	ands	r5, r6
      temp |= ((GPIO_Init->Pull) << (position * 2u));
 8001bc0:	688e      	ldr	r6, [r1, #8]
 8001bc2:	fa06 f60c 	lsl.w	r6, r6, ip
 8001bc6:	4335      	orrs	r5, r6
      GPIOx->PUPDR = temp;
 8001bc8:	60c5      	str	r5, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8001bca:	00d5      	lsls	r5, r2, #3
 8001bcc:	d559      	bpl.n	8001c82 <HAL_GPIO_Init+0x18e>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001bce:	f8d8 5060 	ldr.w	r5, [r8, #96]	; 0x60
 8001bd2:	f045 0501 	orr.w	r5, r5, #1
 8001bd6:	f8c8 5060 	str.w	r5, [r8, #96]	; 0x60
 8001bda:	f8d8 5060 	ldr.w	r5, [r8, #96]	; 0x60
 8001bde:	f023 0603 	bic.w	r6, r3, #3
 8001be2:	f106 4680 	add.w	r6, r6, #1073741824	; 0x40000000
 8001be6:	f005 0501 	and.w	r5, r5, #1
 8001bea:	f506 3680 	add.w	r6, r6, #65536	; 0x10000
 8001bee:	9503      	str	r5, [sp, #12]
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 8001bf0:	f003 0c03 	and.w	ip, r3, #3
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001bf4:	9d03      	ldr	r5, [sp, #12]
        temp = SYSCFG->EXTICR[position >> 2u];
 8001bf6:	68b5      	ldr	r5, [r6, #8]
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 8001bf8:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 8001bfc:	270f      	movs	r7, #15
 8001bfe:	fa07 f70c 	lsl.w	r7, r7, ip
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 8001c02:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 8001c06:	ea25 0707 	bic.w	r7, r5, r7
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 8001c0a:	d03c      	beq.n	8001c86 <HAL_GPIO_Init+0x192>
 8001c0c:	4d25      	ldr	r5, [pc, #148]	; (8001ca4 <HAL_GPIO_Init+0x1b0>)
 8001c0e:	42a8      	cmp	r0, r5
 8001c10:	d03b      	beq.n	8001c8a <HAL_GPIO_Init+0x196>
 8001c12:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8001c16:	42a8      	cmp	r0, r5
 8001c18:	d039      	beq.n	8001c8e <HAL_GPIO_Init+0x19a>
 8001c1a:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8001c1e:	42a8      	cmp	r0, r5
 8001c20:	d037      	beq.n	8001c92 <HAL_GPIO_Init+0x19e>
 8001c22:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8001c26:	42a8      	cmp	r0, r5
 8001c28:	d035      	beq.n	8001c96 <HAL_GPIO_Init+0x1a2>
 8001c2a:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8001c2e:	42a8      	cmp	r0, r5
 8001c30:	d033      	beq.n	8001c9a <HAL_GPIO_Init+0x1a6>
 8001c32:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8001c36:	42a8      	cmp	r0, r5
 8001c38:	bf14      	ite	ne
 8001c3a:	2507      	movne	r5, #7
 8001c3c:	2506      	moveq	r5, #6
 8001c3e:	fa05 f50c 	lsl.w	r5, r5, ip
 8001c42:	433d      	orrs	r5, r7
        SYSCFG->EXTICR[position >> 2u] = temp;
 8001c44:	60b5      	str	r5, [r6, #8]
        temp = EXTI->IMR1;
 8001c46:	6825      	ldr	r5, [r4, #0]
        temp &= ~(iocurrent);
 8001c48:	ea6f 060e 	mvn.w	r6, lr
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8001c4c:	03d7      	lsls	r7, r2, #15
        temp &= ~(iocurrent);
 8001c4e:	bf54      	ite	pl
 8001c50:	4035      	andpl	r5, r6
          temp |= iocurrent;
 8001c52:	ea4e 0505 	orrmi.w	r5, lr, r5
        EXTI->IMR1 = temp;
 8001c56:	6025      	str	r5, [r4, #0]
        temp = EXTI->EMR1;
 8001c58:	6865      	ldr	r5, [r4, #4]
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8001c5a:	0397      	lsls	r7, r2, #14
        temp &= ~(iocurrent);
 8001c5c:	bf54      	ite	pl
 8001c5e:	4035      	andpl	r5, r6
          temp |= iocurrent;
 8001c60:	ea4e 0505 	orrmi.w	r5, lr, r5
        EXTI->EMR1 = temp;
 8001c64:	6065      	str	r5, [r4, #4]
        temp = EXTI->RTSR1;
 8001c66:	68a5      	ldr	r5, [r4, #8]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8001c68:	02d7      	lsls	r7, r2, #11
        temp &= ~(iocurrent);
 8001c6a:	bf54      	ite	pl
 8001c6c:	4035      	andpl	r5, r6
          temp |= iocurrent;
 8001c6e:	ea4e 0505 	orrmi.w	r5, lr, r5
        EXTI->RTSR1 = temp;
 8001c72:	60a5      	str	r5, [r4, #8]
        temp = EXTI->FTSR1;
 8001c74:	68e5      	ldr	r5, [r4, #12]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8001c76:	0292      	lsls	r2, r2, #10
        temp &= ~(iocurrent);
 8001c78:	bf54      	ite	pl
 8001c7a:	4035      	andpl	r5, r6
          temp |= iocurrent;
 8001c7c:	ea4e 0505 	orrmi.w	r5, lr, r5
        EXTI->FTSR1 = temp;
 8001c80:	60e5      	str	r5, [r4, #12]
    position++;
 8001c82:	3301      	adds	r3, #1
 8001c84:	e73f      	b.n	8001b06 <HAL_GPIO_Init+0x12>
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 8001c86:	2500      	movs	r5, #0
 8001c88:	e7d9      	b.n	8001c3e <HAL_GPIO_Init+0x14a>
 8001c8a:	2501      	movs	r5, #1
 8001c8c:	e7d7      	b.n	8001c3e <HAL_GPIO_Init+0x14a>
 8001c8e:	2502      	movs	r5, #2
 8001c90:	e7d5      	b.n	8001c3e <HAL_GPIO_Init+0x14a>
 8001c92:	2503      	movs	r5, #3
 8001c94:	e7d3      	b.n	8001c3e <HAL_GPIO_Init+0x14a>
 8001c96:	2504      	movs	r5, #4
 8001c98:	e7d1      	b.n	8001c3e <HAL_GPIO_Init+0x14a>
 8001c9a:	2505      	movs	r5, #5
 8001c9c:	e7cf      	b.n	8001c3e <HAL_GPIO_Init+0x14a>
 8001c9e:	bf00      	nop
 8001ca0:	40010400 	.word	0x40010400
 8001ca4:	48000400 	.word	0x48000400
 8001ca8:	40021000 	.word	0x40021000

08001cac <HAL_GPIO_ReadPin>:
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != 0x00u)
 8001cac:	6903      	ldr	r3, [r0, #16]
 8001cae:	4219      	tst	r1, r3
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
}
 8001cb0:	bf14      	ite	ne
 8001cb2:	2001      	movne	r0, #1
 8001cb4:	2000      	moveq	r0, #0
 8001cb6:	4770      	bx	lr

08001cb8 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8001cb8:	b10a      	cbz	r2, 8001cbe <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 8001cba:	6181      	str	r1, [r0, #24]
 8001cbc:	4770      	bx	lr
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 8001cbe:	6281      	str	r1, [r0, #40]	; 0x28
 8001cc0:	4770      	bx	lr

08001cc2 <HAL_GPIO_TogglePin>:
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->ODR ^= GPIO_Pin;
 8001cc2:	6943      	ldr	r3, [r0, #20]
 8001cc4:	4059      	eors	r1, r3
 8001cc6:	6141      	str	r1, [r0, #20]
 8001cc8:	4770      	bx	lr

08001cca <HAL_I2C_Init>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
 8001cca:	b510      	push	{r4, lr}
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
 8001ccc:	4604      	mov	r4, r0
 8001cce:	2800      	cmp	r0, #0
 8001cd0:	d04a      	beq.n	8001d68 <HAL_I2C_Init+0x9e>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if (hi2c->State == HAL_I2C_STATE_RESET)
 8001cd2:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 8001cd6:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8001cda:	b91b      	cbnz	r3, 8001ce4 <HAL_I2C_Init+0x1a>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
 8001cdc:	f880 2040 	strb.w	r2, [r0, #64]	; 0x40

    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    hi2c->MspInitCallback(hi2c);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_I2C_MspInit(hi2c);
 8001ce0:	f005 fb26 	bl	8007330 <HAL_I2C_MspInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
 8001ce4:	2324      	movs	r3, #36	; 0x24
 8001ce6:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
 8001cea:	6823      	ldr	r3, [r4, #0]
  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Disable Own Address1 before set the Own Address1 configuration */
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;

  /* Configure I2Cx: Own Address1 and ack own address1 mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 8001cec:	68e1      	ldr	r1, [r4, #12]
  __HAL_I2C_DISABLE(hi2c);
 8001cee:	681a      	ldr	r2, [r3, #0]
 8001cf0:	f022 0201 	bic.w	r2, r2, #1
 8001cf4:	601a      	str	r2, [r3, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 8001cf6:	6862      	ldr	r2, [r4, #4]
 8001cf8:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
 8001cfc:	611a      	str	r2, [r3, #16]
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 8001cfe:	689a      	ldr	r2, [r3, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 8001d00:	2901      	cmp	r1, #1
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 8001d02:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8001d06:	609a      	str	r2, [r3, #8]
 8001d08:	68a2      	ldr	r2, [r4, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 8001d0a:	d124      	bne.n	8001d56 <HAL_I2C_Init+0x8c>
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 8001d0c:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8001d10:	609a      	str	r2, [r3, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
  {
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
  }
  /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 8001d12:	685a      	ldr	r2, [r3, #4]
  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Disable Own Address2 before set the Own Address2 configuration */
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;

  /* Configure I2Cx: Dual mode and Own Address2 */
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 8001d14:	6961      	ldr	r1, [r4, #20]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 8001d16:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
 8001d1a:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8001d1e:	605a      	str	r2, [r3, #4]
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 8001d20:	68da      	ldr	r2, [r3, #12]
 8001d22:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8001d26:	60da      	str	r2, [r3, #12]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 8001d28:	6922      	ldr	r2, [r4, #16]
 8001d2a:	430a      	orrs	r2, r1
 8001d2c:	69a1      	ldr	r1, [r4, #24]
 8001d2e:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8001d32:	60da      	str	r2, [r3, #12]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 8001d34:	6a21      	ldr	r1, [r4, #32]
 8001d36:	69e2      	ldr	r2, [r4, #28]
 8001d38:	430a      	orrs	r2, r1
 8001d3a:	601a      	str	r2, [r3, #0]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
 8001d3c:	681a      	ldr	r2, [r3, #0]
 8001d3e:	f042 0201 	orr.w	r2, r2, #1
 8001d42:	601a      	str	r2, [r3, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8001d44:	2000      	movs	r0, #0
  hi2c->State = HAL_I2C_STATE_READY;
 8001d46:	2320      	movs	r3, #32
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8001d48:	6460      	str	r0, [r4, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
 8001d4a:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
 8001d4e:	6320      	str	r0, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8001d50:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42

  return HAL_OK;
 8001d54:	bd10      	pop	{r4, pc}
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 8001d56:	f442 4204 	orr.w	r2, r2, #33792	; 0x8400
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 8001d5a:	2902      	cmp	r1, #2
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 8001d5c:	609a      	str	r2, [r3, #8]
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
 8001d5e:	bf04      	itt	eq
 8001d60:	f44f 6200 	moveq.w	r2, #2048	; 0x800
 8001d64:	605a      	streq	r2, [r3, #4]
 8001d66:	e7d4      	b.n	8001d12 <HAL_I2C_Init+0x48>
    return HAL_ERROR;
 8001d68:	2001      	movs	r0, #1
}
 8001d6a:	bd10      	pop	{r4, pc}

08001d6c <HAL_I2CEx_ConfigAnalogFilter>:
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 8001d6c:	f890 2041 	ldrb.w	r2, [r0, #65]	; 0x41
 8001d70:	b2d2      	uxtb	r2, r2
 8001d72:	2a20      	cmp	r2, #32
{
 8001d74:	b510      	push	{r4, lr}
  if (hi2c->State == HAL_I2C_STATE_READY)
 8001d76:	d11d      	bne.n	8001db4 <HAL_I2CEx_ConfigAnalogFilter+0x48>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 8001d78:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 8001d7c:	2b01      	cmp	r3, #1
 8001d7e:	d019      	beq.n	8001db4 <HAL_I2CEx_ConfigAnalogFilter+0x48>

    hi2c->State = HAL_I2C_STATE_BUSY;
 8001d80:	2324      	movs	r3, #36	; 0x24
 8001d82:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 8001d86:	6803      	ldr	r3, [r0, #0]
 8001d88:	681c      	ldr	r4, [r3, #0]
 8001d8a:	f024 0401 	bic.w	r4, r4, #1
 8001d8e:	601c      	str	r4, [r3, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
 8001d90:	681c      	ldr	r4, [r3, #0]
 8001d92:	f424 5480 	bic.w	r4, r4, #4096	; 0x1000
 8001d96:	601c      	str	r4, [r3, #0]

    /* Set analog filter bit*/
    hi2c->Instance->CR1 |= AnalogFilter;
 8001d98:	681c      	ldr	r4, [r3, #0]
 8001d9a:	4321      	orrs	r1, r4
 8001d9c:	6019      	str	r1, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
 8001d9e:	6819      	ldr	r1, [r3, #0]
 8001da0:	f041 0101 	orr.w	r1, r1, #1
 8001da4:	6019      	str	r1, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8001da6:	2300      	movs	r3, #0
    hi2c->State = HAL_I2C_STATE_READY;
 8001da8:	f880 2041 	strb.w	r2, [r0, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8001dac:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40

    return HAL_OK;
 8001db0:	4618      	mov	r0, r3
 8001db2:	bd10      	pop	{r4, pc}
  }
  else
  {
    return HAL_BUSY;
 8001db4:	2002      	movs	r0, #2
  }
}
 8001db6:	bd10      	pop	{r4, pc}

08001db8 <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
 8001db8:	b510      	push	{r4, lr}

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 8001dba:	f890 4041 	ldrb.w	r4, [r0, #65]	; 0x41
 8001dbe:	b2e4      	uxtb	r4, r4
 8001dc0:	2c20      	cmp	r4, #32
 8001dc2:	d11c      	bne.n	8001dfe <HAL_I2CEx_ConfigDigitalFilter+0x46>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 8001dc4:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 8001dc8:	2b01      	cmp	r3, #1
 8001dca:	d018      	beq.n	8001dfe <HAL_I2CEx_ConfigDigitalFilter+0x46>

    hi2c->State = HAL_I2C_STATE_BUSY;
 8001dcc:	2324      	movs	r3, #36	; 0x24
 8001dce:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 8001dd2:	6803      	ldr	r3, [r0, #0]
 8001dd4:	681a      	ldr	r2, [r3, #0]
 8001dd6:	f022 0201 	bic.w	r2, r2, #1
 8001dda:	601a      	str	r2, [r3, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
 8001ddc:	681a      	ldr	r2, [r3, #0]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
 8001dde:	f422 6270 	bic.w	r2, r2, #3840	; 0xf00

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
 8001de2:	ea42 2101 	orr.w	r1, r2, r1, lsl #8

    /* Store the new register value */
    hi2c->Instance->CR1 = tmpreg;
 8001de6:	6019      	str	r1, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
 8001de8:	681a      	ldr	r2, [r3, #0]
 8001dea:	f042 0201 	orr.w	r2, r2, #1
 8001dee:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8001df0:	2300      	movs	r3, #0
    hi2c->State = HAL_I2C_STATE_READY;
 8001df2:	f880 4041 	strb.w	r4, [r0, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8001df6:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40

    return HAL_OK;
 8001dfa:	4618      	mov	r0, r3
 8001dfc:	bd10      	pop	{r4, pc}
  }
  else
  {
    return HAL_BUSY;
 8001dfe:	2002      	movs	r0, #2
  }
}
 8001e00:	bd10      	pop	{r4, pc}
	...

08001e04 <HAL_PWREx_GetVoltageRange>:
    else
    {
      return PWR_REGULATOR_VOLTAGE_SCALE1_BOOST;
    }
#else
  return  (PWR->CR1 & PWR_CR1_VOS);
 8001e04:	4b02      	ldr	r3, [pc, #8]	; (8001e10 <HAL_PWREx_GetVoltageRange+0xc>)
 8001e06:	6818      	ldr	r0, [r3, #0]
#endif
}
 8001e08:	f400 60c0 	and.w	r0, r0, #1536	; 0x600
 8001e0c:	4770      	bx	lr
 8001e0e:	bf00      	nop
 8001e10:	40007000 	.word	0x40007000

08001e14 <HAL_PWREx_ControlVoltageScaling>:
  *        cleared before returning the status. If the flag is not cleared within
  *        50 microseconds, HAL_TIMEOUT status is reported.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)
{
 8001e14:	4b17      	ldr	r3, [pc, #92]	; (8001e74 <HAL_PWREx_ControlVoltageScaling+0x60>)
#else

  /* If Set Range 1 */
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
  {
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) != PWR_REGULATOR_VOLTAGE_SCALE1)
 8001e16:	681a      	ldr	r2, [r3, #0]
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
 8001e18:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) != PWR_REGULATOR_VOLTAGE_SCALE1)
 8001e1c:	f402 62c0 	and.w	r2, r2, #1536	; 0x600
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
 8001e20:	d11c      	bne.n	8001e5c <HAL_PWREx_ControlVoltageScaling+0x48>
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) != PWR_REGULATOR_VOLTAGE_SCALE1)
 8001e22:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 8001e26:	d015      	beq.n	8001e54 <HAL_PWREx_ControlVoltageScaling+0x40>
    {
      /* Set Range 1 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 8001e28:	681a      	ldr	r2, [r3, #0]
 8001e2a:	f422 62c0 	bic.w	r2, r2, #1536	; 0x600
 8001e2e:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8001e32:	601a      	str	r2, [r3, #0]

      /* Wait until VOSF is cleared */
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 8001e34:	4a10      	ldr	r2, [pc, #64]	; (8001e78 <HAL_PWREx_ControlVoltageScaling+0x64>)
 8001e36:	6811      	ldr	r1, [r2, #0]
 8001e38:	2232      	movs	r2, #50	; 0x32
 8001e3a:	434a      	muls	r2, r1
 8001e3c:	490f      	ldr	r1, [pc, #60]	; (8001e7c <HAL_PWREx_ControlVoltageScaling+0x68>)
 8001e3e:	fbb2 f2f1 	udiv	r2, r2, r1
 8001e42:	4619      	mov	r1, r3
 8001e44:	3201      	adds	r2, #1
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8001e46:	6958      	ldr	r0, [r3, #20]
 8001e48:	0540      	lsls	r0, r0, #21
 8001e4a:	d500      	bpl.n	8001e4e <HAL_PWREx_ControlVoltageScaling+0x3a>
 8001e4c:	b922      	cbnz	r2, 8001e58 <HAL_PWREx_ControlVoltageScaling+0x44>
      {
        wait_loop_index--;
      }
      if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF))
 8001e4e:	694b      	ldr	r3, [r1, #20]
 8001e50:	055b      	lsls	r3, r3, #21
 8001e52:	d40d      	bmi.n	8001e70 <HAL_PWREx_ControlVoltageScaling+0x5c>
      /* No need to wait for VOSF to be cleared for this transition */
    }
  }
#endif

  return HAL_OK;
 8001e54:	2000      	movs	r0, #0
 8001e56:	4770      	bx	lr
        wait_loop_index--;
 8001e58:	3a01      	subs	r2, #1
 8001e5a:	e7f4      	b.n	8001e46 <HAL_PWREx_ControlVoltageScaling+0x32>
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) != PWR_REGULATOR_VOLTAGE_SCALE2)
 8001e5c:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE2);
 8001e60:	bf1f      	itttt	ne
 8001e62:	681a      	ldrne	r2, [r3, #0]
 8001e64:	f422 62c0 	bicne.w	r2, r2, #1536	; 0x600
 8001e68:	f442 6280 	orrne.w	r2, r2, #1024	; 0x400
 8001e6c:	601a      	strne	r2, [r3, #0]
 8001e6e:	e7f1      	b.n	8001e54 <HAL_PWREx_ControlVoltageScaling+0x40>
        return HAL_TIMEOUT;
 8001e70:	2003      	movs	r0, #3
}
 8001e72:	4770      	bx	lr
 8001e74:	40007000 	.word	0x40007000
 8001e78:	20000058 	.word	0x20000058
 8001e7c:	000f4240 	.word	0x000f4240

08001e80 <RCC_SetFlashLatencyFromMSIRange>:
            voltage range.
  * @param  msirange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
 8001e80:	b537      	push	{r0, r1, r2, r4, r5, lr}
  uint32_t vos;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */

  if(__HAL_RCC_PWR_IS_CLK_ENABLED())
 8001e82:	4d1e      	ldr	r5, [pc, #120]	; (8001efc <RCC_SetFlashLatencyFromMSIRange+0x7c>)
 8001e84:	6dab      	ldr	r3, [r5, #88]	; 0x58
 8001e86:	00da      	lsls	r2, r3, #3
{
 8001e88:	4604      	mov	r4, r0
  if(__HAL_RCC_PWR_IS_CLK_ENABLED())
 8001e8a:	d518      	bpl.n	8001ebe <RCC_SetFlashLatencyFromMSIRange+0x3e>
  {
    vos = HAL_PWREx_GetVoltageRange();
 8001e8c:	f7ff ffba 	bl	8001e04 <HAL_PWREx_GetVoltageRange>
    __HAL_RCC_PWR_CLK_ENABLE();
    vos = HAL_PWREx_GetVoltageRange();
    __HAL_RCC_PWR_CLK_DISABLE();
  }

  if(vos == PWR_REGULATOR_VOLTAGE_SCALE1)
 8001e90:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8001e94:	d123      	bne.n	8001ede <RCC_SetFlashLatencyFromMSIRange+0x5e>
  {
    if(msirange > RCC_MSIRANGE_8)
 8001e96:	2c80      	cmp	r4, #128	; 0x80
 8001e98:	d929      	bls.n	8001eee <RCC_SetFlashLatencyFromMSIRange+0x6e>
    {
      /* MSI > 16Mhz */
      if(msirange > RCC_MSIRANGE_10)
 8001e9a:	2ca0      	cmp	r4, #160	; 0xa0
        latency = FLASH_LATENCY_2; /* 2WS */
      }
      else
      {
        /* MSI 24Mhz or 32Mhz */
        latency = FLASH_LATENCY_1; /* 1WS */
 8001e9c:	bf8c      	ite	hi
 8001e9e:	2002      	movhi	r0, #2
 8001ea0:	2001      	movls	r0, #1
      /* else MSI < 8Mhz default FLASH_LATENCY_0 0WS */
    }
#endif
  }

  __HAL_FLASH_SET_LATENCY(latency);
 8001ea2:	4a17      	ldr	r2, [pc, #92]	; (8001f00 <RCC_SetFlashLatencyFromMSIRange+0x80>)
 8001ea4:	6813      	ldr	r3, [r2, #0]
 8001ea6:	f023 0307 	bic.w	r3, r3, #7
 8001eaa:	4303      	orrs	r3, r0
 8001eac:	6013      	str	r3, [r2, #0]

  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  if(__HAL_FLASH_GET_LATENCY() != latency)
 8001eae:	6813      	ldr	r3, [r2, #0]
 8001eb0:	f003 0307 	and.w	r3, r3, #7
  {
    return HAL_ERROR;
  }

  return HAL_OK;
}
 8001eb4:	1a18      	subs	r0, r3, r0
 8001eb6:	bf18      	it	ne
 8001eb8:	2001      	movne	r0, #1
 8001eba:	b003      	add	sp, #12
 8001ebc:	bd30      	pop	{r4, r5, pc}
    __HAL_RCC_PWR_CLK_ENABLE();
 8001ebe:	6dab      	ldr	r3, [r5, #88]	; 0x58
 8001ec0:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8001ec4:	65ab      	str	r3, [r5, #88]	; 0x58
 8001ec6:	6dab      	ldr	r3, [r5, #88]	; 0x58
 8001ec8:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001ecc:	9301      	str	r3, [sp, #4]
 8001ece:	9b01      	ldr	r3, [sp, #4]
    vos = HAL_PWREx_GetVoltageRange();
 8001ed0:	f7ff ff98 	bl	8001e04 <HAL_PWREx_GetVoltageRange>
    __HAL_RCC_PWR_CLK_DISABLE();
 8001ed4:	6dab      	ldr	r3, [r5, #88]	; 0x58
 8001ed6:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8001eda:	65ab      	str	r3, [r5, #88]	; 0x58
 8001edc:	e7d8      	b.n	8001e90 <RCC_SetFlashLatencyFromMSIRange+0x10>
    if(msirange > RCC_MSIRANGE_8)
 8001ede:	2c80      	cmp	r4, #128	; 0x80
 8001ee0:	d807      	bhi.n	8001ef2 <RCC_SetFlashLatencyFromMSIRange+0x72>
      if(msirange == RCC_MSIRANGE_8)
 8001ee2:	d008      	beq.n	8001ef6 <RCC_SetFlashLatencyFromMSIRange+0x76>
      else if(msirange == RCC_MSIRANGE_7)
 8001ee4:	f1a4 0370 	sub.w	r3, r4, #112	; 0x70
 8001ee8:	4258      	negs	r0, r3
 8001eea:	4158      	adcs	r0, r3
 8001eec:	e7d9      	b.n	8001ea2 <RCC_SetFlashLatencyFromMSIRange+0x22>
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
 8001eee:	2000      	movs	r0, #0
 8001ef0:	e7d7      	b.n	8001ea2 <RCC_SetFlashLatencyFromMSIRange+0x22>
      latency = FLASH_LATENCY_3; /* 3WS */
 8001ef2:	2003      	movs	r0, #3
 8001ef4:	e7d5      	b.n	8001ea2 <RCC_SetFlashLatencyFromMSIRange+0x22>
        latency = FLASH_LATENCY_2; /* 2WS */
 8001ef6:	2002      	movs	r0, #2
 8001ef8:	e7d3      	b.n	8001ea2 <RCC_SetFlashLatencyFromMSIRange+0x22>
 8001efa:	bf00      	nop
 8001efc:	40021000 	.word	0x40021000
 8001f00:	40022000 	.word	0x40022000

08001f04 <HAL_RCC_GetSysClockFreq>:
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 8001f04:	4b25      	ldr	r3, [pc, #148]	; (8001f9c <HAL_RCC_GetSysClockFreq+0x98>)
 8001f06:	689a      	ldr	r2, [r3, #8]
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 8001f08:	68d9      	ldr	r1, [r3, #12]
  if((sysclk_source == RCC_CFGR_SWS_MSI) ||
 8001f0a:	f012 020c 	ands.w	r2, r2, #12
 8001f0e:	d005      	beq.n	8001f1c <HAL_RCC_GetSysClockFreq+0x18>
 8001f10:	2a0c      	cmp	r2, #12
 8001f12:	d115      	bne.n	8001f40 <HAL_RCC_GetSysClockFreq+0x3c>
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 8001f14:	f001 0103 	and.w	r1, r1, #3
     ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_oscsource == RCC_PLLSOURCE_MSI)))
 8001f18:	2901      	cmp	r1, #1
 8001f1a:	d118      	bne.n	8001f4e <HAL_RCC_GetSysClockFreq+0x4a>
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 8001f1c:	6819      	ldr	r1, [r3, #0]
    msirange = MSIRangeTable[msirange];
 8001f1e:	4820      	ldr	r0, [pc, #128]	; (8001fa0 <HAL_RCC_GetSysClockFreq+0x9c>)
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 8001f20:	0709      	lsls	r1, r1, #28
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 8001f22:	bf55      	itete	pl
 8001f24:	f8d3 1094 	ldrpl.w	r1, [r3, #148]	; 0x94
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 8001f28:	6819      	ldrmi	r1, [r3, #0]
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 8001f2a:	f3c1 2103 	ubfxpl	r1, r1, #8, #4
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 8001f2e:	f3c1 1103 	ubfxmi	r1, r1, #4, #4
    msirange = MSIRangeTable[msirange];
 8001f32:	f850 0021 	ldr.w	r0, [r0, r1, lsl #2]
    if(sysclk_source == RCC_CFGR_SWS_MSI)
 8001f36:	b382      	cbz	r2, 8001f9a <HAL_RCC_GetSysClockFreq+0x96>
  if(sysclk_source == RCC_CFGR_SWS_PLL)
 8001f38:	2a0c      	cmp	r2, #12
 8001f3a:	d009      	beq.n	8001f50 <HAL_RCC_GetSysClockFreq+0x4c>
 8001f3c:	2000      	movs	r0, #0
  return sysclockfreq;
 8001f3e:	4770      	bx	lr
  else if(sysclk_source == RCC_CFGR_SWS_HSI)
 8001f40:	2a04      	cmp	r2, #4
 8001f42:	d029      	beq.n	8001f98 <HAL_RCC_GetSysClockFreq+0x94>
 8001f44:	2a08      	cmp	r2, #8
 8001f46:	4817      	ldr	r0, [pc, #92]	; (8001fa4 <HAL_RCC_GetSysClockFreq+0xa0>)
 8001f48:	bf18      	it	ne
 8001f4a:	2000      	movne	r0, #0
 8001f4c:	4770      	bx	lr
  uint32_t msirange = 0U, sysclockfreq = 0U;
 8001f4e:	2000      	movs	r0, #0
    pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 8001f50:	68d9      	ldr	r1, [r3, #12]
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8001f52:	68da      	ldr	r2, [r3, #12]
    pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 8001f54:	f001 0103 	and.w	r1, r1, #3
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8001f58:	f3c2 1202 	ubfx	r2, r2, #4, #3
    switch (pllsource)
 8001f5c:	2902      	cmp	r1, #2
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8001f5e:	f102 0201 	add.w	r2, r2, #1
    switch (pllsource)
 8001f62:	d005      	beq.n	8001f70 <HAL_RCC_GetSysClockFreq+0x6c>
 8001f64:	2903      	cmp	r1, #3
 8001f66:	d012      	beq.n	8001f8e <HAL_RCC_GetSysClockFreq+0x8a>
      pllvco = (msirange / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8001f68:	68d9      	ldr	r1, [r3, #12]
 8001f6a:	f3c1 2106 	ubfx	r1, r1, #8, #7
 8001f6e:	e003      	b.n	8001f78 <HAL_RCC_GetSysClockFreq+0x74>
      pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8001f70:	68d9      	ldr	r1, [r3, #12]
 8001f72:	480d      	ldr	r0, [pc, #52]	; (8001fa8 <HAL_RCC_GetSysClockFreq+0xa4>)
 8001f74:	f3c1 2106 	ubfx	r1, r1, #8, #7
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 8001f78:	68db      	ldr	r3, [r3, #12]
      pllvco = (msirange / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8001f7a:	fbb0 f0f2 	udiv	r0, r0, r2
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 8001f7e:	f3c3 6341 	ubfx	r3, r3, #25, #2
 8001f82:	3301      	adds	r3, #1
      pllvco = (msirange / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8001f84:	4348      	muls	r0, r1
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 8001f86:	005b      	lsls	r3, r3, #1
    sysclockfreq = pllvco/pllr;
 8001f88:	fbb0 f0f3 	udiv	r0, r0, r3
 8001f8c:	4770      	bx	lr
      pllvco = (HSE_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8001f8e:	68d9      	ldr	r1, [r3, #12]
 8001f90:	4804      	ldr	r0, [pc, #16]	; (8001fa4 <HAL_RCC_GetSysClockFreq+0xa0>)
 8001f92:	f3c1 2106 	ubfx	r1, r1, #8, #7
 8001f96:	e7ef      	b.n	8001f78 <HAL_RCC_GetSysClockFreq+0x74>
    sysclockfreq = HSI_VALUE;
 8001f98:	4803      	ldr	r0, [pc, #12]	; (8001fa8 <HAL_RCC_GetSysClockFreq+0xa4>)
}
 8001f9a:	4770      	bx	lr
 8001f9c:	40021000 	.word	0x40021000
 8001fa0:	0800d1b8 	.word	0x0800d1b8
 8001fa4:	007a1200 	.word	0x007a1200
 8001fa8:	00f42400 	.word	0x00f42400

08001fac <HAL_RCC_OscConfig>:
{
 8001fac:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  if(RCC_OscInitStruct == NULL)
 8001fb0:	4605      	mov	r5, r0
 8001fb2:	b918      	cbnz	r0, 8001fbc <HAL_RCC_OscConfig+0x10>
    return HAL_ERROR;
 8001fb4:	2001      	movs	r0, #1
}
 8001fb6:	b003      	add	sp, #12
 8001fb8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 8001fbc:	4ca5      	ldr	r4, [pc, #660]	; (8002254 <HAL_RCC_OscConfig+0x2a8>)
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 8001fbe:	6803      	ldr	r3, [r0, #0]
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 8001fc0:	68a6      	ldr	r6, [r4, #8]
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 8001fc2:	68e7      	ldr	r7, [r4, #12]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 8001fc4:	06db      	lsls	r3, r3, #27
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 8001fc6:	f006 060c 	and.w	r6, r6, #12
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 8001fca:	f007 0703 	and.w	r7, r7, #3
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 8001fce:	d53c      	bpl.n	800204a <HAL_RCC_OscConfig+0x9e>
    if((sysclk_source == RCC_CFGR_SWS_MSI) ||
 8001fd0:	b11e      	cbz	r6, 8001fda <HAL_RCC_OscConfig+0x2e>
 8001fd2:	2e0c      	cmp	r6, #12
 8001fd4:	d163      	bne.n	800209e <HAL_RCC_OscConfig+0xf2>
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_oscsource == RCC_PLLSOURCE_MSI)))
 8001fd6:	2f01      	cmp	r7, #1
 8001fd8:	d161      	bne.n	800209e <HAL_RCC_OscConfig+0xf2>
      if((READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 8001fda:	6823      	ldr	r3, [r4, #0]
 8001fdc:	0798      	lsls	r0, r3, #30
 8001fde:	d502      	bpl.n	8001fe6 <HAL_RCC_OscConfig+0x3a>
 8001fe0:	69ab      	ldr	r3, [r5, #24]
 8001fe2:	2b00      	cmp	r3, #0
 8001fe4:	d0e6      	beq.n	8001fb4 <HAL_RCC_OscConfig+0x8>
        if(RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 8001fe6:	6823      	ldr	r3, [r4, #0]
 8001fe8:	6a28      	ldr	r0, [r5, #32]
 8001fea:	0719      	lsls	r1, r3, #28
 8001fec:	bf56      	itet	pl
 8001fee:	f8d4 3094 	ldrpl.w	r3, [r4, #148]	; 0x94
 8001ff2:	6823      	ldrmi	r3, [r4, #0]
 8001ff4:	091b      	lsrpl	r3, r3, #4
 8001ff6:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8001ffa:	4283      	cmp	r3, r0
 8001ffc:	d23a      	bcs.n	8002074 <HAL_RCC_OscConfig+0xc8>
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 8001ffe:	f7ff ff3f 	bl	8001e80 <RCC_SetFlashLatencyFromMSIRange>
 8002002:	2800      	cmp	r0, #0
 8002004:	d1d6      	bne.n	8001fb4 <HAL_RCC_OscConfig+0x8>
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8002006:	6823      	ldr	r3, [r4, #0]
 8002008:	f043 0308 	orr.w	r3, r3, #8
 800200c:	6023      	str	r3, [r4, #0]
 800200e:	6823      	ldr	r3, [r4, #0]
 8002010:	6a2a      	ldr	r2, [r5, #32]
 8002012:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8002016:	4313      	orrs	r3, r2
 8002018:	6023      	str	r3, [r4, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 800201a:	6863      	ldr	r3, [r4, #4]
 800201c:	69ea      	ldr	r2, [r5, #28]
 800201e:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 8002022:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8002026:	6063      	str	r3, [r4, #4]
        SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 8002028:	f7ff ff6c 	bl	8001f04 <HAL_RCC_GetSysClockFreq>
 800202c:	68a3      	ldr	r3, [r4, #8]
 800202e:	4a8a      	ldr	r2, [pc, #552]	; (8002258 <HAL_RCC_OscConfig+0x2ac>)
 8002030:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8002034:	5cd3      	ldrb	r3, [r2, r3]
 8002036:	f003 031f 	and.w	r3, r3, #31
 800203a:	40d8      	lsrs	r0, r3
 800203c:	4b87      	ldr	r3, [pc, #540]	; (800225c <HAL_RCC_OscConfig+0x2b0>)
 800203e:	6018      	str	r0, [r3, #0]
        status = HAL_InitTick (TICK_INT_PRIORITY);
 8002040:	200f      	movs	r0, #15
 8002042:	f7fe ff95 	bl	8000f70 <HAL_InitTick>
        if(status != HAL_OK)
 8002046:	2800      	cmp	r0, #0
 8002048:	d1b5      	bne.n	8001fb6 <HAL_RCC_OscConfig+0xa>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800204a:	682b      	ldr	r3, [r5, #0]
 800204c:	07d8      	lsls	r0, r3, #31
 800204e:	d45d      	bmi.n	800210c <HAL_RCC_OscConfig+0x160>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8002050:	682b      	ldr	r3, [r5, #0]
 8002052:	0799      	lsls	r1, r3, #30
 8002054:	f100 809c 	bmi.w	8002190 <HAL_RCC_OscConfig+0x1e4>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8002058:	682b      	ldr	r3, [r5, #0]
 800205a:	0718      	lsls	r0, r3, #28
 800205c:	f100 80d0 	bmi.w	8002200 <HAL_RCC_OscConfig+0x254>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8002060:	682b      	ldr	r3, [r5, #0]
 8002062:	0759      	lsls	r1, r3, #29
 8002064:	f100 80fc 	bmi.w	8002260 <HAL_RCC_OscConfig+0x2b4>
  if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 8002068:	6aab      	ldr	r3, [r5, #40]	; 0x28
 800206a:	2b00      	cmp	r3, #0
 800206c:	f040 8165 	bne.w	800233a <HAL_RCC_OscConfig+0x38e>
  return HAL_OK;
 8002070:	2000      	movs	r0, #0
 8002072:	e7a0      	b.n	8001fb6 <HAL_RCC_OscConfig+0xa>
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8002074:	6823      	ldr	r3, [r4, #0]
 8002076:	f043 0308 	orr.w	r3, r3, #8
 800207a:	6023      	str	r3, [r4, #0]
 800207c:	6823      	ldr	r3, [r4, #0]
 800207e:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8002082:	4303      	orrs	r3, r0
 8002084:	6023      	str	r3, [r4, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8002086:	6863      	ldr	r3, [r4, #4]
 8002088:	69ea      	ldr	r2, [r5, #28]
 800208a:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 800208e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8002092:	6063      	str	r3, [r4, #4]
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 8002094:	f7ff fef4 	bl	8001e80 <RCC_SetFlashLatencyFromMSIRange>
 8002098:	2800      	cmp	r0, #0
 800209a:	d0c5      	beq.n	8002028 <HAL_RCC_OscConfig+0x7c>
 800209c:	e78a      	b.n	8001fb4 <HAL_RCC_OscConfig+0x8>
      if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 800209e:	69ab      	ldr	r3, [r5, #24]
 80020a0:	b31b      	cbz	r3, 80020ea <HAL_RCC_OscConfig+0x13e>
        __HAL_RCC_MSI_ENABLE();
 80020a2:	6823      	ldr	r3, [r4, #0]
 80020a4:	f043 0301 	orr.w	r3, r3, #1
 80020a8:	6023      	str	r3, [r4, #0]
        tickstart = HAL_GetTick();
 80020aa:	f7fe ff91 	bl	8000fd0 <HAL_GetTick>
 80020ae:	4680      	mov	r8, r0
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 80020b0:	6823      	ldr	r3, [r4, #0]
 80020b2:	079a      	lsls	r2, r3, #30
 80020b4:	d511      	bpl.n	80020da <HAL_RCC_OscConfig+0x12e>
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 80020b6:	6823      	ldr	r3, [r4, #0]
 80020b8:	f043 0308 	orr.w	r3, r3, #8
 80020bc:	6023      	str	r3, [r4, #0]
 80020be:	6823      	ldr	r3, [r4, #0]
 80020c0:	6a2a      	ldr	r2, [r5, #32]
 80020c2:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80020c6:	4313      	orrs	r3, r2
 80020c8:	6023      	str	r3, [r4, #0]
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 80020ca:	6863      	ldr	r3, [r4, #4]
 80020cc:	69ea      	ldr	r2, [r5, #28]
 80020ce:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 80020d2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80020d6:	6063      	str	r3, [r4, #4]
 80020d8:	e7b7      	b.n	800204a <HAL_RCC_OscConfig+0x9e>
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 80020da:	f7fe ff79 	bl	8000fd0 <HAL_GetTick>
 80020de:	eba0 0008 	sub.w	r0, r0, r8
 80020e2:	2802      	cmp	r0, #2
 80020e4:	d9e4      	bls.n	80020b0 <HAL_RCC_OscConfig+0x104>
            return HAL_TIMEOUT;
 80020e6:	2003      	movs	r0, #3
 80020e8:	e765      	b.n	8001fb6 <HAL_RCC_OscConfig+0xa>
        __HAL_RCC_MSI_DISABLE();
 80020ea:	6823      	ldr	r3, [r4, #0]
 80020ec:	f023 0301 	bic.w	r3, r3, #1
 80020f0:	6023      	str	r3, [r4, #0]
        tickstart = HAL_GetTick();
 80020f2:	f7fe ff6d 	bl	8000fd0 <HAL_GetTick>
 80020f6:	4680      	mov	r8, r0
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U)
 80020f8:	6823      	ldr	r3, [r4, #0]
 80020fa:	079b      	lsls	r3, r3, #30
 80020fc:	d5a5      	bpl.n	800204a <HAL_RCC_OscConfig+0x9e>
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 80020fe:	f7fe ff67 	bl	8000fd0 <HAL_GetTick>
 8002102:	eba0 0008 	sub.w	r0, r0, r8
 8002106:	2802      	cmp	r0, #2
 8002108:	d9f6      	bls.n	80020f8 <HAL_RCC_OscConfig+0x14c>
 800210a:	e7ec      	b.n	80020e6 <HAL_RCC_OscConfig+0x13a>
    if((sysclk_source == RCC_CFGR_SWS_HSE) ||
 800210c:	2e08      	cmp	r6, #8
 800210e:	d003      	beq.n	8002118 <HAL_RCC_OscConfig+0x16c>
 8002110:	2e0c      	cmp	r6, #12
 8002112:	d108      	bne.n	8002126 <HAL_RCC_OscConfig+0x17a>
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_oscsource == RCC_PLLSOURCE_HSE)))
 8002114:	2f03      	cmp	r7, #3
 8002116:	d106      	bne.n	8002126 <HAL_RCC_OscConfig+0x17a>
      if((READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8002118:	6823      	ldr	r3, [r4, #0]
 800211a:	039a      	lsls	r2, r3, #14
 800211c:	d598      	bpl.n	8002050 <HAL_RCC_OscConfig+0xa4>
 800211e:	686b      	ldr	r3, [r5, #4]
 8002120:	2b00      	cmp	r3, #0
 8002122:	d195      	bne.n	8002050 <HAL_RCC_OscConfig+0xa4>
 8002124:	e746      	b.n	8001fb4 <HAL_RCC_OscConfig+0x8>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8002126:	686b      	ldr	r3, [r5, #4]
 8002128:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800212c:	d110      	bne.n	8002150 <HAL_RCC_OscConfig+0x1a4>
 800212e:	6823      	ldr	r3, [r4, #0]
 8002130:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8002134:	6023      	str	r3, [r4, #0]
        tickstart = HAL_GetTick();
 8002136:	f7fe ff4b 	bl	8000fd0 <HAL_GetTick>
 800213a:	4680      	mov	r8, r0
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 800213c:	6823      	ldr	r3, [r4, #0]
 800213e:	039b      	lsls	r3, r3, #14
 8002140:	d486      	bmi.n	8002050 <HAL_RCC_OscConfig+0xa4>
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8002142:	f7fe ff45 	bl	8000fd0 <HAL_GetTick>
 8002146:	eba0 0008 	sub.w	r0, r0, r8
 800214a:	2864      	cmp	r0, #100	; 0x64
 800214c:	d9f6      	bls.n	800213c <HAL_RCC_OscConfig+0x190>
 800214e:	e7ca      	b.n	80020e6 <HAL_RCC_OscConfig+0x13a>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8002150:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8002154:	d104      	bne.n	8002160 <HAL_RCC_OscConfig+0x1b4>
 8002156:	6823      	ldr	r3, [r4, #0]
 8002158:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800215c:	6023      	str	r3, [r4, #0]
 800215e:	e7e6      	b.n	800212e <HAL_RCC_OscConfig+0x182>
 8002160:	6822      	ldr	r2, [r4, #0]
 8002162:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8002166:	6022      	str	r2, [r4, #0]
 8002168:	6822      	ldr	r2, [r4, #0]
 800216a:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800216e:	6022      	str	r2, [r4, #0]
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8002170:	2b00      	cmp	r3, #0
 8002172:	d1e0      	bne.n	8002136 <HAL_RCC_OscConfig+0x18a>
        tickstart = HAL_GetTick();
 8002174:	f7fe ff2c 	bl	8000fd0 <HAL_GetTick>
 8002178:	4680      	mov	r8, r0
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 800217a:	6823      	ldr	r3, [r4, #0]
 800217c:	0398      	lsls	r0, r3, #14
 800217e:	f57f af67 	bpl.w	8002050 <HAL_RCC_OscConfig+0xa4>
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8002182:	f7fe ff25 	bl	8000fd0 <HAL_GetTick>
 8002186:	eba0 0008 	sub.w	r0, r0, r8
 800218a:	2864      	cmp	r0, #100	; 0x64
 800218c:	d9f5      	bls.n	800217a <HAL_RCC_OscConfig+0x1ce>
 800218e:	e7aa      	b.n	80020e6 <HAL_RCC_OscConfig+0x13a>
    if((sysclk_source == RCC_CFGR_SWS_HSI) ||
 8002190:	2e04      	cmp	r6, #4
 8002192:	d003      	beq.n	800219c <HAL_RCC_OscConfig+0x1f0>
 8002194:	2e0c      	cmp	r6, #12
 8002196:	d110      	bne.n	80021ba <HAL_RCC_OscConfig+0x20e>
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_oscsource == RCC_PLLSOURCE_HSI)))
 8002198:	2f02      	cmp	r7, #2
 800219a:	d10e      	bne.n	80021ba <HAL_RCC_OscConfig+0x20e>
      if((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 800219c:	6823      	ldr	r3, [r4, #0]
 800219e:	0559      	lsls	r1, r3, #21
 80021a0:	d503      	bpl.n	80021aa <HAL_RCC_OscConfig+0x1fe>
 80021a2:	68eb      	ldr	r3, [r5, #12]
 80021a4:	2b00      	cmp	r3, #0
 80021a6:	f43f af05 	beq.w	8001fb4 <HAL_RCC_OscConfig+0x8>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80021aa:	6863      	ldr	r3, [r4, #4]
 80021ac:	692a      	ldr	r2, [r5, #16]
 80021ae:	f023 53f8 	bic.w	r3, r3, #520093696	; 0x1f000000
 80021b2:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80021b6:	6063      	str	r3, [r4, #4]
 80021b8:	e74e      	b.n	8002058 <HAL_RCC_OscConfig+0xac>
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 80021ba:	68eb      	ldr	r3, [r5, #12]
 80021bc:	b17b      	cbz	r3, 80021de <HAL_RCC_OscConfig+0x232>
        __HAL_RCC_HSI_ENABLE();
 80021be:	6823      	ldr	r3, [r4, #0]
 80021c0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80021c4:	6023      	str	r3, [r4, #0]
        tickstart = HAL_GetTick();
 80021c6:	f7fe ff03 	bl	8000fd0 <HAL_GetTick>
 80021ca:	4607      	mov	r7, r0
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 80021cc:	6823      	ldr	r3, [r4, #0]
 80021ce:	055a      	lsls	r2, r3, #21
 80021d0:	d4eb      	bmi.n	80021aa <HAL_RCC_OscConfig+0x1fe>
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 80021d2:	f7fe fefd 	bl	8000fd0 <HAL_GetTick>
 80021d6:	1bc0      	subs	r0, r0, r7
 80021d8:	2802      	cmp	r0, #2
 80021da:	d9f7      	bls.n	80021cc <HAL_RCC_OscConfig+0x220>
 80021dc:	e783      	b.n	80020e6 <HAL_RCC_OscConfig+0x13a>
        __HAL_RCC_HSI_DISABLE();
 80021de:	6823      	ldr	r3, [r4, #0]
 80021e0:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80021e4:	6023      	str	r3, [r4, #0]
        tickstart = HAL_GetTick();
 80021e6:	f7fe fef3 	bl	8000fd0 <HAL_GetTick>
 80021ea:	4607      	mov	r7, r0
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 80021ec:	6823      	ldr	r3, [r4, #0]
 80021ee:	055b      	lsls	r3, r3, #21
 80021f0:	f57f af32 	bpl.w	8002058 <HAL_RCC_OscConfig+0xac>
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 80021f4:	f7fe feec 	bl	8000fd0 <HAL_GetTick>
 80021f8:	1bc0      	subs	r0, r0, r7
 80021fa:	2802      	cmp	r0, #2
 80021fc:	d9f6      	bls.n	80021ec <HAL_RCC_OscConfig+0x240>
 80021fe:	e772      	b.n	80020e6 <HAL_RCC_OscConfig+0x13a>
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8002200:	696b      	ldr	r3, [r5, #20]
 8002202:	b19b      	cbz	r3, 800222c <HAL_RCC_OscConfig+0x280>
      __HAL_RCC_LSI_ENABLE();
 8002204:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 8002208:	f043 0301 	orr.w	r3, r3, #1
 800220c:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
      tickstart = HAL_GetTick();
 8002210:	f7fe fede 	bl	8000fd0 <HAL_GetTick>
 8002214:	4607      	mov	r7, r0
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
 8002216:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 800221a:	079a      	lsls	r2, r3, #30
 800221c:	f53f af20 	bmi.w	8002060 <HAL_RCC_OscConfig+0xb4>
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8002220:	f7fe fed6 	bl	8000fd0 <HAL_GetTick>
 8002224:	1bc0      	subs	r0, r0, r7
 8002226:	2802      	cmp	r0, #2
 8002228:	d9f5      	bls.n	8002216 <HAL_RCC_OscConfig+0x26a>
 800222a:	e75c      	b.n	80020e6 <HAL_RCC_OscConfig+0x13a>
      __HAL_RCC_LSI_DISABLE();
 800222c:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 8002230:	f023 0301 	bic.w	r3, r3, #1
 8002234:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
      tickstart = HAL_GetTick();
 8002238:	f7fe feca 	bl	8000fd0 <HAL_GetTick>
 800223c:	4607      	mov	r7, r0
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
 800223e:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 8002242:	079b      	lsls	r3, r3, #30
 8002244:	f57f af0c 	bpl.w	8002060 <HAL_RCC_OscConfig+0xb4>
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8002248:	f7fe fec2 	bl	8000fd0 <HAL_GetTick>
 800224c:	1bc0      	subs	r0, r0, r7
 800224e:	2802      	cmp	r0, #2
 8002250:	d9f5      	bls.n	800223e <HAL_RCC_OscConfig+0x292>
 8002252:	e748      	b.n	80020e6 <HAL_RCC_OscConfig+0x13a>
 8002254:	40021000 	.word	0x40021000
 8002258:	0800d19e 	.word	0x0800d19e
 800225c:	20000058 	.word	0x20000058
    if(HAL_IS_BIT_CLR(RCC->APB1ENR1, RCC_APB1ENR1_PWREN))
 8002260:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8002262:	00d8      	lsls	r0, r3, #3
 8002264:	d429      	bmi.n	80022ba <HAL_RCC_OscConfig+0x30e>
      __HAL_RCC_PWR_CLK_ENABLE();
 8002266:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8002268:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800226c:	65a3      	str	r3, [r4, #88]	; 0x58
 800226e:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8002270:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8002274:	9301      	str	r3, [sp, #4]
 8002276:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8002278:	f04f 0801 	mov.w	r8, #1
    if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 800227c:	4f5d      	ldr	r7, [pc, #372]	; (80023f4 <HAL_RCC_OscConfig+0x448>)
 800227e:	683b      	ldr	r3, [r7, #0]
 8002280:	05d9      	lsls	r1, r3, #23
 8002282:	d51d      	bpl.n	80022c0 <HAL_RCC_OscConfig+0x314>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8002284:	68ab      	ldr	r3, [r5, #8]
 8002286:	2b01      	cmp	r3, #1
 8002288:	d12b      	bne.n	80022e2 <HAL_RCC_OscConfig+0x336>
 800228a:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 800228e:	f043 0301 	orr.w	r3, r3, #1
 8002292:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
      tickstart = HAL_GetTick();
 8002296:	f7fe fe9b 	bl	8000fd0 <HAL_GetTick>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800229a:	f241 3988 	movw	r9, #5000	; 0x1388
      tickstart = HAL_GetTick();
 800229e:	4607      	mov	r7, r0
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 80022a0:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 80022a4:	079b      	lsls	r3, r3, #30
 80022a6:	d542      	bpl.n	800232e <HAL_RCC_OscConfig+0x382>
    if(pwrclkchanged == SET)
 80022a8:	f1b8 0f00 	cmp.w	r8, #0
 80022ac:	f43f aedc 	beq.w	8002068 <HAL_RCC_OscConfig+0xbc>
      __HAL_RCC_PWR_CLK_DISABLE();
 80022b0:	6da3      	ldr	r3, [r4, #88]	; 0x58
 80022b2:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 80022b6:	65a3      	str	r3, [r4, #88]	; 0x58
 80022b8:	e6d6      	b.n	8002068 <HAL_RCC_OscConfig+0xbc>
    FlagStatus       pwrclkchanged = RESET;
 80022ba:	f04f 0800 	mov.w	r8, #0
 80022be:	e7dd      	b.n	800227c <HAL_RCC_OscConfig+0x2d0>
      SET_BIT(PWR->CR1, PWR_CR1_DBP);
 80022c0:	683b      	ldr	r3, [r7, #0]
 80022c2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80022c6:	603b      	str	r3, [r7, #0]
      tickstart = HAL_GetTick();
 80022c8:	f7fe fe82 	bl	8000fd0 <HAL_GetTick>
 80022cc:	4681      	mov	r9, r0
      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 80022ce:	683b      	ldr	r3, [r7, #0]
 80022d0:	05da      	lsls	r2, r3, #23
 80022d2:	d4d7      	bmi.n	8002284 <HAL_RCC_OscConfig+0x2d8>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80022d4:	f7fe fe7c 	bl	8000fd0 <HAL_GetTick>
 80022d8:	eba0 0009 	sub.w	r0, r0, r9
 80022dc:	2802      	cmp	r0, #2
 80022de:	d9f6      	bls.n	80022ce <HAL_RCC_OscConfig+0x322>
 80022e0:	e701      	b.n	80020e6 <HAL_RCC_OscConfig+0x13a>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80022e2:	2b05      	cmp	r3, #5
 80022e4:	d106      	bne.n	80022f4 <HAL_RCC_OscConfig+0x348>
 80022e6:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 80022ea:	f043 0304 	orr.w	r3, r3, #4
 80022ee:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
 80022f2:	e7ca      	b.n	800228a <HAL_RCC_OscConfig+0x2de>
 80022f4:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
 80022f8:	f022 0201 	bic.w	r2, r2, #1
 80022fc:	f8c4 2090 	str.w	r2, [r4, #144]	; 0x90
 8002300:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
 8002304:	f022 0204 	bic.w	r2, r2, #4
 8002308:	f8c4 2090 	str.w	r2, [r4, #144]	; 0x90
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 800230c:	2b00      	cmp	r3, #0
 800230e:	d1c2      	bne.n	8002296 <HAL_RCC_OscConfig+0x2ea>
      tickstart = HAL_GetTick();
 8002310:	f7fe fe5e 	bl	8000fd0 <HAL_GetTick>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8002314:	f241 3988 	movw	r9, #5000	; 0x1388
      tickstart = HAL_GetTick();
 8002318:	4607      	mov	r7, r0
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 800231a:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 800231e:	0798      	lsls	r0, r3, #30
 8002320:	d5c2      	bpl.n	80022a8 <HAL_RCC_OscConfig+0x2fc>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8002322:	f7fe fe55 	bl	8000fd0 <HAL_GetTick>
 8002326:	1bc0      	subs	r0, r0, r7
 8002328:	4548      	cmp	r0, r9
 800232a:	d9f6      	bls.n	800231a <HAL_RCC_OscConfig+0x36e>
 800232c:	e6db      	b.n	80020e6 <HAL_RCC_OscConfig+0x13a>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800232e:	f7fe fe4f 	bl	8000fd0 <HAL_GetTick>
 8002332:	1bc0      	subs	r0, r0, r7
 8002334:	4548      	cmp	r0, r9
 8002336:	d9b3      	bls.n	80022a0 <HAL_RCC_OscConfig+0x2f4>
 8002338:	e6d5      	b.n	80020e6 <HAL_RCC_OscConfig+0x13a>
    if(sysclk_source != RCC_CFGR_SWS_PLL)
 800233a:	2e0c      	cmp	r6, #12
 800233c:	f43f ae3a 	beq.w	8001fb4 <HAL_RCC_OscConfig+0x8>
      if(RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 8002340:	2b02      	cmp	r3, #2
        __HAL_RCC_PLL_DISABLE();
 8002342:	6823      	ldr	r3, [r4, #0]
 8002344:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8002348:	6023      	str	r3, [r4, #0]
      if(RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 800234a:	d137      	bne.n	80023bc <HAL_RCC_OscConfig+0x410>
        tickstart = HAL_GetTick();
 800234c:	f7fe fe40 	bl	8000fd0 <HAL_GetTick>
 8002350:	4606      	mov	r6, r0
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8002352:	6823      	ldr	r3, [r4, #0]
 8002354:	0199      	lsls	r1, r3, #6
 8002356:	d42b      	bmi.n	80023b0 <HAL_RCC_OscConfig+0x404>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8002358:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 800235a:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800235c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8002360:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 8002362:	3a01      	subs	r2, #1
 8002364:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
 8002368:	6baa      	ldr	r2, [r5, #56]	; 0x38
 800236a:	0912      	lsrs	r2, r2, #4
 800236c:	ea43 4342 	orr.w	r3, r3, r2, lsl #17
 8002370:	6bea      	ldr	r2, [r5, #60]	; 0x3c
 8002372:	0852      	lsrs	r2, r2, #1
 8002374:	3a01      	subs	r2, #1
 8002376:	ea43 5342 	orr.w	r3, r3, r2, lsl #21
 800237a:	6c2a      	ldr	r2, [r5, #64]	; 0x40
 800237c:	0852      	lsrs	r2, r2, #1
 800237e:	3a01      	subs	r2, #1
 8002380:	ea43 6342 	orr.w	r3, r3, r2, lsl #25
 8002384:	60e3      	str	r3, [r4, #12]
        __HAL_RCC_PLL_ENABLE();
 8002386:	6823      	ldr	r3, [r4, #0]
 8002388:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800238c:	6023      	str	r3, [r4, #0]
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 800238e:	68e3      	ldr	r3, [r4, #12]
 8002390:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8002394:	60e3      	str	r3, [r4, #12]
        tickstart = HAL_GetTick();
 8002396:	f7fe fe1b 	bl	8000fd0 <HAL_GetTick>
 800239a:	4605      	mov	r5, r0
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 800239c:	6823      	ldr	r3, [r4, #0]
 800239e:	019a      	lsls	r2, r3, #6
 80023a0:	f53f ae66 	bmi.w	8002070 <HAL_RCC_OscConfig+0xc4>
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 80023a4:	f7fe fe14 	bl	8000fd0 <HAL_GetTick>
 80023a8:	1b40      	subs	r0, r0, r5
 80023aa:	2802      	cmp	r0, #2
 80023ac:	d9f6      	bls.n	800239c <HAL_RCC_OscConfig+0x3f0>
 80023ae:	e69a      	b.n	80020e6 <HAL_RCC_OscConfig+0x13a>
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 80023b0:	f7fe fe0e 	bl	8000fd0 <HAL_GetTick>
 80023b4:	1b80      	subs	r0, r0, r6
 80023b6:	2802      	cmp	r0, #2
 80023b8:	d9cb      	bls.n	8002352 <HAL_RCC_OscConfig+0x3a6>
 80023ba:	e694      	b.n	80020e6 <HAL_RCC_OscConfig+0x13a>
        if(READ_BIT(RCC->CR, (RCC_CR_PLLSAI1RDY | RCC_CR_PLLSAI2RDY)) == 0U)
 80023bc:	6823      	ldr	r3, [r4, #0]
 80023be:	f013 5f20 	tst.w	r3, #671088640	; 0x28000000
          MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
 80023c2:	bf02      	ittt	eq
 80023c4:	68e3      	ldreq	r3, [r4, #12]
 80023c6:	f023 0303 	biceq.w	r3, r3, #3
 80023ca:	60e3      	streq	r3, [r4, #12]
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_SAI3CLK);
 80023cc:	68e3      	ldr	r3, [r4, #12]
 80023ce:	f023 7388 	bic.w	r3, r3, #17825792	; 0x1100000
 80023d2:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80023d6:	60e3      	str	r3, [r4, #12]
        tickstart = HAL_GetTick();
 80023d8:	f7fe fdfa 	bl	8000fd0 <HAL_GetTick>
 80023dc:	4605      	mov	r5, r0
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 80023de:	6823      	ldr	r3, [r4, #0]
 80023e0:	019b      	lsls	r3, r3, #6
 80023e2:	f57f ae45 	bpl.w	8002070 <HAL_RCC_OscConfig+0xc4>
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 80023e6:	f7fe fdf3 	bl	8000fd0 <HAL_GetTick>
 80023ea:	1b40      	subs	r0, r0, r5
 80023ec:	2802      	cmp	r0, #2
 80023ee:	d9f6      	bls.n	80023de <HAL_RCC_OscConfig+0x432>
 80023f0:	e679      	b.n	80020e6 <HAL_RCC_OscConfig+0x13a>
 80023f2:	bf00      	nop
 80023f4:	40007000 	.word	0x40007000

080023f8 <HAL_RCC_ClockConfig>:
{
 80023f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80023fc:	460e      	mov	r6, r1
  if(RCC_ClkInitStruct == NULL)
 80023fe:	4604      	mov	r4, r0
 8002400:	b910      	cbnz	r0, 8002408 <HAL_RCC_ClockConfig+0x10>
    return HAL_ERROR;
 8002402:	2001      	movs	r0, #1
 8002404:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8002408:	4a40      	ldr	r2, [pc, #256]	; (800250c <HAL_RCC_ClockConfig+0x114>)
 800240a:	6813      	ldr	r3, [r2, #0]
 800240c:	f003 0307 	and.w	r3, r3, #7
 8002410:	428b      	cmp	r3, r1
 8002412:	d329      	bcc.n	8002468 <HAL_RCC_ClockConfig+0x70>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8002414:	6823      	ldr	r3, [r4, #0]
 8002416:	07d9      	lsls	r1, r3, #31
 8002418:	d431      	bmi.n	800247e <HAL_RCC_ClockConfig+0x86>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800241a:	6821      	ldr	r1, [r4, #0]
 800241c:	078a      	lsls	r2, r1, #30
 800241e:	d45b      	bmi.n	80024d8 <HAL_RCC_ClockConfig+0xe0>
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 8002420:	4a3a      	ldr	r2, [pc, #232]	; (800250c <HAL_RCC_ClockConfig+0x114>)
 8002422:	6813      	ldr	r3, [r2, #0]
 8002424:	f003 0307 	and.w	r3, r3, #7
 8002428:	429e      	cmp	r6, r3
 800242a:	d35d      	bcc.n	80024e8 <HAL_RCC_ClockConfig+0xf0>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800242c:	f011 0f04 	tst.w	r1, #4
 8002430:	4d37      	ldr	r5, [pc, #220]	; (8002510 <HAL_RCC_ClockConfig+0x118>)
 8002432:	d164      	bne.n	80024fe <HAL_RCC_ClockConfig+0x106>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8002434:	070b      	lsls	r3, r1, #28
 8002436:	d506      	bpl.n	8002446 <HAL_RCC_ClockConfig+0x4e>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 8002438:	68ab      	ldr	r3, [r5, #8]
 800243a:	6922      	ldr	r2, [r4, #16]
 800243c:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 8002440:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 8002444:	60ab      	str	r3, [r5, #8]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 8002446:	f7ff fd5d 	bl	8001f04 <HAL_RCC_GetSysClockFreq>
 800244a:	68ab      	ldr	r3, [r5, #8]
 800244c:	4a31      	ldr	r2, [pc, #196]	; (8002514 <HAL_RCC_ClockConfig+0x11c>)
 800244e:	f3c3 1303 	ubfx	r3, r3, #4, #4
}
 8002452:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 8002456:	5cd3      	ldrb	r3, [r2, r3]
 8002458:	f003 031f 	and.w	r3, r3, #31
 800245c:	40d8      	lsrs	r0, r3
 800245e:	4b2e      	ldr	r3, [pc, #184]	; (8002518 <HAL_RCC_ClockConfig+0x120>)
 8002460:	6018      	str	r0, [r3, #0]
  status = HAL_InitTick (TICK_INT_PRIORITY);
 8002462:	200f      	movs	r0, #15
 8002464:	f7fe bd84 	b.w	8000f70 <HAL_InitTick>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8002468:	6813      	ldr	r3, [r2, #0]
 800246a:	f023 0307 	bic.w	r3, r3, #7
 800246e:	430b      	orrs	r3, r1
 8002470:	6013      	str	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8002472:	6813      	ldr	r3, [r2, #0]
 8002474:	f003 0307 	and.w	r3, r3, #7
 8002478:	4299      	cmp	r1, r3
 800247a:	d1c2      	bne.n	8002402 <HAL_RCC_ClockConfig+0xa>
 800247c:	e7ca      	b.n	8002414 <HAL_RCC_ClockConfig+0x1c>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800247e:	6862      	ldr	r2, [r4, #4]
 8002480:	4d23      	ldr	r5, [pc, #140]	; (8002510 <HAL_RCC_ClockConfig+0x118>)
 8002482:	2a03      	cmp	r2, #3
      if(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8002484:	682b      	ldr	r3, [r5, #0]
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8002486:	d11b      	bne.n	80024c0 <HAL_RCC_ClockConfig+0xc8>
      if(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8002488:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
        if(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 800248c:	d0b9      	beq.n	8002402 <HAL_RCC_ClockConfig+0xa>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 800248e:	68ab      	ldr	r3, [r5, #8]
 8002490:	f023 0303 	bic.w	r3, r3, #3
 8002494:	4313      	orrs	r3, r2
 8002496:	60ab      	str	r3, [r5, #8]
    tickstart = HAL_GetTick();
 8002498:	f7fe fd9a 	bl	8000fd0 <HAL_GetTick>
      if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800249c:	f241 3888 	movw	r8, #5000	; 0x1388
    tickstart = HAL_GetTick();
 80024a0:	4607      	mov	r7, r0
    while(__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 80024a2:	68ab      	ldr	r3, [r5, #8]
 80024a4:	6862      	ldr	r2, [r4, #4]
 80024a6:	f003 030c 	and.w	r3, r3, #12
 80024aa:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 80024ae:	d0b4      	beq.n	800241a <HAL_RCC_ClockConfig+0x22>
      if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80024b0:	f7fe fd8e 	bl	8000fd0 <HAL_GetTick>
 80024b4:	1bc0      	subs	r0, r0, r7
 80024b6:	4540      	cmp	r0, r8
 80024b8:	d9f3      	bls.n	80024a2 <HAL_RCC_ClockConfig+0xaa>
        return HAL_TIMEOUT;
 80024ba:	2003      	movs	r0, #3
}
 80024bc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80024c0:	2a02      	cmp	r2, #2
 80024c2:	d102      	bne.n	80024ca <HAL_RCC_ClockConfig+0xd2>
        if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 80024c4:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 80024c8:	e7e0      	b.n	800248c <HAL_RCC_ClockConfig+0x94>
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 80024ca:	b912      	cbnz	r2, 80024d2 <HAL_RCC_ClockConfig+0xda>
        if(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 80024cc:	f013 0f02 	tst.w	r3, #2
 80024d0:	e7dc      	b.n	800248c <HAL_RCC_ClockConfig+0x94>
        if(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 80024d2:	f413 6f80 	tst.w	r3, #1024	; 0x400
 80024d6:	e7d9      	b.n	800248c <HAL_RCC_ClockConfig+0x94>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 80024d8:	4a0d      	ldr	r2, [pc, #52]	; (8002510 <HAL_RCC_ClockConfig+0x118>)
 80024da:	68a0      	ldr	r0, [r4, #8]
 80024dc:	6893      	ldr	r3, [r2, #8]
 80024de:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80024e2:	4303      	orrs	r3, r0
 80024e4:	6093      	str	r3, [r2, #8]
 80024e6:	e79b      	b.n	8002420 <HAL_RCC_ClockConfig+0x28>
    __HAL_FLASH_SET_LATENCY(FLatency);
 80024e8:	6813      	ldr	r3, [r2, #0]
 80024ea:	f023 0307 	bic.w	r3, r3, #7
 80024ee:	4333      	orrs	r3, r6
 80024f0:	6013      	str	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 80024f2:	6813      	ldr	r3, [r2, #0]
 80024f4:	f003 0307 	and.w	r3, r3, #7
 80024f8:	429e      	cmp	r6, r3
 80024fa:	d182      	bne.n	8002402 <HAL_RCC_ClockConfig+0xa>
 80024fc:	e796      	b.n	800242c <HAL_RCC_ClockConfig+0x34>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 80024fe:	68ab      	ldr	r3, [r5, #8]
 8002500:	68e2      	ldr	r2, [r4, #12]
 8002502:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8002506:	4313      	orrs	r3, r2
 8002508:	60ab      	str	r3, [r5, #8]
 800250a:	e793      	b.n	8002434 <HAL_RCC_ClockConfig+0x3c>
 800250c:	40022000 	.word	0x40022000
 8002510:	40021000 	.word	0x40021000
 8002514:	0800d19e 	.word	0x0800d19e
 8002518:	20000058 	.word	0x20000058

0800251c <HAL_RCC_GetPCLK1Freq>:
  return (HAL_RCC_GetHCLKFreq() >> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos] & 0x1FU));
 800251c:	4b05      	ldr	r3, [pc, #20]	; (8002534 <HAL_RCC_GetPCLK1Freq+0x18>)
 800251e:	4a06      	ldr	r2, [pc, #24]	; (8002538 <HAL_RCC_GetPCLK1Freq+0x1c>)
 8002520:	689b      	ldr	r3, [r3, #8]
 8002522:	f3c3 2302 	ubfx	r3, r3, #8, #3
 8002526:	5cd3      	ldrb	r3, [r2, r3]
 8002528:	4a04      	ldr	r2, [pc, #16]	; (800253c <HAL_RCC_GetPCLK1Freq+0x20>)
 800252a:	6810      	ldr	r0, [r2, #0]
 800252c:	f003 031f 	and.w	r3, r3, #31
}
 8002530:	40d8      	lsrs	r0, r3
 8002532:	4770      	bx	lr
 8002534:	40021000 	.word	0x40021000
 8002538:	0800d1ae 	.word	0x0800d1ae
 800253c:	20000058 	.word	0x20000058

08002540 <HAL_RCC_GetPCLK2Freq>:
  return (HAL_RCC_GetHCLKFreq()>> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos] & 0x1FU));
 8002540:	4b05      	ldr	r3, [pc, #20]	; (8002558 <HAL_RCC_GetPCLK2Freq+0x18>)
 8002542:	4a06      	ldr	r2, [pc, #24]	; (800255c <HAL_RCC_GetPCLK2Freq+0x1c>)
 8002544:	689b      	ldr	r3, [r3, #8]
 8002546:	f3c3 23c2 	ubfx	r3, r3, #11, #3
 800254a:	5cd3      	ldrb	r3, [r2, r3]
 800254c:	4a04      	ldr	r2, [pc, #16]	; (8002560 <HAL_RCC_GetPCLK2Freq+0x20>)
 800254e:	6810      	ldr	r0, [r2, #0]
 8002550:	f003 031f 	and.w	r3, r3, #31
}
 8002554:	40d8      	lsrs	r0, r3
 8002556:	4770      	bx	lr
 8002558:	40021000 	.word	0x40021000
 800255c:	0800d1ae 	.word	0x0800d1ae
 8002560:	20000058 	.word	0x20000058

08002564 <RCCEx_PLLSAI1_Config>:
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_Config(RCC_PLLSAI1InitTypeDef *PllSai1, uint32_t Divider)
{
 8002564:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_RCC_PLLSAI1M_VALUE(PllSai1->PLLSAI1M));
  assert_param(IS_RCC_PLLSAI1N_VALUE(PllSai1->PLLSAI1N));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PllSai1->PLLSAI1ClockOut));

  /* Check that PLLSAI1 clock source and divider M can be applied */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 8002566:	4b45      	ldr	r3, [pc, #276]	; (800267c <RCCEx_PLLSAI1_Config+0x118>)
 8002568:	68da      	ldr	r2, [r3, #12]
 800256a:	f012 0f03 	tst.w	r2, #3
{
 800256e:	4605      	mov	r5, r0
 8002570:	460e      	mov	r6, r1
 8002572:	461c      	mov	r4, r3
 8002574:	6800      	ldr	r0, [r0, #0]
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 8002576:	d02a      	beq.n	80025ce <RCCEx_PLLSAI1_Config+0x6a>
  {
    /* PLL clock source and divider M already set, check that no request for change  */
    if((__HAL_RCC_GET_PLL_OSCSOURCE() != PllSai1->PLLSAI1Source)
 8002578:	68da      	ldr	r2, [r3, #12]
 800257a:	f002 0203 	and.w	r2, r2, #3
 800257e:	4282      	cmp	r2, r0
 8002580:	d13c      	bne.n	80025fc <RCCEx_PLLSAI1_Config+0x98>
       ||
 8002582:	2a00      	cmp	r2, #0
 8002584:	d03a      	beq.n	80025fc <RCCEx_PLLSAI1_Config+0x98>
       (PllSai1->PLLSAI1Source == RCC_PLLSOURCE_NONE)
#if !defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
       ||
       (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U) != PllSai1->PLLSAI1M)
 8002586:	68db      	ldr	r3, [r3, #12]
       ||
 8002588:	686a      	ldr	r2, [r5, #4]
       (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U) != PllSai1->PLLSAI1M)
 800258a:	f3c3 1302 	ubfx	r3, r3, #4, #3
 800258e:	3301      	adds	r3, #1
       ||
 8002590:	4293      	cmp	r3, r2
 8002592:	d133      	bne.n	80025fc <RCCEx_PLLSAI1_Config+0x98>
  }

  if(status == HAL_OK)
  {
    /* Disable the PLLSAI1 */
    __HAL_RCC_PLLSAI1_DISABLE();
 8002594:	6823      	ldr	r3, [r4, #0]
 8002596:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 800259a:	6023      	str	r3, [r4, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800259c:	f7fe fd18 	bl	8000fd0 <HAL_GetTick>
 80025a0:	4607      	mov	r7, r0

    /* Wait till PLLSAI1 is ready to be updated */
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) != 0U)
 80025a2:	6823      	ldr	r3, [r4, #0]
 80025a4:	011a      	lsls	r2, r3, #4
 80025a6:	d432      	bmi.n	800260e <RCCEx_PLLSAI1_Config+0xaa>
 80025a8:	68af      	ldr	r7, [r5, #8]
      }
    }

    if(status == HAL_OK)
    {
      if(Divider == DIVIDER_P_UPDATE)
 80025aa:	2e00      	cmp	r6, #0
 80025ac:	d036      	beq.n	800261c <RCCEx_PLLSAI1_Config+0xb8>
                   ((PllSai1->PLLSAI1P >> 4U) << RCC_PLLSAI1CFGR_PLLSAI1P_Pos));
#endif /* RCC_PLLSAI1P_DIV_2_31_SUPPORT */

#endif /* RCC_PLLSAI1M_DIV_1_16_SUPPORT */
      }
      else if(Divider == DIVIDER_Q_UPDATE)
 80025ae:	2e01      	cmp	r6, #1
 80025b0:	d150      	bne.n	8002654 <RCCEx_PLLSAI1_Config+0xf0>
                   (PllSai1->PLLSAI1N << RCC_PLLSAI1CFGR_PLLSAI1N_Pos) |
                   (((PllSai1->PLLSAI1Q >> 1U) - 1U) << RCC_PLLSAI1CFGR_PLLSAI1Q_Pos) |
                   ((PllSai1->PLLSAI1M - 1U) << RCC_PLLSAI1CFGR_PLLSAI1M_Pos));
#else
        /* Configure the PLLSAI1 Division factor Q and Multiplication factor N*/
        MODIFY_REG(RCC->PLLSAI1CFGR,
 80025b2:	6922      	ldr	r2, [r4, #16]
 80025b4:	6928      	ldr	r0, [r5, #16]
 80025b6:	f422 02c0 	bic.w	r2, r2, #6291456	; 0x600000
 80025ba:	0840      	lsrs	r0, r0, #1
 80025bc:	f422 42fe 	bic.w	r2, r2, #32512	; 0x7f00
 80025c0:	3801      	subs	r0, #1
 80025c2:	ea42 2207 	orr.w	r2, r2, r7, lsl #8
 80025c6:	ea42 5240 	orr.w	r2, r2, r0, lsl #21
 80025ca:	6122      	str	r2, [r4, #16]
 80025cc:	e032      	b.n	8002634 <RCCEx_PLLSAI1_Config+0xd0>
    switch(PllSai1->PLLSAI1Source)
 80025ce:	2802      	cmp	r0, #2
 80025d0:	d010      	beq.n	80025f4 <RCCEx_PLLSAI1_Config+0x90>
 80025d2:	2803      	cmp	r0, #3
 80025d4:	d014      	beq.n	8002600 <RCCEx_PLLSAI1_Config+0x9c>
 80025d6:	2801      	cmp	r0, #1
 80025d8:	d110      	bne.n	80025fc <RCCEx_PLLSAI1_Config+0x98>
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_MSIRDY))
 80025da:	681b      	ldr	r3, [r3, #0]
 80025dc:	079f      	lsls	r7, r3, #30
 80025de:	d538      	bpl.n	8002652 <RCCEx_PLLSAI1_Config+0xee>
      MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM, PllSai1->PLLSAI1Source | (PllSai1->PLLSAI1M - 1U) << RCC_PLLCFGR_PLLM_Pos);
 80025e0:	68e3      	ldr	r3, [r4, #12]
 80025e2:	686a      	ldr	r2, [r5, #4]
 80025e4:	f023 0373 	bic.w	r3, r3, #115	; 0x73
 80025e8:	3a01      	subs	r2, #1
 80025ea:	4318      	orrs	r0, r3
 80025ec:	ea40 1002 	orr.w	r0, r0, r2, lsl #4
 80025f0:	60e0      	str	r0, [r4, #12]
 80025f2:	e7cf      	b.n	8002594 <RCCEx_PLLSAI1_Config+0x30>
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSIRDY))
 80025f4:	681b      	ldr	r3, [r3, #0]
 80025f6:	f413 6f80 	tst.w	r3, #1024	; 0x400
        if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSEBYP))
 80025fa:	d1f1      	bne.n	80025e0 <RCCEx_PLLSAI1_Config+0x7c>
 80025fc:	2001      	movs	r0, #1
 80025fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSERDY))
 8002600:	681a      	ldr	r2, [r3, #0]
 8002602:	0391      	lsls	r1, r2, #14
 8002604:	d4ec      	bmi.n	80025e0 <RCCEx_PLLSAI1_Config+0x7c>
        if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSEBYP))
 8002606:	681b      	ldr	r3, [r3, #0]
 8002608:	f413 2f80 	tst.w	r3, #262144	; 0x40000
 800260c:	e7f5      	b.n	80025fa <RCCEx_PLLSAI1_Config+0x96>
      if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 800260e:	f7fe fcdf 	bl	8000fd0 <HAL_GetTick>
 8002612:	1bc0      	subs	r0, r0, r7
 8002614:	2802      	cmp	r0, #2
 8002616:	d9c4      	bls.n	80025a2 <RCCEx_PLLSAI1_Config+0x3e>
        status = HAL_TIMEOUT;
 8002618:	2003      	movs	r0, #3
 800261a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        MODIFY_REG(RCC->PLLSAI1CFGR,
 800261c:	6921      	ldr	r1, [r4, #16]
 800261e:	68eb      	ldr	r3, [r5, #12]
 8002620:	f421 311f 	bic.w	r1, r1, #162816	; 0x27c00
 8002624:	f421 7140 	bic.w	r1, r1, #768	; 0x300
 8002628:	ea41 2107 	orr.w	r1, r1, r7, lsl #8
 800262c:	091b      	lsrs	r3, r3, #4
 800262e:	ea41 4143 	orr.w	r1, r1, r3, lsl #17
 8002632:	6121      	str	r1, [r4, #16]
                   (((PllSai1->PLLSAI1R >> 1U) - 1U) << RCC_PLLSAI1CFGR_PLLSAI1R_Pos));
#endif /* RCC_PLLSAI1M_DIV_1_16_SUPPORT */
      }

      /* Enable the PLLSAI1 again by setting PLLSAI1ON to 1*/
      __HAL_RCC_PLLSAI1_ENABLE();
 8002634:	6823      	ldr	r3, [r4, #0]
 8002636:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 800263a:	6023      	str	r3, [r4, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800263c:	f7fe fcc8 	bl	8000fd0 <HAL_GetTick>
 8002640:	4606      	mov	r6, r0

      /* Wait till PLLSAI1 is ready */
      while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == 0U)
 8002642:	6823      	ldr	r3, [r4, #0]
 8002644:	011b      	lsls	r3, r3, #4
 8002646:	d513      	bpl.n	8002670 <RCCEx_PLLSAI1_Config+0x10c>
      }

      if(status == HAL_OK)
      {
        /* Configure the PLLSAI1 Clock output(s) */
        __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PllSai1->PLLSAI1ClockOut);
 8002648:	6923      	ldr	r3, [r4, #16]
 800264a:	69aa      	ldr	r2, [r5, #24]
 800264c:	4313      	orrs	r3, r2
 800264e:	6123      	str	r3, [r4, #16]
 8002650:	2000      	movs	r0, #0
      }
    }
  }

  return status;
}
 8002652:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        MODIFY_REG(RCC->PLLSAI1CFGR,
 8002654:	6923      	ldr	r3, [r4, #16]
 8002656:	6968      	ldr	r0, [r5, #20]
 8002658:	f023 63c0 	bic.w	r3, r3, #100663296	; 0x6000000
 800265c:	0840      	lsrs	r0, r0, #1
 800265e:	f423 43fe 	bic.w	r3, r3, #32512	; 0x7f00
 8002662:	3801      	subs	r0, #1
 8002664:	ea43 2307 	orr.w	r3, r3, r7, lsl #8
 8002668:	ea43 6340 	orr.w	r3, r3, r0, lsl #25
 800266c:	6123      	str	r3, [r4, #16]
 800266e:	e7e1      	b.n	8002634 <RCCEx_PLLSAI1_Config+0xd0>
        if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 8002670:	f7fe fcae 	bl	8000fd0 <HAL_GetTick>
 8002674:	1b80      	subs	r0, r0, r6
 8002676:	2802      	cmp	r0, #2
 8002678:	d9e3      	bls.n	8002642 <RCCEx_PLLSAI1_Config+0xde>
 800267a:	e7cd      	b.n	8002618 <RCCEx_PLLSAI1_Config+0xb4>
 800267c:	40021000 	.word	0x40021000

08002680 <RCCEx_PLLSAI2_Config>:
  * @note   PLLSAI2 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI2_Config(RCC_PLLSAI2InitTypeDef *PllSai2, uint32_t Divider)
{
 8002680:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_RCC_PLLSAI2M_VALUE(PllSai2->PLLSAI2M));
  assert_param(IS_RCC_PLLSAI2N_VALUE(PllSai2->PLLSAI2N));
  assert_param(IS_RCC_PLLSAI2CLOCKOUT_VALUE(PllSai2->PLLSAI2ClockOut));

  /* Check that PLLSAI2 clock source and divider M can be applied */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 8002682:	4b3d      	ldr	r3, [pc, #244]	; (8002778 <RCCEx_PLLSAI2_Config+0xf8>)
 8002684:	68da      	ldr	r2, [r3, #12]
 8002686:	f012 0f03 	tst.w	r2, #3
{
 800268a:	4605      	mov	r5, r0
 800268c:	460e      	mov	r6, r1
 800268e:	461c      	mov	r4, r3
 8002690:	6800      	ldr	r0, [r0, #0]
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 8002692:	d028      	beq.n	80026e6 <RCCEx_PLLSAI2_Config+0x66>
  {
    /* PLL clock source and divider M already set, check that no request for change  */
    if((__HAL_RCC_GET_PLL_OSCSOURCE() != PllSai2->PLLSAI2Source)
 8002694:	68da      	ldr	r2, [r3, #12]
 8002696:	f002 0203 	and.w	r2, r2, #3
 800269a:	4282      	cmp	r2, r0
 800269c:	d13a      	bne.n	8002714 <RCCEx_PLLSAI2_Config+0x94>
       ||
 800269e:	2a00      	cmp	r2, #0
 80026a0:	d038      	beq.n	8002714 <RCCEx_PLLSAI2_Config+0x94>
       (PllSai2->PLLSAI2Source == RCC_PLLSOURCE_NONE)
#if !defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
       ||
       (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U) != PllSai2->PLLSAI2M)
 80026a2:	68db      	ldr	r3, [r3, #12]
       ||
 80026a4:	686a      	ldr	r2, [r5, #4]
       (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U) != PllSai2->PLLSAI2M)
 80026a6:	f3c3 1302 	ubfx	r3, r3, #4, #3
 80026aa:	3301      	adds	r3, #1
       ||
 80026ac:	4293      	cmp	r3, r2
 80026ae:	d131      	bne.n	8002714 <RCCEx_PLLSAI2_Config+0x94>
  }

  if(status == HAL_OK)
  {
    /* Disable the PLLSAI2 */
    __HAL_RCC_PLLSAI2_DISABLE();
 80026b0:	6823      	ldr	r3, [r4, #0]
 80026b2:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 80026b6:	6023      	str	r3, [r4, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 80026b8:	f7fe fc8a 	bl	8000fd0 <HAL_GetTick>
 80026bc:	4607      	mov	r7, r0

    /* Wait till PLLSAI2 is ready to be updated */
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) != 0U)
 80026be:	6823      	ldr	r3, [r4, #0]
 80026c0:	009a      	lsls	r2, r3, #2
 80026c2:	d430      	bmi.n	8002726 <RCCEx_PLLSAI2_Config+0xa6>
 80026c4:	68a8      	ldr	r0, [r5, #8]
      }
    }

    if(status == HAL_OK)
    {
      if(Divider == DIVIDER_P_UPDATE)
 80026c6:	2e00      	cmp	r6, #0
 80026c8:	d034      	beq.n	8002734 <RCCEx_PLLSAI2_Config+0xb4>
                   (PllSai2->PLLSAI2N << RCC_PLLSAI2CFGR_PLLSAI2N_Pos) |
                   (((PllSai2->PLLSAI2R >> 1U) - 1U) << RCC_PLLSAI2CFGR_PLLSAI2R_Pos) |
                   ((PllSai2->PLLSAI2M - 1U) << RCC_PLLSAI2CFGR_PLLSAI2M_Pos));
#else
        /* Configure the PLLSAI2 Division factor R and Multiplication factor N*/
        MODIFY_REG(RCC->PLLSAI2CFGR,
 80026ca:	6963      	ldr	r3, [r4, #20]
 80026cc:	6929      	ldr	r1, [r5, #16]
 80026ce:	f023 63c0 	bic.w	r3, r3, #100663296	; 0x6000000
 80026d2:	0849      	lsrs	r1, r1, #1
 80026d4:	f423 43fe 	bic.w	r3, r3, #32512	; 0x7f00
 80026d8:	3901      	subs	r1, #1
 80026da:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 80026de:	ea43 6341 	orr.w	r3, r3, r1, lsl #25
 80026e2:	6163      	str	r3, [r4, #20]
 80026e4:	e032      	b.n	800274c <RCCEx_PLLSAI2_Config+0xcc>
    switch(PllSai2->PLLSAI2Source)
 80026e6:	2802      	cmp	r0, #2
 80026e8:	d010      	beq.n	800270c <RCCEx_PLLSAI2_Config+0x8c>
 80026ea:	2803      	cmp	r0, #3
 80026ec:	d014      	beq.n	8002718 <RCCEx_PLLSAI2_Config+0x98>
 80026ee:	2801      	cmp	r0, #1
 80026f0:	d110      	bne.n	8002714 <RCCEx_PLLSAI2_Config+0x94>
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_MSIRDY))
 80026f2:	681b      	ldr	r3, [r3, #0]
 80026f4:	079f      	lsls	r7, r3, #30
 80026f6:	d538      	bpl.n	800276a <RCCEx_PLLSAI2_Config+0xea>
      MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM, PllSai2->PLLSAI2Source | (PllSai2->PLLSAI2M - 1U) << RCC_PLLCFGR_PLLM_Pos);
 80026f8:	68e3      	ldr	r3, [r4, #12]
 80026fa:	686a      	ldr	r2, [r5, #4]
 80026fc:	f023 0373 	bic.w	r3, r3, #115	; 0x73
 8002700:	3a01      	subs	r2, #1
 8002702:	4318      	orrs	r0, r3
 8002704:	ea40 1002 	orr.w	r0, r0, r2, lsl #4
 8002708:	60e0      	str	r0, [r4, #12]
 800270a:	e7d1      	b.n	80026b0 <RCCEx_PLLSAI2_Config+0x30>
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSIRDY))
 800270c:	681b      	ldr	r3, [r3, #0]
 800270e:	f413 6f80 	tst.w	r3, #1024	; 0x400
        if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSEBYP))
 8002712:	d1f1      	bne.n	80026f8 <RCCEx_PLLSAI2_Config+0x78>
 8002714:	2001      	movs	r0, #1
 8002716:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSERDY))
 8002718:	681a      	ldr	r2, [r3, #0]
 800271a:	0391      	lsls	r1, r2, #14
 800271c:	d4ec      	bmi.n	80026f8 <RCCEx_PLLSAI2_Config+0x78>
        if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSEBYP))
 800271e:	681b      	ldr	r3, [r3, #0]
 8002720:	f413 2f80 	tst.w	r3, #262144	; 0x40000
 8002724:	e7f5      	b.n	8002712 <RCCEx_PLLSAI2_Config+0x92>
      if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 8002726:	f7fe fc53 	bl	8000fd0 <HAL_GetTick>
 800272a:	1bc0      	subs	r0, r0, r7
 800272c:	2802      	cmp	r0, #2
 800272e:	d9c6      	bls.n	80026be <RCCEx_PLLSAI2_Config+0x3e>
        status = HAL_TIMEOUT;
 8002730:	2003      	movs	r0, #3
 8002732:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        MODIFY_REG(RCC->PLLSAI2CFGR,
 8002734:	6962      	ldr	r2, [r4, #20]
 8002736:	68eb      	ldr	r3, [r5, #12]
 8002738:	f422 321f 	bic.w	r2, r2, #162816	; 0x27c00
 800273c:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8002740:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 8002744:	091b      	lsrs	r3, r3, #4
 8002746:	ea42 4243 	orr.w	r2, r2, r3, lsl #17
 800274a:	6162      	str	r2, [r4, #20]
                   (((PllSai2->PLLSAI2R >> 1U) - 1U) << RCC_PLLSAI2CFGR_PLLSAI2R_Pos));
#endif /* RCC_PLLSAI2M_DIV_1_16_SUPPORT */
      }

      /* Enable the PLLSAI2 again by setting PLLSAI2ON to 1*/
      __HAL_RCC_PLLSAI2_ENABLE();
 800274c:	6823      	ldr	r3, [r4, #0]
 800274e:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8002752:	6023      	str	r3, [r4, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8002754:	f7fe fc3c 	bl	8000fd0 <HAL_GetTick>
 8002758:	4606      	mov	r6, r0

      /* Wait till PLLSAI2 is ready */
      while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) == 0U)
 800275a:	6823      	ldr	r3, [r4, #0]
 800275c:	009b      	lsls	r3, r3, #2
 800275e:	d505      	bpl.n	800276c <RCCEx_PLLSAI2_Config+0xec>
      }

      if(status == HAL_OK)
      {
        /* Configure the PLLSAI2 Clock output(s) */
        __HAL_RCC_PLLSAI2CLKOUT_ENABLE(PllSai2->PLLSAI2ClockOut);
 8002760:	6963      	ldr	r3, [r4, #20]
 8002762:	696a      	ldr	r2, [r5, #20]
 8002764:	4313      	orrs	r3, r2
 8002766:	6163      	str	r3, [r4, #20]
 8002768:	2000      	movs	r0, #0
      }
    }
  }

  return status;
}
 800276a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 800276c:	f7fe fc30 	bl	8000fd0 <HAL_GetTick>
 8002770:	1b80      	subs	r0, r0, r6
 8002772:	2802      	cmp	r0, #2
 8002774:	d9f1      	bls.n	800275a <RCCEx_PLLSAI2_Config+0xda>
 8002776:	e7db      	b.n	8002730 <RCCEx_PLLSAI2_Config+0xb0>
 8002778:	40021000 	.word	0x40021000

0800277c <HAL_RCCEx_PeriphCLKConfig>:
{
 800277c:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 8002780:	6806      	ldr	r6, [r0, #0]
 8002782:	f416 6600 	ands.w	r6, r6, #2048	; 0x800
{
 8002786:	4604      	mov	r4, r0
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 8002788:	d024      	beq.n	80027d4 <HAL_RCCEx_PeriphCLKConfig+0x58>
    switch(PeriphClkInit->Sai1ClockSelection)
 800278a:	6e41      	ldr	r1, [r0, #100]	; 0x64
 800278c:	f5b1 0f80 	cmp.w	r1, #4194304	; 0x400000
 8002790:	d02c      	beq.n	80027ec <HAL_RCCEx_PeriphCLKConfig+0x70>
 8002792:	d802      	bhi.n	800279a <HAL_RCCEx_PeriphCLKConfig+0x1e>
 8002794:	b1c1      	cbz	r1, 80027c8 <HAL_RCCEx_PeriphCLKConfig+0x4c>
      ret = HAL_ERROR;
 8002796:	2601      	movs	r6, #1
 8002798:	e01c      	b.n	80027d4 <HAL_RCCEx_PeriphCLKConfig+0x58>
    switch(PeriphClkInit->Sai1ClockSelection)
 800279a:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 800279e:	d00d      	beq.n	80027bc <HAL_RCCEx_PeriphCLKConfig+0x40>
 80027a0:	f5b1 0f40 	cmp.w	r1, #12582912	; 0xc00000
 80027a4:	d1f7      	bne.n	8002796 <HAL_RCCEx_PeriphCLKConfig+0x1a>
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 80027a6:	4abc      	ldr	r2, [pc, #752]	; (8002a98 <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 80027a8:	6e61      	ldr	r1, [r4, #100]	; 0x64
 80027aa:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 80027ae:	f423 0340 	bic.w	r3, r3, #12582912	; 0xc00000
 80027b2:	430b      	orrs	r3, r1
 80027b4:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
 80027b8:	2600      	movs	r6, #0
 80027ba:	e00b      	b.n	80027d4 <HAL_RCCEx_PeriphCLKConfig+0x58>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 80027bc:	4ab6      	ldr	r2, [pc, #728]	; (8002a98 <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 80027be:	68d3      	ldr	r3, [r2, #12]
 80027c0:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80027c4:	60d3      	str	r3, [r2, #12]
      break;
 80027c6:	e7ee      	b.n	80027a6 <HAL_RCCEx_PeriphCLKConfig+0x2a>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
 80027c8:	3004      	adds	r0, #4
 80027ca:	f7ff fecb 	bl	8002564 <RCCEx_PLLSAI1_Config>
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 80027ce:	4606      	mov	r6, r0
    if(ret == HAL_OK)
 80027d0:	2800      	cmp	r0, #0
 80027d2:	d0e8      	beq.n	80027a6 <HAL_RCCEx_PeriphCLKConfig+0x2a>
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2))
 80027d4:	6823      	ldr	r3, [r4, #0]
 80027d6:	04d8      	lsls	r0, r3, #19
 80027d8:	d506      	bpl.n	80027e8 <HAL_RCCEx_PeriphCLKConfig+0x6c>
    switch(PeriphClkInit->Sai2ClockSelection)
 80027da:	6ea1      	ldr	r1, [r4, #104]	; 0x68
 80027dc:	f1b1 7f80 	cmp.w	r1, #16777216	; 0x1000000
 80027e0:	d074      	beq.n	80028cc <HAL_RCCEx_PeriphCLKConfig+0x150>
 80027e2:	d808      	bhi.n	80027f6 <HAL_RCCEx_PeriphCLKConfig+0x7a>
 80027e4:	b1a9      	cbz	r1, 8002812 <HAL_RCCEx_PeriphCLKConfig+0x96>
      ret = HAL_ERROR;
 80027e6:	2601      	movs	r6, #1
 80027e8:	4635      	mov	r5, r6
 80027ea:	e021      	b.n	8002830 <HAL_RCCEx_PeriphCLKConfig+0xb4>
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 80027ec:	2100      	movs	r1, #0
 80027ee:	3020      	adds	r0, #32
 80027f0:	f7ff ff46 	bl	8002680 <RCCEx_PLLSAI2_Config>
 80027f4:	e7eb      	b.n	80027ce <HAL_RCCEx_PeriphCLKConfig+0x52>
    switch(PeriphClkInit->Sai2ClockSelection)
 80027f6:	f1b1 7f00 	cmp.w	r1, #33554432	; 0x2000000
 80027fa:	d004      	beq.n	8002806 <HAL_RCCEx_PeriphCLKConfig+0x8a>
 80027fc:	f1b1 7f40 	cmp.w	r1, #50331648	; 0x3000000
 8002800:	d1f1      	bne.n	80027e6 <HAL_RCCEx_PeriphCLKConfig+0x6a>
 8002802:	4635      	mov	r5, r6
 8002804:	e009      	b.n	800281a <HAL_RCCEx_PeriphCLKConfig+0x9e>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 8002806:	4aa4      	ldr	r2, [pc, #656]	; (8002a98 <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 8002808:	68d3      	ldr	r3, [r2, #12]
 800280a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800280e:	60d3      	str	r3, [r2, #12]
 8002810:	e7f7      	b.n	8002802 <HAL_RCCEx_PeriphCLKConfig+0x86>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
 8002812:	1d20      	adds	r0, r4, #4
 8002814:	f7ff fea6 	bl	8002564 <RCCEx_PLLSAI1_Config>
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 8002818:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800281a:	2d00      	cmp	r5, #0
 800281c:	d15c      	bne.n	80028d8 <HAL_RCCEx_PeriphCLKConfig+0x15c>
      __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 800281e:	4a9e      	ldr	r2, [pc, #632]	; (8002a98 <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 8002820:	6ea1      	ldr	r1, [r4, #104]	; 0x68
 8002822:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8002826:	f023 7340 	bic.w	r3, r3, #50331648	; 0x3000000
 800282a:	430b      	orrs	r3, r1
 800282c:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8002830:	6823      	ldr	r3, [r4, #0]
 8002832:	0399      	lsls	r1, r3, #14
 8002834:	f140 813b 	bpl.w	8002aae <HAL_RCCEx_PeriphCLKConfig+0x332>
    if(__HAL_RCC_PWR_IS_CLK_DISABLED() != 0U)
 8002838:	4f97      	ldr	r7, [pc, #604]	; (8002a98 <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 800283a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800283c:	00da      	lsls	r2, r3, #3
 800283e:	f140 8157 	bpl.w	8002af0 <HAL_RCCEx_PeriphCLKConfig+0x374>
    FlagStatus       pwrclkchanged = RESET;
 8002842:	f04f 0800 	mov.w	r8, #0
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8002846:	f8df 9254 	ldr.w	r9, [pc, #596]	; 8002a9c <HAL_RCCEx_PeriphCLKConfig+0x320>
 800284a:	f8d9 3000 	ldr.w	r3, [r9]
 800284e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8002852:	f8c9 3000 	str.w	r3, [r9]
    tickstart = HAL_GetTick();
 8002856:	f7fe fbbb 	bl	8000fd0 <HAL_GetTick>
 800285a:	4682      	mov	sl, r0
    while(READ_BIT(PWR->CR1, PWR_CR1_DBP) == 0U)
 800285c:	f8d9 3000 	ldr.w	r3, [r9]
 8002860:	05db      	lsls	r3, r3, #23
 8002862:	d53b      	bpl.n	80028dc <HAL_RCCEx_PeriphCLKConfig+0x160>
    if(ret == HAL_OK)
 8002864:	2d00      	cmp	r5, #0
 8002866:	d140      	bne.n	80028ea <HAL_RCCEx_PeriphCLKConfig+0x16e>
      tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
 8002868:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
      if((tmpregister != RCC_RTCCLKSOURCE_NONE) && (tmpregister != PeriphClkInit->RTCClockSelection))
 800286c:	f413 7340 	ands.w	r3, r3, #768	; 0x300
 8002870:	d015      	beq.n	800289e <HAL_RCCEx_PeriphCLKConfig+0x122>
 8002872:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
 8002876:	4293      	cmp	r3, r2
 8002878:	d011      	beq.n	800289e <HAL_RCCEx_PeriphCLKConfig+0x122>
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 800287a:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
        __HAL_RCC_BACKUPRESET_FORCE();
 800287e:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 8002882:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8002886:	f8c7 2090 	str.w	r2, [r7, #144]	; 0x90
        __HAL_RCC_BACKUPRESET_RELEASE();
 800288a:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 800288e:	f423 7340 	bic.w	r3, r3, #768	; 0x300
        __HAL_RCC_BACKUPRESET_RELEASE();
 8002892:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8002896:	f8c7 2090 	str.w	r2, [r7, #144]	; 0x90
        RCC->BDCR = tmpregister;
 800289a:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
 800289e:	07d8      	lsls	r0, r3, #31
 80028a0:	d509      	bpl.n	80028b6 <HAL_RCCEx_PeriphCLKConfig+0x13a>
        tickstart = HAL_GetTick();
 80028a2:	f7fe fb95 	bl	8000fd0 <HAL_GetTick>
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80028a6:	f241 3988 	movw	r9, #5000	; 0x1388
        tickstart = HAL_GetTick();
 80028aa:	4605      	mov	r5, r0
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 80028ac:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80028b0:	0799      	lsls	r1, r3, #30
 80028b2:	f140 80f5 	bpl.w	8002aa0 <HAL_RCCEx_PeriphCLKConfig+0x324>
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 80028b6:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80028ba:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
 80028be:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80028c2:	4313      	orrs	r3, r2
 80028c4:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 80028c8:	4635      	mov	r5, r6
 80028ca:	e00e      	b.n	80028ea <HAL_RCCEx_PeriphCLKConfig+0x16e>
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 80028cc:	2100      	movs	r1, #0
 80028ce:	f104 0020 	add.w	r0, r4, #32
 80028d2:	f7ff fed5 	bl	8002680 <RCCEx_PLLSAI2_Config>
 80028d6:	e79f      	b.n	8002818 <HAL_RCCEx_PeriphCLKConfig+0x9c>
 80028d8:	462e      	mov	r6, r5
 80028da:	e7a9      	b.n	8002830 <HAL_RCCEx_PeriphCLKConfig+0xb4>
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80028dc:	f7fe fb78 	bl	8000fd0 <HAL_GetTick>
 80028e0:	eba0 000a 	sub.w	r0, r0, sl
 80028e4:	2802      	cmp	r0, #2
 80028e6:	d9b9      	bls.n	800285c <HAL_RCCEx_PeriphCLKConfig+0xe0>
        ret = HAL_TIMEOUT;
 80028e8:	2503      	movs	r5, #3
    if(pwrclkchanged == SET)
 80028ea:	f1b8 0f00 	cmp.w	r8, #0
 80028ee:	d003      	beq.n	80028f8 <HAL_RCCEx_PeriphCLKConfig+0x17c>
      __HAL_RCC_PWR_CLK_DISABLE();
 80028f0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80028f2:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 80028f6:	65bb      	str	r3, [r7, #88]	; 0x58
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 80028f8:	6823      	ldr	r3, [r4, #0]
 80028fa:	07da      	lsls	r2, r3, #31
 80028fc:	d508      	bpl.n	8002910 <HAL_RCCEx_PeriphCLKConfig+0x194>
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 80028fe:	4966      	ldr	r1, [pc, #408]	; (8002a98 <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 8002900:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8002902:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8002906:	f022 0203 	bic.w	r2, r2, #3
 800290a:	4302      	orrs	r2, r0
 800290c:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 8002910:	079f      	lsls	r7, r3, #30
 8002912:	d508      	bpl.n	8002926 <HAL_RCCEx_PeriphCLKConfig+0x1aa>
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 8002914:	4960      	ldr	r1, [pc, #384]	; (8002a98 <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 8002916:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8002918:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 800291c:	f022 020c 	bic.w	r2, r2, #12
 8002920:	4302      	orrs	r2, r0
 8002922:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 8002926:	075e      	lsls	r6, r3, #29
 8002928:	d508      	bpl.n	800293c <HAL_RCCEx_PeriphCLKConfig+0x1c0>
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 800292a:	495b      	ldr	r1, [pc, #364]	; (8002a98 <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 800292c:	6c20      	ldr	r0, [r4, #64]	; 0x40
 800292e:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8002932:	f022 0230 	bic.w	r2, r2, #48	; 0x30
 8002936:	4302      	orrs	r2, r0
 8002938:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 800293c:	0718      	lsls	r0, r3, #28
 800293e:	d508      	bpl.n	8002952 <HAL_RCCEx_PeriphCLKConfig+0x1d6>
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 8002940:	4955      	ldr	r1, [pc, #340]	; (8002a98 <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 8002942:	6c60      	ldr	r0, [r4, #68]	; 0x44
 8002944:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8002948:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
 800294c:	4302      	orrs	r2, r0
 800294e:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 8002952:	06d9      	lsls	r1, r3, #27
 8002954:	d508      	bpl.n	8002968 <HAL_RCCEx_PeriphCLKConfig+0x1ec>
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
 8002956:	4950      	ldr	r1, [pc, #320]	; (8002a98 <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 8002958:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 800295a:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 800295e:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8002962:	4302      	orrs	r2, r0
 8002964:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 8002968:	069a      	lsls	r2, r3, #26
 800296a:	d508      	bpl.n	800297e <HAL_RCCEx_PeriphCLKConfig+0x202>
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 800296c:	494a      	ldr	r1, [pc, #296]	; (8002a98 <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 800296e:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 8002970:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8002974:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
 8002978:	4302      	orrs	r2, r0
 800297a:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 800297e:	059f      	lsls	r7, r3, #22
 8002980:	d508      	bpl.n	8002994 <HAL_RCCEx_PeriphCLKConfig+0x218>
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 8002982:	4945      	ldr	r1, [pc, #276]	; (8002a98 <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 8002984:	6de0      	ldr	r0, [r4, #92]	; 0x5c
 8002986:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 800298a:	f422 2240 	bic.w	r2, r2, #786432	; 0xc0000
 800298e:	4302      	orrs	r2, r0
 8002990:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 8002994:	055e      	lsls	r6, r3, #21
 8002996:	d508      	bpl.n	80029aa <HAL_RCCEx_PeriphCLKConfig+0x22e>
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 8002998:	493f      	ldr	r1, [pc, #252]	; (8002a98 <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 800299a:	6e20      	ldr	r0, [r4, #96]	; 0x60
 800299c:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80029a0:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 80029a4:	4302      	orrs	r2, r0
 80029a6:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 80029aa:	0658      	lsls	r0, r3, #25
 80029ac:	d508      	bpl.n	80029c0 <HAL_RCCEx_PeriphCLKConfig+0x244>
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 80029ae:	493a      	ldr	r1, [pc, #232]	; (8002a98 <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 80029b0:	6d20      	ldr	r0, [r4, #80]	; 0x50
 80029b2:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80029b6:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 80029ba:	4302      	orrs	r2, r0
 80029bc:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 80029c0:	0619      	lsls	r1, r3, #24
 80029c2:	d508      	bpl.n	80029d6 <HAL_RCCEx_PeriphCLKConfig+0x25a>
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 80029c4:	4934      	ldr	r1, [pc, #208]	; (8002a98 <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 80029c6:	6d60      	ldr	r0, [r4, #84]	; 0x54
 80029c8:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80029cc:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
 80029d0:	4302      	orrs	r2, r0
 80029d2:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 80029d6:	05da      	lsls	r2, r3, #23
 80029d8:	d508      	bpl.n	80029ec <HAL_RCCEx_PeriphCLKConfig+0x270>
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 80029da:	492f      	ldr	r1, [pc, #188]	; (8002a98 <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 80029dc:	6da0      	ldr	r0, [r4, #88]	; 0x58
 80029de:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80029e2:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
 80029e6:	4302      	orrs	r2, r0
 80029e8:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == (RCC_PERIPHCLK_SDMMC1))
 80029ec:	031f      	lsls	r7, r3, #12
 80029ee:	d50f      	bpl.n	8002a10 <HAL_RCCEx_PeriphCLKConfig+0x294>
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 80029f0:	4a29      	ldr	r2, [pc, #164]	; (8002a98 <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 80029f2:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
 80029f4:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 80029f8:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
 80029fc:	430b      	orrs	r3, r1
    if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLL)   /* PLL "Q" ? */
 80029fe:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 8002a02:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLL)   /* PLL "Q" ? */
 8002a06:	d154      	bne.n	8002ab2 <HAL_RCCEx_PeriphCLKConfig+0x336>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8002a08:	68d3      	ldr	r3, [r2, #12]
 8002a0a:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8002a0e:	60d3      	str	r3, [r2, #12]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 8002a10:	6823      	ldr	r3, [r4, #0]
 8002a12:	035e      	lsls	r6, r3, #13
 8002a14:	d50f      	bpl.n	8002a36 <HAL_RCCEx_PeriphCLKConfig+0x2ba>
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 8002a16:	4a20      	ldr	r2, [pc, #128]	; (8002a98 <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 8002a18:	6f21      	ldr	r1, [r4, #112]	; 0x70
 8002a1a:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8002a1e:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
 8002a22:	430b      	orrs	r3, r1
    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 8002a24:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 8002a28:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 8002a2c:	d14c      	bne.n	8002ac8 <HAL_RCCEx_PeriphCLKConfig+0x34c>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8002a2e:	68d3      	ldr	r3, [r2, #12]
 8002a30:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8002a34:	60d3      	str	r3, [r2, #12]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 8002a36:	6823      	ldr	r3, [r4, #0]
 8002a38:	0458      	lsls	r0, r3, #17
 8002a3a:	d512      	bpl.n	8002a62 <HAL_RCCEx_PeriphCLKConfig+0x2e6>
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 8002a3c:	4916      	ldr	r1, [pc, #88]	; (8002a98 <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 8002a3e:	6f62      	ldr	r2, [r4, #116]	; 0x74
 8002a40:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 8002a44:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
 8002a48:	4313      	orrs	r3, r2
    if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
 8002a4a:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 8002a4e:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
    if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
 8002a52:	d144      	bne.n	8002ade <HAL_RCCEx_PeriphCLKConfig+0x362>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_R_UPDATE);
 8002a54:	2102      	movs	r1, #2
 8002a56:	1d20      	adds	r0, r4, #4
 8002a58:	f7ff fd84 	bl	8002564 <RCCEx_PLLSAI1_Config>
      if(ret != HAL_OK)
 8002a5c:	2800      	cmp	r0, #0
 8002a5e:	bf18      	it	ne
 8002a60:	4605      	movne	r5, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SWPMI1) == RCC_PERIPHCLK_SWPMI1)
 8002a62:	6822      	ldr	r2, [r4, #0]
 8002a64:	0411      	lsls	r1, r2, #16
 8002a66:	d508      	bpl.n	8002a7a <HAL_RCCEx_PeriphCLKConfig+0x2fe>
    __HAL_RCC_SWPMI1_CONFIG(PeriphClkInit->Swpmi1ClockSelection);
 8002a68:	490b      	ldr	r1, [pc, #44]	; (8002a98 <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 8002a6a:	6fa0      	ldr	r0, [r4, #120]	; 0x78
 8002a6c:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 8002a70:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 8002a74:	4303      	orrs	r3, r0
 8002a76:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
 8002a7a:	03d3      	lsls	r3, r2, #15
 8002a7c:	d508      	bpl.n	8002a90 <HAL_RCCEx_PeriphCLKConfig+0x314>
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
 8002a7e:	4a06      	ldr	r2, [pc, #24]	; (8002a98 <HAL_RCCEx_PeriphCLKConfig+0x31c>)
 8002a80:	6fe1      	ldr	r1, [r4, #124]	; 0x7c
 8002a82:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8002a86:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8002a8a:	430b      	orrs	r3, r1
 8002a8c:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
}
 8002a90:	4628      	mov	r0, r5
 8002a92:	b002      	add	sp, #8
 8002a94:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8002a98:	40021000 	.word	0x40021000
 8002a9c:	40007000 	.word	0x40007000
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8002aa0:	f7fe fa96 	bl	8000fd0 <HAL_GetTick>
 8002aa4:	1b40      	subs	r0, r0, r5
 8002aa6:	4548      	cmp	r0, r9
 8002aa8:	f67f af00 	bls.w	80028ac <HAL_RCCEx_PeriphCLKConfig+0x130>
 8002aac:	e71c      	b.n	80028e8 <HAL_RCCEx_PeriphCLKConfig+0x16c>
 8002aae:	4635      	mov	r5, r6
 8002ab0:	e722      	b.n	80028f8 <HAL_RCCEx_PeriphCLKConfig+0x17c>
    else if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLLSAI1)
 8002ab2:	f1b1 6f80 	cmp.w	r1, #67108864	; 0x4000000
 8002ab6:	d1ab      	bne.n	8002a10 <HAL_RCCEx_PeriphCLKConfig+0x294>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 8002ab8:	2101      	movs	r1, #1
 8002aba:	1d20      	adds	r0, r4, #4
 8002abc:	f7ff fd52 	bl	8002564 <RCCEx_PLLSAI1_Config>
      if(ret != HAL_OK)
 8002ac0:	2800      	cmp	r0, #0
 8002ac2:	bf18      	it	ne
 8002ac4:	4605      	movne	r5, r0
 8002ac6:	e7a3      	b.n	8002a10 <HAL_RCCEx_PeriphCLKConfig+0x294>
    else if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLLSAI1)
 8002ac8:	f1b1 6f80 	cmp.w	r1, #67108864	; 0x4000000
 8002acc:	d1b3      	bne.n	8002a36 <HAL_RCCEx_PeriphCLKConfig+0x2ba>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 8002ace:	2101      	movs	r1, #1
 8002ad0:	1d20      	adds	r0, r4, #4
 8002ad2:	f7ff fd47 	bl	8002564 <RCCEx_PLLSAI1_Config>
      if(ret != HAL_OK)
 8002ad6:	2800      	cmp	r0, #0
 8002ad8:	bf18      	it	ne
 8002ada:	4605      	movne	r5, r0
 8002adc:	e7ab      	b.n	8002a36 <HAL_RCCEx_PeriphCLKConfig+0x2ba>
    else if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI2)
 8002ade:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
 8002ae2:	d1be      	bne.n	8002a62 <HAL_RCCEx_PeriphCLKConfig+0x2e6>
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_R_UPDATE);
 8002ae4:	2102      	movs	r1, #2
 8002ae6:	f104 0020 	add.w	r0, r4, #32
 8002aea:	f7ff fdc9 	bl	8002680 <RCCEx_PLLSAI2_Config>
 8002aee:	e7b5      	b.n	8002a5c <HAL_RCCEx_PeriphCLKConfig+0x2e0>
      __HAL_RCC_PWR_CLK_ENABLE();
 8002af0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8002af2:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8002af6:	65bb      	str	r3, [r7, #88]	; 0x58
 8002af8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8002afa:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8002afe:	9301      	str	r3, [sp, #4]
 8002b00:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8002b02:	f04f 0801 	mov.w	r8, #1
 8002b06:	e69e      	b.n	8002846 <HAL_RCCEx_PeriphCLKConfig+0xca>

08002b08 <SPI_WaitFifoStateUntilTimeout.part.1>:
        /* Disable the SPI and reset the CRC: the CRC value should be cleared
           on both master and slave sides in order to resynchronize the master
           and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8002b08:	6803      	ldr	r3, [r0, #0]
 8002b0a:	685a      	ldr	r2, [r3, #4]
 8002b0c:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
 8002b10:	605a      	str	r2, [r3, #4]

        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8002b12:	6842      	ldr	r2, [r0, #4]
 8002b14:	f5b2 7f82 	cmp.w	r2, #260	; 0x104
 8002b18:	d10a      	bne.n	8002b30 <SPI_WaitFifoStateUntilTimeout.part.1+0x28>
 8002b1a:	6882      	ldr	r2, [r0, #8]
 8002b1c:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
 8002b20:	d002      	beq.n	8002b28 <SPI_WaitFifoStateUntilTimeout.part.1+0x20>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 8002b22:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 8002b26:	d103      	bne.n	8002b30 <SPI_WaitFifoStateUntilTimeout.part.1+0x28>
        {
          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
 8002b28:	681a      	ldr	r2, [r3, #0]
 8002b2a:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8002b2e:	601a      	str	r2, [r3, #0]
        }

        /* Reset CRC Calculation */
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8002b30:	6a82      	ldr	r2, [r0, #40]	; 0x28
 8002b32:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 8002b36:	d107      	bne.n	8002b48 <SPI_WaitFifoStateUntilTimeout.part.1+0x40>
        {
          SPI_RESET_CRC(hspi);
 8002b38:	681a      	ldr	r2, [r3, #0]
 8002b3a:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8002b3e:	601a      	str	r2, [r3, #0]
 8002b40:	681a      	ldr	r2, [r3, #0]
 8002b42:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8002b46:	601a      	str	r2, [r3, #0]
        }

        hspi->State = HAL_SPI_STATE_READY;
 8002b48:	2301      	movs	r3, #1
 8002b4a:	f880 305d 	strb.w	r3, [r0, #93]	; 0x5d

        /* Process Unlocked */
        __HAL_UNLOCK(hspi);
 8002b4e:	2300      	movs	r3, #0
 8002b50:	f880 305c 	strb.w	r3, [r0, #92]	; 0x5c
      }
    }
  }

  return HAL_OK;
}
 8002b54:	2003      	movs	r0, #3
 8002b56:	4770      	bx	lr

08002b58 <SPI_WaitFlagStateUntilTimeout.constprop.10>:
static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus State,
 8002b58:	b570      	push	{r4, r5, r6, lr}
 8002b5a:	4604      	mov	r4, r0
 8002b5c:	460d      	mov	r5, r1
 8002b5e:	4616      	mov	r6, r2
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8002b60:	6823      	ldr	r3, [r4, #0]
 8002b62:	6898      	ldr	r0, [r3, #8]
 8002b64:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8002b68:	d100      	bne.n	8002b6c <SPI_WaitFlagStateUntilTimeout.constprop.10+0x14>
}
 8002b6a:	bd70      	pop	{r4, r5, r6, pc}
    if (Timeout != HAL_MAX_DELAY)
 8002b6c:	1c6a      	adds	r2, r5, #1
 8002b6e:	d0f8      	beq.n	8002b62 <SPI_WaitFlagStateUntilTimeout.constprop.10+0xa>
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 8002b70:	f7fe fa2e 	bl	8000fd0 <HAL_GetTick>
 8002b74:	1b80      	subs	r0, r0, r6
 8002b76:	4285      	cmp	r5, r0
 8002b78:	d8f2      	bhi.n	8002b60 <SPI_WaitFlagStateUntilTimeout.constprop.10+0x8>
 8002b7a:	4620      	mov	r0, r4
}
 8002b7c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8002b80:	f7ff bfc2 	b.w	8002b08 <SPI_WaitFifoStateUntilTimeout.part.1>

08002b84 <SPI_WaitFifoStateUntilTimeout.constprop.11>:
static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State,
 8002b84:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002b86:	4605      	mov	r5, r0
 8002b88:	460c      	mov	r4, r1
 8002b8a:	4616      	mov	r6, r2
 8002b8c:	461f      	mov	r7, r3
  while ((hspi->Instance->SR & Fifo) != State)
 8002b8e:	6829      	ldr	r1, [r5, #0]
 8002b90:	6888      	ldr	r0, [r1, #8]
 8002b92:	4020      	ands	r0, r4
 8002b94:	d100      	bne.n	8002b98 <SPI_WaitFifoStateUntilTimeout.constprop.11+0x14>
}
 8002b96:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if ((Fifo == SPI_SR_FRLVL) && (State == SPI_FRLVL_EMPTY))
 8002b98:	f5b4 6fc0 	cmp.w	r4, #1536	; 0x600
      READ_REG(*((__IO uint8_t *)&hspi->Instance->DR));
 8002b9c:	bf08      	it	eq
 8002b9e:	7b0b      	ldrbeq	r3, [r1, #12]
    if (Timeout != HAL_MAX_DELAY)
 8002ba0:	1c73      	adds	r3, r6, #1
 8002ba2:	d0f5      	beq.n	8002b90 <SPI_WaitFifoStateUntilTimeout.constprop.11+0xc>
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 8002ba4:	f7fe fa14 	bl	8000fd0 <HAL_GetTick>
 8002ba8:	1bc0      	subs	r0, r0, r7
 8002baa:	4286      	cmp	r6, r0
 8002bac:	d8ef      	bhi.n	8002b8e <SPI_WaitFifoStateUntilTimeout.constprop.11+0xa>
 8002bae:	4628      	mov	r0, r5
}
 8002bb0:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 8002bb4:	f7ff bfa8 	b.w	8002b08 <SPI_WaitFifoStateUntilTimeout.part.1>

08002bb8 <SPI_EndRxTxTransaction>:
  * @param  Timeout Timeout duration
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
{
 8002bb8:	b570      	push	{r4, r5, r6, lr}
  /* Control if the TX fifo is empty */
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8002bba:	4613      	mov	r3, r2
{
 8002bbc:	460d      	mov	r5, r1
 8002bbe:	4616      	mov	r6, r2
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8002bc0:	460a      	mov	r2, r1
 8002bc2:	f44f 51c0 	mov.w	r1, #6144	; 0x1800
{
 8002bc6:	4604      	mov	r4, r0
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8002bc8:	f7ff ffdc 	bl	8002b84 <SPI_WaitFifoStateUntilTimeout.constprop.11>
 8002bcc:	b128      	cbz	r0, 8002bda <SPI_EndRxTxTransaction+0x22>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8002bce:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8002bd0:	f043 0320 	orr.w	r3, r3, #32
 8002bd4:	6623      	str	r3, [r4, #96]	; 0x60
      return HAL_TIMEOUT;
 8002bd6:	2003      	movs	r0, #3
 8002bd8:	e00f      	b.n	8002bfa <SPI_EndRxTxTransaction+0x42>
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
    return HAL_TIMEOUT;
  }

  /* Control the BSY flag */
  if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 8002bda:	4632      	mov	r2, r6
 8002bdc:	4629      	mov	r1, r5
 8002bde:	4620      	mov	r0, r4
 8002be0:	f7ff ffba 	bl	8002b58 <SPI_WaitFlagStateUntilTimeout.constprop.10>
 8002be4:	2800      	cmp	r0, #0
 8002be6:	d1f2      	bne.n	8002bce <SPI_EndRxTxTransaction+0x16>
    if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8002be8:	4633      	mov	r3, r6
 8002bea:	462a      	mov	r2, r5
 8002bec:	f44f 61c0 	mov.w	r1, #1536	; 0x600
 8002bf0:	4620      	mov	r0, r4
 8002bf2:	f7ff ffc7 	bl	8002b84 <SPI_WaitFifoStateUntilTimeout.constprop.11>
 8002bf6:	2800      	cmp	r0, #0
 8002bf8:	d1e9      	bne.n	8002bce <SPI_EndRxTxTransaction+0x16>
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
    return HAL_TIMEOUT;
  }

  return HAL_OK;
}
 8002bfa:	bd70      	pop	{r4, r5, r6, pc}

08002bfc <SPI_EndRxTransaction>:
{
 8002bfc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8002bfe:	6843      	ldr	r3, [r0, #4]
 8002c00:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
{
 8002c04:	4604      	mov	r4, r0
 8002c06:	460e      	mov	r6, r1
 8002c08:	4617      	mov	r7, r2
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8002c0a:	d10b      	bne.n	8002c24 <SPI_EndRxTransaction+0x28>
 8002c0c:	6883      	ldr	r3, [r0, #8]
 8002c0e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8002c12:	d002      	beq.n	8002c1a <SPI_EndRxTransaction+0x1e>
                                               || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 8002c14:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8002c18:	d104      	bne.n	8002c24 <SPI_EndRxTransaction+0x28>
    __HAL_SPI_DISABLE(hspi);
 8002c1a:	6823      	ldr	r3, [r4, #0]
 8002c1c:	681a      	ldr	r2, [r3, #0]
 8002c1e:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8002c22:	601a      	str	r2, [r3, #0]
  if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 8002c24:	463a      	mov	r2, r7
 8002c26:	4631      	mov	r1, r6
 8002c28:	4620      	mov	r0, r4
 8002c2a:	f7ff ff95 	bl	8002b58 <SPI_WaitFlagStateUntilTimeout.constprop.10>
 8002c2e:	4605      	mov	r5, r0
 8002c30:	b128      	cbz	r0, 8002c3e <SPI_EndRxTransaction+0x42>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8002c32:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8002c34:	f043 0320 	orr.w	r3, r3, #32
 8002c38:	6623      	str	r3, [r4, #96]	; 0x60
      return HAL_TIMEOUT;
 8002c3a:	2503      	movs	r5, #3
 8002c3c:	e013      	b.n	8002c66 <SPI_EndRxTransaction+0x6a>
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8002c3e:	6863      	ldr	r3, [r4, #4]
 8002c40:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 8002c44:	d10f      	bne.n	8002c66 <SPI_EndRxTransaction+0x6a>
 8002c46:	68a3      	ldr	r3, [r4, #8]
 8002c48:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8002c4c:	d002      	beq.n	8002c54 <SPI_EndRxTransaction+0x58>
                                               || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 8002c4e:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8002c52:	d108      	bne.n	8002c66 <SPI_EndRxTransaction+0x6a>
    if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8002c54:	463b      	mov	r3, r7
 8002c56:	4632      	mov	r2, r6
 8002c58:	f44f 61c0 	mov.w	r1, #1536	; 0x600
 8002c5c:	4620      	mov	r0, r4
 8002c5e:	f7ff ff91 	bl	8002b84 <SPI_WaitFifoStateUntilTimeout.constprop.11>
 8002c62:	2800      	cmp	r0, #0
 8002c64:	d1e5      	bne.n	8002c32 <SPI_EndRxTransaction+0x36>
}
 8002c66:	4628      	mov	r0, r5
 8002c68:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08002c6a <HAL_SPI_Init>:
{
 8002c6a:	b570      	push	{r4, r5, r6, lr}
  if (hspi == NULL)
 8002c6c:	4604      	mov	r4, r0
 8002c6e:	2800      	cmp	r0, #0
 8002c70:	d04a      	beq.n	8002d08 <HAL_SPI_Init+0x9e>
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8002c72:	2300      	movs	r3, #0
 8002c74:	6283      	str	r3, [r0, #40]	; 0x28
  if (hspi->State == HAL_SPI_STATE_RESET)
 8002c76:	f890 305d 	ldrb.w	r3, [r0, #93]	; 0x5d
 8002c7a:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8002c7e:	b91b      	cbnz	r3, 8002c88 <HAL_SPI_Init+0x1e>
    hspi->Lock = HAL_UNLOCKED;
 8002c80:	f880 205c 	strb.w	r2, [r0, #92]	; 0x5c
    HAL_SPI_MspInit(hspi);
 8002c84:	f004 fb8a 	bl	800739c <HAL_SPI_MspInit>
  hspi->State = HAL_SPI_STATE_BUSY;
 8002c88:	2302      	movs	r3, #2
  __HAL_SPI_DISABLE(hspi);
 8002c8a:	6821      	ldr	r1, [r4, #0]
  hspi->State = HAL_SPI_STATE_BUSY;
 8002c8c:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
  __HAL_SPI_DISABLE(hspi);
 8002c90:	680b      	ldr	r3, [r1, #0]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8002c92:	68e2      	ldr	r2, [r4, #12]
  __HAL_SPI_DISABLE(hspi);
 8002c94:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8002c98:	f5b2 6fe0 	cmp.w	r2, #1792	; 0x700
  __HAL_SPI_DISABLE(hspi);
 8002c9c:	600b      	str	r3, [r1, #0]
 8002c9e:	f04f 0300 	mov.w	r3, #0
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8002ca2:	d92e      	bls.n	8002d02 <HAL_SPI_Init+0x98>
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 8002ca4:	4618      	mov	r0, r3
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 8002ca6:	f5b2 6f70 	cmp.w	r2, #3840	; 0xf00
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8002caa:	bf18      	it	ne
 8002cac:	62a3      	strne	r3, [r4, #40]	; 0x28
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 8002cae:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002cb0:	b92b      	cbnz	r3, 8002cbe <HAL_SPI_Init+0x54>
    if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8002cb2:	f5b2 6fe0 	cmp.w	r2, #1792	; 0x700
      hspi->Init.CRCLength = SPI_CRC_LENGTH_16BIT;
 8002cb6:	bf8c      	ite	hi
 8002cb8:	2302      	movhi	r3, #2
      hspi->Init.CRCLength = SPI_CRC_LENGTH_8BIT;
 8002cba:	2301      	movls	r3, #1
 8002cbc:	6323      	str	r3, [r4, #48]	; 0x30
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 8002cbe:	68a6      	ldr	r6, [r4, #8]
 8002cc0:	6863      	ldr	r3, [r4, #4]
 8002cc2:	69a5      	ldr	r5, [r4, #24]
 8002cc4:	4333      	orrs	r3, r6
 8002cc6:	6926      	ldr	r6, [r4, #16]
 8002cc8:	4333      	orrs	r3, r6
 8002cca:	6966      	ldr	r6, [r4, #20]
 8002ccc:	4333      	orrs	r3, r6
 8002cce:	69e6      	ldr	r6, [r4, #28]
 8002cd0:	4333      	orrs	r3, r6
 8002cd2:	6a26      	ldr	r6, [r4, #32]
 8002cd4:	4333      	orrs	r3, r6
 8002cd6:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 8002cd8:	4333      	orrs	r3, r6
 8002cda:	f405 7600 	and.w	r6, r5, #512	; 0x200
 8002cde:	4333      	orrs	r3, r6
 8002ce0:	600b      	str	r3, [r1, #0]
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 8002ce2:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8002ce4:	431a      	orrs	r2, r3
 8002ce6:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8002ce8:	0c2d      	lsrs	r5, r5, #16
 8002cea:	431a      	orrs	r2, r3
 8002cec:	f005 0504 	and.w	r5, r5, #4
 8002cf0:	432a      	orrs	r2, r5
 8002cf2:	4302      	orrs	r2, r0
  hspi->State     = HAL_SPI_STATE_READY;
 8002cf4:	2301      	movs	r3, #1
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8002cf6:	2000      	movs	r0, #0
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 8002cf8:	604a      	str	r2, [r1, #4]
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8002cfa:	6620      	str	r0, [r4, #96]	; 0x60
  hspi->State     = HAL_SPI_STATE_READY;
 8002cfc:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
  return HAL_OK;
 8002d00:	bd70      	pop	{r4, r5, r6, pc}
    frxth = SPI_RXFIFO_THRESHOLD_QF;
 8002d02:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8002d06:	e7d0      	b.n	8002caa <HAL_SPI_Init+0x40>
    return HAL_ERROR;
 8002d08:	2001      	movs	r0, #1
}
 8002d0a:	bd70      	pop	{r4, r5, r6, pc}

08002d0c <HAL_SPI_Transmit>:
{
 8002d0c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 8002d10:	461e      	mov	r6, r3
  __HAL_LOCK(hspi);
 8002d12:	f890 305c 	ldrb.w	r3, [r0, #92]	; 0x5c
 8002d16:	2b01      	cmp	r3, #1
{
 8002d18:	4604      	mov	r4, r0
 8002d1a:	460d      	mov	r5, r1
 8002d1c:	4690      	mov	r8, r2
  __HAL_LOCK(hspi);
 8002d1e:	f000 80b1 	beq.w	8002e84 <HAL_SPI_Transmit+0x178>
 8002d22:	2301      	movs	r3, #1
 8002d24:	f880 305c 	strb.w	r3, [r0, #92]	; 0x5c
  tickstart = HAL_GetTick();
 8002d28:	f7fe f952 	bl	8000fd0 <HAL_GetTick>
 8002d2c:	4607      	mov	r7, r0
  if (hspi->State != HAL_SPI_STATE_READY)
 8002d2e:	f894 005d 	ldrb.w	r0, [r4, #93]	; 0x5d
 8002d32:	b2c0      	uxtb	r0, r0
 8002d34:	2801      	cmp	r0, #1
 8002d36:	f040 80a3 	bne.w	8002e80 <HAL_SPI_Transmit+0x174>
  if ((pData == NULL) || (Size == 0U))
 8002d3a:	2d00      	cmp	r5, #0
 8002d3c:	d05f      	beq.n	8002dfe <HAL_SPI_Transmit+0xf2>
 8002d3e:	f1b8 0f00 	cmp.w	r8, #0
 8002d42:	d05c      	beq.n	8002dfe <HAL_SPI_Transmit+0xf2>
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 8002d44:	2303      	movs	r3, #3
 8002d46:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8002d4a:	2000      	movs	r0, #0
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8002d4c:	68a3      	ldr	r3, [r4, #8]
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8002d4e:	6620      	str	r0, [r4, #96]	; 0x60
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
 8002d50:	6420      	str	r0, [r4, #64]	; 0x40
  hspi->TxXferCount = Size;
 8002d52:	f8a4 803e 	strh.w	r8, [r4, #62]	; 0x3e
  hspi->RxXferSize  = 0U;
 8002d56:	f8a4 0044 	strh.w	r0, [r4, #68]	; 0x44
  hspi->RxXferCount = 0U;
 8002d5a:	f8a4 0046 	strh.w	r0, [r4, #70]	; 0x46
  hspi->TxISR       = NULL;
 8002d5e:	6520      	str	r0, [r4, #80]	; 0x50
  hspi->RxISR       = NULL;
 8002d60:	64e0      	str	r0, [r4, #76]	; 0x4c
 8002d62:	6820      	ldr	r0, [r4, #0]
  hspi->pTxBuffPtr  = (uint8_t *)pData;
 8002d64:	63a5      	str	r5, [r4, #56]	; 0x38
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8002d66:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    SPI_1LINE_TX(hspi);
 8002d6a:	bf08      	it	eq
 8002d6c:	6803      	ldreq	r3, [r0, #0]
  hspi->TxXferSize  = Size;
 8002d6e:	f8a4 803c 	strh.w	r8, [r4, #60]	; 0x3c
    SPI_1LINE_TX(hspi);
 8002d72:	bf04      	itt	eq
 8002d74:	f443 4380 	orreq.w	r3, r3, #16384	; 0x4000
 8002d78:	6003      	streq	r3, [r0, #0]
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8002d7a:	6803      	ldr	r3, [r0, #0]
 8002d7c:	065b      	lsls	r3, r3, #25
    __HAL_SPI_ENABLE(hspi);
 8002d7e:	bf5e      	ittt	pl
 8002d80:	6803      	ldrpl	r3, [r0, #0]
 8002d82:	f043 0340 	orrpl.w	r3, r3, #64	; 0x40
 8002d86:	6003      	strpl	r3, [r0, #0]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8002d88:	68e3      	ldr	r3, [r4, #12]
 8002d8a:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 8002d8e:	6863      	ldr	r3, [r4, #4]
 8002d90:	d93e      	bls.n	8002e10 <HAL_SPI_Transmit+0x104>
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 8002d92:	b113      	cbz	r3, 8002d9a <HAL_SPI_Transmit+0x8e>
 8002d94:	f1b8 0f01 	cmp.w	r8, #1
 8002d98:	d107      	bne.n	8002daa <HAL_SPI_Transmit+0x9e>
      hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8002d9a:	f835 3b02 	ldrh.w	r3, [r5], #2
 8002d9e:	60c3      	str	r3, [r0, #12]
      hspi->pTxBuffPtr += sizeof(uint16_t);
 8002da0:	63a5      	str	r5, [r4, #56]	; 0x38
        hspi->TxXferCount--;
 8002da2:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8002da4:	3b01      	subs	r3, #1
 8002da6:	b29b      	uxth	r3, r3
 8002da8:	87e3      	strh	r3, [r4, #62]	; 0x3e
    while (hspi->TxXferCount > 0U)
 8002daa:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8002dac:	b29b      	uxth	r3, r3
 8002dae:	b9a3      	cbnz	r3, 8002dda <HAL_SPI_Transmit+0xce>
  if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 8002db0:	463a      	mov	r2, r7
 8002db2:	4631      	mov	r1, r6
 8002db4:	4620      	mov	r0, r4
 8002db6:	f7ff feff 	bl	8002bb8 <SPI_EndRxTxTransaction>
 8002dba:	2800      	cmp	r0, #0
 8002dbc:	d15d      	bne.n	8002e7a <HAL_SPI_Transmit+0x16e>
  if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 8002dbe:	68a3      	ldr	r3, [r4, #8]
 8002dc0:	b933      	cbnz	r3, 8002dd0 <HAL_SPI_Transmit+0xc4>
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
 8002dc2:	9301      	str	r3, [sp, #4]
 8002dc4:	6823      	ldr	r3, [r4, #0]
 8002dc6:	68da      	ldr	r2, [r3, #12]
 8002dc8:	9201      	str	r2, [sp, #4]
 8002dca:	689b      	ldr	r3, [r3, #8]
 8002dcc:	9301      	str	r3, [sp, #4]
 8002dce:	9b01      	ldr	r3, [sp, #4]
  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8002dd0:	6e20      	ldr	r0, [r4, #96]	; 0x60
    errorcode = HAL_BUSY;
 8002dd2:	3000      	adds	r0, #0
 8002dd4:	bf18      	it	ne
 8002dd6:	2001      	movne	r0, #1
 8002dd8:	e011      	b.n	8002dfe <HAL_SPI_Transmit+0xf2>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 8002dda:	6822      	ldr	r2, [r4, #0]
 8002ddc:	6893      	ldr	r3, [r2, #8]
 8002dde:	0798      	lsls	r0, r3, #30
 8002de0:	d505      	bpl.n	8002dee <HAL_SPI_Transmit+0xe2>
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8002de2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002de4:	f833 1b02 	ldrh.w	r1, [r3], #2
 8002de8:	60d1      	str	r1, [r2, #12]
        hspi->pTxBuffPtr += sizeof(uint16_t);
 8002dea:	63a3      	str	r3, [r4, #56]	; 0x38
 8002dec:	e7d9      	b.n	8002da2 <HAL_SPI_Transmit+0x96>
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8002dee:	f7fe f8ef 	bl	8000fd0 <HAL_GetTick>
 8002df2:	1bc0      	subs	r0, r0, r7
 8002df4:	42b0      	cmp	r0, r6
 8002df6:	d3d8      	bcc.n	8002daa <HAL_SPI_Transmit+0x9e>
 8002df8:	1c71      	adds	r1, r6, #1
 8002dfa:	d0d6      	beq.n	8002daa <HAL_SPI_Transmit+0x9e>
          errorcode = HAL_TIMEOUT;
 8002dfc:	2003      	movs	r0, #3
  hspi->State = HAL_SPI_STATE_READY;
 8002dfe:	2301      	movs	r3, #1
 8002e00:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
  __HAL_UNLOCK(hspi);
 8002e04:	2300      	movs	r3, #0
 8002e06:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
}
 8002e0a:	b002      	add	sp, #8
 8002e0c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 8002e10:	b113      	cbz	r3, 8002e18 <HAL_SPI_Transmit+0x10c>
 8002e12:	f1b8 0f01 	cmp.w	r8, #1
 8002e16:	d113      	bne.n	8002e40 <HAL_SPI_Transmit+0x134>
      if (hspi->TxXferCount > 1U)
 8002e18:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8002e1a:	b29b      	uxth	r3, r3
 8002e1c:	2b01      	cmp	r3, #1
 8002e1e:	d906      	bls.n	8002e2e <HAL_SPI_Transmit+0x122>
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8002e20:	f835 3b02 	ldrh.w	r3, [r5], #2
 8002e24:	60c3      	str	r3, [r0, #12]
        hspi->pTxBuffPtr += sizeof(uint16_t);
 8002e26:	63a5      	str	r5, [r4, #56]	; 0x38
          hspi->TxXferCount -= 2U;
 8002e28:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8002e2a:	3b02      	subs	r3, #2
 8002e2c:	e006      	b.n	8002e3c <HAL_SPI_Transmit+0x130>
        *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 8002e2e:	782b      	ldrb	r3, [r5, #0]
 8002e30:	7303      	strb	r3, [r0, #12]
        hspi->pTxBuffPtr ++;
 8002e32:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002e34:	3301      	adds	r3, #1
 8002e36:	63a3      	str	r3, [r4, #56]	; 0x38
        hspi->TxXferCount--;
 8002e38:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8002e3a:	3b01      	subs	r3, #1
 8002e3c:	b29b      	uxth	r3, r3
 8002e3e:	87e3      	strh	r3, [r4, #62]	; 0x3e
    while (hspi->TxXferCount > 0U)
 8002e40:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8002e42:	b29b      	uxth	r3, r3
 8002e44:	2b00      	cmp	r3, #0
 8002e46:	d0b3      	beq.n	8002db0 <HAL_SPI_Transmit+0xa4>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 8002e48:	6823      	ldr	r3, [r4, #0]
 8002e4a:	689a      	ldr	r2, [r3, #8]
 8002e4c:	0792      	lsls	r2, r2, #30
 8002e4e:	d50c      	bpl.n	8002e6a <HAL_SPI_Transmit+0x15e>
        if (hspi->TxXferCount > 1U)
 8002e50:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 8002e52:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8002e54:	b292      	uxth	r2, r2
 8002e56:	2a01      	cmp	r2, #1
 8002e58:	d904      	bls.n	8002e64 <HAL_SPI_Transmit+0x158>
          hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8002e5a:	f830 2b02 	ldrh.w	r2, [r0], #2
 8002e5e:	60da      	str	r2, [r3, #12]
          hspi->pTxBuffPtr += sizeof(uint16_t);
 8002e60:	63a0      	str	r0, [r4, #56]	; 0x38
 8002e62:	e7e1      	b.n	8002e28 <HAL_SPI_Transmit+0x11c>
          *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 8002e64:	7802      	ldrb	r2, [r0, #0]
 8002e66:	731a      	strb	r2, [r3, #12]
 8002e68:	e7e3      	b.n	8002e32 <HAL_SPI_Transmit+0x126>
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8002e6a:	f7fe f8b1 	bl	8000fd0 <HAL_GetTick>
 8002e6e:	1bc0      	subs	r0, r0, r7
 8002e70:	4286      	cmp	r6, r0
 8002e72:	d8e5      	bhi.n	8002e40 <HAL_SPI_Transmit+0x134>
 8002e74:	1c73      	adds	r3, r6, #1
 8002e76:	d0e3      	beq.n	8002e40 <HAL_SPI_Transmit+0x134>
 8002e78:	e7c0      	b.n	8002dfc <HAL_SPI_Transmit+0xf0>
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 8002e7a:	2320      	movs	r3, #32
 8002e7c:	6623      	str	r3, [r4, #96]	; 0x60
 8002e7e:	e79e      	b.n	8002dbe <HAL_SPI_Transmit+0xb2>
    errorcode = HAL_BUSY;
 8002e80:	2002      	movs	r0, #2
 8002e82:	e7bc      	b.n	8002dfe <HAL_SPI_Transmit+0xf2>
  __HAL_LOCK(hspi);
 8002e84:	2002      	movs	r0, #2
 8002e86:	e7c0      	b.n	8002e0a <HAL_SPI_Transmit+0xfe>

08002e88 <HAL_SPI_TransmitReceive>:
{
 8002e88:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8002e8c:	461e      	mov	r6, r3
  __HAL_LOCK(hspi);
 8002e8e:	f890 305c 	ldrb.w	r3, [r0, #92]	; 0x5c
{
 8002e92:	9f08      	ldr	r7, [sp, #32]
  __HAL_LOCK(hspi);
 8002e94:	2b01      	cmp	r3, #1
{
 8002e96:	4604      	mov	r4, r0
 8002e98:	460d      	mov	r5, r1
 8002e9a:	4691      	mov	r9, r2
  __HAL_LOCK(hspi);
 8002e9c:	f000 8115 	beq.w	80030ca <HAL_SPI_TransmitReceive+0x242>
 8002ea0:	2301      	movs	r3, #1
 8002ea2:	f880 305c 	strb.w	r3, [r0, #92]	; 0x5c
  tickstart = HAL_GetTick();
 8002ea6:	f7fe f893 	bl	8000fd0 <HAL_GetTick>
  tmp_state           = hspi->State;
 8002eaa:	f894 305d 	ldrb.w	r3, [r4, #93]	; 0x5d
  tmp_mode            = hspi->Init.Mode;
 8002eae:	6861      	ldr	r1, [r4, #4]
  tmp_state           = hspi->State;
 8002eb0:	b2db      	uxtb	r3, r3
  if (!((tmp_state == HAL_SPI_STATE_READY) || \
 8002eb2:	2b01      	cmp	r3, #1
  tickstart = HAL_GetTick();
 8002eb4:	4680      	mov	r8, r0
  if (!((tmp_state == HAL_SPI_STATE_READY) || \
 8002eb6:	d00a      	beq.n	8002ece <HAL_SPI_TransmitReceive+0x46>
 8002eb8:	f5b1 7f82 	cmp.w	r1, #260	; 0x104
 8002ebc:	f040 8103 	bne.w	80030c6 <HAL_SPI_TransmitReceive+0x23e>
        ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
 8002ec0:	68a0      	ldr	r0, [r4, #8]
 8002ec2:	2800      	cmp	r0, #0
 8002ec4:	f040 80ff 	bne.w	80030c6 <HAL_SPI_TransmitReceive+0x23e>
 8002ec8:	2b04      	cmp	r3, #4
 8002eca:	f040 80fc 	bne.w	80030c6 <HAL_SPI_TransmitReceive+0x23e>
  if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
 8002ece:	2d00      	cmp	r5, #0
 8002ed0:	d049      	beq.n	8002f66 <HAL_SPI_TransmitReceive+0xde>
 8002ed2:	f1b9 0f00 	cmp.w	r9, #0
 8002ed6:	d046      	beq.n	8002f66 <HAL_SPI_TransmitReceive+0xde>
 8002ed8:	2e00      	cmp	r6, #0
 8002eda:	d044      	beq.n	8002f66 <HAL_SPI_TransmitReceive+0xde>
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 8002edc:	f894 305d 	ldrb.w	r3, [r4, #93]	; 0x5d
  if ((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || (initial_RxXferCount > 1U))
 8002ee0:	68e2      	ldr	r2, [r4, #12]
 8002ee2:	6820      	ldr	r0, [r4, #0]
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 8002ee4:	f8c4 9040 	str.w	r9, [r4, #64]	; 0x40
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 8002ee8:	2b04      	cmp	r3, #4
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 8002eea:	bf1c      	itt	ne
 8002eec:	2305      	movne	r3, #5
 8002eee:	f884 305d 	strbne.w	r3, [r4, #93]	; 0x5d
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8002ef2:	2300      	movs	r3, #0
 8002ef4:	6623      	str	r3, [r4, #96]	; 0x60
  if ((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || (initial_RxXferCount > 1U))
 8002ef6:	f5b2 6fe0 	cmp.w	r2, #1792	; 0x700
  hspi->RxXferCount = Size;
 8002efa:	f8a4 6046 	strh.w	r6, [r4, #70]	; 0x46
  hspi->TxXferCount = Size;
 8002efe:	87e6      	strh	r6, [r4, #62]	; 0x3e
  hspi->RxISR       = NULL;
 8002f00:	64e3      	str	r3, [r4, #76]	; 0x4c
  hspi->TxISR       = NULL;
 8002f02:	6523      	str	r3, [r4, #80]	; 0x50
  hspi->RxXferSize  = Size;
 8002f04:	f8a4 6044 	strh.w	r6, [r4, #68]	; 0x44
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
 8002f08:	63a5      	str	r5, [r4, #56]	; 0x38
  hspi->TxXferSize  = Size;
 8002f0a:	87a6      	strh	r6, [r4, #60]	; 0x3c
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8002f0c:	6843      	ldr	r3, [r0, #4]
  if ((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || (initial_RxXferCount > 1U))
 8002f0e:	d801      	bhi.n	8002f14 <HAL_SPI_TransmitReceive+0x8c>
 8002f10:	2e01      	cmp	r6, #1
 8002f12:	d92a      	bls.n	8002f6a <HAL_SPI_TransmitReceive+0xe2>
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8002f14:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8002f18:	6043      	str	r3, [r0, #4]
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8002f1a:	6803      	ldr	r3, [r0, #0]
 8002f1c:	065b      	lsls	r3, r3, #25
    __HAL_SPI_ENABLE(hspi);
 8002f1e:	bf5e      	ittt	pl
 8002f20:	6803      	ldrpl	r3, [r0, #0]
 8002f22:	f043 0340 	orrpl.w	r3, r3, #64	; 0x40
 8002f26:	6003      	strpl	r3, [r0, #0]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8002f28:	f5b2 6fe0 	cmp.w	r2, #1792	; 0x700
 8002f2c:	d956      	bls.n	8002fdc <HAL_SPI_TransmitReceive+0x154>
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 8002f2e:	b109      	cbz	r1, 8002f34 <HAL_SPI_TransmitReceive+0xac>
 8002f30:	2e01      	cmp	r6, #1
 8002f32:	d107      	bne.n	8002f44 <HAL_SPI_TransmitReceive+0xbc>
      hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8002f34:	f835 3b02 	ldrh.w	r3, [r5], #2
 8002f38:	60c3      	str	r3, [r0, #12]
      hspi->TxXferCount--;
 8002f3a:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
      hspi->pTxBuffPtr += sizeof(uint16_t);
 8002f3c:	63a5      	str	r5, [r4, #56]	; 0x38
      hspi->TxXferCount--;
 8002f3e:	3b01      	subs	r3, #1
 8002f40:	b29b      	uxth	r3, r3
 8002f42:	87e3      	strh	r3, [r4, #62]	; 0x3e
        txallowed = 1U;
 8002f44:	2501      	movs	r5, #1
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 8002f46:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8002f48:	b29b      	uxth	r3, r3
 8002f4a:	b98b      	cbnz	r3, 8002f70 <HAL_SPI_TransmitReceive+0xe8>
 8002f4c:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 8002f50:	b29b      	uxth	r3, r3
 8002f52:	b96b      	cbnz	r3, 8002f70 <HAL_SPI_TransmitReceive+0xe8>
  if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 8002f54:	4642      	mov	r2, r8
 8002f56:	4639      	mov	r1, r7
 8002f58:	4620      	mov	r0, r4
 8002f5a:	f7ff fe2d 	bl	8002bb8 <SPI_EndRxTxTransaction>
 8002f5e:	2800      	cmp	r0, #0
 8002f60:	d034      	beq.n	8002fcc <HAL_SPI_TransmitReceive+0x144>
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 8002f62:	2320      	movs	r3, #32
 8002f64:	6623      	str	r3, [r4, #96]	; 0x60
    errorcode = HAL_ERROR;
 8002f66:	2001      	movs	r0, #1
 8002f68:	e030      	b.n	8002fcc <HAL_SPI_TransmitReceive+0x144>
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8002f6a:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8002f6e:	e7d3      	b.n	8002f18 <HAL_SPI_TransmitReceive+0x90>
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
 8002f70:	6822      	ldr	r2, [r4, #0]
 8002f72:	6893      	ldr	r3, [r2, #8]
 8002f74:	0799      	lsls	r1, r3, #30
 8002f76:	d50d      	bpl.n	8002f94 <HAL_SPI_TransmitReceive+0x10c>
 8002f78:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8002f7a:	b29b      	uxth	r3, r3
 8002f7c:	b153      	cbz	r3, 8002f94 <HAL_SPI_TransmitReceive+0x10c>
 8002f7e:	b14d      	cbz	r5, 8002f94 <HAL_SPI_TransmitReceive+0x10c>
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8002f80:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002f82:	f833 1b02 	ldrh.w	r1, [r3], #2
 8002f86:	60d1      	str	r1, [r2, #12]
        hspi->pTxBuffPtr += sizeof(uint16_t);
 8002f88:	63a3      	str	r3, [r4, #56]	; 0x38
        hspi->TxXferCount--;
 8002f8a:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8002f8c:	3b01      	subs	r3, #1
 8002f8e:	b29b      	uxth	r3, r3
 8002f90:	87e3      	strh	r3, [r4, #62]	; 0x3e
        txallowed = 0U;
 8002f92:	2500      	movs	r5, #0
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
 8002f94:	6893      	ldr	r3, [r2, #8]
 8002f96:	07db      	lsls	r3, r3, #31
 8002f98:	d50f      	bpl.n	8002fba <HAL_SPI_TransmitReceive+0x132>
 8002f9a:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 8002f9e:	b29b      	uxth	r3, r3
 8002fa0:	b15b      	cbz	r3, 8002fba <HAL_SPI_TransmitReceive+0x132>
        *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
 8002fa2:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8002fa4:	68d2      	ldr	r2, [r2, #12]
 8002fa6:	f823 2b02 	strh.w	r2, [r3], #2
        hspi->pRxBuffPtr += sizeof(uint16_t);
 8002faa:	6423      	str	r3, [r4, #64]	; 0x40
        hspi->RxXferCount--;
 8002fac:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 8002fb0:	3b01      	subs	r3, #1
 8002fb2:	b29b      	uxth	r3, r3
 8002fb4:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
        txallowed = 1U;
 8002fb8:	2501      	movs	r5, #1
      if (((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY))
 8002fba:	f7fe f809 	bl	8000fd0 <HAL_GetTick>
 8002fbe:	eba0 0008 	sub.w	r0, r0, r8
 8002fc2:	4287      	cmp	r7, r0
 8002fc4:	d8bf      	bhi.n	8002f46 <HAL_SPI_TransmitReceive+0xbe>
 8002fc6:	1c7e      	adds	r6, r7, #1
 8002fc8:	d0bd      	beq.n	8002f46 <HAL_SPI_TransmitReceive+0xbe>
        errorcode = HAL_TIMEOUT;
 8002fca:	2003      	movs	r0, #3
  hspi->State = HAL_SPI_STATE_READY;
 8002fcc:	2301      	movs	r3, #1
 8002fce:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
  __HAL_UNLOCK(hspi);
 8002fd2:	2300      	movs	r3, #0
 8002fd4:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
 8002fd8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 8002fdc:	b109      	cbz	r1, 8002fe2 <HAL_SPI_TransmitReceive+0x15a>
 8002fde:	2e01      	cmp	r6, #1
 8002fe0:	d10b      	bne.n	8002ffa <HAL_SPI_TransmitReceive+0x172>
      if (hspi->TxXferCount > 1U)
 8002fe2:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8002fe4:	b29b      	uxth	r3, r3
 8002fe6:	2b01      	cmp	r3, #1
 8002fe8:	d951      	bls.n	800308e <HAL_SPI_TransmitReceive+0x206>
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8002fea:	f835 3b02 	ldrh.w	r3, [r5], #2
 8002fee:	60c3      	str	r3, [r0, #12]
        hspi->TxXferCount -= 2U;
 8002ff0:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
        hspi->pTxBuffPtr += sizeof(uint16_t);
 8002ff2:	63a5      	str	r5, [r4, #56]	; 0x38
        hspi->TxXferCount -= 2U;
 8002ff4:	3b02      	subs	r3, #2
        hspi->TxXferCount--;
 8002ff6:	b29b      	uxth	r3, r3
 8002ff8:	87e3      	strh	r3, [r4, #62]	; 0x3e
        txallowed = 1U;
 8002ffa:	2501      	movs	r5, #1
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 8002ffc:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8002ffe:	b29b      	uxth	r3, r3
 8003000:	b923      	cbnz	r3, 800300c <HAL_SPI_TransmitReceive+0x184>
 8003002:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 8003006:	b29b      	uxth	r3, r3
 8003008:	2b00      	cmp	r3, #0
 800300a:	d0a3      	beq.n	8002f54 <HAL_SPI_TransmitReceive+0xcc>
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
 800300c:	6822      	ldr	r2, [r4, #0]
 800300e:	6893      	ldr	r3, [r2, #8]
 8003010:	0798      	lsls	r0, r3, #30
 8003012:	d511      	bpl.n	8003038 <HAL_SPI_TransmitReceive+0x1b0>
 8003014:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8003016:	b29b      	uxth	r3, r3
 8003018:	b173      	cbz	r3, 8003038 <HAL_SPI_TransmitReceive+0x1b0>
 800301a:	b16d      	cbz	r5, 8003038 <HAL_SPI_TransmitReceive+0x1b0>
        if (hspi->TxXferCount > 1U)
 800301c:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 800301e:	b29b      	uxth	r3, r3
 8003020:	2b01      	cmp	r3, #1
 8003022:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003024:	d93b      	bls.n	800309e <HAL_SPI_TransmitReceive+0x216>
          hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8003026:	f833 1b02 	ldrh.w	r1, [r3], #2
 800302a:	60d1      	str	r1, [r2, #12]
          hspi->pTxBuffPtr += sizeof(uint16_t);
 800302c:	63a3      	str	r3, [r4, #56]	; 0x38
          hspi->TxXferCount -= 2U;
 800302e:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8003030:	3b02      	subs	r3, #2
          hspi->TxXferCount--;
 8003032:	b29b      	uxth	r3, r3
 8003034:	87e3      	strh	r3, [r4, #62]	; 0x3e
        txallowed = 0U;
 8003036:	2500      	movs	r5, #0
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
 8003038:	6822      	ldr	r2, [r4, #0]
 800303a:	6893      	ldr	r3, [r2, #8]
 800303c:	07d9      	lsls	r1, r3, #31
 800303e:	d51d      	bpl.n	800307c <HAL_SPI_TransmitReceive+0x1f4>
 8003040:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 8003044:	b29b      	uxth	r3, r3
 8003046:	b1cb      	cbz	r3, 800307c <HAL_SPI_TransmitReceive+0x1f4>
        if (hspi->RxXferCount > 1U)
 8003048:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 800304c:	b29b      	uxth	r3, r3
 800304e:	2b01      	cmp	r3, #1
 8003050:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8003052:	d92c      	bls.n	80030ae <HAL_SPI_TransmitReceive+0x226>
          *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
 8003054:	68d1      	ldr	r1, [r2, #12]
 8003056:	f823 1b02 	strh.w	r1, [r3], #2
          hspi->pRxBuffPtr += sizeof(uint16_t);
 800305a:	6423      	str	r3, [r4, #64]	; 0x40
          hspi->RxXferCount -= 2U;
 800305c:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 8003060:	3b02      	subs	r3, #2
 8003062:	b29b      	uxth	r3, r3
 8003064:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
          if (hspi->RxXferCount <= 1U)
 8003068:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 800306c:	b29b      	uxth	r3, r3
 800306e:	2b01      	cmp	r3, #1
 8003070:	d803      	bhi.n	800307a <HAL_SPI_TransmitReceive+0x1f2>
            SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8003072:	6853      	ldr	r3, [r2, #4]
 8003074:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8003078:	6053      	str	r3, [r2, #4]
        txallowed = 1U;
 800307a:	2501      	movs	r5, #1
      if ((((HAL_GetTick() - tickstart) >=  Timeout) && ((Timeout != HAL_MAX_DELAY))) || (Timeout == 0U))
 800307c:	f7fd ffa8 	bl	8000fd0 <HAL_GetTick>
 8003080:	eba0 0008 	sub.w	r0, r0, r8
 8003084:	4287      	cmp	r7, r0
 8003086:	d8b9      	bhi.n	8002ffc <HAL_SPI_TransmitReceive+0x174>
 8003088:	1c7b      	adds	r3, r7, #1
 800308a:	d0b7      	beq.n	8002ffc <HAL_SPI_TransmitReceive+0x174>
 800308c:	e79d      	b.n	8002fca <HAL_SPI_TransmitReceive+0x142>
        *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
 800308e:	782b      	ldrb	r3, [r5, #0]
 8003090:	7303      	strb	r3, [r0, #12]
        hspi->pTxBuffPtr++;
 8003092:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003094:	3301      	adds	r3, #1
 8003096:	63a3      	str	r3, [r4, #56]	; 0x38
        hspi->TxXferCount--;
 8003098:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 800309a:	3b01      	subs	r3, #1
 800309c:	e7ab      	b.n	8002ff6 <HAL_SPI_TransmitReceive+0x16e>
          *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
 800309e:	781b      	ldrb	r3, [r3, #0]
 80030a0:	7313      	strb	r3, [r2, #12]
          hspi->pTxBuffPtr++;
 80030a2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80030a4:	3301      	adds	r3, #1
 80030a6:	63a3      	str	r3, [r4, #56]	; 0x38
          hspi->TxXferCount--;
 80030a8:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80030aa:	3b01      	subs	r3, #1
 80030ac:	e7c1      	b.n	8003032 <HAL_SPI_TransmitReceive+0x1aa>
          (*(uint8_t *)hspi->pRxBuffPtr) = *(__IO uint8_t *)&hspi->Instance->DR;
 80030ae:	7b12      	ldrb	r2, [r2, #12]
 80030b0:	701a      	strb	r2, [r3, #0]
          hspi->pRxBuffPtr++;
 80030b2:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80030b4:	3301      	adds	r3, #1
 80030b6:	6423      	str	r3, [r4, #64]	; 0x40
          hspi->RxXferCount--;
 80030b8:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 80030bc:	3b01      	subs	r3, #1
 80030be:	b29b      	uxth	r3, r3
 80030c0:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
 80030c4:	e7d9      	b.n	800307a <HAL_SPI_TransmitReceive+0x1f2>
    errorcode = HAL_BUSY;
 80030c6:	2002      	movs	r0, #2
 80030c8:	e780      	b.n	8002fcc <HAL_SPI_TransmitReceive+0x144>
  __HAL_LOCK(hspi);
 80030ca:	2002      	movs	r0, #2
}
 80030cc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

080030d0 <HAL_SPI_Receive>:
{
 80030d0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 80030d4:	461d      	mov	r5, r3
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
 80030d6:	6843      	ldr	r3, [r0, #4]
 80030d8:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
{
 80030dc:	4604      	mov	r4, r0
 80030de:	4688      	mov	r8, r1
 80030e0:	4617      	mov	r7, r2
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
 80030e2:	d10c      	bne.n	80030fe <HAL_SPI_Receive+0x2e>
 80030e4:	6883      	ldr	r3, [r0, #8]
 80030e6:	b953      	cbnz	r3, 80030fe <HAL_SPI_Receive+0x2e>
    hspi->State = HAL_SPI_STATE_BUSY_RX;
 80030e8:	2304      	movs	r3, #4
 80030ea:	f880 305d 	strb.w	r3, [r0, #93]	; 0x5d
    return HAL_SPI_TransmitReceive(hspi, pData, pData, Size, Timeout);
 80030ee:	4613      	mov	r3, r2
 80030f0:	9500      	str	r5, [sp, #0]
 80030f2:	460a      	mov	r2, r1
 80030f4:	f7ff fec8 	bl	8002e88 <HAL_SPI_TransmitReceive>
}
 80030f8:	b002      	add	sp, #8
 80030fa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  __HAL_LOCK(hspi);
 80030fe:	f894 305c 	ldrb.w	r3, [r4, #92]	; 0x5c
 8003102:	2b01      	cmp	r3, #1
 8003104:	f000 808d 	beq.w	8003222 <HAL_SPI_Receive+0x152>
 8003108:	2301      	movs	r3, #1
 800310a:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
  tickstart = HAL_GetTick();
 800310e:	f7fd ff5f 	bl	8000fd0 <HAL_GetTick>
 8003112:	4606      	mov	r6, r0
  if (hspi->State != HAL_SPI_STATE_READY)
 8003114:	f894 005d 	ldrb.w	r0, [r4, #93]	; 0x5d
 8003118:	b2c0      	uxtb	r0, r0
 800311a:	2801      	cmp	r0, #1
 800311c:	d17f      	bne.n	800321e <HAL_SPI_Receive+0x14e>
  if ((pData == NULL) || (Size == 0U))
 800311e:	f1b8 0f00 	cmp.w	r8, #0
 8003122:	d06a      	beq.n	80031fa <HAL_SPI_Receive+0x12a>
 8003124:	2f00      	cmp	r7, #0
 8003126:	d068      	beq.n	80031fa <HAL_SPI_Receive+0x12a>
  hspi->State       = HAL_SPI_STATE_BUSY_RX;
 8003128:	2304      	movs	r3, #4
 800312a:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
 800312e:	6821      	ldr	r1, [r4, #0]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8003130:	68e2      	ldr	r2, [r4, #12]
  hspi->RxXferSize  = Size;
 8003132:	f8a4 7044 	strh.w	r7, [r4, #68]	; 0x44
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8003136:	2300      	movs	r3, #0
 8003138:	6623      	str	r3, [r4, #96]	; 0x60
  hspi->RxXferCount = Size;
 800313a:	f8a4 7046 	strh.w	r7, [r4, #70]	; 0x46
  hspi->TxXferCount = 0U;
 800313e:	87e3      	strh	r3, [r4, #62]	; 0x3e
  hspi->pTxBuffPtr  = (uint8_t *)NULL;
 8003140:	63a3      	str	r3, [r4, #56]	; 0x38
  hspi->TxXferSize  = 0U;
 8003142:	87a3      	strh	r3, [r4, #60]	; 0x3c
  hspi->RxISR       = NULL;
 8003144:	64e3      	str	r3, [r4, #76]	; 0x4c
  hspi->TxISR       = NULL;
 8003146:	6523      	str	r3, [r4, #80]	; 0x50
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8003148:	684b      	ldr	r3, [r1, #4]
  hspi->pRxBuffPtr  = (uint8_t *)pData;
 800314a:	f8c4 8040 	str.w	r8, [r4, #64]	; 0x40
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 800314e:	f5b2 6fe0 	cmp.w	r2, #1792	; 0x700
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8003152:	bf8c      	ite	hi
 8003154:	f423 5380 	bichi.w	r3, r3, #4096	; 0x1000
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8003158:	f443 5380 	orrls.w	r3, r3, #4096	; 0x1000
 800315c:	604b      	str	r3, [r1, #4]
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 800315e:	68a3      	ldr	r3, [r4, #8]
 8003160:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    SPI_1LINE_RX(hspi);
 8003164:	bf02      	ittt	eq
 8003166:	680b      	ldreq	r3, [r1, #0]
 8003168:	f423 4380 	biceq.w	r3, r3, #16384	; 0x4000
 800316c:	600b      	streq	r3, [r1, #0]
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 800316e:	680b      	ldr	r3, [r1, #0]
 8003170:	065f      	lsls	r7, r3, #25
    __HAL_SPI_ENABLE(hspi);
 8003172:	bf5e      	ittt	pl
 8003174:	680b      	ldrpl	r3, [r1, #0]
 8003176:	f043 0340 	orrpl.w	r3, r3, #64	; 0x40
 800317a:	600b      	strpl	r3, [r1, #0]
  if (hspi->Init.DataSize <= SPI_DATASIZE_8BIT)
 800317c:	f5b2 6fe0 	cmp.w	r2, #1792	; 0x700
 8003180:	d923      	bls.n	80031ca <HAL_SPI_Receive+0xfa>
    while (hspi->RxXferCount > 0U)
 8003182:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 8003186:	b29b      	uxth	r3, r3
 8003188:	b323      	cbz	r3, 80031d4 <HAL_SPI_Receive+0x104>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
 800318a:	6823      	ldr	r3, [r4, #0]
 800318c:	689a      	ldr	r2, [r3, #8]
 800318e:	07d2      	lsls	r2, r2, #31
 8003190:	d53a      	bpl.n	8003208 <HAL_SPI_Receive+0x138>
        *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
 8003192:	68da      	ldr	r2, [r3, #12]
 8003194:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8003196:	f823 2b02 	strh.w	r2, [r3], #2
        hspi->pRxBuffPtr += sizeof(uint16_t);
 800319a:	6423      	str	r3, [r4, #64]	; 0x40
        hspi->RxXferCount--;
 800319c:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 80031a0:	3b01      	subs	r3, #1
 80031a2:	b29b      	uxth	r3, r3
 80031a4:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
 80031a8:	e7eb      	b.n	8003182 <HAL_SPI_Receive+0xb2>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
 80031aa:	6823      	ldr	r3, [r4, #0]
 80031ac:	689a      	ldr	r2, [r3, #8]
 80031ae:	07d0      	lsls	r0, r2, #31
 80031b0:	d51b      	bpl.n	80031ea <HAL_SPI_Receive+0x11a>
        (* (uint8_t *)hspi->pRxBuffPtr) = *(__IO uint8_t *)&hspi->Instance->DR;
 80031b2:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80031b4:	7b1b      	ldrb	r3, [r3, #12]
 80031b6:	7013      	strb	r3, [r2, #0]
        hspi->pRxBuffPtr += sizeof(uint8_t);
 80031b8:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80031ba:	3301      	adds	r3, #1
 80031bc:	6423      	str	r3, [r4, #64]	; 0x40
        hspi->RxXferCount--;
 80031be:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 80031c2:	3b01      	subs	r3, #1
 80031c4:	b29b      	uxth	r3, r3
 80031c6:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
    while (hspi->RxXferCount > 0U)
 80031ca:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 80031ce:	b29b      	uxth	r3, r3
 80031d0:	2b00      	cmp	r3, #0
 80031d2:	d1ea      	bne.n	80031aa <HAL_SPI_Receive+0xda>
  if (SPI_EndRxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 80031d4:	4632      	mov	r2, r6
 80031d6:	4629      	mov	r1, r5
 80031d8:	4620      	mov	r0, r4
 80031da:	f7ff fd0f 	bl	8002bfc <SPI_EndRxTransaction>
 80031de:	b9d8      	cbnz	r0, 8003218 <HAL_SPI_Receive+0x148>
  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 80031e0:	6e20      	ldr	r0, [r4, #96]	; 0x60
    errorcode = HAL_BUSY;
 80031e2:	3000      	adds	r0, #0
 80031e4:	bf18      	it	ne
 80031e6:	2001      	movne	r0, #1
 80031e8:	e007      	b.n	80031fa <HAL_SPI_Receive+0x12a>
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 80031ea:	f7fd fef1 	bl	8000fd0 <HAL_GetTick>
 80031ee:	1b80      	subs	r0, r0, r6
 80031f0:	4285      	cmp	r5, r0
 80031f2:	d8ea      	bhi.n	80031ca <HAL_SPI_Receive+0xfa>
 80031f4:	1c69      	adds	r1, r5, #1
 80031f6:	d0e8      	beq.n	80031ca <HAL_SPI_Receive+0xfa>
          errorcode = HAL_TIMEOUT;
 80031f8:	2003      	movs	r0, #3
  hspi->State = HAL_SPI_STATE_READY;
 80031fa:	2301      	movs	r3, #1
 80031fc:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
  __HAL_UNLOCK(hspi);
 8003200:	2300      	movs	r3, #0
 8003202:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
  return errorcode;
 8003206:	e777      	b.n	80030f8 <HAL_SPI_Receive+0x28>
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8003208:	f7fd fee2 	bl	8000fd0 <HAL_GetTick>
 800320c:	1b80      	subs	r0, r0, r6
 800320e:	4285      	cmp	r5, r0
 8003210:	d8b7      	bhi.n	8003182 <HAL_SPI_Receive+0xb2>
 8003212:	1c6b      	adds	r3, r5, #1
 8003214:	d0b5      	beq.n	8003182 <HAL_SPI_Receive+0xb2>
 8003216:	e7ef      	b.n	80031f8 <HAL_SPI_Receive+0x128>
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 8003218:	2320      	movs	r3, #32
 800321a:	6623      	str	r3, [r4, #96]	; 0x60
 800321c:	e7e0      	b.n	80031e0 <HAL_SPI_Receive+0x110>
    errorcode = HAL_BUSY;
 800321e:	2002      	movs	r0, #2
 8003220:	e7eb      	b.n	80031fa <HAL_SPI_Receive+0x12a>
  __HAL_LOCK(hspi);
 8003222:	2002      	movs	r0, #2
 8003224:	e768      	b.n	80030f8 <HAL_SPI_Receive+0x28>

08003226 <HAL_SPI_GetState>:
  return hspi->State;
 8003226:	f890 005d 	ldrb.w	r0, [r0, #93]	; 0x5d
}
 800322a:	4770      	bx	lr

0800322c <TIM_OC1_SetConfig>:
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800322c:	6a03      	ldr	r3, [r0, #32]
 800322e:	f023 0301 	bic.w	r3, r3, #1
 8003232:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8003234:	6a03      	ldr	r3, [r0, #32]
{
 8003236:	b570      	push	{r4, r5, r6, lr}
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8003238:	6844      	ldr	r4, [r0, #4]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 800323a:	6982      	ldr	r2, [r0, #24]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
  tmpccmrx &= ~TIM_CCMR1_CC1S;
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 800323c:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 800323e:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8003242:	f022 0273 	bic.w	r2, r2, #115	; 0x73
  tmpccmrx |= OC_Config->OCMode;
 8003246:	432a      	orrs	r2, r5

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 8003248:	688d      	ldr	r5, [r1, #8]
  tmpccer &= ~TIM_CCER_CC1P;
 800324a:	f023 0302 	bic.w	r3, r3, #2
  tmpccer |= OC_Config->OCPolarity;
 800324e:	432b      	orrs	r3, r5

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 8003250:	4d1b      	ldr	r5, [pc, #108]	; (80032c0 <TIM_OC1_SetConfig+0x94>)
 8003252:	42a8      	cmp	r0, r5
 8003254:	d00f      	beq.n	8003276 <TIM_OC1_SetConfig+0x4a>
 8003256:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 800325a:	42a8      	cmp	r0, r5
 800325c:	d00b      	beq.n	8003276 <TIM_OC1_SetConfig+0x4a>
 800325e:	f505 6540 	add.w	r5, r5, #3072	; 0xc00
 8003262:	42a8      	cmp	r0, r5
 8003264:	d007      	beq.n	8003276 <TIM_OC1_SetConfig+0x4a>
 8003266:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 800326a:	42a8      	cmp	r0, r5
 800326c:	d003      	beq.n	8003276 <TIM_OC1_SetConfig+0x4a>
 800326e:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8003272:	42a8      	cmp	r0, r5
 8003274:	d11e      	bne.n	80032b4 <TIM_OC1_SetConfig+0x88>
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
 8003276:	68cd      	ldr	r5, [r1, #12]
    tmpccer &= ~TIM_CCER_CC1NP;
 8003278:	f023 0308 	bic.w	r3, r3, #8
    tmpccer |= OC_Config->OCNPolarity;
 800327c:	432b      	orrs	r3, r5
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC1NE;
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800327e:	4d10      	ldr	r5, [pc, #64]	; (80032c0 <TIM_OC1_SetConfig+0x94>)
 8003280:	42a8      	cmp	r0, r5
    tmpccer &= ~TIM_CCER_CC1NE;
 8003282:	f023 0304 	bic.w	r3, r3, #4
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8003286:	d00f      	beq.n	80032a8 <TIM_OC1_SetConfig+0x7c>
 8003288:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 800328c:	42a8      	cmp	r0, r5
 800328e:	d00b      	beq.n	80032a8 <TIM_OC1_SetConfig+0x7c>
 8003290:	f505 6540 	add.w	r5, r5, #3072	; 0xc00
 8003294:	42a8      	cmp	r0, r5
 8003296:	d007      	beq.n	80032a8 <TIM_OC1_SetConfig+0x7c>
 8003298:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 800329c:	42a8      	cmp	r0, r5
 800329e:	d003      	beq.n	80032a8 <TIM_OC1_SetConfig+0x7c>
 80032a0:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80032a4:	42a8      	cmp	r0, r5
 80032a6:	d105      	bne.n	80032b4 <TIM_OC1_SetConfig+0x88>
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS1;
    tmpcr2 &= ~TIM_CR2_OIS1N;
 80032a8:	f424 7540 	bic.w	r5, r4, #768	; 0x300
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
 80032ac:	698e      	ldr	r6, [r1, #24]
 80032ae:	694c      	ldr	r4, [r1, #20]
 80032b0:	4334      	orrs	r4, r6
 80032b2:	432c      	orrs	r4, r5
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 80032b4:	6044      	str	r4, [r0, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 80032b6:	6182      	str	r2, [r0, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 80032b8:	684a      	ldr	r2, [r1, #4]
 80032ba:	6342      	str	r2, [r0, #52]	; 0x34

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 80032bc:	6203      	str	r3, [r0, #32]
 80032be:	bd70      	pop	{r4, r5, r6, pc}
 80032c0:	40012c00 	.word	0x40012c00

080032c4 <TIM_OC3_SetConfig>:
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 80032c4:	6a03      	ldr	r3, [r0, #32]
 80032c6:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80032ca:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 80032cc:	6a03      	ldr	r3, [r0, #32]
{
 80032ce:	b570      	push	{r4, r5, r6, lr}
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 80032d0:	6844      	ldr	r4, [r0, #4]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 80032d2:	69c2      	ldr	r2, [r0, #28]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
  tmpccmrx &= ~TIM_CCMR2_CC3S;
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 80032d4:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 80032d6:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80032da:	f022 0273 	bic.w	r2, r2, #115	; 0x73
  tmpccmrx |= OC_Config->OCMode;
 80032de:	432a      	orrs	r2, r5

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8U);
 80032e0:	688d      	ldr	r5, [r1, #8]
  tmpccer &= ~TIM_CCER_CC3P;
 80032e2:	f423 7300 	bic.w	r3, r3, #512	; 0x200
  tmpccer |= (OC_Config->OCPolarity << 8U);
 80032e6:	ea43 2305 	orr.w	r3, r3, r5, lsl #8

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 80032ea:	4d16      	ldr	r5, [pc, #88]	; (8003344 <TIM_OC3_SetConfig+0x80>)
 80032ec:	42a8      	cmp	r0, r5
 80032ee:	d003      	beq.n	80032f8 <TIM_OC3_SetConfig+0x34>
 80032f0:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 80032f4:	42a8      	cmp	r0, r5
 80032f6:	d10d      	bne.n	8003314 <TIM_OC3_SetConfig+0x50>
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC3NP;
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 80032f8:	68cd      	ldr	r5, [r1, #12]
    tmpccer &= ~TIM_CCER_CC3NP;
 80032fa:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 80032fe:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8003302:	4d10      	ldr	r5, [pc, #64]	; (8003344 <TIM_OC3_SetConfig+0x80>)
 8003304:	42a8      	cmp	r0, r5
    tmpccer &= ~TIM_CCER_CC3NE;
 8003306:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800330a:	d00e      	beq.n	800332a <TIM_OC3_SetConfig+0x66>
 800330c:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8003310:	42a8      	cmp	r0, r5
 8003312:	d00a      	beq.n	800332a <TIM_OC3_SetConfig+0x66>
 8003314:	4d0c      	ldr	r5, [pc, #48]	; (8003348 <TIM_OC3_SetConfig+0x84>)
 8003316:	42a8      	cmp	r0, r5
 8003318:	d007      	beq.n	800332a <TIM_OC3_SetConfig+0x66>
 800331a:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 800331e:	42a8      	cmp	r0, r5
 8003320:	d003      	beq.n	800332a <TIM_OC3_SetConfig+0x66>
 8003322:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8003326:	42a8      	cmp	r0, r5
 8003328:	d106      	bne.n	8003338 <TIM_OC3_SetConfig+0x74>
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS3;
    tmpcr2 &= ~TIM_CR2_OIS3N;
 800332a:	f424 5540 	bic.w	r5, r4, #12288	; 0x3000
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 800332e:	698e      	ldr	r6, [r1, #24]
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
 8003330:	694c      	ldr	r4, [r1, #20]
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 8003332:	4334      	orrs	r4, r6
 8003334:	ea45 1404 	orr.w	r4, r5, r4, lsl #4
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8003338:	6044      	str	r4, [r0, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 800333a:	61c2      	str	r2, [r0, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 800333c:	684a      	ldr	r2, [r1, #4]
 800333e:	63c2      	str	r2, [r0, #60]	; 0x3c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8003340:	6203      	str	r3, [r0, #32]
 8003342:	bd70      	pop	{r4, r5, r6, pc}
 8003344:	40012c00 	.word	0x40012c00
 8003348:	40014000 	.word	0x40014000

0800334c <TIM_OC4_SetConfig>:
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 800334c:	6a03      	ldr	r3, [r0, #32]
 800334e:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8003352:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8003354:	6a03      	ldr	r3, [r0, #32]
{
 8003356:	b530      	push	{r4, r5, lr}
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8003358:	6844      	ldr	r4, [r0, #4]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 800335a:	69c2      	ldr	r2, [r0, #28]
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
  tmpccmrx &= ~TIM_CCMR2_CC4S;

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 800335c:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 800335e:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 8003362:	f422 42e6 	bic.w	r2, r2, #29440	; 0x7300
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8003366:	ea42 2205 	orr.w	r2, r2, r5, lsl #8

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12U);
 800336a:	688d      	ldr	r5, [r1, #8]
  tmpccer &= ~TIM_CCER_CC4P;
 800336c:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
  tmpccer |= (OC_Config->OCPolarity << 12U);
 8003370:	ea43 3305 	orr.w	r3, r3, r5, lsl #12

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8003374:	4d0e      	ldr	r5, [pc, #56]	; (80033b0 <TIM_OC4_SetConfig+0x64>)
 8003376:	42a8      	cmp	r0, r5
 8003378:	d00f      	beq.n	800339a <TIM_OC4_SetConfig+0x4e>
 800337a:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 800337e:	42a8      	cmp	r0, r5
 8003380:	d00b      	beq.n	800339a <TIM_OC4_SetConfig+0x4e>
 8003382:	f505 6540 	add.w	r5, r5, #3072	; 0xc00
 8003386:	42a8      	cmp	r0, r5
 8003388:	d007      	beq.n	800339a <TIM_OC4_SetConfig+0x4e>
 800338a:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 800338e:	42a8      	cmp	r0, r5
 8003390:	d003      	beq.n	800339a <TIM_OC4_SetConfig+0x4e>
 8003392:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8003396:	42a8      	cmp	r0, r5
 8003398:	d104      	bne.n	80033a4 <TIM_OC4_SetConfig+0x58>

    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS4;

    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
 800339a:	694d      	ldr	r5, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS4;
 800339c:	f424 4480 	bic.w	r4, r4, #16384	; 0x4000
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
 80033a0:	ea44 1485 	orr.w	r4, r4, r5, lsl #6
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 80033a4:	6044      	str	r4, [r0, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 80033a6:	61c2      	str	r2, [r0, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 80033a8:	684a      	ldr	r2, [r1, #4]
 80033aa:	6402      	str	r2, [r0, #64]	; 0x40

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 80033ac:	6203      	str	r3, [r0, #32]
 80033ae:	bd30      	pop	{r4, r5, pc}
 80033b0:	40012c00 	.word	0x40012c00

080033b4 <TIM_OC5_SetConfig>:
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC5E;
 80033b4:	6a03      	ldr	r3, [r0, #32]
 80033b6:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80033ba:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 80033bc:	6a03      	ldr	r3, [r0, #32]
{
 80033be:	b530      	push	{r4, r5, lr}
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 80033c0:	6844      	ldr	r4, [r0, #4]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;
 80033c2:	6d42      	ldr	r2, [r0, #84]	; 0x54

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 80033c4:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
 80033c6:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80033ca:	f022 0270 	bic.w	r2, r2, #112	; 0x70
  tmpccmrx |= OC_Config->OCMode;
 80033ce:	432a      	orrs	r2, r5

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC5P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 16U);
 80033d0:	688d      	ldr	r5, [r1, #8]
  tmpccer &= ~TIM_CCER_CC5P;
 80033d2:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
  tmpccer |= (OC_Config->OCPolarity << 16U);
 80033d6:	ea43 4305 	orr.w	r3, r3, r5, lsl #16

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 80033da:	4d0f      	ldr	r5, [pc, #60]	; (8003418 <TIM_OC5_SetConfig+0x64>)
 80033dc:	42a8      	cmp	r0, r5
 80033de:	d00f      	beq.n	8003400 <TIM_OC5_SetConfig+0x4c>
 80033e0:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 80033e4:	42a8      	cmp	r0, r5
 80033e6:	d00b      	beq.n	8003400 <TIM_OC5_SetConfig+0x4c>
 80033e8:	f505 6540 	add.w	r5, r5, #3072	; 0xc00
 80033ec:	42a8      	cmp	r0, r5
 80033ee:	d007      	beq.n	8003400 <TIM_OC5_SetConfig+0x4c>
 80033f0:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80033f4:	42a8      	cmp	r0, r5
 80033f6:	d003      	beq.n	8003400 <TIM_OC5_SetConfig+0x4c>
 80033f8:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80033fc:	42a8      	cmp	r0, r5
 80033fe:	d104      	bne.n	800340a <TIM_OC5_SetConfig+0x56>
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS5;
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 8U);
 8003400:	694d      	ldr	r5, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS5;
 8003402:	f424 3480 	bic.w	r4, r4, #65536	; 0x10000
    tmpcr2 |= (OC_Config->OCIdleState << 8U);
 8003406:	ea44 2405 	orr.w	r4, r4, r5, lsl #8
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800340a:	6044      	str	r4, [r0, #4]

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
 800340c:	6542      	str	r2, [r0, #84]	; 0x54

  /* Set the Capture Compare Register value */
  TIMx->CCR5 = OC_Config->Pulse;
 800340e:	684a      	ldr	r2, [r1, #4]
 8003410:	6582      	str	r2, [r0, #88]	; 0x58

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8003412:	6203      	str	r3, [r0, #32]
 8003414:	bd30      	pop	{r4, r5, pc}
 8003416:	bf00      	nop
 8003418:	40012c00 	.word	0x40012c00

0800341c <TIM_OC6_SetConfig>:
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC6E;
 800341c:	6a03      	ldr	r3, [r0, #32]
 800341e:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 8003422:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8003424:	6a03      	ldr	r3, [r0, #32]
{
 8003426:	b530      	push	{r4, r5, lr}
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8003428:	6844      	ldr	r4, [r0, #4]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;
 800342a:	6d42      	ldr	r2, [r0, #84]	; 0x54

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 800342c:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
 800342e:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 8003432:	f422 42e0 	bic.w	r2, r2, #28672	; 0x7000
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8003436:	ea42 2205 	orr.w	r2, r2, r5, lsl #8

  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 20U);
 800343a:	688d      	ldr	r5, [r1, #8]
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
 800343c:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
  tmpccer |= (OC_Config->OCPolarity << 20U);
 8003440:	ea43 5305 	orr.w	r3, r3, r5, lsl #20

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8003444:	4d0e      	ldr	r5, [pc, #56]	; (8003480 <TIM_OC6_SetConfig+0x64>)
 8003446:	42a8      	cmp	r0, r5
 8003448:	d00f      	beq.n	800346a <TIM_OC6_SetConfig+0x4e>
 800344a:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 800344e:	42a8      	cmp	r0, r5
 8003450:	d00b      	beq.n	800346a <TIM_OC6_SetConfig+0x4e>
 8003452:	f505 6540 	add.w	r5, r5, #3072	; 0xc00
 8003456:	42a8      	cmp	r0, r5
 8003458:	d007      	beq.n	800346a <TIM_OC6_SetConfig+0x4e>
 800345a:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 800345e:	42a8      	cmp	r0, r5
 8003460:	d003      	beq.n	800346a <TIM_OC6_SetConfig+0x4e>
 8003462:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8003466:	42a8      	cmp	r0, r5
 8003468:	d104      	bne.n	8003474 <TIM_OC6_SetConfig+0x58>
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS6;
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 10U);
 800346a:	694d      	ldr	r5, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS6;
 800346c:	f424 2480 	bic.w	r4, r4, #262144	; 0x40000
    tmpcr2 |= (OC_Config->OCIdleState << 10U);
 8003470:	ea44 2485 	orr.w	r4, r4, r5, lsl #10
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8003474:	6044      	str	r4, [r0, #4]

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
 8003476:	6542      	str	r2, [r0, #84]	; 0x54

  /* Set the Capture Compare Register value */
  TIMx->CCR6 = OC_Config->Pulse;
 8003478:	684a      	ldr	r2, [r1, #4]
 800347a:	65c2      	str	r2, [r0, #92]	; 0x5c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800347c:	6203      	str	r3, [r0, #32]
 800347e:	bd30      	pop	{r4, r5, pc}
 8003480:	40012c00 	.word	0x40012c00

08003484 <HAL_TIM_PWM_MspInit>:
 8003484:	4770      	bx	lr
	...

08003488 <TIM_Base_SetConfig>:
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8003488:	4a30      	ldr	r2, [pc, #192]	; (800354c <TIM_Base_SetConfig+0xc4>)
  tmpcr1 = TIMx->CR1;
 800348a:	6803      	ldr	r3, [r0, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800348c:	4290      	cmp	r0, r2
 800348e:	d012      	beq.n	80034b6 <TIM_Base_SetConfig+0x2e>
 8003490:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8003494:	d00f      	beq.n	80034b6 <TIM_Base_SetConfig+0x2e>
 8003496:	f5a2 3294 	sub.w	r2, r2, #75776	; 0x12800
 800349a:	4290      	cmp	r0, r2
 800349c:	d00b      	beq.n	80034b6 <TIM_Base_SetConfig+0x2e>
 800349e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80034a2:	4290      	cmp	r0, r2
 80034a4:	d007      	beq.n	80034b6 <TIM_Base_SetConfig+0x2e>
 80034a6:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80034aa:	4290      	cmp	r0, r2
 80034ac:	d003      	beq.n	80034b6 <TIM_Base_SetConfig+0x2e>
 80034ae:	f502 3294 	add.w	r2, r2, #75776	; 0x12800
 80034b2:	4290      	cmp	r0, r2
 80034b4:	d119      	bne.n	80034ea <TIM_Base_SetConfig+0x62>
    tmpcr1 |= Structure->CounterMode;
 80034b6:	684a      	ldr	r2, [r1, #4]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 80034b8:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 80034bc:	4313      	orrs	r3, r2
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 80034be:	4a23      	ldr	r2, [pc, #140]	; (800354c <TIM_Base_SetConfig+0xc4>)
 80034c0:	4290      	cmp	r0, r2
 80034c2:	d01d      	beq.n	8003500 <TIM_Base_SetConfig+0x78>
 80034c4:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 80034c8:	d01a      	beq.n	8003500 <TIM_Base_SetConfig+0x78>
 80034ca:	f5a2 3294 	sub.w	r2, r2, #75776	; 0x12800
 80034ce:	4290      	cmp	r0, r2
 80034d0:	d016      	beq.n	8003500 <TIM_Base_SetConfig+0x78>
 80034d2:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80034d6:	4290      	cmp	r0, r2
 80034d8:	d012      	beq.n	8003500 <TIM_Base_SetConfig+0x78>
 80034da:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80034de:	4290      	cmp	r0, r2
 80034e0:	d00e      	beq.n	8003500 <TIM_Base_SetConfig+0x78>
 80034e2:	f502 3294 	add.w	r2, r2, #75776	; 0x12800
 80034e6:	4290      	cmp	r0, r2
 80034e8:	d00a      	beq.n	8003500 <TIM_Base_SetConfig+0x78>
 80034ea:	4a19      	ldr	r2, [pc, #100]	; (8003550 <TIM_Base_SetConfig+0xc8>)
 80034ec:	4290      	cmp	r0, r2
 80034ee:	d007      	beq.n	8003500 <TIM_Base_SetConfig+0x78>
 80034f0:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80034f4:	4290      	cmp	r0, r2
 80034f6:	d003      	beq.n	8003500 <TIM_Base_SetConfig+0x78>
 80034f8:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80034fc:	4290      	cmp	r0, r2
 80034fe:	d103      	bne.n	8003508 <TIM_Base_SetConfig+0x80>
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8003500:	68ca      	ldr	r2, [r1, #12]
    tmpcr1 &= ~TIM_CR1_CKD;
 8003502:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8003506:	4313      	orrs	r3, r2
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8003508:	694a      	ldr	r2, [r1, #20]
 800350a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800350e:	4313      	orrs	r3, r2
  TIMx->CR1 = tmpcr1;
 8003510:	6003      	str	r3, [r0, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8003512:	688b      	ldr	r3, [r1, #8]
 8003514:	62c3      	str	r3, [r0, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 8003516:	680b      	ldr	r3, [r1, #0]
 8003518:	6283      	str	r3, [r0, #40]	; 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 800351a:	4b0c      	ldr	r3, [pc, #48]	; (800354c <TIM_Base_SetConfig+0xc4>)
 800351c:	4298      	cmp	r0, r3
 800351e:	d00f      	beq.n	8003540 <TIM_Base_SetConfig+0xb8>
 8003520:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8003524:	4298      	cmp	r0, r3
 8003526:	d00b      	beq.n	8003540 <TIM_Base_SetConfig+0xb8>
 8003528:	f503 6340 	add.w	r3, r3, #3072	; 0xc00
 800352c:	4298      	cmp	r0, r3
 800352e:	d007      	beq.n	8003540 <TIM_Base_SetConfig+0xb8>
 8003530:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8003534:	4298      	cmp	r0, r3
 8003536:	d003      	beq.n	8003540 <TIM_Base_SetConfig+0xb8>
 8003538:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800353c:	4298      	cmp	r0, r3
 800353e:	d101      	bne.n	8003544 <TIM_Base_SetConfig+0xbc>
    TIMx->RCR = Structure->RepetitionCounter;
 8003540:	690b      	ldr	r3, [r1, #16]
 8003542:	6303      	str	r3, [r0, #48]	; 0x30
  TIMx->EGR = TIM_EGR_UG;
 8003544:	2301      	movs	r3, #1
 8003546:	6143      	str	r3, [r0, #20]
 8003548:	4770      	bx	lr
 800354a:	bf00      	nop
 800354c:	40012c00 	.word	0x40012c00
 8003550:	40014000 	.word	0x40014000

08003554 <HAL_TIM_PWM_Init>:
{
 8003554:	b510      	push	{r4, lr}
  if (htim == NULL)
 8003556:	4604      	mov	r4, r0
 8003558:	b1a0      	cbz	r0, 8003584 <HAL_TIM_PWM_Init+0x30>
  if (htim->State == HAL_TIM_STATE_RESET)
 800355a:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 800355e:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8003562:	b91b      	cbnz	r3, 800356c <HAL_TIM_PWM_Init+0x18>
    htim->Lock = HAL_UNLOCKED;
 8003564:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    HAL_TIM_PWM_MspInit(htim);
 8003568:	f7ff ff8c 	bl	8003484 <HAL_TIM_PWM_MspInit>
  htim->State = HAL_TIM_STATE_BUSY;
 800356c:	2302      	movs	r3, #2
 800356e:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8003572:	6820      	ldr	r0, [r4, #0]
 8003574:	1d21      	adds	r1, r4, #4
 8003576:	f7ff ff87 	bl	8003488 <TIM_Base_SetConfig>
  htim->State = HAL_TIM_STATE_READY;
 800357a:	2301      	movs	r3, #1
 800357c:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  return HAL_OK;
 8003580:	2000      	movs	r0, #0
 8003582:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 8003584:	2001      	movs	r0, #1
}
 8003586:	bd10      	pop	{r4, pc}

08003588 <TIM_OC2_SetConfig>:
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8003588:	6a03      	ldr	r3, [r0, #32]
 800358a:	f023 0310 	bic.w	r3, r3, #16
 800358e:	6203      	str	r3, [r0, #32]
  tmpccer = TIMx->CCER;
 8003590:	6a03      	ldr	r3, [r0, #32]
{
 8003592:	b570      	push	{r4, r5, r6, lr}
  tmpcr2 =  TIMx->CR2;
 8003594:	6844      	ldr	r4, [r0, #4]
  tmpccmrx = TIMx->CCMR1;
 8003596:	6982      	ldr	r2, [r0, #24]
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8003598:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 800359a:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 800359e:	f422 42e6 	bic.w	r2, r2, #29440	; 0x7300
  tmpccmrx |= (OC_Config->OCMode << 8U);
 80035a2:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
  tmpccer |= (OC_Config->OCPolarity << 4U);
 80035a6:	688d      	ldr	r5, [r1, #8]
  tmpccer &= ~TIM_CCER_CC2P;
 80035a8:	f023 0320 	bic.w	r3, r3, #32
  tmpccer |= (OC_Config->OCPolarity << 4U);
 80035ac:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 80035b0:	4d16      	ldr	r5, [pc, #88]	; (800360c <TIM_OC2_SetConfig+0x84>)
 80035b2:	42a8      	cmp	r0, r5
 80035b4:	d003      	beq.n	80035be <TIM_OC2_SetConfig+0x36>
 80035b6:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 80035ba:	42a8      	cmp	r0, r5
 80035bc:	d10d      	bne.n	80035da <TIM_OC2_SetConfig+0x52>
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 80035be:	68cd      	ldr	r5, [r1, #12]
    tmpccer &= ~TIM_CCER_CC2NP;
 80035c0:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 80035c4:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 80035c8:	4d10      	ldr	r5, [pc, #64]	; (800360c <TIM_OC2_SetConfig+0x84>)
 80035ca:	42a8      	cmp	r0, r5
    tmpccer &= ~TIM_CCER_CC2NE;
 80035cc:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 80035d0:	d00e      	beq.n	80035f0 <TIM_OC2_SetConfig+0x68>
 80035d2:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 80035d6:	42a8      	cmp	r0, r5
 80035d8:	d00a      	beq.n	80035f0 <TIM_OC2_SetConfig+0x68>
 80035da:	4d0d      	ldr	r5, [pc, #52]	; (8003610 <TIM_OC2_SetConfig+0x88>)
 80035dc:	42a8      	cmp	r0, r5
 80035de:	d007      	beq.n	80035f0 <TIM_OC2_SetConfig+0x68>
 80035e0:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80035e4:	42a8      	cmp	r0, r5
 80035e6:	d003      	beq.n	80035f0 <TIM_OC2_SetConfig+0x68>
 80035e8:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80035ec:	42a8      	cmp	r0, r5
 80035ee:	d106      	bne.n	80035fe <TIM_OC2_SetConfig+0x76>
    tmpcr2 &= ~TIM_CR2_OIS2N;
 80035f0:	f424 6540 	bic.w	r5, r4, #3072	; 0xc00
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 80035f4:	698e      	ldr	r6, [r1, #24]
    tmpcr2 |= (OC_Config->OCIdleState << 2U);
 80035f6:	694c      	ldr	r4, [r1, #20]
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 80035f8:	4334      	orrs	r4, r6
 80035fa:	ea45 0484 	orr.w	r4, r5, r4, lsl #2
  TIMx->CR2 = tmpcr2;
 80035fe:	6044      	str	r4, [r0, #4]
  TIMx->CCMR1 = tmpccmrx;
 8003600:	6182      	str	r2, [r0, #24]
  TIMx->CCR2 = OC_Config->Pulse;
 8003602:	684a      	ldr	r2, [r1, #4]
 8003604:	6382      	str	r2, [r0, #56]	; 0x38
  TIMx->CCER = tmpccer;
 8003606:	6203      	str	r3, [r0, #32]
 8003608:	bd70      	pop	{r4, r5, r6, pc}
 800360a:	bf00      	nop
 800360c:	40012c00 	.word	0x40012c00
 8003610:	40014000 	.word	0x40014000

08003614 <HAL_TIM_PWM_ConfigChannel>:
{
 8003614:	b538      	push	{r3, r4, r5, lr}
  __HAL_LOCK(htim);
 8003616:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 800361a:	2b01      	cmp	r3, #1
{
 800361c:	4604      	mov	r4, r0
 800361e:	f04f 0002 	mov.w	r0, #2
  __HAL_LOCK(htim);
 8003622:	d010      	beq.n	8003646 <HAL_TIM_PWM_ConfigChannel+0x32>
 8003624:	2301      	movs	r3, #1
  switch (Channel)
 8003626:	2a08      	cmp	r2, #8
  __HAL_LOCK(htim);
 8003628:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
  htim->State = HAL_TIM_STATE_BUSY;
 800362c:	f884 003d 	strb.w	r0, [r4, #61]	; 0x3d
  switch (Channel)
 8003630:	d043      	beq.n	80036ba <HAL_TIM_PWM_ConfigChannel+0xa6>
 8003632:	d809      	bhi.n	8003648 <HAL_TIM_PWM_ConfigChannel+0x34>
 8003634:	b1fa      	cbz	r2, 8003676 <HAL_TIM_PWM_ConfigChannel+0x62>
 8003636:	2a04      	cmp	r2, #4
 8003638:	d02e      	beq.n	8003698 <HAL_TIM_PWM_ConfigChannel+0x84>
  htim->State = HAL_TIM_STATE_READY;
 800363a:	2301      	movs	r3, #1
  __HAL_UNLOCK(htim);
 800363c:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
 800363e:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 8003642:	f884 003c 	strb.w	r0, [r4, #60]	; 0x3c
}
 8003646:	bd38      	pop	{r3, r4, r5, pc}
  switch (Channel)
 8003648:	2a10      	cmp	r2, #16
 800364a:	d047      	beq.n	80036dc <HAL_TIM_PWM_ConfigChannel+0xc8>
 800364c:	2a14      	cmp	r2, #20
 800364e:	d056      	beq.n	80036fe <HAL_TIM_PWM_ConfigChannel+0xea>
 8003650:	2a0c      	cmp	r2, #12
 8003652:	d1f2      	bne.n	800363a <HAL_TIM_PWM_ConfigChannel+0x26>
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 8003654:	6820      	ldr	r0, [r4, #0]
 8003656:	f7ff fe79 	bl	800334c <TIM_OC4_SetConfig>
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 800365a:	6823      	ldr	r3, [r4, #0]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
 800365c:	6909      	ldr	r1, [r1, #16]
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 800365e:	69da      	ldr	r2, [r3, #28]
 8003660:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8003664:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
 8003666:	69da      	ldr	r2, [r3, #28]
 8003668:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800366c:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
 800366e:	69da      	ldr	r2, [r3, #28]
 8003670:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8003674:	e030      	b.n	80036d8 <HAL_TIM_PWM_ConfigChannel+0xc4>
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 8003676:	6820      	ldr	r0, [r4, #0]
 8003678:	f7ff fdd8 	bl	800322c <TIM_OC1_SetConfig>
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 800367c:	6823      	ldr	r3, [r4, #0]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 800367e:	6909      	ldr	r1, [r1, #16]
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 8003680:	699a      	ldr	r2, [r3, #24]
 8003682:	f042 0208 	orr.w	r2, r2, #8
 8003686:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
 8003688:	699a      	ldr	r2, [r3, #24]
 800368a:	f022 0204 	bic.w	r2, r2, #4
 800368e:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 8003690:	699a      	ldr	r2, [r3, #24]
 8003692:	430a      	orrs	r2, r1
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 8003694:	619a      	str	r2, [r3, #24]
      break;
 8003696:	e7d0      	b.n	800363a <HAL_TIM_PWM_ConfigChannel+0x26>
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 8003698:	6820      	ldr	r0, [r4, #0]
 800369a:	f7ff ff75 	bl	8003588 <TIM_OC2_SetConfig>
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 800369e:	6823      	ldr	r3, [r4, #0]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 80036a0:	6909      	ldr	r1, [r1, #16]
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 80036a2:	699a      	ldr	r2, [r3, #24]
 80036a4:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 80036a8:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
 80036aa:	699a      	ldr	r2, [r3, #24]
 80036ac:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 80036b0:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 80036b2:	699a      	ldr	r2, [r3, #24]
 80036b4:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 80036b8:	e7ec      	b.n	8003694 <HAL_TIM_PWM_ConfigChannel+0x80>
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 80036ba:	6820      	ldr	r0, [r4, #0]
 80036bc:	f7ff fe02 	bl	80032c4 <TIM_OC3_SetConfig>
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 80036c0:	6823      	ldr	r3, [r4, #0]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 80036c2:	6909      	ldr	r1, [r1, #16]
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 80036c4:	69da      	ldr	r2, [r3, #28]
 80036c6:	f042 0208 	orr.w	r2, r2, #8
 80036ca:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
 80036cc:	69da      	ldr	r2, [r3, #28]
 80036ce:	f022 0204 	bic.w	r2, r2, #4
 80036d2:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 80036d4:	69da      	ldr	r2, [r3, #28]
 80036d6:	430a      	orrs	r2, r1
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
 80036d8:	61da      	str	r2, [r3, #28]
      break;
 80036da:	e7ae      	b.n	800363a <HAL_TIM_PWM_ConfigChannel+0x26>
      TIM_OC5_SetConfig(htim->Instance, sConfig);
 80036dc:	6820      	ldr	r0, [r4, #0]
 80036de:	f7ff fe69 	bl	80033b4 <TIM_OC5_SetConfig>
      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
 80036e2:	6823      	ldr	r3, [r4, #0]
      htim->Instance->CCMR3 |= sConfig->OCFastMode;
 80036e4:	6909      	ldr	r1, [r1, #16]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
 80036e6:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 80036e8:	f042 0208 	orr.w	r2, r2, #8
 80036ec:	655a      	str	r2, [r3, #84]	; 0x54
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE;
 80036ee:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 80036f0:	f022 0204 	bic.w	r2, r2, #4
 80036f4:	655a      	str	r2, [r3, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode;
 80036f6:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 80036f8:	430a      	orrs	r2, r1
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;
 80036fa:	655a      	str	r2, [r3, #84]	; 0x54
      break;
 80036fc:	e79d      	b.n	800363a <HAL_TIM_PWM_ConfigChannel+0x26>
      TIM_OC6_SetConfig(htim->Instance, sConfig);
 80036fe:	6820      	ldr	r0, [r4, #0]
 8003700:	f7ff fe8c 	bl	800341c <TIM_OC6_SetConfig>
      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
 8003704:	6823      	ldr	r3, [r4, #0]
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;
 8003706:	6909      	ldr	r1, [r1, #16]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
 8003708:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800370a:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 800370e:	655a      	str	r2, [r3, #84]	; 0x54
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE;
 8003710:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8003712:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8003716:	655a      	str	r2, [r3, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;
 8003718:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800371a:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 800371e:	e7ec      	b.n	80036fa <HAL_TIM_PWM_ConfigChannel+0xe6>

08003720 <TIM_CCxChannelCmd>:
  assert_param(IS_TIM_CHANNELS(Channel));

  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;
 8003720:	6a03      	ldr	r3, [r0, #32]
  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
 8003722:	f001 011f 	and.w	r1, r1, #31
{
 8003726:	b510      	push	{r4, lr}
  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
 8003728:	2401      	movs	r4, #1
 800372a:	408c      	lsls	r4, r1
  TIMx->CCER &= ~tmp;
 800372c:	ea23 0304 	bic.w	r3, r3, r4
 8003730:	6203      	str	r3, [r0, #32]

  /* Set or reset the CCxE Bit */
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
 8003732:	6a03      	ldr	r3, [r0, #32]
 8003734:	408a      	lsls	r2, r1
 8003736:	431a      	orrs	r2, r3
 8003738:	6202      	str	r2, [r0, #32]
 800373a:	bd10      	pop	{r4, pc}

0800373c <HAL_TIM_PWM_Start>:
{
 800373c:	b510      	push	{r4, lr}
 800373e:	4604      	mov	r4, r0
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
 8003740:	2201      	movs	r2, #1
 8003742:	6800      	ldr	r0, [r0, #0]
 8003744:	f7ff ffec 	bl	8003720 <TIM_CCxChannelCmd>
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 8003748:	6823      	ldr	r3, [r4, #0]
 800374a:	4a14      	ldr	r2, [pc, #80]	; (800379c <HAL_TIM_PWM_Start+0x60>)
 800374c:	4293      	cmp	r3, r2
 800374e:	d01f      	beq.n	8003790 <HAL_TIM_PWM_Start+0x54>
 8003750:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 8003754:	4293      	cmp	r3, r2
 8003756:	d01b      	beq.n	8003790 <HAL_TIM_PWM_Start+0x54>
 8003758:	f502 6240 	add.w	r2, r2, #3072	; 0xc00
 800375c:	4293      	cmp	r3, r2
 800375e:	d017      	beq.n	8003790 <HAL_TIM_PWM_Start+0x54>
 8003760:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8003764:	4293      	cmp	r3, r2
 8003766:	d013      	beq.n	8003790 <HAL_TIM_PWM_Start+0x54>
 8003768:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800376c:	4293      	cmp	r3, r2
 800376e:	d00f      	beq.n	8003790 <HAL_TIM_PWM_Start+0x54>
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(htim))
 8003770:	6899      	ldr	r1, [r3, #8]
 8003772:	480b      	ldr	r0, [pc, #44]	; (80037a0 <HAL_TIM_PWM_Start+0x64>)
 8003774:	4001      	ands	r1, r0
 8003776:	2906      	cmp	r1, #6
 8003778:	d008      	beq.n	800378c <HAL_TIM_PWM_Start+0x50>
 800377a:	689a      	ldr	r2, [r3, #8]
 800377c:	4002      	ands	r2, r0
 800377e:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 8003782:	d003      	beq.n	800378c <HAL_TIM_PWM_Start+0x50>
    __HAL_TIM_ENABLE(htim);
 8003784:	681a      	ldr	r2, [r3, #0]
 8003786:	f042 0201 	orr.w	r2, r2, #1
 800378a:	601a      	str	r2, [r3, #0]
}
 800378c:	2000      	movs	r0, #0
 800378e:	bd10      	pop	{r4, pc}
    __HAL_TIM_MOE_ENABLE(htim);
 8003790:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8003792:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8003796:	645a      	str	r2, [r3, #68]	; 0x44
 8003798:	e7ea      	b.n	8003770 <HAL_TIM_PWM_Start+0x34>
 800379a:	bf00      	nop
 800379c:	40012c00 	.word	0x40012c00
 80037a0:	00010007 	.word	0x00010007

080037a4 <HAL_TIMEx_MasterConfigSynchronization>:
  assert_param(IS_TIM_SYNCHRO_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 80037a4:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 80037a8:	2b01      	cmp	r3, #1
{
 80037aa:	b530      	push	{r4, r5, lr}
 80037ac:	f04f 0302 	mov.w	r3, #2
  __HAL_LOCK(htim);
 80037b0:	d01f      	beq.n	80037f2 <HAL_TIMEx_MasterConfigSynchronization+0x4e>

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 80037b2:	6802      	ldr	r2, [r0, #0]

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;

  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 80037b4:	4d10      	ldr	r5, [pc, #64]	; (80037f8 <HAL_TIMEx_MasterConfigSynchronization+0x54>)
  htim->State = HAL_TIM_STATE_BUSY;
 80037b6:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 80037ba:	42aa      	cmp	r2, r5
  tmpcr2 = htim->Instance->CR2;
 80037bc:	6853      	ldr	r3, [r2, #4]
  tmpsmcr = htim->Instance->SMCR;
 80037be:	6894      	ldr	r4, [r2, #8]
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 80037c0:	d003      	beq.n	80037ca <HAL_TIMEx_MasterConfigSynchronization+0x26>
 80037c2:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 80037c6:	42aa      	cmp	r2, r5
 80037c8:	d103      	bne.n	80037d2 <HAL_TIMEx_MasterConfigSynchronization+0x2e>
    assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));

    /* Clear the MMS2 bits */
    tmpcr2 &= ~TIM_CR2_MMS2;
    /* Select the TRGO2 source*/
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 80037ca:	684d      	ldr	r5, [r1, #4]
    tmpcr2 &= ~TIM_CR2_MMS2;
 80037cc:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 80037d0:	432b      	orrs	r3, r5
  }

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 80037d2:	680d      	ldr	r5, [r1, #0]

  /* Reset the MSM Bit */
  tmpsmcr &= ~TIM_SMCR_MSM;
  /* Set master mode */
  tmpsmcr |= sMasterConfig->MasterSlaveMode;
 80037d4:	6889      	ldr	r1, [r1, #8]
  tmpcr2 &= ~TIM_CR2_MMS;
 80037d6:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 80037da:	432b      	orrs	r3, r5
  tmpsmcr &= ~TIM_SMCR_MSM;
 80037dc:	f024 0480 	bic.w	r4, r4, #128	; 0x80

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;
 80037e0:	6053      	str	r3, [r2, #4]
  tmpsmcr |= sMasterConfig->MasterSlaveMode;
 80037e2:	4321      	orrs	r1, r4

  /* Update TIMx SMCR */
  htim->Instance->SMCR = tmpsmcr;

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;
 80037e4:	2301      	movs	r3, #1
  htim->Instance->SMCR = tmpsmcr;
 80037e6:	6091      	str	r1, [r2, #8]
  htim->State = HAL_TIM_STATE_READY;
 80037e8:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d

  __HAL_UNLOCK(htim);
 80037ec:	2300      	movs	r3, #0
 80037ee:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  __HAL_LOCK(htim);
 80037f2:	4618      	mov	r0, r3

  return HAL_OK;
}
 80037f4:	bd30      	pop	{r4, r5, pc}
 80037f6:	bf00      	nop
 80037f8:	40012c00 	.word	0x40012c00

080037fc <UART_SetConfig>:
  uint32_t lpuart_ker_ck_pres         = 0x00000000U;

  /* Check the parameters */
  assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
  if (UART_INSTANCE_LOWPOWER(huart))
 80037fc:	6802      	ldr	r2, [r0, #0]
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 80037fe:	69c1      	ldr	r1, [r0, #28]
{
 8003800:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003802:	4604      	mov	r4, r0
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8003804:	6883      	ldr	r3, [r0, #8]
 8003806:	6900      	ldr	r0, [r0, #16]
#if defined(USART_CR1_FIFOEN)
  tmpreg |= (uint32_t)huart->FifoMode;
#endif
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8003808:	6815      	ldr	r5, [r2, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800380a:	4303      	orrs	r3, r0
 800380c:	6960      	ldr	r0, [r4, #20]
 800380e:	4303      	orrs	r3, r0
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8003810:	48ba      	ldr	r0, [pc, #744]	; (8003afc <UART_SetConfig+0x300>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8003812:	430b      	orrs	r3, r1
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8003814:	4028      	ands	r0, r5
 8003816:	4303      	orrs	r3, r0
 8003818:	6013      	str	r3, [r2, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800381a:	6853      	ldr	r3, [r2, #4]
 800381c:	68e0      	ldr	r0, [r4, #12]
 800381e:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 8003822:	4303      	orrs	r3, r0
 8003824:	6053      	str	r3, [r2, #4]
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;

  if (!(UART_INSTANCE_LOWPOWER(huart)))
 8003826:	4bb6      	ldr	r3, [pc, #728]	; (8003b00 <UART_SetConfig+0x304>)
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 8003828:	69a0      	ldr	r0, [r4, #24]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 800382a:	429a      	cmp	r2, r3
  {
    tmpreg |= huart->Init.OneBitSampling;
 800382c:	bf1c      	itt	ne
 800382e:	6a23      	ldrne	r3, [r4, #32]
 8003830:	4318      	orrne	r0, r3
  }
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 8003832:	6893      	ldr	r3, [r2, #8]
 8003834:	f423 6330 	bic.w	r3, r3, #2816	; 0xb00
 8003838:	4303      	orrs	r3, r0
 800383a:	6093      	str	r3, [r2, #8]
  * - UART Clock Prescaler : set PRESCALER according to huart->Init.ClockPrescaler value */
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
#endif

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 800383c:	4bb1      	ldr	r3, [pc, #708]	; (8003b04 <UART_SetConfig+0x308>)
 800383e:	429a      	cmp	r2, r3
 8003840:	d119      	bne.n	8003876 <UART_SetConfig+0x7a>
 8003842:	f503 4358 	add.w	r3, r3, #55296	; 0xd800
 8003846:	4ab0      	ldr	r2, [pc, #704]	; (8003b08 <UART_SetConfig+0x30c>)
 8003848:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800384c:	f003 0303 	and.w	r3, r3, #3
        }
      }  /*   if ( (tmpreg < (3 * huart->Init.BaudRate) ) || (tmpreg > (4096 * huart->Init.BaudRate) )) */
    } /* if (tmpreg != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8003850:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 8003854:	5cd3      	ldrb	r3, [r2, r3]
 8003856:	f040 8138 	bne.w	8003aca <UART_SetConfig+0x2ce>
  {
    switch (clocksource)
 800385a:	2b08      	cmp	r3, #8
 800385c:	f200 808f 	bhi.w	800397e <UART_SetConfig+0x182>
 8003860:	e8df f013 	tbh	[pc, r3, lsl #1]
 8003864:	00ca011a 	.word	0x00ca011a
 8003868:	008d00f9 	.word	0x008d00f9
 800386c:	008d0114 	.word	0x008d0114
 8003870:	008d008d 	.word	0x008d008d
 8003874:	0036      	.short	0x0036
  UART_GETCLOCKSOURCE(huart, clocksource);
 8003876:	4ba5      	ldr	r3, [pc, #660]	; (8003b0c <UART_SetConfig+0x310>)
 8003878:	429a      	cmp	r2, r3
 800387a:	d107      	bne.n	800388c <UART_SetConfig+0x90>
 800387c:	f503 33e6 	add.w	r3, r3, #117760	; 0x1cc00
 8003880:	4aa3      	ldr	r2, [pc, #652]	; (8003b10 <UART_SetConfig+0x314>)
 8003882:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8003886:	f003 030c 	and.w	r3, r3, #12
 800388a:	e7e1      	b.n	8003850 <UART_SetConfig+0x54>
 800388c:	4ba1      	ldr	r3, [pc, #644]	; (8003b14 <UART_SetConfig+0x318>)
 800388e:	429a      	cmp	r2, r3
 8003890:	d123      	bne.n	80038da <UART_SetConfig+0xde>
 8003892:	f503 33e4 	add.w	r3, r3, #116736	; 0x1c800
 8003896:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800389a:	f003 0330 	and.w	r3, r3, #48	; 0x30
 800389e:	2b10      	cmp	r3, #16
 80038a0:	f000 80f1 	beq.w	8003a86 <UART_SetConfig+0x28a>
 80038a4:	d80b      	bhi.n	80038be <UART_SetConfig+0xc2>
 80038a6:	2b00      	cmp	r3, #0
 80038a8:	f000 80f3 	beq.w	8003a92 <UART_SetConfig+0x296>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80038ac:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
#endif
        break;
      case UART_CLOCKSOURCE_UNDEFINED:
      default:
        ret = HAL_ERROR;
 80038b0:	f04f 0201 	mov.w	r2, #1
  uint32_t usartdiv                   = 0x00000000U;
 80038b4:	f04f 0300 	mov.w	r3, #0
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80038b8:	f000 80f8 	beq.w	8003aac <UART_SetConfig+0x2b0>
 80038bc:	e0a8      	b.n	8003a10 <UART_SetConfig+0x214>
  UART_GETCLOCKSOURCE(huart, clocksource);
 80038be:	2b20      	cmp	r3, #32
 80038c0:	f000 80c6 	beq.w	8003a50 <UART_SetConfig+0x254>
 80038c4:	2b30      	cmp	r3, #48	; 0x30
 80038c6:	d1f1      	bne.n	80038ac <UART_SetConfig+0xb0>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80038c8:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 80038cc:	f040 80b8 	bne.w	8003a40 <UART_SetConfig+0x244>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
 80038d0:	6860      	ldr	r0, [r4, #4]
 80038d2:	0843      	lsrs	r3, r0, #1
 80038d4:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 80038d8:	e0c3      	b.n	8003a62 <UART_SetConfig+0x266>
  UART_GETCLOCKSOURCE(huart, clocksource);
 80038da:	4b8f      	ldr	r3, [pc, #572]	; (8003b18 <UART_SetConfig+0x31c>)
 80038dc:	429a      	cmp	r2, r3
 80038de:	d11e      	bne.n	800391e <UART_SetConfig+0x122>
 80038e0:	f503 33e2 	add.w	r3, r3, #115712	; 0x1c400
 80038e4:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80038e8:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 80038ec:	2b40      	cmp	r3, #64	; 0x40
 80038ee:	f000 80bb 	beq.w	8003a68 <UART_SetConfig+0x26c>
 80038f2:	d80a      	bhi.n	800390a <UART_SetConfig+0x10e>
 80038f4:	b97b      	cbnz	r3, 8003916 <UART_SetConfig+0x11a>
  if (UART_INSTANCE_LOWPOWER(huart))
 80038f6:	4b82      	ldr	r3, [pc, #520]	; (8003b00 <UART_SetConfig+0x304>)
 80038f8:	429a      	cmp	r2, r3
 80038fa:	f040 80ca 	bne.w	8003a92 <UART_SetConfig+0x296>
        lpuart_ker_ck_pres = HAL_RCC_GetPCLK1Freq();
 80038fe:	f7fe fe0d 	bl	800251c <HAL_RCC_GetPCLK1Freq>
        break;
 8003902:	2300      	movs	r3, #0
    if (lpuart_ker_ck_pres != 0U)
 8003904:	bbb0      	cbnz	r0, 8003974 <UART_SetConfig+0x178>
 8003906:	4602      	mov	r2, r0
 8003908:	e03a      	b.n	8003980 <UART_SetConfig+0x184>
  UART_GETCLOCKSOURCE(huart, clocksource);
 800390a:	2b80      	cmp	r3, #128	; 0x80
 800390c:	f000 809d 	beq.w	8003a4a <UART_SetConfig+0x24e>
 8003910:	2bc0      	cmp	r3, #192	; 0xc0
 8003912:	f000 80b0 	beq.w	8003a76 <UART_SetConfig+0x27a>
  if (UART_INSTANCE_LOWPOWER(huart))
 8003916:	4b7a      	ldr	r3, [pc, #488]	; (8003b00 <UART_SetConfig+0x304>)
 8003918:	429a      	cmp	r2, r3
 800391a:	d1c7      	bne.n	80038ac <UART_SetConfig+0xb0>
 800391c:	e02f      	b.n	800397e <UART_SetConfig+0x182>
  UART_GETCLOCKSOURCE(huart, clocksource);
 800391e:	4b7f      	ldr	r3, [pc, #508]	; (8003b1c <UART_SetConfig+0x320>)
 8003920:	429a      	cmp	r2, r3
 8003922:	d111      	bne.n	8003948 <UART_SetConfig+0x14c>
 8003924:	f503 33e0 	add.w	r3, r3, #114688	; 0x1c000
 8003928:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800392c:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8003930:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8003934:	f000 8098 	beq.w	8003a68 <UART_SetConfig+0x26c>
 8003938:	d9dc      	bls.n	80038f4 <UART_SetConfig+0xf8>
 800393a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800393e:	f000 8084 	beq.w	8003a4a <UART_SetConfig+0x24e>
 8003942:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8003946:	e7e4      	b.n	8003912 <UART_SetConfig+0x116>
 8003948:	4b6d      	ldr	r3, [pc, #436]	; (8003b00 <UART_SetConfig+0x304>)
 800394a:	429a      	cmp	r2, r3
 800394c:	d1ae      	bne.n	80038ac <UART_SetConfig+0xb0>
 800394e:	f503 33c8 	add.w	r3, r3, #102400	; 0x19000
 8003952:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8003956:	f403 6340 	and.w	r3, r3, #3072	; 0xc00
 800395a:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800395e:	f000 8083 	beq.w	8003a68 <UART_SetConfig+0x26c>
 8003962:	d9c7      	bls.n	80038f4 <UART_SetConfig+0xf8>
 8003964:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8003968:	d06f      	beq.n	8003a4a <UART_SetConfig+0x24e>
 800396a:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 800396e:	e7d0      	b.n	8003912 <UART_SetConfig+0x116>
        lpuart_ker_ck_pres = (uint32_t)HSI_VALUE;
 8003970:	486b      	ldr	r0, [pc, #428]	; (8003b20 <UART_SetConfig+0x324>)
  if (UART_INSTANCE_LOWPOWER(huart))
 8003972:	2302      	movs	r3, #2
      if ((lpuart_ker_ck_pres < (3 * huart->Init.BaudRate)) ||
 8003974:	6862      	ldr	r2, [r4, #4]
 8003976:	eb02 0142 	add.w	r1, r2, r2, lsl #1
 800397a:	4281      	cmp	r1, r0
 800397c:	d905      	bls.n	800398a <UART_SetConfig+0x18e>
        ret = HAL_ERROR;
 800397e:	2201      	movs	r2, #1
  huart->NbTxDataToProcess = 1;
  huart->NbRxDataToProcess = 1;
#endif

  /* Clear ISR function pointers */
  huart->RxISR = NULL;
 8003980:	2300      	movs	r3, #0
 8003982:	6623      	str	r3, [r4, #96]	; 0x60
  huart->TxISR = NULL;
 8003984:	6663      	str	r3, [r4, #100]	; 0x64

  return ret;
}
 8003986:	4610      	mov	r0, r2
 8003988:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if ((lpuart_ker_ck_pres < (3 * huart->Init.BaudRate)) ||
 800398a:	ebb0 3f02 	cmp.w	r0, r2, lsl #12
 800398e:	d8f6      	bhi.n	800397e <UART_SetConfig+0x182>
        switch (clocksource)
 8003990:	2b08      	cmp	r3, #8
 8003992:	d82e      	bhi.n	80039f2 <UART_SetConfig+0x1f6>
 8003994:	e8df f003 	tbb	[pc, r3]
 8003998:	2d1c2d05 	.word	0x2d1c2d05
 800399c:	2d2d2d24 	.word	0x2d2d2d24
 80039a0:	27          	.byte	0x27
 80039a1:	00          	.byte	0x00
            usartdiv = (uint32_t)(UART_DIV_LPUART(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 80039a2:	f7fe fdbb 	bl	800251c <HAL_RCC_GetPCLK1Freq>
            usartdiv = (uint32_t)(UART_DIV_LPUART(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 80039a6:	6862      	ldr	r2, [r4, #4]
 80039a8:	f44f 7180 	mov.w	r1, #256	; 0x100
 80039ac:	0856      	lsrs	r6, r2, #1
 80039ae:	2700      	movs	r7, #0
 80039b0:	fbe1 6700 	umlal	r6, r7, r1, r0
 80039b4:	2300      	movs	r3, #0
 80039b6:	4630      	mov	r0, r6
 80039b8:	4639      	mov	r1, r7
            usartdiv = (uint32_t)(UART_DIV_LPUART(LSE_VALUE, huart->Init.BaudRate));
 80039ba:	f7fd f951 	bl	8000c60 <__aeabi_uldivmod>
            break;
 80039be:	2200      	movs	r2, #0
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 80039c0:	4b58      	ldr	r3, [pc, #352]	; (8003b24 <UART_SetConfig+0x328>)
 80039c2:	f5a0 7140 	sub.w	r1, r0, #768	; 0x300
 80039c6:	4299      	cmp	r1, r3
 80039c8:	d8d9      	bhi.n	800397e <UART_SetConfig+0x182>
          huart->Instance->BRR = usartdiv;
 80039ca:	6823      	ldr	r3, [r4, #0]
 80039cc:	60d8      	str	r0, [r3, #12]
 80039ce:	e7d7      	b.n	8003980 <UART_SetConfig+0x184>
            usartdiv = (uint32_t)(UART_DIV_LPUART(HSI_VALUE, huart->Init.BaudRate));
 80039d0:	4855      	ldr	r0, [pc, #340]	; (8003b28 <UART_SetConfig+0x32c>)
 80039d2:	0855      	lsrs	r5, r2, #1
 80039d4:	2300      	movs	r3, #0
 80039d6:	2100      	movs	r1, #0
 80039d8:	1940      	adds	r0, r0, r5
            usartdiv = (uint32_t)(UART_DIV_LPUART(LSE_VALUE, huart->Init.BaudRate));
 80039da:	f141 0100 	adc.w	r1, r1, #0
 80039de:	e7ec      	b.n	80039ba <UART_SetConfig+0x1be>
            usartdiv = (uint32_t)(UART_DIV_LPUART(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 80039e0:	f7fe fa90 	bl	8001f04 <HAL_RCC_GetSysClockFreq>
 80039e4:	e7df      	b.n	80039a6 <UART_SetConfig+0x1aa>
            usartdiv = (uint32_t)(UART_DIV_LPUART(LSE_VALUE, huart->Init.BaudRate));
 80039e6:	0850      	lsrs	r0, r2, #1
 80039e8:	2100      	movs	r1, #0
 80039ea:	2300      	movs	r3, #0
 80039ec:	f510 0000 	adds.w	r0, r0, #8388608	; 0x800000
 80039f0:	e7f3      	b.n	80039da <UART_SetConfig+0x1de>
            ret = HAL_ERROR;
 80039f2:	2201      	movs	r2, #1
  uint32_t usartdiv                   = 0x00000000U;
 80039f4:	2000      	movs	r0, #0
 80039f6:	e7e3      	b.n	80039c0 <UART_SetConfig+0x1c4>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 80039f8:	f7fe fda2 	bl	8002540 <HAL_RCC_GetPCLK2Freq>
 80039fc:	e04e      	b.n	8003a9c <UART_SetConfig+0x2a0>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 80039fe:	f7fe fd8d 	bl	800251c <HAL_RCC_GetPCLK1Freq>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 8003a02:	6862      	ldr	r2, [r4, #4]
 8003a04:	eb00 0352 	add.w	r3, r0, r2, lsr #1
 8003a08:	fbb3 f3f2 	udiv	r3, r3, r2
 8003a0c:	b29b      	uxth	r3, r3
  HAL_StatusTypeDef ret               = HAL_OK;
 8003a0e:	2200      	movs	r2, #0
    if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8003a10:	f1a3 0010 	sub.w	r0, r3, #16
 8003a14:	f64f 71ef 	movw	r1, #65519	; 0xffef
 8003a18:	4288      	cmp	r0, r1
 8003a1a:	d8b0      	bhi.n	800397e <UART_SetConfig+0x182>
      huart->Instance->BRR = usartdiv;
 8003a1c:	6821      	ldr	r1, [r4, #0]
 8003a1e:	60cb      	str	r3, [r1, #12]
 8003a20:	e7ae      	b.n	8003980 <UART_SetConfig+0x184>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 8003a22:	f7fe fd8d 	bl	8002540 <HAL_RCC_GetPCLK2Freq>
 8003a26:	e7ec      	b.n	8003a02 <UART_SetConfig+0x206>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate));
 8003a28:	6860      	ldr	r0, [r4, #4]
 8003a2a:	0843      	lsrs	r3, r0, #1
 8003a2c:	f503 0374 	add.w	r3, r3, #15990784	; 0xf40000
 8003a30:	f503 5310 	add.w	r3, r3, #9216	; 0x2400
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
 8003a34:	fbb3 f3f0 	udiv	r3, r3, r0
 8003a38:	e7e8      	b.n	8003a0c <UART_SetConfig+0x210>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 8003a3a:	f7fe fa63 	bl	8001f04 <HAL_RCC_GetSysClockFreq>
 8003a3e:	e7e0      	b.n	8003a02 <UART_SetConfig+0x206>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
 8003a40:	6860      	ldr	r0, [r4, #4]
 8003a42:	0843      	lsrs	r3, r0, #1
 8003a44:	f503 4300 	add.w	r3, r3, #32768	; 0x8000
 8003a48:	e7f4      	b.n	8003a34 <UART_SetConfig+0x238>
  if (UART_INSTANCE_LOWPOWER(huart))
 8003a4a:	4b2d      	ldr	r3, [pc, #180]	; (8003b00 <UART_SetConfig+0x304>)
 8003a4c:	429a      	cmp	r2, r3
 8003a4e:	d08f      	beq.n	8003970 <UART_SetConfig+0x174>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8003a50:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 8003a54:	d1e8      	bne.n	8003a28 <UART_SetConfig+0x22c>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate));
 8003a56:	6860      	ldr	r0, [r4, #4]
 8003a58:	0843      	lsrs	r3, r0, #1
 8003a5a:	f103 73f4 	add.w	r3, r3, #31981568	; 0x1e80000
 8003a5e:	f503 4390 	add.w	r3, r3, #18432	; 0x4800
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
 8003a62:	fbb3 f3f0 	udiv	r3, r3, r0
 8003a66:	e01f      	b.n	8003aa8 <UART_SetConfig+0x2ac>
  if (UART_INSTANCE_LOWPOWER(huart))
 8003a68:	4b25      	ldr	r3, [pc, #148]	; (8003b00 <UART_SetConfig+0x304>)
 8003a6a:	429a      	cmp	r2, r3
 8003a6c:	d10b      	bne.n	8003a86 <UART_SetConfig+0x28a>
        lpuart_ker_ck_pres = HAL_RCC_GetSysClockFreq();
 8003a6e:	f7fe fa49 	bl	8001f04 <HAL_RCC_GetSysClockFreq>
        break;
 8003a72:	2304      	movs	r3, #4
 8003a74:	e746      	b.n	8003904 <UART_SetConfig+0x108>
  if (UART_INSTANCE_LOWPOWER(huart))
 8003a76:	4b22      	ldr	r3, [pc, #136]	; (8003b00 <UART_SetConfig+0x304>)
 8003a78:	429a      	cmp	r2, r3
 8003a7a:	f47f af25 	bne.w	80038c8 <UART_SetConfig+0xcc>
        lpuart_ker_ck_pres = (uint32_t)LSE_VALUE;
 8003a7e:	f44f 4000 	mov.w	r0, #32768	; 0x8000
  if (UART_INSTANCE_LOWPOWER(huart))
 8003a82:	2308      	movs	r3, #8
 8003a84:	e776      	b.n	8003974 <UART_SetConfig+0x178>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8003a86:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 8003a8a:	d1d6      	bne.n	8003a3a <UART_SetConfig+0x23e>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 8003a8c:	f7fe fa3a 	bl	8001f04 <HAL_RCC_GetSysClockFreq>
 8003a90:	e004      	b.n	8003a9c <UART_SetConfig+0x2a0>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8003a92:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 8003a96:	d1b2      	bne.n	80039fe <UART_SetConfig+0x202>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 8003a98:	f7fe fd40 	bl	800251c <HAL_RCC_GetPCLK1Freq>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 8003a9c:	6861      	ldr	r1, [r4, #4]
 8003a9e:	084a      	lsrs	r2, r1, #1
 8003aa0:	eb02 0340 	add.w	r3, r2, r0, lsl #1
 8003aa4:	fbb3 f3f1 	udiv	r3, r3, r1
 8003aa8:	b29b      	uxth	r3, r3
  HAL_StatusTypeDef ret               = HAL_OK;
 8003aaa:	2200      	movs	r2, #0
    if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8003aac:	f1a3 0010 	sub.w	r0, r3, #16
 8003ab0:	f64f 71ef 	movw	r1, #65519	; 0xffef
 8003ab4:	4288      	cmp	r0, r1
 8003ab6:	f63f af62 	bhi.w	800397e <UART_SetConfig+0x182>
      brrtemp = usartdiv & 0xFFF0U;
 8003aba:	f023 010f 	bic.w	r1, r3, #15
      huart->Instance->BRR = brrtemp;
 8003abe:	6820      	ldr	r0, [r4, #0]
      brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 8003ac0:	f3c3 0342 	ubfx	r3, r3, #1, #3
      huart->Instance->BRR = brrtemp;
 8003ac4:	430b      	orrs	r3, r1
 8003ac6:	60c3      	str	r3, [r0, #12]
 8003ac8:	e75a      	b.n	8003980 <UART_SetConfig+0x184>
    switch (clocksource)
 8003aca:	2b08      	cmp	r3, #8
 8003acc:	f63f af57 	bhi.w	800397e <UART_SetConfig+0x182>
 8003ad0:	a201      	add	r2, pc, #4	; (adr r2, 8003ad8 <UART_SetConfig+0x2dc>)
 8003ad2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8003ad6:	bf00      	nop
 8003ad8:	080039ff 	.word	0x080039ff
 8003adc:	08003a23 	.word	0x08003a23
 8003ae0:	08003a29 	.word	0x08003a29
 8003ae4:	0800397f 	.word	0x0800397f
 8003ae8:	08003a3b 	.word	0x08003a3b
 8003aec:	0800397f 	.word	0x0800397f
 8003af0:	0800397f 	.word	0x0800397f
 8003af4:	0800397f 	.word	0x0800397f
 8003af8:	08003a41 	.word	0x08003a41
 8003afc:	efff69f3 	.word	0xefff69f3
 8003b00:	40008000 	.word	0x40008000
 8003b04:	40013800 	.word	0x40013800
 8003b08:	0800c530 	.word	0x0800c530
 8003b0c:	40004400 	.word	0x40004400
 8003b10:	0800c534 	.word	0x0800c534
 8003b14:	40004800 	.word	0x40004800
 8003b18:	40004c00 	.word	0x40004c00
 8003b1c:	40005000 	.word	0x40005000
 8003b20:	00f42400 	.word	0x00f42400
 8003b24:	000ffcff 	.word	0x000ffcff
 8003b28:	f4240000 	.word	0xf4240000

08003b2c <UART_AdvFeatureConfig>:
{
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 8003b2c:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8003b2e:	07da      	lsls	r2, r3, #31
{
 8003b30:	b510      	push	{r4, lr}
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 8003b32:	d506      	bpl.n	8003b42 <UART_AdvFeatureConfig+0x16>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 8003b34:	6801      	ldr	r1, [r0, #0]
 8003b36:	6a84      	ldr	r4, [r0, #40]	; 0x28
 8003b38:	684a      	ldr	r2, [r1, #4]
 8003b3a:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 8003b3e:	4322      	orrs	r2, r4
 8003b40:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 8003b42:	079c      	lsls	r4, r3, #30
 8003b44:	d506      	bpl.n	8003b54 <UART_AdvFeatureConfig+0x28>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 8003b46:	6801      	ldr	r1, [r0, #0]
 8003b48:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 8003b4a:	684a      	ldr	r2, [r1, #4]
 8003b4c:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8003b50:	4322      	orrs	r2, r4
 8003b52:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 8003b54:	0759      	lsls	r1, r3, #29
 8003b56:	d506      	bpl.n	8003b66 <UART_AdvFeatureConfig+0x3a>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 8003b58:	6801      	ldr	r1, [r0, #0]
 8003b5a:	6b04      	ldr	r4, [r0, #48]	; 0x30
 8003b5c:	684a      	ldr	r2, [r1, #4]
 8003b5e:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8003b62:	4322      	orrs	r2, r4
 8003b64:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 8003b66:	071a      	lsls	r2, r3, #28
 8003b68:	d506      	bpl.n	8003b78 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 8003b6a:	6801      	ldr	r1, [r0, #0]
 8003b6c:	6b44      	ldr	r4, [r0, #52]	; 0x34
 8003b6e:	684a      	ldr	r2, [r1, #4]
 8003b70:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8003b74:	4322      	orrs	r2, r4
 8003b76:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 8003b78:	06dc      	lsls	r4, r3, #27
 8003b7a:	d506      	bpl.n	8003b8a <UART_AdvFeatureConfig+0x5e>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 8003b7c:	6801      	ldr	r1, [r0, #0]
 8003b7e:	6b84      	ldr	r4, [r0, #56]	; 0x38
 8003b80:	688a      	ldr	r2, [r1, #8]
 8003b82:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8003b86:	4322      	orrs	r2, r4
 8003b88:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 8003b8a:	0699      	lsls	r1, r3, #26
 8003b8c:	d506      	bpl.n	8003b9c <UART_AdvFeatureConfig+0x70>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 8003b8e:	6801      	ldr	r1, [r0, #0]
 8003b90:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
 8003b92:	688a      	ldr	r2, [r1, #8]
 8003b94:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8003b98:	4322      	orrs	r2, r4
 8003b9a:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 8003b9c:	065a      	lsls	r2, r3, #25
 8003b9e:	d50f      	bpl.n	8003bc0 <UART_AdvFeatureConfig+0x94>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 8003ba0:	6801      	ldr	r1, [r0, #0]
 8003ba2:	6c04      	ldr	r4, [r0, #64]	; 0x40
 8003ba4:	684a      	ldr	r2, [r1, #4]
 8003ba6:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 8003baa:	4322      	orrs	r2, r4
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 8003bac:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 8003bb0:	604a      	str	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 8003bb2:	d105      	bne.n	8003bc0 <UART_AdvFeatureConfig+0x94>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 8003bb4:	684a      	ldr	r2, [r1, #4]
 8003bb6:	6c44      	ldr	r4, [r0, #68]	; 0x44
 8003bb8:	f422 02c0 	bic.w	r2, r2, #6291456	; 0x600000
 8003bbc:	4322      	orrs	r2, r4
 8003bbe:	604a      	str	r2, [r1, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 8003bc0:	061b      	lsls	r3, r3, #24
 8003bc2:	d506      	bpl.n	8003bd2 <UART_AdvFeatureConfig+0xa6>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 8003bc4:	6802      	ldr	r2, [r0, #0]
 8003bc6:	6c81      	ldr	r1, [r0, #72]	; 0x48
 8003bc8:	6853      	ldr	r3, [r2, #4]
 8003bca:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 8003bce:	430b      	orrs	r3, r1
 8003bd0:	6053      	str	r3, [r2, #4]
 8003bd2:	bd10      	pop	{r4, pc}

08003bd4 <UART_WaitOnFlagUntilTimeout>:
  * @param Tickstart Tick start value
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
{
 8003bd4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8003bd8:	9d06      	ldr	r5, [sp, #24]
 8003bda:	4604      	mov	r4, r0
 8003bdc:	460f      	mov	r7, r1
 8003bde:	4616      	mov	r6, r2
 8003be0:	4698      	mov	r8, r3
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8003be2:	6821      	ldr	r1, [r4, #0]
 8003be4:	69ca      	ldr	r2, [r1, #28]
 8003be6:	ea37 0302 	bics.w	r3, r7, r2
 8003bea:	bf0c      	ite	eq
 8003bec:	2201      	moveq	r2, #1
 8003bee:	2200      	movne	r2, #0
 8003bf0:	42b2      	cmp	r2, r6
 8003bf2:	d002      	beq.n	8003bfa <UART_WaitOnFlagUntilTimeout+0x26>

        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;
 8003bf4:	2000      	movs	r0, #0
}
 8003bf6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (Timeout != HAL_MAX_DELAY)
 8003bfa:	1c6b      	adds	r3, r5, #1
 8003bfc:	d0f2      	beq.n	8003be4 <UART_WaitOnFlagUntilTimeout+0x10>
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) > Timeout))
 8003bfe:	b99d      	cbnz	r5, 8003c28 <UART_WaitOnFlagUntilTimeout+0x54>
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 8003c00:	6823      	ldr	r3, [r4, #0]
 8003c02:	681a      	ldr	r2, [r3, #0]
 8003c04:	f422 72d0 	bic.w	r2, r2, #416	; 0x1a0
 8003c08:	601a      	str	r2, [r3, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8003c0a:	689a      	ldr	r2, [r3, #8]
 8003c0c:	f022 0201 	bic.w	r2, r2, #1
 8003c10:	609a      	str	r2, [r3, #8]
        huart->gState = HAL_UART_STATE_READY;
 8003c12:	2320      	movs	r3, #32
 8003c14:	f884 3071 	strb.w	r3, [r4, #113]	; 0x71
        huart->RxState = HAL_UART_STATE_READY;
 8003c18:	f884 3072 	strb.w	r3, [r4, #114]	; 0x72
        __HAL_UNLOCK(huart);
 8003c1c:	2300      	movs	r3, #0
 8003c1e:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
 8003c22:	2003      	movs	r0, #3
 8003c24:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) > Timeout))
 8003c28:	f7fd f9d2 	bl	8000fd0 <HAL_GetTick>
 8003c2c:	eba0 0008 	sub.w	r0, r0, r8
 8003c30:	4285      	cmp	r5, r0
 8003c32:	d2d6      	bcs.n	8003be2 <UART_WaitOnFlagUntilTimeout+0xe>
 8003c34:	e7e4      	b.n	8003c00 <UART_WaitOnFlagUntilTimeout+0x2c>

08003c36 <HAL_UART_Transmit>:
{
 8003c36:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 8003c3a:	461f      	mov	r7, r3
  if (huart->gState == HAL_UART_STATE_READY)
 8003c3c:	f890 3071 	ldrb.w	r3, [r0, #113]	; 0x71
 8003c40:	2b20      	cmp	r3, #32
{
 8003c42:	4604      	mov	r4, r0
 8003c44:	460d      	mov	r5, r1
 8003c46:	4690      	mov	r8, r2
  if (huart->gState == HAL_UART_STATE_READY)
 8003c48:	d14a      	bne.n	8003ce0 <HAL_UART_Transmit+0xaa>
    if ((pData == NULL) || (Size == 0U))
 8003c4a:	2900      	cmp	r1, #0
 8003c4c:	d046      	beq.n	8003cdc <HAL_UART_Transmit+0xa6>
 8003c4e:	2a00      	cmp	r2, #0
 8003c50:	d044      	beq.n	8003cdc <HAL_UART_Transmit+0xa6>
    __HAL_LOCK(huart);
 8003c52:	f890 3070 	ldrb.w	r3, [r0, #112]	; 0x70
 8003c56:	2b01      	cmp	r3, #1
 8003c58:	d042      	beq.n	8003ce0 <HAL_UART_Transmit+0xaa>
 8003c5a:	2301      	movs	r3, #1
 8003c5c:	f880 3070 	strb.w	r3, [r0, #112]	; 0x70
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8003c60:	2300      	movs	r3, #0
 8003c62:	6743      	str	r3, [r0, #116]	; 0x74
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8003c64:	2321      	movs	r3, #33	; 0x21
 8003c66:	f880 3071 	strb.w	r3, [r0, #113]	; 0x71
    tickstart = HAL_GetTick();
 8003c6a:	f7fd f9b1 	bl	8000fd0 <HAL_GetTick>
    huart->TxXferSize  = Size;
 8003c6e:	f8a4 8050 	strh.w	r8, [r4, #80]	; 0x50
    tickstart = HAL_GetTick();
 8003c72:	4606      	mov	r6, r0
    huart->TxXferCount = Size;
 8003c74:	f8a4 8052 	strh.w	r8, [r4, #82]	; 0x52
    while (huart->TxXferCount > 0U)
 8003c78:	f8b4 2052 	ldrh.w	r2, [r4, #82]	; 0x52
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 8003c7c:	9700      	str	r7, [sp, #0]
    while (huart->TxXferCount > 0U)
 8003c7e:	b292      	uxth	r2, r2
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 8003c80:	4633      	mov	r3, r6
    while (huart->TxXferCount > 0U)
 8003c82:	b952      	cbnz	r2, 8003c9a <HAL_UART_Transmit+0x64>
    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 8003c84:	2140      	movs	r1, #64	; 0x40
 8003c86:	4620      	mov	r0, r4
 8003c88:	f7ff ffa4 	bl	8003bd4 <UART_WaitOnFlagUntilTimeout>
 8003c8c:	b958      	cbnz	r0, 8003ca6 <HAL_UART_Transmit+0x70>
    huart->gState = HAL_UART_STATE_READY;
 8003c8e:	2320      	movs	r3, #32
 8003c90:	f884 3071 	strb.w	r3, [r4, #113]	; 0x71
    __HAL_UNLOCK(huart);
 8003c94:	f884 0070 	strb.w	r0, [r4, #112]	; 0x70
    return HAL_OK;
 8003c98:	e006      	b.n	8003ca8 <HAL_UART_Transmit+0x72>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 8003c9a:	2200      	movs	r2, #0
 8003c9c:	2180      	movs	r1, #128	; 0x80
 8003c9e:	4620      	mov	r0, r4
 8003ca0:	f7ff ff98 	bl	8003bd4 <UART_WaitOnFlagUntilTimeout>
 8003ca4:	b118      	cbz	r0, 8003cae <HAL_UART_Transmit+0x78>
        return HAL_TIMEOUT;
 8003ca6:	2003      	movs	r0, #3
}
 8003ca8:	b002      	add	sp, #8
 8003caa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8003cae:	68a3      	ldr	r3, [r4, #8]
 8003cb0:	6822      	ldr	r2, [r4, #0]
 8003cb2:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8003cb6:	d10d      	bne.n	8003cd4 <HAL_UART_Transmit+0x9e>
 8003cb8:	6923      	ldr	r3, [r4, #16]
 8003cba:	b95b      	cbnz	r3, 8003cd4 <HAL_UART_Transmit+0x9e>
        huart->Instance->TDR = (*tmp & (uint16_t)0x01FFU);
 8003cbc:	f835 3b02 	ldrh.w	r3, [r5], #2
 8003cc0:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8003cc4:	8513      	strh	r3, [r2, #40]	; 0x28
      huart->TxXferCount--;
 8003cc6:	f8b4 3052 	ldrh.w	r3, [r4, #82]	; 0x52
 8003cca:	3b01      	subs	r3, #1
 8003ccc:	b29b      	uxth	r3, r3
 8003cce:	f8a4 3052 	strh.w	r3, [r4, #82]	; 0x52
 8003cd2:	e7d1      	b.n	8003c78 <HAL_UART_Transmit+0x42>
        huart->Instance->TDR = (*pData++ & (uint8_t)0xFFU);
 8003cd4:	782b      	ldrb	r3, [r5, #0]
 8003cd6:	8513      	strh	r3, [r2, #40]	; 0x28
 8003cd8:	3501      	adds	r5, #1
 8003cda:	e7f4      	b.n	8003cc6 <HAL_UART_Transmit+0x90>
      return  HAL_ERROR;
 8003cdc:	2001      	movs	r0, #1
 8003cde:	e7e3      	b.n	8003ca8 <HAL_UART_Transmit+0x72>
    return HAL_BUSY;
 8003ce0:	2002      	movs	r0, #2
 8003ce2:	e7e1      	b.n	8003ca8 <HAL_UART_Transmit+0x72>

08003ce4 <HAL_UART_Receive>:
{
 8003ce4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 8003ce8:	4698      	mov	r8, r3
  if (huart->RxState == HAL_UART_STATE_READY)
 8003cea:	f890 3072 	ldrb.w	r3, [r0, #114]	; 0x72
 8003cee:	2b20      	cmp	r3, #32
{
 8003cf0:	4604      	mov	r4, r0
 8003cf2:	460d      	mov	r5, r1
 8003cf4:	4616      	mov	r6, r2
  if (huart->RxState == HAL_UART_STATE_READY)
 8003cf6:	d160      	bne.n	8003dba <HAL_UART_Receive+0xd6>
    if ((pData == NULL) || (Size == 0U))
 8003cf8:	2900      	cmp	r1, #0
 8003cfa:	d05c      	beq.n	8003db6 <HAL_UART_Receive+0xd2>
 8003cfc:	2a00      	cmp	r2, #0
 8003cfe:	d05a      	beq.n	8003db6 <HAL_UART_Receive+0xd2>
    __HAL_LOCK(huart);
 8003d00:	f890 3070 	ldrb.w	r3, [r0, #112]	; 0x70
 8003d04:	2b01      	cmp	r3, #1
 8003d06:	d058      	beq.n	8003dba <HAL_UART_Receive+0xd6>
 8003d08:	2301      	movs	r3, #1
 8003d0a:	f880 3070 	strb.w	r3, [r0, #112]	; 0x70
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8003d0e:	2300      	movs	r3, #0
 8003d10:	6743      	str	r3, [r0, #116]	; 0x74
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 8003d12:	2322      	movs	r3, #34	; 0x22
 8003d14:	f880 3072 	strb.w	r3, [r0, #114]	; 0x72
    tickstart = HAL_GetTick();
 8003d18:	f7fd f95a 	bl	8000fd0 <HAL_GetTick>
    UART_MASK_COMPUTATION(huart);
 8003d1c:	68a3      	ldr	r3, [r4, #8]
    huart->RxXferSize  = Size;
 8003d1e:	f8a4 6058 	strh.w	r6, [r4, #88]	; 0x58
    UART_MASK_COMPUTATION(huart);
 8003d22:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    tickstart = HAL_GetTick();
 8003d26:	4607      	mov	r7, r0
    huart->RxXferCount = Size;
 8003d28:	f8a4 605a 	strh.w	r6, [r4, #90]	; 0x5a
    UART_MASK_COMPUTATION(huart);
 8003d2c:	d115      	bne.n	8003d5a <HAL_UART_Receive+0x76>
 8003d2e:	6923      	ldr	r3, [r4, #16]
 8003d30:	b98b      	cbnz	r3, 8003d56 <HAL_UART_Receive+0x72>
 8003d32:	f240 13ff 	movw	r3, #511	; 0x1ff
 8003d36:	f8a4 305c 	strh.w	r3, [r4, #92]	; 0x5c
    uhMask = huart->Mask;
 8003d3a:	f8b4 605c 	ldrh.w	r6, [r4, #92]	; 0x5c
    while (huart->RxXferCount > 0U)
 8003d3e:	f8b4 005a 	ldrh.w	r0, [r4, #90]	; 0x5a
 8003d42:	b280      	uxth	r0, r0
 8003d44:	b9b8      	cbnz	r0, 8003d76 <HAL_UART_Receive+0x92>
    huart->RxState = HAL_UART_STATE_READY;
 8003d46:	2320      	movs	r3, #32
 8003d48:	f884 3072 	strb.w	r3, [r4, #114]	; 0x72
    __HAL_UNLOCK(huart);
 8003d4c:	f884 0070 	strb.w	r0, [r4, #112]	; 0x70
}
 8003d50:	b002      	add	sp, #8
 8003d52:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    UART_MASK_COMPUTATION(huart);
 8003d56:	23ff      	movs	r3, #255	; 0xff
 8003d58:	e7ed      	b.n	8003d36 <HAL_UART_Receive+0x52>
 8003d5a:	b923      	cbnz	r3, 8003d66 <HAL_UART_Receive+0x82>
 8003d5c:	6923      	ldr	r3, [r4, #16]
 8003d5e:	2b00      	cmp	r3, #0
 8003d60:	d0f9      	beq.n	8003d56 <HAL_UART_Receive+0x72>
 8003d62:	237f      	movs	r3, #127	; 0x7f
 8003d64:	e7e7      	b.n	8003d36 <HAL_UART_Receive+0x52>
 8003d66:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8003d6a:	d1e6      	bne.n	8003d3a <HAL_UART_Receive+0x56>
 8003d6c:	6923      	ldr	r3, [r4, #16]
 8003d6e:	2b00      	cmp	r3, #0
 8003d70:	d0f7      	beq.n	8003d62 <HAL_UART_Receive+0x7e>
 8003d72:	233f      	movs	r3, #63	; 0x3f
 8003d74:	e7df      	b.n	8003d36 <HAL_UART_Receive+0x52>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
 8003d76:	f8cd 8000 	str.w	r8, [sp]
 8003d7a:	463b      	mov	r3, r7
 8003d7c:	2200      	movs	r2, #0
 8003d7e:	2120      	movs	r1, #32
 8003d80:	4620      	mov	r0, r4
 8003d82:	f7ff ff27 	bl	8003bd4 <UART_WaitOnFlagUntilTimeout>
 8003d86:	b9d0      	cbnz	r0, 8003dbe <HAL_UART_Receive+0xda>
      if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8003d88:	68a3      	ldr	r3, [r4, #8]
 8003d8a:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8003d8e:	6823      	ldr	r3, [r4, #0]
 8003d90:	d10c      	bne.n	8003dac <HAL_UART_Receive+0xc8>
 8003d92:	6922      	ldr	r2, [r4, #16]
 8003d94:	b952      	cbnz	r2, 8003dac <HAL_UART_Receive+0xc8>
        *tmp = (uint16_t)(huart->Instance->RDR & uhMask);
 8003d96:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8003d98:	4033      	ands	r3, r6
 8003d9a:	f825 3b02 	strh.w	r3, [r5], #2
      huart->RxXferCount--;
 8003d9e:	f8b4 305a 	ldrh.w	r3, [r4, #90]	; 0x5a
 8003da2:	3b01      	subs	r3, #1
 8003da4:	b29b      	uxth	r3, r3
 8003da6:	f8a4 305a 	strh.w	r3, [r4, #90]	; 0x5a
 8003daa:	e7c8      	b.n	8003d3e <HAL_UART_Receive+0x5a>
        *pData++ = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
 8003dac:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8003dae:	4033      	ands	r3, r6
 8003db0:	702b      	strb	r3, [r5, #0]
 8003db2:	3501      	adds	r5, #1
 8003db4:	e7f3      	b.n	8003d9e <HAL_UART_Receive+0xba>
      return  HAL_ERROR;
 8003db6:	2001      	movs	r0, #1
 8003db8:	e7ca      	b.n	8003d50 <HAL_UART_Receive+0x6c>
    return HAL_BUSY;
 8003dba:	2002      	movs	r0, #2
 8003dbc:	e7c8      	b.n	8003d50 <HAL_UART_Receive+0x6c>
        return HAL_TIMEOUT;
 8003dbe:	2003      	movs	r0, #3
 8003dc0:	e7c6      	b.n	8003d50 <HAL_UART_Receive+0x6c>

08003dc2 <UART_CheckIdleState>:
{
 8003dc2:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8003dc4:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8003dc6:	2600      	movs	r6, #0
 8003dc8:	6746      	str	r6, [r0, #116]	; 0x74
  tickstart = HAL_GetTick();
 8003dca:	f7fd f901 	bl	8000fd0 <HAL_GetTick>
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8003dce:	6823      	ldr	r3, [r4, #0]
 8003dd0:	681b      	ldr	r3, [r3, #0]
 8003dd2:	071a      	lsls	r2, r3, #28
  tickstart = HAL_GetTick();
 8003dd4:	4605      	mov	r5, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8003dd6:	d417      	bmi.n	8003e08 <UART_CheckIdleState+0x46>
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 8003dd8:	6823      	ldr	r3, [r4, #0]
 8003dda:	681b      	ldr	r3, [r3, #0]
 8003ddc:	075b      	lsls	r3, r3, #29
 8003dde:	d50a      	bpl.n	8003df6 <UART_CheckIdleState+0x34>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8003de0:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 8003de4:	9300      	str	r3, [sp, #0]
 8003de6:	2200      	movs	r2, #0
 8003de8:	462b      	mov	r3, r5
 8003dea:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 8003dee:	4620      	mov	r0, r4
 8003df0:	f7ff fef0 	bl	8003bd4 <UART_WaitOnFlagUntilTimeout>
 8003df4:	b9a0      	cbnz	r0, 8003e20 <UART_CheckIdleState+0x5e>
  huart->gState = HAL_UART_STATE_READY;
 8003df6:	2320      	movs	r3, #32
  __HAL_UNLOCK(huart);
 8003df8:	2000      	movs	r0, #0
  huart->gState = HAL_UART_STATE_READY;
 8003dfa:	f884 3071 	strb.w	r3, [r4, #113]	; 0x71
  __HAL_UNLOCK(huart);
 8003dfe:	f884 0070 	strb.w	r0, [r4, #112]	; 0x70
  huart->RxState = HAL_UART_STATE_READY;
 8003e02:	f884 3072 	strb.w	r3, [r4, #114]	; 0x72
  return HAL_OK;
 8003e06:	e00c      	b.n	8003e22 <UART_CheckIdleState+0x60>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8003e08:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 8003e0c:	9300      	str	r3, [sp, #0]
 8003e0e:	4632      	mov	r2, r6
 8003e10:	4603      	mov	r3, r0
 8003e12:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 8003e16:	4620      	mov	r0, r4
 8003e18:	f7ff fedc 	bl	8003bd4 <UART_WaitOnFlagUntilTimeout>
 8003e1c:	2800      	cmp	r0, #0
 8003e1e:	d0db      	beq.n	8003dd8 <UART_CheckIdleState+0x16>
      return HAL_TIMEOUT;
 8003e20:	2003      	movs	r0, #3
}
 8003e22:	b002      	add	sp, #8
 8003e24:	bd70      	pop	{r4, r5, r6, pc}

08003e26 <HAL_UART_Init>:
{
 8003e26:	b510      	push	{r4, lr}
  if (huart == NULL)
 8003e28:	4604      	mov	r4, r0
 8003e2a:	b360      	cbz	r0, 8003e86 <HAL_UART_Init+0x60>
  if (huart->gState == HAL_UART_STATE_RESET)
 8003e2c:	f890 3071 	ldrb.w	r3, [r0, #113]	; 0x71
 8003e30:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8003e34:	b91b      	cbnz	r3, 8003e3e <HAL_UART_Init+0x18>
    huart->Lock = HAL_UNLOCKED;
 8003e36:	f880 2070 	strb.w	r2, [r0, #112]	; 0x70
    HAL_UART_MspInit(huart);
 8003e3a:	f003 fb09 	bl	8007450 <HAL_UART_MspInit>
  __HAL_UART_DISABLE(huart);
 8003e3e:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 8003e40:	2324      	movs	r3, #36	; 0x24
 8003e42:	f884 3071 	strb.w	r3, [r4, #113]	; 0x71
  __HAL_UART_DISABLE(huart);
 8003e46:	6813      	ldr	r3, [r2, #0]
 8003e48:	f023 0301 	bic.w	r3, r3, #1
 8003e4c:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 8003e4e:	4620      	mov	r0, r4
 8003e50:	f7ff fcd4 	bl	80037fc <UART_SetConfig>
 8003e54:	2801      	cmp	r0, #1
 8003e56:	d016      	beq.n	8003e86 <HAL_UART_Init+0x60>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 8003e58:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8003e5a:	b113      	cbz	r3, 8003e62 <HAL_UART_Init+0x3c>
    UART_AdvFeatureConfig(huart);
 8003e5c:	4620      	mov	r0, r4
 8003e5e:	f7ff fe65 	bl	8003b2c <UART_AdvFeatureConfig>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8003e62:	6823      	ldr	r3, [r4, #0]
 8003e64:	685a      	ldr	r2, [r3, #4]
 8003e66:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 8003e6a:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8003e6c:	689a      	ldr	r2, [r3, #8]
 8003e6e:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 8003e72:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
 8003e74:	681a      	ldr	r2, [r3, #0]
 8003e76:	f042 0201 	orr.w	r2, r2, #1
  return (UART_CheckIdleState(huart));
 8003e7a:	4620      	mov	r0, r4
  __HAL_UART_ENABLE(huart);
 8003e7c:	601a      	str	r2, [r3, #0]
}
 8003e7e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  return (UART_CheckIdleState(huart));
 8003e82:	f7ff bf9e 	b.w	8003dc2 <UART_CheckIdleState>
}
 8003e86:	2001      	movs	r0, #1
 8003e88:	bd10      	pop	{r4, pc}

08003e8a <osKernelStart>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval status code that indicates the execution status of the function
* @note   MUST REMAIN UNCHANGED: \b osKernelStart shall be consistent in every CMSIS-RTOS.
*/
osStatus osKernelStart (void)
{
 8003e8a:	b508      	push	{r3, lr}
  vTaskStartScheduler();
 8003e8c:	f000 fc9e 	bl	80047cc <vTaskStartScheduler>
  
  return osOK;
}
 8003e90:	2000      	movs	r0, #0
 8003e92:	bd08      	pop	{r3, pc}

08003e94 <osThreadCreate>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval thread ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osThreadCreate shall be consistent in every CMSIS-RTOS.
*/
osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument)
{
 8003e94:	b530      	push	{r4, r5, lr}

    handle = xTaskCreateStatic((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
              thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
              thread_def->buffer, thread_def->controlblock);
#else
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 8003e96:	f9b0 4008 	ldrsh.w	r4, [r0, #8]
 8003e9a:	8a02      	ldrh	r2, [r0, #16]
{
 8003e9c:	460b      	mov	r3, r1
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 8003e9e:	e890 0022 	ldmia.w	r0, {r1, r5}
{
 8003ea2:	b085      	sub	sp, #20
  if (priority != osPriorityError) {
 8003ea4:	2c84      	cmp	r4, #132	; 0x84
    fpriority += (priority - osPriorityIdle);
 8003ea6:	bf14      	ite	ne
 8003ea8:	3403      	addne	r4, #3
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
 8003eaa:	2400      	moveq	r4, #0
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 8003eac:	a803      	add	r0, sp, #12
 8003eae:	9001      	str	r0, [sp, #4]
 8003eb0:	9400      	str	r4, [sp, #0]
 8003eb2:	4628      	mov	r0, r5
 8003eb4:	f000 fb78 	bl	80045a8 <xTaskCreate>
 8003eb8:	2801      	cmp	r0, #1
                   &handle) != pdPASS)  {
    return NULL;
  }     
#endif
  
  return handle;
 8003eba:	bf0c      	ite	eq
 8003ebc:	9803      	ldreq	r0, [sp, #12]
    return NULL;
 8003ebe:	2000      	movne	r0, #0
}
 8003ec0:	b005      	add	sp, #20
 8003ec2:	bd30      	pop	{r4, r5, pc}

08003ec4 <osDelay>:
* @brief   Wait for Timeout (Time Delay)
* @param   millisec      time delay value
* @retval  status code that indicates the execution status of the function.
*/
osStatus osDelay (uint32_t millisec)
{
 8003ec4:	b508      	push	{r3, lr}
#if INCLUDE_vTaskDelay
  TickType_t ticks = millisec / portTICK_PERIOD_MS;
  
  vTaskDelay(ticks ? ticks : 1);          /* Minimum delay = 1 tick */
 8003ec6:	2800      	cmp	r0, #0
 8003ec8:	bf08      	it	eq
 8003eca:	2001      	moveq	r0, #1
 8003ecc:	f000 fdcc 	bl	8004a68 <vTaskDelay>
#else
  (void) millisec;
  
  return osErrorResource;
#endif
}
 8003ed0:	2000      	movs	r0, #0
 8003ed2:	bd08      	pop	{r3, pc}

08003ed4 <osSystickHandler>:
* @brief  Handles the tick increment
* @param  none.
* @retval none.
*/
void osSystickHandler(void)
{
 8003ed4:	b508      	push	{r3, lr}

#if (INCLUDE_xTaskGetSchedulerState  == 1 )
  if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)
 8003ed6:	f000 fe91 	bl	8004bfc <xTaskGetSchedulerState>
 8003eda:	2801      	cmp	r0, #1
 8003edc:	d003      	beq.n	8003ee6 <osSystickHandler+0x12>
#endif  /* INCLUDE_xTaskGetSchedulerState */  
    xPortSysTickHandler();
#if (INCLUDE_xTaskGetSchedulerState  == 1 )
  }
#endif  /* INCLUDE_xTaskGetSchedulerState */  
}
 8003ede:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    xPortSysTickHandler();
 8003ee2:	f000 b917 	b.w	8004114 <xPortSysTickHandler>
 8003ee6:	bd08      	pop	{r3, pc}

08003ee8 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8003ee8:	f100 0308 	add.w	r3, r0, #8
 8003eec:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8003eee:	f04f 32ff 	mov.w	r2, #4294967295

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8003ef2:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8003ef4:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8003ef6:	2300      	movs	r3, #0
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8003ef8:	6082      	str	r2, [r0, #8]
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8003efa:	6003      	str	r3, [r0, #0]
 8003efc:	4770      	bx	lr

08003efe <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 8003efe:	2300      	movs	r3, #0
 8003f00:	6103      	str	r3, [r0, #16]
 8003f02:	4770      	bx	lr

08003f04 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 8003f04:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 8003f06:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8003f08:	689a      	ldr	r2, [r3, #8]
 8003f0a:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8003f0c:	689a      	ldr	r2, [r3, #8]
 8003f0e:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
 8003f10:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8003f12:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = ( void * ) pxList;
 8003f14:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 8003f16:	3301      	adds	r3, #1
 8003f18:	6003      	str	r3, [r0, #0]
 8003f1a:	4770      	bx	lr

08003f1c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 8003f1c:	680a      	ldr	r2, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8003f1e:	1c53      	adds	r3, r2, #1
{
 8003f20:	b530      	push	{r4, r5, lr}
	if( xValueOfInsertion == portMAX_DELAY )
 8003f22:	d10a      	bne.n	8003f3a <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 8003f24:	6903      	ldr	r3, [r0, #16]
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 8003f26:	685a      	ldr	r2, [r3, #4]
 8003f28:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 8003f2a:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
 8003f2c:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 8003f2e:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8003f30:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = ( void * ) pxList;
 8003f32:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 8003f34:	3301      	adds	r3, #1
 8003f36:	6003      	str	r3, [r0, #0]
 8003f38:	bd30      	pop	{r4, r5, pc}
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8003f3a:	f100 0308 	add.w	r3, r0, #8
 8003f3e:	685c      	ldr	r4, [r3, #4]
 8003f40:	6825      	ldr	r5, [r4, #0]
 8003f42:	42aa      	cmp	r2, r5
 8003f44:	d3ef      	bcc.n	8003f26 <vListInsert+0xa>
 8003f46:	4623      	mov	r3, r4
 8003f48:	e7f9      	b.n	8003f3e <vListInsert+0x22>

08003f4a <uxListRemove>:
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8003f4a:	6841      	ldr	r1, [r0, #4]
 8003f4c:	6882      	ldr	r2, [r0, #8]
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 8003f4e:	6903      	ldr	r3, [r0, #16]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8003f50:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8003f52:	6882      	ldr	r2, [r0, #8]
 8003f54:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8003f56:	6859      	ldr	r1, [r3, #4]
 8003f58:	4288      	cmp	r0, r1
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8003f5a:	bf08      	it	eq
 8003f5c:	605a      	streq	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 8003f5e:	2200      	movs	r2, #0
 8003f60:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 8003f62:	681a      	ldr	r2, [r3, #0]
 8003f64:	3a01      	subs	r2, #1
 8003f66:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
 8003f68:	6818      	ldr	r0, [r3, #0]
}
 8003f6a:	4770      	bx	lr

08003f6c <prvTaskExitError>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
 8003f6c:	b082      	sub	sp, #8
volatile uint32_t ulDummy = 0;
 8003f6e:	2300      	movs	r3, #0
 8003f70:	9301      	str	r3, [sp, #4]
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 8003f72:	4b0d      	ldr	r3, [pc, #52]	; (8003fa8 <prvTaskExitError+0x3c>)
 8003f74:	681b      	ldr	r3, [r3, #0]
 8003f76:	3301      	adds	r3, #1
 8003f78:	d008      	beq.n	8003f8c <prvTaskExitError+0x20>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 8003f7a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003f7e:	f383 8811 	msr	BASEPRI, r3
 8003f82:	f3bf 8f6f 	isb	sy
 8003f86:	f3bf 8f4f 	dsb	sy
 8003f8a:	e7fe      	b.n	8003f8a <prvTaskExitError+0x1e>
 8003f8c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003f90:	f383 8811 	msr	BASEPRI, r3
 8003f94:	f3bf 8f6f 	isb	sy
 8003f98:	f3bf 8f4f 	dsb	sy
	portDISABLE_INTERRUPTS();
	while( ulDummy == 0 )
 8003f9c:	9b01      	ldr	r3, [sp, #4]
 8003f9e:	2b00      	cmp	r3, #0
 8003fa0:	d0fc      	beq.n	8003f9c <prvTaskExitError+0x30>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
 8003fa2:	b002      	add	sp, #8
 8003fa4:	4770      	bx	lr
 8003fa6:	bf00      	nop
 8003fa8:	20000000 	.word	0x20000000

08003fac <prvPortStartFirstTask>:
{
	/* Start the first task.  This also clears the bit that indicates the FPU is
	in use in case the FPU was used before the scheduler was started - which
	would otherwise result in the unnecessary leaving of space in the SVC stack
	for lazy saving of FPU registers. */
	__asm volatile(
 8003fac:	4808      	ldr	r0, [pc, #32]	; (8003fd0 <prvPortStartFirstTask+0x24>)
 8003fae:	6800      	ldr	r0, [r0, #0]
 8003fb0:	6800      	ldr	r0, [r0, #0]
 8003fb2:	f380 8808 	msr	MSP, r0
 8003fb6:	f04f 0000 	mov.w	r0, #0
 8003fba:	f380 8814 	msr	CONTROL, r0
 8003fbe:	b662      	cpsie	i
 8003fc0:	b661      	cpsie	f
 8003fc2:	f3bf 8f4f 	dsb	sy
 8003fc6:	f3bf 8f6f 	isb	sy
 8003fca:	df00      	svc	0
 8003fcc:	bf00      	nop
 8003fce:	0000      	.short	0x0000
 8003fd0:	e000ed08 	.word	0xe000ed08

08003fd4 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
 8003fd4:	f8df 000c 	ldr.w	r0, [pc, #12]	; 8003fe4 <vPortEnableVFP+0x10>
 8003fd8:	6801      	ldr	r1, [r0, #0]
 8003fda:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8003fde:	6001      	str	r1, [r0, #0]
 8003fe0:	4770      	bx	lr
 8003fe2:	0000      	.short	0x0000
 8003fe4:	e000ed88 	.word	0xe000ed88

08003fe8 <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 8003fe8:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8003fec:	f840 3c04 	str.w	r3, [r0, #-4]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 8003ff0:	4b07      	ldr	r3, [pc, #28]	; (8004010 <pxPortInitialiseStack+0x28>)
 8003ff2:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 8003ff6:	f021 0101 	bic.w	r1, r1, #1
	*pxTopOfStack = portINITIAL_EXC_RETURN;
 8003ffa:	f06f 0302 	mvn.w	r3, #2
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 8003ffe:	f840 1c08 	str.w	r1, [r0, #-8]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 8004002:	f840 2c20 	str.w	r2, [r0, #-32]
	*pxTopOfStack = portINITIAL_EXC_RETURN;
 8004006:	f840 3c24 	str.w	r3, [r0, #-36]
}
 800400a:	3844      	subs	r0, #68	; 0x44
 800400c:	4770      	bx	lr
 800400e:	bf00      	nop
 8004010:	08003f6d 	.word	0x08003f6d
	...

08004020 <SVC_Handler>:
	__asm volatile (
 8004020:	4b07      	ldr	r3, [pc, #28]	; (8004040 <pxCurrentTCBConst2>)
 8004022:	6819      	ldr	r1, [r3, #0]
 8004024:	6808      	ldr	r0, [r1, #0]
 8004026:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800402a:	f380 8809 	msr	PSP, r0
 800402e:	f3bf 8f6f 	isb	sy
 8004032:	f04f 0000 	mov.w	r0, #0
 8004036:	f380 8811 	msr	BASEPRI, r0
 800403a:	4770      	bx	lr
 800403c:	f3af 8000 	nop.w

08004040 <pxCurrentTCBConst2>:
 8004040:	20007f08 	.word	0x20007f08

08004044 <vPortEnterCritical>:
 8004044:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004048:	f383 8811 	msr	BASEPRI, r3
 800404c:	f3bf 8f6f 	isb	sy
 8004050:	f3bf 8f4f 	dsb	sy
	uxCriticalNesting++;
 8004054:	4a0a      	ldr	r2, [pc, #40]	; (8004080 <vPortEnterCritical+0x3c>)
 8004056:	6813      	ldr	r3, [r2, #0]
 8004058:	3301      	adds	r3, #1
	if( uxCriticalNesting == 1 )
 800405a:	2b01      	cmp	r3, #1
	uxCriticalNesting++;
 800405c:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 1 )
 800405e:	d10d      	bne.n	800407c <vPortEnterCritical+0x38>
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 8004060:	4b08      	ldr	r3, [pc, #32]	; (8004084 <vPortEnterCritical+0x40>)
 8004062:	681b      	ldr	r3, [r3, #0]
 8004064:	f013 0fff 	tst.w	r3, #255	; 0xff
 8004068:	d008      	beq.n	800407c <vPortEnterCritical+0x38>
 800406a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800406e:	f383 8811 	msr	BASEPRI, r3
 8004072:	f3bf 8f6f 	isb	sy
 8004076:	f3bf 8f4f 	dsb	sy
 800407a:	e7fe      	b.n	800407a <vPortEnterCritical+0x36>
 800407c:	4770      	bx	lr
 800407e:	bf00      	nop
 8004080:	20000000 	.word	0x20000000
 8004084:	e000ed04 	.word	0xe000ed04

08004088 <vPortExitCritical>:
	configASSERT( uxCriticalNesting );
 8004088:	4a08      	ldr	r2, [pc, #32]	; (80040ac <vPortExitCritical+0x24>)
 800408a:	6813      	ldr	r3, [r2, #0]
 800408c:	b943      	cbnz	r3, 80040a0 <vPortExitCritical+0x18>
 800408e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004092:	f383 8811 	msr	BASEPRI, r3
 8004096:	f3bf 8f6f 	isb	sy
 800409a:	f3bf 8f4f 	dsb	sy
 800409e:	e7fe      	b.n	800409e <vPortExitCritical+0x16>
	uxCriticalNesting--;
 80040a0:	3b01      	subs	r3, #1
 80040a2:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 80040a4:	b90b      	cbnz	r3, 80040aa <vPortExitCritical+0x22>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 80040a6:	f383 8811 	msr	BASEPRI, r3
 80040aa:	4770      	bx	lr
 80040ac:	20000000 	.word	0x20000000

080040b0 <PendSV_Handler>:
	__asm volatile
 80040b0:	f3ef 8009 	mrs	r0, PSP
 80040b4:	f3bf 8f6f 	isb	sy
 80040b8:	4b15      	ldr	r3, [pc, #84]	; (8004110 <pxCurrentTCBConst>)
 80040ba:	681a      	ldr	r2, [r3, #0]
 80040bc:	f01e 0f10 	tst.w	lr, #16
 80040c0:	bf08      	it	eq
 80040c2:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 80040c6:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80040ca:	6010      	str	r0, [r2, #0]
 80040cc:	e92d 0009 	stmdb	sp!, {r0, r3}
 80040d0:	f04f 0050 	mov.w	r0, #80	; 0x50
 80040d4:	f380 8811 	msr	BASEPRI, r0
 80040d8:	f3bf 8f4f 	dsb	sy
 80040dc:	f3bf 8f6f 	isb	sy
 80040e0:	f000 fce6 	bl	8004ab0 <vTaskSwitchContext>
 80040e4:	f04f 0000 	mov.w	r0, #0
 80040e8:	f380 8811 	msr	BASEPRI, r0
 80040ec:	bc09      	pop	{r0, r3}
 80040ee:	6819      	ldr	r1, [r3, #0]
 80040f0:	6808      	ldr	r0, [r1, #0]
 80040f2:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80040f6:	f01e 0f10 	tst.w	lr, #16
 80040fa:	bf08      	it	eq
 80040fc:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 8004100:	f380 8809 	msr	PSP, r0
 8004104:	f3bf 8f6f 	isb	sy
 8004108:	4770      	bx	lr
 800410a:	bf00      	nop
 800410c:	f3af 8000 	nop.w

08004110 <pxCurrentTCBConst>:
 8004110:	20007f08 	.word	0x20007f08

08004114 <xPortSysTickHandler>:
{
 8004114:	b508      	push	{r3, lr}
	__asm volatile
 8004116:	f04f 0350 	mov.w	r3, #80	; 0x50
 800411a:	f383 8811 	msr	BASEPRI, r3
 800411e:	f3bf 8f6f 	isb	sy
 8004122:	f3bf 8f4f 	dsb	sy
		if( xTaskIncrementTick() != pdFALSE )
 8004126:	f000 fb95 	bl	8004854 <xTaskIncrementTick>
 800412a:	b118      	cbz	r0, 8004134 <xPortSysTickHandler+0x20>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 800412c:	4b03      	ldr	r3, [pc, #12]	; (800413c <xPortSysTickHandler+0x28>)
 800412e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004132:	601a      	str	r2, [r3, #0]
	__asm volatile
 8004134:	2300      	movs	r3, #0
 8004136:	f383 8811 	msr	BASEPRI, r3
 800413a:	bd08      	pop	{r3, pc}
 800413c:	e000ed04 	.word	0xe000ed04

08004140 <vPortSetupTimerInterrupt>:
	portNVIC_SYSTICK_CTRL_REG = 0UL;
 8004140:	4a08      	ldr	r2, [pc, #32]	; (8004164 <vPortSetupTimerInterrupt+0x24>)
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 8004142:	4909      	ldr	r1, [pc, #36]	; (8004168 <vPortSetupTimerInterrupt+0x28>)
	portNVIC_SYSTICK_CTRL_REG = 0UL;
 8004144:	2300      	movs	r3, #0
 8004146:	6013      	str	r3, [r2, #0]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 8004148:	600b      	str	r3, [r1, #0]
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 800414a:	4b08      	ldr	r3, [pc, #32]	; (800416c <vPortSetupTimerInterrupt+0x2c>)
 800414c:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8004150:	681b      	ldr	r3, [r3, #0]
 8004152:	fbb3 f3f1 	udiv	r3, r3, r1
 8004156:	4906      	ldr	r1, [pc, #24]	; (8004170 <vPortSetupTimerInterrupt+0x30>)
 8004158:	3b01      	subs	r3, #1
 800415a:	600b      	str	r3, [r1, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 800415c:	2307      	movs	r3, #7
 800415e:	6013      	str	r3, [r2, #0]
 8004160:	4770      	bx	lr
 8004162:	bf00      	nop
 8004164:	e000e010 	.word	0xe000e010
 8004168:	e000e018 	.word	0xe000e018
 800416c:	20000058 	.word	0x20000058
 8004170:	e000e014 	.word	0xe000e014

08004174 <xPortStartScheduler>:
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 8004174:	4b39      	ldr	r3, [pc, #228]	; (800425c <xPortStartScheduler+0xe8>)
 8004176:	4a3a      	ldr	r2, [pc, #232]	; (8004260 <xPortStartScheduler+0xec>)
{
 8004178:	b513      	push	{r0, r1, r4, lr}
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 800417a:	6819      	ldr	r1, [r3, #0]
 800417c:	4291      	cmp	r1, r2
 800417e:	d108      	bne.n	8004192 <xPortStartScheduler+0x1e>
	__asm volatile
 8004180:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004184:	f383 8811 	msr	BASEPRI, r3
 8004188:	f3bf 8f6f 	isb	sy
 800418c:	f3bf 8f4f 	dsb	sy
 8004190:	e7fe      	b.n	8004190 <xPortStartScheduler+0x1c>
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
 8004192:	681a      	ldr	r2, [r3, #0]
 8004194:	4b33      	ldr	r3, [pc, #204]	; (8004264 <xPortStartScheduler+0xf0>)
 8004196:	429a      	cmp	r2, r3
 8004198:	d108      	bne.n	80041ac <xPortStartScheduler+0x38>
 800419a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800419e:	f383 8811 	msr	BASEPRI, r3
 80041a2:	f3bf 8f6f 	isb	sy
 80041a6:	f3bf 8f4f 	dsb	sy
 80041aa:	e7fe      	b.n	80041aa <xPortStartScheduler+0x36>
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 80041ac:	4b2e      	ldr	r3, [pc, #184]	; (8004268 <xPortStartScheduler+0xf4>)
 80041ae:	781a      	ldrb	r2, [r3, #0]
 80041b0:	b2d2      	uxtb	r2, r2
 80041b2:	9201      	str	r2, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 80041b4:	22ff      	movs	r2, #255	; 0xff
 80041b6:	701a      	strb	r2, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 80041b8:	781b      	ldrb	r3, [r3, #0]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 80041ba:	4a2c      	ldr	r2, [pc, #176]	; (800426c <xPortStartScheduler+0xf8>)
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 80041bc:	b2db      	uxtb	r3, r3
 80041be:	f88d 3003 	strb.w	r3, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 80041c2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80041c6:	f003 0350 	and.w	r3, r3, #80	; 0x50
 80041ca:	7013      	strb	r3, [r2, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 80041cc:	4b28      	ldr	r3, [pc, #160]	; (8004270 <xPortStartScheduler+0xfc>)
 80041ce:	2207      	movs	r2, #7
 80041d0:	601a      	str	r2, [r3, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 80041d2:	2100      	movs	r1, #0
 80041d4:	f89d 0003 	ldrb.w	r0, [sp, #3]
 80041d8:	0600      	lsls	r0, r0, #24
 80041da:	f102 34ff 	add.w	r4, r2, #4294967295
 80041de:	d40d      	bmi.n	80041fc <xPortStartScheduler+0x88>
 80041e0:	b101      	cbz	r1, 80041e4 <xPortStartScheduler+0x70>
 80041e2:	601a      	str	r2, [r3, #0]
			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
 80041e4:	681a      	ldr	r2, [r3, #0]
 80041e6:	2a03      	cmp	r2, #3
 80041e8:	d011      	beq.n	800420e <xPortStartScheduler+0x9a>
 80041ea:	f04f 0350 	mov.w	r3, #80	; 0x50
 80041ee:	f383 8811 	msr	BASEPRI, r3
 80041f2:	f3bf 8f6f 	isb	sy
 80041f6:	f3bf 8f4f 	dsb	sy
 80041fa:	e7fe      	b.n	80041fa <xPortStartScheduler+0x86>
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 80041fc:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8004200:	0052      	lsls	r2, r2, #1
 8004202:	b2d2      	uxtb	r2, r2
 8004204:	f88d 2003 	strb.w	r2, [sp, #3]
 8004208:	2101      	movs	r1, #1
 800420a:	4622      	mov	r2, r4
 800420c:	e7e2      	b.n	80041d4 <xPortStartScheduler+0x60>
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
 800420e:	0212      	lsls	r2, r2, #8
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 8004210:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 8004214:	601a      	str	r2, [r3, #0]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 8004216:	9b01      	ldr	r3, [sp, #4]
 8004218:	4a13      	ldr	r2, [pc, #76]	; (8004268 <xPortStartScheduler+0xf4>)
 800421a:	b2db      	uxtb	r3, r3
 800421c:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 800421e:	4b15      	ldr	r3, [pc, #84]	; (8004274 <xPortStartScheduler+0x100>)
 8004220:	681a      	ldr	r2, [r3, #0]
 8004222:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 8004226:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 8004228:	681a      	ldr	r2, [r3, #0]
 800422a:	f042 4270 	orr.w	r2, r2, #4026531840	; 0xf0000000
 800422e:	601a      	str	r2, [r3, #0]
	vPortSetupTimerInterrupt();
 8004230:	f7ff ff86 	bl	8004140 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
 8004234:	4b10      	ldr	r3, [pc, #64]	; (8004278 <xPortStartScheduler+0x104>)
 8004236:	2400      	movs	r4, #0
 8004238:	601c      	str	r4, [r3, #0]
	vPortEnableVFP();
 800423a:	f7ff fecb 	bl	8003fd4 <vPortEnableVFP>
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 800423e:	4a0f      	ldr	r2, [pc, #60]	; (800427c <xPortStartScheduler+0x108>)
 8004240:	6813      	ldr	r3, [r2, #0]
 8004242:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
 8004246:	6013      	str	r3, [r2, #0]
	prvPortStartFirstTask();
 8004248:	f7ff feb0 	bl	8003fac <prvPortStartFirstTask>
	vTaskSwitchContext();
 800424c:	f000 fc30 	bl	8004ab0 <vTaskSwitchContext>
	prvTaskExitError();
 8004250:	f7ff fe8c 	bl	8003f6c <prvTaskExitError>
}
 8004254:	4620      	mov	r0, r4
 8004256:	b002      	add	sp, #8
 8004258:	bd10      	pop	{r4, pc}
 800425a:	bf00      	nop
 800425c:	e000ed00 	.word	0xe000ed00
 8004260:	410fc271 	.word	0x410fc271
 8004264:	410fc270 	.word	0x410fc270
 8004268:	e000e400 	.word	0xe000e400
 800426c:	200006e8 	.word	0x200006e8
 8004270:	200006ec 	.word	0x200006ec
 8004274:	e000ed20 	.word	0xe000ed20
 8004278:	20000000 	.word	0x20000000
 800427c:	e000ef34 	.word	0xe000ef34

08004280 <prvInsertBlockIntoFreeList>:
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
 8004280:	b510      	push	{r4, lr}
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 8004282:	4b0f      	ldr	r3, [pc, #60]	; (80042c0 <prvInsertBlockIntoFreeList+0x40>)
 8004284:	681a      	ldr	r2, [r3, #0]
 8004286:	4282      	cmp	r2, r0
 8004288:	d318      	bcc.n	80042bc <prvInsertBlockIntoFreeList+0x3c>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 800428a:	685c      	ldr	r4, [r3, #4]
 800428c:	1919      	adds	r1, r3, r4
 800428e:	4288      	cmp	r0, r1
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 8004290:	bf01      	itttt	eq
 8004292:	6841      	ldreq	r1, [r0, #4]
 8004294:	4618      	moveq	r0, r3
 8004296:	1909      	addeq	r1, r1, r4
 8004298:	6059      	streq	r1, [r3, #4]
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 800429a:	6844      	ldr	r4, [r0, #4]
 800429c:	1901      	adds	r1, r0, r4
 800429e:	428a      	cmp	r2, r1
 80042a0:	d107      	bne.n	80042b2 <prvInsertBlockIntoFreeList+0x32>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
 80042a2:	4908      	ldr	r1, [pc, #32]	; (80042c4 <prvInsertBlockIntoFreeList+0x44>)
 80042a4:	6809      	ldr	r1, [r1, #0]
 80042a6:	428a      	cmp	r2, r1
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 80042a8:	bf1f      	itttt	ne
 80042aa:	6851      	ldrne	r1, [r2, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 80042ac:	6812      	ldrne	r2, [r2, #0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 80042ae:	1909      	addne	r1, r1, r4
 80042b0:	6041      	strne	r1, [r0, #4]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 80042b2:	4298      	cmp	r0, r3
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 80042b4:	6002      	str	r2, [r0, #0]
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 80042b6:	bf18      	it	ne
 80042b8:	6018      	strne	r0, [r3, #0]
 80042ba:	bd10      	pop	{r4, pc}
 80042bc:	4613      	mov	r3, r2
 80042be:	e7e1      	b.n	8004284 <prvInsertBlockIntoFreeList+0x4>
 80042c0:	20007f00 	.word	0x20007f00
 80042c4:	200006f0 	.word	0x200006f0

080042c8 <pvPortMalloc>:
{
 80042c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80042cc:	4604      	mov	r4, r0
	vTaskSuspendAll();
 80042ce:	f000 fab9 	bl	8004844 <vTaskSuspendAll>
		if( pxEnd == NULL )
 80042d2:	493e      	ldr	r1, [pc, #248]	; (80043cc <pvPortMalloc+0x104>)
 80042d4:	4d3e      	ldr	r5, [pc, #248]	; (80043d0 <pvPortMalloc+0x108>)
 80042d6:	680b      	ldr	r3, [r1, #0]
 80042d8:	bb0b      	cbnz	r3, 800431e <pvPortMalloc+0x56>
	uxAddress = ( size_t ) ucHeap;
 80042da:	4a3e      	ldr	r2, [pc, #248]	; (80043d4 <pvPortMalloc+0x10c>)
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 80042dc:	0756      	lsls	r6, r2, #29
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 80042de:	bf1f      	itttt	ne
 80042e0:	1dd0      	addne	r0, r2, #7
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 80042e2:	f020 0007 	bicne.w	r0, r0, #7
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 80042e6:	f502 43f0 	addne.w	r3, r2, #30720	; 0x7800
 80042ea:	1a1b      	subne	r3, r3, r0
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 80042ec:	bf14      	ite	ne
 80042ee:	4602      	movne	r2, r0
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
 80042f0:	f44f 43f0 	moveq.w	r3, #30720	; 0x7800
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
 80042f4:	4413      	add	r3, r2
	uxAddress -= xHeapStructSize;
 80042f6:	3b08      	subs	r3, #8
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 80042f8:	f023 0307 	bic.w	r3, r3, #7
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 80042fc:	4e36      	ldr	r6, [pc, #216]	; (80043d8 <pvPortMalloc+0x110>)
	pxEnd = ( void * ) uxAddress;
 80042fe:	600b      	str	r3, [r1, #0]
	xStart.xBlockSize = ( size_t ) 0;
 8004300:	2000      	movs	r0, #0
 8004302:	6070      	str	r0, [r6, #4]
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 8004304:	6032      	str	r2, [r6, #0]
	pxEnd->xBlockSize = 0;
 8004306:	6058      	str	r0, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
 8004308:	6018      	str	r0, [r3, #0]
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 800430a:	1a98      	subs	r0, r3, r2
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 800430c:	6013      	str	r3, [r2, #0]
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 800430e:	4b33      	ldr	r3, [pc, #204]	; (80043dc <pvPortMalloc+0x114>)
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 8004310:	6050      	str	r0, [r2, #4]
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8004312:	6018      	str	r0, [r3, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8004314:	4b32      	ldr	r3, [pc, #200]	; (80043e0 <pvPortMalloc+0x118>)
 8004316:	6018      	str	r0, [r3, #0]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 8004318:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 800431c:	602b      	str	r3, [r5, #0]
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 800431e:	682f      	ldr	r7, [r5, #0]
 8004320:	4227      	tst	r7, r4
 8004322:	d116      	bne.n	8004352 <pvPortMalloc+0x8a>
			if( xWantedSize > 0 )
 8004324:	2c00      	cmp	r4, #0
 8004326:	d041      	beq.n	80043ac <pvPortMalloc+0xe4>
				xWantedSize += xHeapStructSize;
 8004328:	f104 0308 	add.w	r3, r4, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 800432c:	0758      	lsls	r0, r3, #29
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 800432e:	bf1c      	itt	ne
 8004330:	f023 0307 	bicne.w	r3, r3, #7
 8004334:	3308      	addne	r3, #8
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 8004336:	b163      	cbz	r3, 8004352 <pvPortMalloc+0x8a>
 8004338:	4a29      	ldr	r2, [pc, #164]	; (80043e0 <pvPortMalloc+0x118>)
 800433a:	6816      	ldr	r6, [r2, #0]
 800433c:	42b3      	cmp	r3, r6
 800433e:	4690      	mov	r8, r2
 8004340:	d807      	bhi.n	8004352 <pvPortMalloc+0x8a>
				pxBlock = xStart.pxNextFreeBlock;
 8004342:	4a25      	ldr	r2, [pc, #148]	; (80043d8 <pvPortMalloc+0x110>)
 8004344:	6815      	ldr	r5, [r2, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8004346:	6868      	ldr	r0, [r5, #4]
 8004348:	4283      	cmp	r3, r0
 800434a:	d804      	bhi.n	8004356 <pvPortMalloc+0x8e>
				if( pxBlock != pxEnd )
 800434c:	6809      	ldr	r1, [r1, #0]
 800434e:	428d      	cmp	r5, r1
 8004350:	d107      	bne.n	8004362 <pvPortMalloc+0x9a>
void *pvReturn = NULL;
 8004352:	2400      	movs	r4, #0
 8004354:	e02a      	b.n	80043ac <pvPortMalloc+0xe4>
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8004356:	682c      	ldr	r4, [r5, #0]
 8004358:	2c00      	cmp	r4, #0
 800435a:	d0f7      	beq.n	800434c <pvPortMalloc+0x84>
 800435c:	462a      	mov	r2, r5
 800435e:	4625      	mov	r5, r4
 8004360:	e7f1      	b.n	8004346 <pvPortMalloc+0x7e>
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 8004362:	6829      	ldr	r1, [r5, #0]
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 8004364:	6814      	ldr	r4, [r2, #0]
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 8004366:	6011      	str	r1, [r2, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 8004368:	1ac2      	subs	r2, r0, r3
 800436a:	2a10      	cmp	r2, #16
 800436c:	d90f      	bls.n	800438e <pvPortMalloc+0xc6>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 800436e:	18e8      	adds	r0, r5, r3
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 8004370:	0741      	lsls	r1, r0, #29
 8004372:	d008      	beq.n	8004386 <pvPortMalloc+0xbe>
 8004374:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004378:	f383 8811 	msr	BASEPRI, r3
 800437c:	f3bf 8f6f 	isb	sy
 8004380:	f3bf 8f4f 	dsb	sy
 8004384:	e7fe      	b.n	8004384 <pvPortMalloc+0xbc>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 8004386:	6042      	str	r2, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
 8004388:	606b      	str	r3, [r5, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
 800438a:	f7ff ff79 	bl	8004280 <prvInsertBlockIntoFreeList>
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 800438e:	4913      	ldr	r1, [pc, #76]	; (80043dc <pvPortMalloc+0x114>)
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8004390:	686b      	ldr	r3, [r5, #4]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8004392:	6808      	ldr	r0, [r1, #0]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8004394:	1af6      	subs	r6, r6, r3
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 8004396:	431f      	orrs	r7, r3
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8004398:	4286      	cmp	r6, r0
					pxBlock->pxNextFreeBlock = NULL;
 800439a:	f04f 0300 	mov.w	r3, #0
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 800439e:	f8c8 6000 	str.w	r6, [r8]
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 80043a2:	bf38      	it	cc
 80043a4:	600e      	strcc	r6, [r1, #0]
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 80043a6:	3408      	adds	r4, #8
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 80043a8:	606f      	str	r7, [r5, #4]
					pxBlock->pxNextFreeBlock = NULL;
 80043aa:	602b      	str	r3, [r5, #0]
	( void ) xTaskResumeAll();
 80043ac:	f000 fae4 	bl	8004978 <xTaskResumeAll>
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 80043b0:	0763      	lsls	r3, r4, #29
 80043b2:	d008      	beq.n	80043c6 <pvPortMalloc+0xfe>
 80043b4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80043b8:	f383 8811 	msr	BASEPRI, r3
 80043bc:	f3bf 8f6f 	isb	sy
 80043c0:	f3bf 8f4f 	dsb	sy
 80043c4:	e7fe      	b.n	80043c4 <pvPortMalloc+0xfc>
}
 80043c6:	4620      	mov	r0, r4
 80043c8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80043cc:	200006f0 	.word	0x200006f0
 80043d0:	20007ef4 	.word	0x20007ef4
 80043d4:	200006f4 	.word	0x200006f4
 80043d8:	20007f00 	.word	0x20007f00
 80043dc:	20007efc 	.word	0x20007efc
 80043e0:	20007ef8 	.word	0x20007ef8

080043e4 <vPortFree>:
{
 80043e4:	b510      	push	{r4, lr}
	if( pv != NULL )
 80043e6:	4604      	mov	r4, r0
 80043e8:	b370      	cbz	r0, 8004448 <vPortFree+0x64>
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 80043ea:	4a18      	ldr	r2, [pc, #96]	; (800444c <vPortFree+0x68>)
 80043ec:	f850 3c04 	ldr.w	r3, [r0, #-4]
 80043f0:	6812      	ldr	r2, [r2, #0]
 80043f2:	4213      	tst	r3, r2
 80043f4:	d108      	bne.n	8004408 <vPortFree+0x24>
 80043f6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80043fa:	f383 8811 	msr	BASEPRI, r3
 80043fe:	f3bf 8f6f 	isb	sy
 8004402:	f3bf 8f4f 	dsb	sy
 8004406:	e7fe      	b.n	8004406 <vPortFree+0x22>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 8004408:	f850 1c08 	ldr.w	r1, [r0, #-8]
 800440c:	b141      	cbz	r1, 8004420 <vPortFree+0x3c>
 800440e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004412:	f383 8811 	msr	BASEPRI, r3
 8004416:	f3bf 8f6f 	isb	sy
 800441a:	f3bf 8f4f 	dsb	sy
 800441e:	e7fe      	b.n	800441e <vPortFree+0x3a>
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 8004420:	ea23 0302 	bic.w	r3, r3, r2
 8004424:	f840 3c04 	str.w	r3, [r0, #-4]
				vTaskSuspendAll();
 8004428:	f000 fa0c 	bl	8004844 <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
 800442c:	4a08      	ldr	r2, [pc, #32]	; (8004450 <vPortFree+0x6c>)
 800442e:	f854 3c04 	ldr.w	r3, [r4, #-4]
 8004432:	6811      	ldr	r1, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 8004434:	f1a4 0008 	sub.w	r0, r4, #8
					xFreeBytesRemaining += pxLink->xBlockSize;
 8004438:	440b      	add	r3, r1
 800443a:	6013      	str	r3, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 800443c:	f7ff ff20 	bl	8004280 <prvInsertBlockIntoFreeList>
}
 8004440:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
				( void ) xTaskResumeAll();
 8004444:	f000 ba98 	b.w	8004978 <xTaskResumeAll>
 8004448:	bd10      	pop	{r4, pc}
 800444a:	bf00      	nop
 800444c:	20007ef4 	.word	0x20007ef4
 8004450:	20007ef8 	.word	0x20007ef8

08004454 <prvTaskIsTaskSuspended>:

		/* Accesses xPendingReadyList so must be called from a critical
		section. */

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );
 8004454:	b940      	cbnz	r0, 8004468 <prvTaskIsTaskSuspended+0x14>
 8004456:	f04f 0350 	mov.w	r3, #80	; 0x50
 800445a:	f383 8811 	msr	BASEPRI, r3
 800445e:	f3bf 8f6f 	isb	sy
 8004462:	f3bf 8f4f 	dsb	sy
 8004466:	e7fe      	b.n	8004466 <prvTaskIsTaskSuspended+0x12>

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
 8004468:	6942      	ldr	r2, [r0, #20]
 800446a:	4b06      	ldr	r3, [pc, #24]	; (8004484 <prvTaskIsTaskSuspended+0x30>)
 800446c:	429a      	cmp	r2, r3
 800446e:	d001      	beq.n	8004474 <prvTaskIsTaskSuspended+0x20>
	BaseType_t xReturn = pdFALSE;
 8004470:	2000      	movs	r0, #0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 8004472:	4770      	bx	lr
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 8004474:	6a80      	ldr	r0, [r0, #40]	; 0x28
 8004476:	4b04      	ldr	r3, [pc, #16]	; (8004488 <prvTaskIsTaskSuspended+0x34>)
 8004478:	4298      	cmp	r0, r3
 800447a:	d0f9      	beq.n	8004470 <prvTaskIsTaskSuspended+0x1c>
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
 800447c:	fab0 f080 	clz	r0, r0
 8004480:	0940      	lsrs	r0, r0, #5
		return xReturn;
 8004482:	4770      	bx	lr
 8004484:	20008004 	.word	0x20008004
 8004488:	20007fec 	.word	0x20007fec

0800448c <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800448c:	4a06      	ldr	r2, [pc, #24]	; (80044a8 <prvResetNextTaskUnblockTime+0x1c>)
 800448e:	6813      	ldr	r3, [r2, #0]
 8004490:	6819      	ldr	r1, [r3, #0]
 8004492:	4b06      	ldr	r3, [pc, #24]	; (80044ac <prvResetNextTaskUnblockTime+0x20>)
 8004494:	b919      	cbnz	r1, 800449e <prvResetNextTaskUnblockTime+0x12>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 8004496:	f04f 32ff 	mov.w	r2, #4294967295
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 800449a:	601a      	str	r2, [r3, #0]
 800449c:	4770      	bx	lr
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 800449e:	6812      	ldr	r2, [r2, #0]
 80044a0:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 80044a2:	68d2      	ldr	r2, [r2, #12]
 80044a4:	6852      	ldr	r2, [r2, #4]
 80044a6:	e7f8      	b.n	800449a <prvResetNextTaskUnblockTime+0xe>
 80044a8:	20007f0c 	.word	0x20007f0c
 80044ac:	20007fe4 	.word	0x20007fe4

080044b0 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 80044b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 80044b2:	4b1b      	ldr	r3, [pc, #108]	; (8004520 <prvAddCurrentTaskToDelayedList+0x70>)
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80044b4:	4e1b      	ldr	r6, [pc, #108]	; (8004524 <prvAddCurrentTaskToDelayedList+0x74>)
const TickType_t xConstTickCount = xTickCount;
 80044b6:	681d      	ldr	r5, [r3, #0]
{
 80044b8:	4604      	mov	r4, r0
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80044ba:	6830      	ldr	r0, [r6, #0]
 80044bc:	3004      	adds	r0, #4
{
 80044be:	460f      	mov	r7, r1
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80044c0:	f7ff fd43 	bl	8003f4a <uxListRemove>
 80044c4:	4633      	mov	r3, r6
 80044c6:	b940      	cbnz	r0, 80044da <prvAddCurrentTaskToDelayedList+0x2a>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 80044c8:	6831      	ldr	r1, [r6, #0]
 80044ca:	4e17      	ldr	r6, [pc, #92]	; (8004528 <prvAddCurrentTaskToDelayedList+0x78>)
 80044cc:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 80044ce:	6832      	ldr	r2, [r6, #0]
 80044d0:	2001      	movs	r0, #1
 80044d2:	4088      	lsls	r0, r1
 80044d4:	ea22 0200 	bic.w	r2, r2, r0
 80044d8:	6032      	str	r2, [r6, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 80044da:	1c62      	adds	r2, r4, #1
 80044dc:	d107      	bne.n	80044ee <prvAddCurrentTaskToDelayedList+0x3e>
 80044de:	b137      	cbz	r7, 80044ee <prvAddCurrentTaskToDelayedList+0x3e>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80044e0:	6819      	ldr	r1, [r3, #0]
 80044e2:	4812      	ldr	r0, [pc, #72]	; (800452c <prvAddCurrentTaskToDelayedList+0x7c>)
 80044e4:	3104      	adds	r1, #4

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 80044e6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80044ea:	f7ff bd0b 	b.w	8003f04 <vListInsertEnd>
			xTimeToWake = xConstTickCount + xTicksToWait;
 80044ee:	442c      	add	r4, r5
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 80044f0:	681a      	ldr	r2, [r3, #0]
			if( xTimeToWake < xConstTickCount )
 80044f2:	42a5      	cmp	r5, r4
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 80044f4:	6054      	str	r4, [r2, #4]
			if( xTimeToWake < xConstTickCount )
 80044f6:	d907      	bls.n	8004508 <prvAddCurrentTaskToDelayedList+0x58>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80044f8:	4a0d      	ldr	r2, [pc, #52]	; (8004530 <prvAddCurrentTaskToDelayedList+0x80>)
 80044fa:	6810      	ldr	r0, [r2, #0]
 80044fc:	6819      	ldr	r1, [r3, #0]
}
 80044fe:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8004502:	3104      	adds	r1, #4
 8004504:	f7ff bd0a 	b.w	8003f1c <vListInsert>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8004508:	4a0a      	ldr	r2, [pc, #40]	; (8004534 <prvAddCurrentTaskToDelayedList+0x84>)
 800450a:	6810      	ldr	r0, [r2, #0]
 800450c:	6819      	ldr	r1, [r3, #0]
 800450e:	3104      	adds	r1, #4
 8004510:	f7ff fd04 	bl	8003f1c <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 8004514:	4b08      	ldr	r3, [pc, #32]	; (8004538 <prvAddCurrentTaskToDelayedList+0x88>)
 8004516:	681a      	ldr	r2, [r3, #0]
 8004518:	4294      	cmp	r4, r2
					xNextTaskUnblockTime = xTimeToWake;
 800451a:	bf38      	it	cc
 800451c:	601c      	strcc	r4, [r3, #0]
 800451e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004520:	2000802c 	.word	0x2000802c
 8004524:	20007f08 	.word	0x20007f08
 8004528:	20007fb4 	.word	0x20007fb4
 800452c:	20008004 	.word	0x20008004
 8004530:	20007f10 	.word	0x20007f10
 8004534:	20007f0c 	.word	0x20007f0c
 8004538:	20007fe4 	.word	0x20007fe4

0800453c <prvIdleTask>:
{
 800453c:	b580      	push	{r7, lr}
				taskYIELD();
 800453e:	f8df 8064 	ldr.w	r8, [pc, #100]	; 80045a4 <prvIdleTask+0x68>
				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 8004542:	4f14      	ldr	r7, [pc, #80]	; (8004594 <prvIdleTask+0x58>)
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8004544:	4c14      	ldr	r4, [pc, #80]	; (8004598 <prvIdleTask+0x5c>)
				--uxCurrentNumberOfTasks;
 8004546:	4e15      	ldr	r6, [pc, #84]	; (800459c <prvIdleTask+0x60>)
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8004548:	6823      	ldr	r3, [r4, #0]
 800454a:	b963      	cbnz	r3, 8004566 <prvIdleTask+0x2a>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 800454c:	4b14      	ldr	r3, [pc, #80]	; (80045a0 <prvIdleTask+0x64>)
 800454e:	681b      	ldr	r3, [r3, #0]
 8004550:	2b01      	cmp	r3, #1
 8004552:	d9f8      	bls.n	8004546 <prvIdleTask+0xa>
				taskYIELD();
 8004554:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8004558:	f8c8 3000 	str.w	r3, [r8]
 800455c:	f3bf 8f4f 	dsb	sy
 8004560:	f3bf 8f6f 	isb	sy
 8004564:	e7ee      	b.n	8004544 <prvIdleTask+0x8>
			taskENTER_CRITICAL();
 8004566:	f7ff fd6d 	bl	8004044 <vPortEnterCritical>
				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 800456a:	68fb      	ldr	r3, [r7, #12]
 800456c:	68dd      	ldr	r5, [r3, #12]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800456e:	1d28      	adds	r0, r5, #4
 8004570:	f7ff fceb 	bl	8003f4a <uxListRemove>
				--uxCurrentNumberOfTasks;
 8004574:	6833      	ldr	r3, [r6, #0]
 8004576:	3b01      	subs	r3, #1
 8004578:	6033      	str	r3, [r6, #0]
				--uxDeletedTasksWaitingCleanUp;
 800457a:	6823      	ldr	r3, [r4, #0]
 800457c:	3b01      	subs	r3, #1
 800457e:	6023      	str	r3, [r4, #0]
			taskEXIT_CRITICAL();
 8004580:	f7ff fd82 	bl	8004088 <vPortExitCritical>
			vPortFree( pxTCB->pxStack );
 8004584:	6b28      	ldr	r0, [r5, #48]	; 0x30
 8004586:	f7ff ff2d 	bl	80043e4 <vPortFree>
			vPortFree( pxTCB );
 800458a:	4628      	mov	r0, r5
 800458c:	f7ff ff2a 	bl	80043e4 <vPortFree>
 8004590:	e7da      	b.n	8004548 <prvIdleTask+0xc>
 8004592:	bf00      	nop
 8004594:	20008018 	.word	0x20008018
 8004598:	20007fa4 	.word	0x20007fa4
 800459c:	20007fa0 	.word	0x20007fa0
 80045a0:	20007f14 	.word	0x20007f14
 80045a4:	e000ed04 	.word	0xe000ed04

080045a8 <xTaskCreate>:
	{
 80045a8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80045ac:	ea4f 0a82 	mov.w	sl, r2, lsl #2
	{
 80045b0:	4680      	mov	r8, r0
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80045b2:	4650      	mov	r0, sl
	{
 80045b4:	460f      	mov	r7, r1
 80045b6:	4699      	mov	r9, r3
 80045b8:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80045ba:	f7ff fe85 	bl	80042c8 <pvPortMalloc>
			if( pxStack != NULL )
 80045be:	4605      	mov	r5, r0
 80045c0:	2800      	cmp	r0, #0
 80045c2:	f000 8096 	beq.w	80046f2 <xTaskCreate+0x14a>
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
 80045c6:	2054      	movs	r0, #84	; 0x54
 80045c8:	f7ff fe7e 	bl	80042c8 <pvPortMalloc>
				if( pxNewTCB != NULL )
 80045cc:	4604      	mov	r4, r0
 80045ce:	2800      	cmp	r0, #0
 80045d0:	f000 808c 	beq.w	80046ec <xTaskCreate+0x144>
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 80045d4:	f1aa 0a04 	sub.w	sl, sl, #4
					pxNewTCB->pxStack = pxStack;
 80045d8:	6305      	str	r5, [r0, #48]	; 0x30
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 80045da:	4455      	add	r5, sl
 80045dc:	1e7b      	subs	r3, r7, #1
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 80045de:	f025 0a07 	bic.w	sl, r5, #7
 80045e2:	f100 0234 	add.w	r2, r0, #52	; 0x34
 80045e6:	370f      	adds	r7, #15
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 80045e8:	7859      	ldrb	r1, [r3, #1]
 80045ea:	f802 1b01 	strb.w	r1, [r2], #1
		if( pcName[ x ] == 0x00 )
 80045ee:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 80045f2:	b109      	cbz	r1, 80045f8 <xTaskCreate+0x50>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 80045f4:	42bb      	cmp	r3, r7
 80045f6:	d1f7      	bne.n	80045e8 <xTaskCreate+0x40>
 80045f8:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 80045fa:	2d06      	cmp	r5, #6
 80045fc:	bf28      	it	cs
 80045fe:	2506      	movcs	r5, #6
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8004600:	f04f 0b00 	mov.w	fp, #0
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8004604:	1d27      	adds	r7, r4, #4
	pxNewTCB->uxPriority = uxPriority;
 8004606:	62e5      	str	r5, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
 8004608:	6465      	str	r5, [r4, #68]	; 0x44
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 800460a:	4638      	mov	r0, r7
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 800460c:	f884 b043 	strb.w	fp, [r4, #67]	; 0x43
		pxNewTCB->uxMutexesHeld = 0;
 8004610:	f8c4 b048 	str.w	fp, [r4, #72]	; 0x48
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8004614:	f7ff fc73 	bl	8003efe <vListInitialiseItem>
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004618:	f1c5 0507 	rsb	r5, r5, #7
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 800461c:	f104 0018 	add.w	r0, r4, #24
 8004620:	f7ff fc6d 	bl	8003efe <vListInitialiseItem>
		pxNewTCB->ulNotifiedValue = 0;
 8004624:	f8c4 b04c 	str.w	fp, [r4, #76]	; 0x4c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 8004628:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800462a:	61a5      	str	r5, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 800462c:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 800462e:	f884 b050 	strb.w	fp, [r4, #80]	; 0x50
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8004632:	464a      	mov	r2, r9
 8004634:	4641      	mov	r1, r8
 8004636:	4650      	mov	r0, sl
 8004638:	f7ff fcd6 	bl	8003fe8 <pxPortInitialiseStack>
 800463c:	6020      	str	r0, [r4, #0]
	if( ( void * ) pxCreatedTask != NULL )
 800463e:	b106      	cbz	r6, 8004642 <xTaskCreate+0x9a>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8004640:	6034      	str	r4, [r6, #0]
	taskENTER_CRITICAL();
 8004642:	f7ff fcff 	bl	8004044 <vPortEnterCritical>
		uxCurrentNumberOfTasks++;
 8004646:	4b32      	ldr	r3, [pc, #200]	; (8004710 <xTaskCreate+0x168>)
		if( pxCurrentTCB == NULL )
 8004648:	4e32      	ldr	r6, [pc, #200]	; (8004714 <xTaskCreate+0x16c>)
		uxCurrentNumberOfTasks++;
 800464a:	681a      	ldr	r2, [r3, #0]
 800464c:	f8df 80f0 	ldr.w	r8, [pc, #240]	; 8004740 <xTaskCreate+0x198>
 8004650:	3201      	adds	r2, #1
 8004652:	601a      	str	r2, [r3, #0]
		if( pxCurrentTCB == NULL )
 8004654:	6835      	ldr	r5, [r6, #0]
 8004656:	2d00      	cmp	r5, #0
 8004658:	d14e      	bne.n	80046f8 <xTaskCreate+0x150>
			pxCurrentTCB = pxNewTCB;
 800465a:	6034      	str	r4, [r6, #0]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 800465c:	681b      	ldr	r3, [r3, #0]
 800465e:	2b01      	cmp	r3, #1
 8004660:	d11d      	bne.n	800469e <xTaskCreate+0xf6>
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8004662:	eb08 0005 	add.w	r0, r8, r5
 8004666:	3514      	adds	r5, #20
 8004668:	f7ff fc3e 	bl	8003ee8 <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 800466c:	2d8c      	cmp	r5, #140	; 0x8c
 800466e:	d1f8      	bne.n	8004662 <xTaskCreate+0xba>
	vListInitialise( &xDelayedTaskList1 );
 8004670:	f8df 90d0 	ldr.w	r9, [pc, #208]	; 8004744 <xTaskCreate+0x19c>
	vListInitialise( &xDelayedTaskList2 );
 8004674:	4d28      	ldr	r5, [pc, #160]	; (8004718 <xTaskCreate+0x170>)
	vListInitialise( &xDelayedTaskList1 );
 8004676:	4648      	mov	r0, r9
 8004678:	f7ff fc36 	bl	8003ee8 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 800467c:	4628      	mov	r0, r5
 800467e:	f7ff fc33 	bl	8003ee8 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8004682:	4826      	ldr	r0, [pc, #152]	; (800471c <xTaskCreate+0x174>)
 8004684:	f7ff fc30 	bl	8003ee8 <vListInitialise>
		vListInitialise( &xTasksWaitingTermination );
 8004688:	4825      	ldr	r0, [pc, #148]	; (8004720 <xTaskCreate+0x178>)
 800468a:	f7ff fc2d 	bl	8003ee8 <vListInitialise>
		vListInitialise( &xSuspendedTaskList );
 800468e:	4825      	ldr	r0, [pc, #148]	; (8004724 <xTaskCreate+0x17c>)
 8004690:	f7ff fc2a 	bl	8003ee8 <vListInitialise>
	pxDelayedTaskList = &xDelayedTaskList1;
 8004694:	4b24      	ldr	r3, [pc, #144]	; (8004728 <xTaskCreate+0x180>)
 8004696:	f8c3 9000 	str.w	r9, [r3]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 800469a:	4b24      	ldr	r3, [pc, #144]	; (800472c <xTaskCreate+0x184>)
 800469c:	601d      	str	r5, [r3, #0]
		uxTaskNumber++;
 800469e:	4a24      	ldr	r2, [pc, #144]	; (8004730 <xTaskCreate+0x188>)
		prvAddTaskToReadyList( pxNewTCB );
 80046a0:	4924      	ldr	r1, [pc, #144]	; (8004734 <xTaskCreate+0x18c>)
		uxTaskNumber++;
 80046a2:	6813      	ldr	r3, [r2, #0]
		prvAddTaskToReadyList( pxNewTCB );
 80046a4:	6808      	ldr	r0, [r1, #0]
		uxTaskNumber++;
 80046a6:	3301      	adds	r3, #1
 80046a8:	6013      	str	r3, [r2, #0]
		prvAddTaskToReadyList( pxNewTCB );
 80046aa:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80046ac:	2501      	movs	r5, #1
 80046ae:	fa05 f302 	lsl.w	r3, r5, r2
 80046b2:	4303      	orrs	r3, r0
 80046b4:	2014      	movs	r0, #20
 80046b6:	600b      	str	r3, [r1, #0]
 80046b8:	fb00 8002 	mla	r0, r0, r2, r8
 80046bc:	4639      	mov	r1, r7
 80046be:	f7ff fc21 	bl	8003f04 <vListInsertEnd>
	taskEXIT_CRITICAL();
 80046c2:	f7ff fce1 	bl	8004088 <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
 80046c6:	4b1c      	ldr	r3, [pc, #112]	; (8004738 <xTaskCreate+0x190>)
 80046c8:	681b      	ldr	r3, [r3, #0]
 80046ca:	b163      	cbz	r3, 80046e6 <xTaskCreate+0x13e>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 80046cc:	6833      	ldr	r3, [r6, #0]
 80046ce:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80046d0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80046d2:	429a      	cmp	r2, r3
 80046d4:	d207      	bcs.n	80046e6 <xTaskCreate+0x13e>
			taskYIELD_IF_USING_PREEMPTION();
 80046d6:	4b19      	ldr	r3, [pc, #100]	; (800473c <xTaskCreate+0x194>)
 80046d8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80046dc:	601a      	str	r2, [r3, #0]
 80046de:	f3bf 8f4f 	dsb	sy
 80046e2:	f3bf 8f6f 	isb	sy
	}
 80046e6:	4628      	mov	r0, r5
 80046e8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
					vPortFree( pxStack );
 80046ec:	4628      	mov	r0, r5
 80046ee:	f7ff fe79 	bl	80043e4 <vPortFree>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 80046f2:	f04f 35ff 	mov.w	r5, #4294967295
 80046f6:	e7f6      	b.n	80046e6 <xTaskCreate+0x13e>
			if( xSchedulerRunning == pdFALSE )
 80046f8:	4b0f      	ldr	r3, [pc, #60]	; (8004738 <xTaskCreate+0x190>)
 80046fa:	681b      	ldr	r3, [r3, #0]
 80046fc:	2b00      	cmp	r3, #0
 80046fe:	d1ce      	bne.n	800469e <xTaskCreate+0xf6>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 8004700:	6833      	ldr	r3, [r6, #0]
 8004702:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8004704:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8004706:	429a      	cmp	r2, r3
					pxCurrentTCB = pxNewTCB;
 8004708:	bf98      	it	ls
 800470a:	6034      	strls	r4, [r6, #0]
 800470c:	e7c7      	b.n	800469e <xTaskCreate+0xf6>
 800470e:	bf00      	nop
 8004710:	20007fa0 	.word	0x20007fa0
 8004714:	20007f08 	.word	0x20007f08
 8004718:	20007fcc 	.word	0x20007fcc
 800471c:	20007fec 	.word	0x20007fec
 8004720:	20008018 	.word	0x20008018
 8004724:	20008004 	.word	0x20008004
 8004728:	20007f0c 	.word	0x20007f0c
 800472c:	20007f10 	.word	0x20007f10
 8004730:	20007fb0 	.word	0x20007fb0
 8004734:	20007fb4 	.word	0x20007fb4
 8004738:	20008000 	.word	0x20008000
 800473c:	e000ed04 	.word	0xe000ed04
 8004740:	20007f14 	.word	0x20007f14
 8004744:	20007fb8 	.word	0x20007fb8

08004748 <vTaskResume>:
	{
 8004748:	b570      	push	{r4, r5, r6, lr}
		configASSERT( xTaskToResume );
 800474a:	4604      	mov	r4, r0
 800474c:	b940      	cbnz	r0, 8004760 <vTaskResume+0x18>
 800474e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004752:	f383 8811 	msr	BASEPRI, r3
 8004756:	f3bf 8f6f 	isb	sy
 800475a:	f3bf 8f4f 	dsb	sy
 800475e:	e7fe      	b.n	800475e <vTaskResume+0x16>
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 8004760:	4d16      	ldr	r5, [pc, #88]	; (80047bc <vTaskResume+0x74>)
 8004762:	682b      	ldr	r3, [r5, #0]
 8004764:	4298      	cmp	r0, r3
 8004766:	d028      	beq.n	80047ba <vTaskResume+0x72>
			taskENTER_CRITICAL();
 8004768:	f7ff fc6c 	bl	8004044 <vPortEnterCritical>
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 800476c:	4620      	mov	r0, r4
 800476e:	f7ff fe71 	bl	8004454 <prvTaskIsTaskSuspended>
 8004772:	b1f0      	cbz	r0, 80047b2 <vTaskResume+0x6a>
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
 8004774:	1d26      	adds	r6, r4, #4
 8004776:	4630      	mov	r0, r6
 8004778:	f7ff fbe7 	bl	8003f4a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 800477c:	4910      	ldr	r1, [pc, #64]	; (80047c0 <vTaskResume+0x78>)
 800477e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8004780:	6808      	ldr	r0, [r1, #0]
 8004782:	2301      	movs	r3, #1
 8004784:	4093      	lsls	r3, r2
 8004786:	4303      	orrs	r3, r0
 8004788:	600b      	str	r3, [r1, #0]
 800478a:	4b0e      	ldr	r3, [pc, #56]	; (80047c4 <vTaskResume+0x7c>)
 800478c:	2014      	movs	r0, #20
 800478e:	fb00 3002 	mla	r0, r0, r2, r3
 8004792:	4631      	mov	r1, r6
 8004794:	f7ff fbb6 	bl	8003f04 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8004798:	682b      	ldr	r3, [r5, #0]
 800479a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800479c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800479e:	429a      	cmp	r2, r3
 80047a0:	d307      	bcc.n	80047b2 <vTaskResume+0x6a>
						taskYIELD_IF_USING_PREEMPTION();
 80047a2:	4b09      	ldr	r3, [pc, #36]	; (80047c8 <vTaskResume+0x80>)
 80047a4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80047a8:	601a      	str	r2, [r3, #0]
 80047aa:	f3bf 8f4f 	dsb	sy
 80047ae:	f3bf 8f6f 	isb	sy
	}
 80047b2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			taskEXIT_CRITICAL();
 80047b6:	f7ff bc67 	b.w	8004088 <vPortExitCritical>
 80047ba:	bd70      	pop	{r4, r5, r6, pc}
 80047bc:	20007f08 	.word	0x20007f08
 80047c0:	20007fb4 	.word	0x20007fb4
 80047c4:	20007f14 	.word	0x20007f14
 80047c8:	e000ed04 	.word	0xe000ed04

080047cc <vTaskStartScheduler>:
{
 80047cc:	b513      	push	{r0, r1, r4, lr}
		xReturn = xTaskCreate(	prvIdleTask,
 80047ce:	4b17      	ldr	r3, [pc, #92]	; (800482c <vTaskStartScheduler+0x60>)
 80047d0:	9301      	str	r3, [sp, #4]
 80047d2:	2400      	movs	r4, #0
 80047d4:	9400      	str	r4, [sp, #0]
 80047d6:	4623      	mov	r3, r4
 80047d8:	2280      	movs	r2, #128	; 0x80
 80047da:	4915      	ldr	r1, [pc, #84]	; (8004830 <vTaskStartScheduler+0x64>)
 80047dc:	4815      	ldr	r0, [pc, #84]	; (8004834 <vTaskStartScheduler+0x68>)
 80047de:	f7ff fee3 	bl	80045a8 <xTaskCreate>
	if( xReturn == pdPASS )
 80047e2:	2801      	cmp	r0, #1
 80047e4:	d114      	bne.n	8004810 <vTaskStartScheduler+0x44>
 80047e6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80047ea:	f383 8811 	msr	BASEPRI, r3
 80047ee:	f3bf 8f6f 	isb	sy
 80047f2:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
 80047f6:	4b10      	ldr	r3, [pc, #64]	; (8004838 <vTaskStartScheduler+0x6c>)
 80047f8:	f04f 32ff 	mov.w	r2, #4294967295
 80047fc:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
 80047fe:	4b0f      	ldr	r3, [pc, #60]	; (800483c <vTaskStartScheduler+0x70>)
 8004800:	6018      	str	r0, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
 8004802:	4b0f      	ldr	r3, [pc, #60]	; (8004840 <vTaskStartScheduler+0x74>)
 8004804:	601c      	str	r4, [r3, #0]
}
 8004806:	b002      	add	sp, #8
 8004808:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		if( xPortStartScheduler() != pdFALSE )
 800480c:	f7ff bcb2 	b.w	8004174 <xPortStartScheduler>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 8004810:	3001      	adds	r0, #1
 8004812:	d108      	bne.n	8004826 <vTaskStartScheduler+0x5a>
 8004814:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004818:	f383 8811 	msr	BASEPRI, r3
 800481c:	f3bf 8f6f 	isb	sy
 8004820:	f3bf 8f4f 	dsb	sy
 8004824:	e7fe      	b.n	8004824 <vTaskStartScheduler+0x58>
}
 8004826:	b002      	add	sp, #8
 8004828:	bd10      	pop	{r4, pc}
 800482a:	bf00      	nop
 800482c:	20007fe0 	.word	0x20007fe0
 8004830:	0800c541 	.word	0x0800c541
 8004834:	0800453d 	.word	0x0800453d
 8004838:	20007fe4 	.word	0x20007fe4
 800483c:	20008000 	.word	0x20008000
 8004840:	2000802c 	.word	0x2000802c

08004844 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
 8004844:	4a02      	ldr	r2, [pc, #8]	; (8004850 <vTaskSuspendAll+0xc>)
 8004846:	6813      	ldr	r3, [r2, #0]
 8004848:	3301      	adds	r3, #1
 800484a:	6013      	str	r3, [r2, #0]
 800484c:	4770      	bx	lr
 800484e:	bf00      	nop
 8004850:	20007fac 	.word	0x20007fac

08004854 <xTaskIncrementTick>:
{
 8004854:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8004858:	4b3c      	ldr	r3, [pc, #240]	; (800494c <xTaskIncrementTick+0xf8>)
 800485a:	681b      	ldr	r3, [r3, #0]
 800485c:	2b00      	cmp	r3, #0
 800485e:	d153      	bne.n	8004908 <xTaskIncrementTick+0xb4>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 8004860:	4b3b      	ldr	r3, [pc, #236]	; (8004950 <xTaskIncrementTick+0xfc>)
 8004862:	681c      	ldr	r4, [r3, #0]
 8004864:	3401      	adds	r4, #1
		xTickCount = xConstTickCount;
 8004866:	601c      	str	r4, [r3, #0]
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 8004868:	b9bc      	cbnz	r4, 800489a <xTaskIncrementTick+0x46>
			taskSWITCH_DELAYED_LISTS();
 800486a:	4b3a      	ldr	r3, [pc, #232]	; (8004954 <xTaskIncrementTick+0x100>)
 800486c:	681a      	ldr	r2, [r3, #0]
 800486e:	6812      	ldr	r2, [r2, #0]
 8004870:	b142      	cbz	r2, 8004884 <xTaskIncrementTick+0x30>
 8004872:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004876:	f383 8811 	msr	BASEPRI, r3
 800487a:	f3bf 8f6f 	isb	sy
 800487e:	f3bf 8f4f 	dsb	sy
 8004882:	e7fe      	b.n	8004882 <xTaskIncrementTick+0x2e>
 8004884:	4a34      	ldr	r2, [pc, #208]	; (8004958 <xTaskIncrementTick+0x104>)
 8004886:	6819      	ldr	r1, [r3, #0]
 8004888:	6810      	ldr	r0, [r2, #0]
 800488a:	6018      	str	r0, [r3, #0]
 800488c:	6011      	str	r1, [r2, #0]
 800488e:	4a33      	ldr	r2, [pc, #204]	; (800495c <xTaskIncrementTick+0x108>)
 8004890:	6813      	ldr	r3, [r2, #0]
 8004892:	3301      	adds	r3, #1
 8004894:	6013      	str	r3, [r2, #0]
 8004896:	f7ff fdf9 	bl	800448c <prvResetNextTaskUnblockTime>
		if( xConstTickCount >= xNextTaskUnblockTime )
 800489a:	4d31      	ldr	r5, [pc, #196]	; (8004960 <xTaskIncrementTick+0x10c>)
 800489c:	4f31      	ldr	r7, [pc, #196]	; (8004964 <xTaskIncrementTick+0x110>)
 800489e:	682b      	ldr	r3, [r5, #0]
 80048a0:	429c      	cmp	r4, r3
 80048a2:	f04f 0b00 	mov.w	fp, #0
 80048a6:	d33e      	bcc.n	8004926 <xTaskIncrementTick+0xd2>
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80048a8:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 8004954 <xTaskIncrementTick+0x100>
					prvAddTaskToReadyList( pxTCB );
 80048ac:	f8df 90c4 	ldr.w	r9, [pc, #196]	; 8004974 <xTaskIncrementTick+0x120>
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80048b0:	f8d8 2000 	ldr.w	r2, [r8]
 80048b4:	6812      	ldr	r2, [r2, #0]
 80048b6:	bb72      	cbnz	r2, 8004916 <xTaskIncrementTick+0xc2>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80048b8:	f04f 32ff 	mov.w	r2, #4294967295
 80048bc:	602a      	str	r2, [r5, #0]
					break;
 80048be:	e032      	b.n	8004926 <xTaskIncrementTick+0xd2>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 80048c0:	f106 0a04 	add.w	sl, r6, #4
 80048c4:	4650      	mov	r0, sl
 80048c6:	f7ff fb40 	bl	8003f4a <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 80048ca:	6ab1      	ldr	r1, [r6, #40]	; 0x28
 80048cc:	b119      	cbz	r1, 80048d6 <xTaskIncrementTick+0x82>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 80048ce:	f106 0018 	add.w	r0, r6, #24
 80048d2:	f7ff fb3a 	bl	8003f4a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 80048d6:	6af0      	ldr	r0, [r6, #44]	; 0x2c
 80048d8:	f8d9 3000 	ldr.w	r3, [r9]
 80048dc:	2201      	movs	r2, #1
 80048de:	fa02 f100 	lsl.w	r1, r2, r0
 80048e2:	4319      	orrs	r1, r3
 80048e4:	4b20      	ldr	r3, [pc, #128]	; (8004968 <xTaskIncrementTick+0x114>)
 80048e6:	f8c9 1000 	str.w	r1, [r9]
 80048ea:	f04f 0e14 	mov.w	lr, #20
 80048ee:	4651      	mov	r1, sl
 80048f0:	fb0e 3000 	mla	r0, lr, r0, r3
 80048f4:	f7ff fb06 	bl	8003f04 <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 80048f8:	6838      	ldr	r0, [r7, #0]
 80048fa:	6af1      	ldr	r1, [r6, #44]	; 0x2c
 80048fc:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
							xSwitchRequired = pdTRUE;
 80048fe:	4291      	cmp	r1, r2
 8004900:	bf28      	it	cs
 8004902:	f04f 0b01 	movcs.w	fp, #1
 8004906:	e7d3      	b.n	80048b0 <xTaskIncrementTick+0x5c>
		++uxPendedTicks;
 8004908:	4a18      	ldr	r2, [pc, #96]	; (800496c <xTaskIncrementTick+0x118>)
 800490a:	6813      	ldr	r3, [r2, #0]
 800490c:	3301      	adds	r3, #1
 800490e:	6013      	str	r3, [r2, #0]
BaseType_t xSwitchRequired = pdFALSE;
 8004910:	f04f 0b00 	mov.w	fp, #0
 8004914:	e011      	b.n	800493a <xTaskIncrementTick+0xe6>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8004916:	f8d8 2000 	ldr.w	r2, [r8]
 800491a:	68d2      	ldr	r2, [r2, #12]
 800491c:	68d6      	ldr	r6, [r2, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 800491e:	6871      	ldr	r1, [r6, #4]
					if( xConstTickCount < xItemValue )
 8004920:	428c      	cmp	r4, r1
 8004922:	d2cd      	bcs.n	80048c0 <xTaskIncrementTick+0x6c>
						xNextTaskUnblockTime = xItemValue;
 8004924:	6029      	str	r1, [r5, #0]
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 8004926:	683a      	ldr	r2, [r7, #0]
 8004928:	4b0f      	ldr	r3, [pc, #60]	; (8004968 <xTaskIncrementTick+0x114>)
 800492a:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
 800492c:	2214      	movs	r2, #20
 800492e:	434a      	muls	r2, r1
 8004930:	589a      	ldr	r2, [r3, r2]
				xSwitchRequired = pdTRUE;
 8004932:	2a02      	cmp	r2, #2
 8004934:	bf28      	it	cs
 8004936:	f04f 0b01 	movcs.w	fp, #1
		if( xYieldPending != pdFALSE )
 800493a:	4a0d      	ldr	r2, [pc, #52]	; (8004970 <xTaskIncrementTick+0x11c>)
 800493c:	6812      	ldr	r2, [r2, #0]
			xSwitchRequired = pdTRUE;
 800493e:	2a00      	cmp	r2, #0
 8004940:	bf18      	it	ne
 8004942:	f04f 0b01 	movne.w	fp, #1
}
 8004946:	4658      	mov	r0, fp
 8004948:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800494c:	20007fac 	.word	0x20007fac
 8004950:	2000802c 	.word	0x2000802c
 8004954:	20007f0c 	.word	0x20007f0c
 8004958:	20007f10 	.word	0x20007f10
 800495c:	20007fe8 	.word	0x20007fe8
 8004960:	20007fe4 	.word	0x20007fe4
 8004964:	20007f08 	.word	0x20007f08
 8004968:	20007f14 	.word	0x20007f14
 800496c:	20007fa8 	.word	0x20007fa8
 8004970:	20008030 	.word	0x20008030
 8004974:	20007fb4 	.word	0x20007fb4

08004978 <xTaskResumeAll>:
{
 8004978:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	configASSERT( uxSchedulerSuspended );
 800497c:	4c31      	ldr	r4, [pc, #196]	; (8004a44 <xTaskResumeAll+0xcc>)
 800497e:	6823      	ldr	r3, [r4, #0]
 8004980:	b943      	cbnz	r3, 8004994 <xTaskResumeAll+0x1c>
 8004982:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004986:	f383 8811 	msr	BASEPRI, r3
 800498a:	f3bf 8f6f 	isb	sy
 800498e:	f3bf 8f4f 	dsb	sy
 8004992:	e7fe      	b.n	8004992 <xTaskResumeAll+0x1a>
	taskENTER_CRITICAL();
 8004994:	f7ff fb56 	bl	8004044 <vPortEnterCritical>
		--uxSchedulerSuspended;
 8004998:	6823      	ldr	r3, [r4, #0]
 800499a:	3b01      	subs	r3, #1
 800499c:	6023      	str	r3, [r4, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800499e:	6824      	ldr	r4, [r4, #0]
 80049a0:	b12c      	cbz	r4, 80049ae <xTaskResumeAll+0x36>
BaseType_t xAlreadyYielded = pdFALSE;
 80049a2:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 80049a4:	f7ff fb70 	bl	8004088 <vPortExitCritical>
}
 80049a8:	4620      	mov	r0, r4
 80049aa:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 80049ae:	4b26      	ldr	r3, [pc, #152]	; (8004a48 <xTaskResumeAll+0xd0>)
 80049b0:	681b      	ldr	r3, [r3, #0]
 80049b2:	2b00      	cmp	r3, #0
 80049b4:	d0f5      	beq.n	80049a2 <xTaskResumeAll+0x2a>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 80049b6:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 8004a60 <xTaskResumeAll+0xe8>
					prvAddTaskToReadyList( pxTCB );
 80049ba:	4f24      	ldr	r7, [pc, #144]	; (8004a4c <xTaskResumeAll+0xd4>)
 80049bc:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 8004a64 <xTaskResumeAll+0xec>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 80049c0:	f8d9 3000 	ldr.w	r3, [r9]
 80049c4:	b9e3      	cbnz	r3, 8004a00 <xTaskResumeAll+0x88>
				if( pxTCB != NULL )
 80049c6:	b10c      	cbz	r4, 80049cc <xTaskResumeAll+0x54>
					prvResetNextTaskUnblockTime();
 80049c8:	f7ff fd60 	bl	800448c <prvResetNextTaskUnblockTime>
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 80049cc:	4d20      	ldr	r5, [pc, #128]	; (8004a50 <xTaskResumeAll+0xd8>)
 80049ce:	682c      	ldr	r4, [r5, #0]
					if( uxPendedCounts > ( UBaseType_t ) 0U )
 80049d0:	b144      	cbz	r4, 80049e4 <xTaskResumeAll+0x6c>
								xYieldPending = pdTRUE;
 80049d2:	4e20      	ldr	r6, [pc, #128]	; (8004a54 <xTaskResumeAll+0xdc>)
 80049d4:	2701      	movs	r7, #1
							if( xTaskIncrementTick() != pdFALSE )
 80049d6:	f7ff ff3d 	bl	8004854 <xTaskIncrementTick>
 80049da:	b100      	cbz	r0, 80049de <xTaskResumeAll+0x66>
								xYieldPending = pdTRUE;
 80049dc:	6037      	str	r7, [r6, #0]
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 80049de:	3c01      	subs	r4, #1
 80049e0:	d1f9      	bne.n	80049d6 <xTaskResumeAll+0x5e>
						uxPendedTicks = 0;
 80049e2:	602c      	str	r4, [r5, #0]
				if( xYieldPending != pdFALSE )
 80049e4:	4b1b      	ldr	r3, [pc, #108]	; (8004a54 <xTaskResumeAll+0xdc>)
 80049e6:	681b      	ldr	r3, [r3, #0]
 80049e8:	2b00      	cmp	r3, #0
 80049ea:	d0da      	beq.n	80049a2 <xTaskResumeAll+0x2a>
					taskYIELD_IF_USING_PREEMPTION();
 80049ec:	4b1a      	ldr	r3, [pc, #104]	; (8004a58 <xTaskResumeAll+0xe0>)
 80049ee:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80049f2:	601a      	str	r2, [r3, #0]
 80049f4:	f3bf 8f4f 	dsb	sy
 80049f8:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
 80049fc:	2401      	movs	r4, #1
 80049fe:	e7d1      	b.n	80049a4 <xTaskResumeAll+0x2c>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 8004a00:	f8d9 300c 	ldr.w	r3, [r9, #12]
 8004a04:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8004a06:	1d26      	adds	r6, r4, #4
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8004a08:	f104 0018 	add.w	r0, r4, #24
 8004a0c:	f7ff fa9d 	bl	8003f4a <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8004a10:	4630      	mov	r0, r6
 8004a12:	f7ff fa9a 	bl	8003f4a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8004a16:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8004a18:	6839      	ldr	r1, [r7, #0]
 8004a1a:	2501      	movs	r5, #1
 8004a1c:	fa05 f302 	lsl.w	r3, r5, r2
 8004a20:	2014      	movs	r0, #20
 8004a22:	430b      	orrs	r3, r1
 8004a24:	fb00 8002 	mla	r0, r0, r2, r8
 8004a28:	4631      	mov	r1, r6
 8004a2a:	603b      	str	r3, [r7, #0]
 8004a2c:	f7ff fa6a 	bl	8003f04 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8004a30:	4b0a      	ldr	r3, [pc, #40]	; (8004a5c <xTaskResumeAll+0xe4>)
 8004a32:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8004a34:	681b      	ldr	r3, [r3, #0]
 8004a36:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004a38:	429a      	cmp	r2, r3
						xYieldPending = pdTRUE;
 8004a3a:	bf24      	itt	cs
 8004a3c:	4b05      	ldrcs	r3, [pc, #20]	; (8004a54 <xTaskResumeAll+0xdc>)
 8004a3e:	601d      	strcs	r5, [r3, #0]
 8004a40:	e7be      	b.n	80049c0 <xTaskResumeAll+0x48>
 8004a42:	bf00      	nop
 8004a44:	20007fac 	.word	0x20007fac
 8004a48:	20007fa0 	.word	0x20007fa0
 8004a4c:	20007fb4 	.word	0x20007fb4
 8004a50:	20007fa8 	.word	0x20007fa8
 8004a54:	20008030 	.word	0x20008030
 8004a58:	e000ed04 	.word	0xe000ed04
 8004a5c:	20007f08 	.word	0x20007f08
 8004a60:	20007fec 	.word	0x20007fec
 8004a64:	20007f14 	.word	0x20007f14

08004a68 <vTaskDelay>:
	{
 8004a68:	b508      	push	{r3, lr}
		if( xTicksToDelay > ( TickType_t ) 0U )
 8004a6a:	b940      	cbnz	r0, 8004a7e <vTaskDelay+0x16>
			portYIELD_WITHIN_API();
 8004a6c:	4b0e      	ldr	r3, [pc, #56]	; (8004aa8 <vTaskDelay+0x40>)
 8004a6e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004a72:	601a      	str	r2, [r3, #0]
 8004a74:	f3bf 8f4f 	dsb	sy
 8004a78:	f3bf 8f6f 	isb	sy
 8004a7c:	bd08      	pop	{r3, pc}
			configASSERT( uxSchedulerSuspended == 0 );
 8004a7e:	4b0b      	ldr	r3, [pc, #44]	; (8004aac <vTaskDelay+0x44>)
 8004a80:	6819      	ldr	r1, [r3, #0]
 8004a82:	b141      	cbz	r1, 8004a96 <vTaskDelay+0x2e>
 8004a84:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004a88:	f383 8811 	msr	BASEPRI, r3
 8004a8c:	f3bf 8f6f 	isb	sy
 8004a90:	f3bf 8f4f 	dsb	sy
 8004a94:	e7fe      	b.n	8004a94 <vTaskDelay+0x2c>
			vTaskSuspendAll();
 8004a96:	f7ff fed5 	bl	8004844 <vTaskSuspendAll>
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 8004a9a:	f7ff fd09 	bl	80044b0 <prvAddCurrentTaskToDelayedList>
			xAlreadyYielded = xTaskResumeAll();
 8004a9e:	f7ff ff6b 	bl	8004978 <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
 8004aa2:	2800      	cmp	r0, #0
 8004aa4:	d0e2      	beq.n	8004a6c <vTaskDelay+0x4>
 8004aa6:	bd08      	pop	{r3, pc}
 8004aa8:	e000ed04 	.word	0xe000ed04
 8004aac:	20007fac 	.word	0x20007fac

08004ab0 <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8004ab0:	4b17      	ldr	r3, [pc, #92]	; (8004b10 <vTaskSwitchContext+0x60>)
 8004ab2:	681a      	ldr	r2, [r3, #0]
 8004ab4:	4b17      	ldr	r3, [pc, #92]	; (8004b14 <vTaskSwitchContext+0x64>)
{
 8004ab6:	b510      	push	{r4, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8004ab8:	b112      	cbz	r2, 8004ac0 <vTaskSwitchContext+0x10>
		xYieldPending = pdTRUE;
 8004aba:	2201      	movs	r2, #1
		taskSELECT_HIGHEST_PRIORITY_TASK();
 8004abc:	601a      	str	r2, [r3, #0]
 8004abe:	bd10      	pop	{r4, pc}
		xYieldPending = pdFALSE;
 8004ac0:	601a      	str	r2, [r3, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK();
 8004ac2:	4b15      	ldr	r3, [pc, #84]	; (8004b18 <vTaskSwitchContext+0x68>)
 8004ac4:	681b      	ldr	r3, [r3, #0]
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 8004ac6:	fab3 f383 	clz	r3, r3
 8004aca:	b2db      	uxtb	r3, r3
 8004acc:	f1c3 031f 	rsb	r3, r3, #31
 8004ad0:	2214      	movs	r2, #20
 8004ad2:	4912      	ldr	r1, [pc, #72]	; (8004b1c <vTaskSwitchContext+0x6c>)
 8004ad4:	435a      	muls	r2, r3
 8004ad6:	1888      	adds	r0, r1, r2
 8004ad8:	588c      	ldr	r4, [r1, r2]
 8004ada:	b944      	cbnz	r4, 8004aee <vTaskSwitchContext+0x3e>
	__asm volatile
 8004adc:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004ae0:	f383 8811 	msr	BASEPRI, r3
 8004ae4:	f3bf 8f6f 	isb	sy
 8004ae8:	f3bf 8f4f 	dsb	sy
 8004aec:	e7fe      	b.n	8004aec <vTaskSwitchContext+0x3c>
 8004aee:	6844      	ldr	r4, [r0, #4]
 8004af0:	3208      	adds	r2, #8
 8004af2:	6864      	ldr	r4, [r4, #4]
 8004af4:	6044      	str	r4, [r0, #4]
 8004af6:	440a      	add	r2, r1
 8004af8:	4294      	cmp	r4, r2
 8004afa:	bf04      	itt	eq
 8004afc:	6862      	ldreq	r2, [r4, #4]
 8004afe:	6042      	streq	r2, [r0, #4]
 8004b00:	2214      	movs	r2, #20
 8004b02:	fb02 1303 	mla	r3, r2, r3, r1
 8004b06:	685b      	ldr	r3, [r3, #4]
 8004b08:	68da      	ldr	r2, [r3, #12]
 8004b0a:	4b05      	ldr	r3, [pc, #20]	; (8004b20 <vTaskSwitchContext+0x70>)
 8004b0c:	e7d6      	b.n	8004abc <vTaskSwitchContext+0xc>
 8004b0e:	bf00      	nop
 8004b10:	20007fac 	.word	0x20007fac
 8004b14:	20008030 	.word	0x20008030
 8004b18:	20007fb4 	.word	0x20007fb4
 8004b1c:	20007f14 	.word	0x20007f14
 8004b20:	20007f08 	.word	0x20007f08

08004b24 <vTaskSuspend>:
	{
 8004b24:	b570      	push	{r4, r5, r6, lr}
 8004b26:	4604      	mov	r4, r0
 8004b28:	4e2c      	ldr	r6, [pc, #176]	; (8004bdc <vTaskSuspend+0xb8>)
		taskENTER_CRITICAL();
 8004b2a:	f7ff fa8b 	bl	8004044 <vPortEnterCritical>
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 8004b2e:	b904      	cbnz	r4, 8004b32 <vTaskSuspend+0xe>
 8004b30:	6834      	ldr	r4, [r6, #0]
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8004b32:	1d25      	adds	r5, r4, #4
 8004b34:	4628      	mov	r0, r5
 8004b36:	f7ff fa08 	bl	8003f4a <uxListRemove>
 8004b3a:	b960      	cbnz	r0, 8004b56 <vTaskSuspend+0x32>
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8004b3c:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8004b3e:	4b28      	ldr	r3, [pc, #160]	; (8004be0 <vTaskSuspend+0xbc>)
 8004b40:	2114      	movs	r1, #20
 8004b42:	4341      	muls	r1, r0
 8004b44:	585b      	ldr	r3, [r3, r1]
 8004b46:	b933      	cbnz	r3, 8004b56 <vTaskSuspend+0x32>
 8004b48:	4926      	ldr	r1, [pc, #152]	; (8004be4 <vTaskSuspend+0xc0>)
 8004b4a:	2201      	movs	r2, #1
 8004b4c:	680b      	ldr	r3, [r1, #0]
 8004b4e:	4082      	lsls	r2, r0
 8004b50:	ea23 0302 	bic.w	r3, r3, r2
 8004b54:	600b      	str	r3, [r1, #0]
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8004b56:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8004b58:	b11b      	cbz	r3, 8004b62 <vTaskSuspend+0x3e>
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8004b5a:	f104 0018 	add.w	r0, r4, #24
 8004b5e:	f7ff f9f4 	bl	8003f4a <uxListRemove>
			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 8004b62:	4629      	mov	r1, r5
 8004b64:	4820      	ldr	r0, [pc, #128]	; (8004be8 <vTaskSuspend+0xc4>)
		if( xSchedulerRunning != pdFALSE )
 8004b66:	4d21      	ldr	r5, [pc, #132]	; (8004bec <vTaskSuspend+0xc8>)
			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 8004b68:	f7ff f9cc 	bl	8003f04 <vListInsertEnd>
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
 8004b6c:	f894 3050 	ldrb.w	r3, [r4, #80]	; 0x50
 8004b70:	2b01      	cmp	r3, #1
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 8004b72:	bf04      	itt	eq
 8004b74:	2300      	moveq	r3, #0
 8004b76:	f884 3050 	strbeq.w	r3, [r4, #80]	; 0x50
		taskEXIT_CRITICAL();
 8004b7a:	f7ff fa85 	bl	8004088 <vPortExitCritical>
		if( xSchedulerRunning != pdFALSE )
 8004b7e:	682a      	ldr	r2, [r5, #0]
 8004b80:	b12a      	cbz	r2, 8004b8e <vTaskSuspend+0x6a>
			taskENTER_CRITICAL();
 8004b82:	f7ff fa5f 	bl	8004044 <vPortEnterCritical>
				prvResetNextTaskUnblockTime();
 8004b86:	f7ff fc81 	bl	800448c <prvResetNextTaskUnblockTime>
			taskEXIT_CRITICAL();
 8004b8a:	f7ff fa7d 	bl	8004088 <vPortExitCritical>
		if( pxTCB == pxCurrentTCB )
 8004b8e:	6833      	ldr	r3, [r6, #0]
 8004b90:	429c      	cmp	r4, r3
 8004b92:	d122      	bne.n	8004bda <vTaskSuspend+0xb6>
			if( xSchedulerRunning != pdFALSE )
 8004b94:	682b      	ldr	r3, [r5, #0]
 8004b96:	b1a3      	cbz	r3, 8004bc2 <vTaskSuspend+0x9e>
				configASSERT( uxSchedulerSuspended == 0 );
 8004b98:	4b15      	ldr	r3, [pc, #84]	; (8004bf0 <vTaskSuspend+0xcc>)
 8004b9a:	681b      	ldr	r3, [r3, #0]
 8004b9c:	b143      	cbz	r3, 8004bb0 <vTaskSuspend+0x8c>
 8004b9e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004ba2:	f383 8811 	msr	BASEPRI, r3
 8004ba6:	f3bf 8f6f 	isb	sy
 8004baa:	f3bf 8f4f 	dsb	sy
 8004bae:	e7fe      	b.n	8004bae <vTaskSuspend+0x8a>
				portYIELD_WITHIN_API();
 8004bb0:	4b10      	ldr	r3, [pc, #64]	; (8004bf4 <vTaskSuspend+0xd0>)
 8004bb2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004bb6:	601a      	str	r2, [r3, #0]
 8004bb8:	f3bf 8f4f 	dsb	sy
 8004bbc:	f3bf 8f6f 	isb	sy
 8004bc0:	bd70      	pop	{r4, r5, r6, pc}
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 8004bc2:	4a09      	ldr	r2, [pc, #36]	; (8004be8 <vTaskSuspend+0xc4>)
 8004bc4:	6811      	ldr	r1, [r2, #0]
 8004bc6:	4a0c      	ldr	r2, [pc, #48]	; (8004bf8 <vTaskSuspend+0xd4>)
 8004bc8:	6812      	ldr	r2, [r2, #0]
 8004bca:	4291      	cmp	r1, r2
 8004bcc:	d101      	bne.n	8004bd2 <vTaskSuspend+0xae>
					pxCurrentTCB = NULL;
 8004bce:	6033      	str	r3, [r6, #0]
 8004bd0:	bd70      	pop	{r4, r5, r6, pc}
	}
 8004bd2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
					vTaskSwitchContext();
 8004bd6:	f7ff bf6b 	b.w	8004ab0 <vTaskSwitchContext>
 8004bda:	bd70      	pop	{r4, r5, r6, pc}
 8004bdc:	20007f08 	.word	0x20007f08
 8004be0:	20007f14 	.word	0x20007f14
 8004be4:	20007fb4 	.word	0x20007fb4
 8004be8:	20008004 	.word	0x20008004
 8004bec:	20008000 	.word	0x20008000
 8004bf0:	20007fac 	.word	0x20007fac
 8004bf4:	e000ed04 	.word	0xe000ed04
 8004bf8:	20007fa0 	.word	0x20007fa0

08004bfc <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
 8004bfc:	4b05      	ldr	r3, [pc, #20]	; (8004c14 <xTaskGetSchedulerState+0x18>)
 8004bfe:	681b      	ldr	r3, [r3, #0]
 8004c00:	b133      	cbz	r3, 8004c10 <xTaskGetSchedulerState+0x14>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8004c02:	4b05      	ldr	r3, [pc, #20]	; (8004c18 <xTaskGetSchedulerState+0x1c>)
 8004c04:	681b      	ldr	r3, [r3, #0]
 8004c06:	2b00      	cmp	r3, #0
				xReturn = taskSCHEDULER_SUSPENDED;
 8004c08:	bf0c      	ite	eq
 8004c0a:	2002      	moveq	r0, #2
 8004c0c:	2000      	movne	r0, #0
 8004c0e:	4770      	bx	lr
			xReturn = taskSCHEDULER_NOT_STARTED;
 8004c10:	2001      	movs	r0, #1
	}
 8004c12:	4770      	bx	lr
 8004c14:	20008000 	.word	0x20008000
 8004c18:	20007fac 	.word	0x20007fac

08004c1c <Flash_Init>:
 * Return		:
 * 				+ true - successfully
 * 				+ false - failture
*******************************************************************************/
bool Flash_Init( void )
{
 8004c1c:	b538      	push	{r3, r4, r5, lr}
	__W25Q64JVS_Data.CS_Port					= CHIP_SELECT_PORT;
 8004c1e:	4c15      	ldr	r4, [pc, #84]	; (8004c74 <Flash_Init+0x58>)
 8004c20:	4b15      	ldr	r3, [pc, #84]	; (8004c78 <Flash_Init+0x5c>)
 8004c22:	6023      	str	r3, [r4, #0]
	__W25Q64JVS_Data.CS_Pin						= CHIP_SELECT_PIN;
 8004c24:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8004c28:	80a3      	strh	r3, [r4, #4]

	__W25Q64JVS_Data.debug						= APP_DEBUG;
 8004c2a:	4b14      	ldr	r3, [pc, #80]	; (8004c7c <Flash_Init+0x60>)
 8004c2c:	60a3      	str	r3, [r4, #8]
	__W25Q64JVS_Data.Delay_ms					= HAL_Delay;
 8004c2e:	4b14      	ldr	r3, [pc, #80]	; (8004c80 <Flash_Init+0x64>)
 8004c30:	60e3      	str	r3, [r4, #12]

	__W25Q64JVS_Data.GPIO_setOutput_Dir			= HW_Flash_Driver_setOutput_Dir;
 8004c32:	4b14      	ldr	r3, [pc, #80]	; (8004c84 <Flash_Init+0x68>)
 8004c34:	6123      	str	r3, [r4, #16]
	__W25Q64JVS_Data.GPIO_setOutput_HighLevel	= HW_Flash_Driver_setOutput_HighLevel;
 8004c36:	4b14      	ldr	r3, [pc, #80]	; (8004c88 <Flash_Init+0x6c>)
 8004c38:	6163      	str	r3, [r4, #20]
	__W25Q64JVS_Data.GPIO_setOutput_LowLevel	= HW_Flash_Driver_setOutput_LowLevel;
 8004c3a:	4b14      	ldr	r3, [pc, #80]	; (8004c8c <Flash_Init+0x70>)
 8004c3c:	61a3      	str	r3, [r4, #24]

	__W25Q64JVS_Data.SPI_Init					= HW_Flash_Driver_SPI_Init;
 8004c3e:	4b14      	ldr	r3, [pc, #80]	; (8004c90 <Flash_Init+0x74>)
 8004c40:	61e3      	str	r3, [r4, #28]
	__W25Q64JVS_Data.SPI_Ready					= HW_Flash_Driver_SPI_Ready;
 8004c42:	4b14      	ldr	r3, [pc, #80]	; (8004c94 <Flash_Init+0x78>)
 8004c44:	6223      	str	r3, [r4, #32]
	__W25Q64JVS_Data.SPI_Write_Bytes			= HW_Flash_Driver_SPI_Write_Bytes;
 8004c46:	4b14      	ldr	r3, [pc, #80]	; (8004c98 <Flash_Init+0x7c>)
 8004c48:	6263      	str	r3, [r4, #36]	; 0x24
	__W25Q64JVS_Data.SPI_Read_Bytes				= HW_Flash_Driver_SPI_Read_Bytes;

	//HAL_Delay(1000);
	W25Q64JVS_Init( &__W25Q64JVS_Data );
 8004c4a:	4620      	mov	r0, r4
	__W25Q64JVS_Data.SPI_Read_Bytes				= HW_Flash_Driver_SPI_Read_Bytes;
 8004c4c:	4b13      	ldr	r3, [pc, #76]	; (8004c9c <Flash_Init+0x80>)
 8004c4e:	62a3      	str	r3, [r4, #40]	; 0x28
	W25Q64JVS_Init( &__W25Q64JVS_Data );
 8004c50:	f000 f882 	bl	8004d58 <W25Q64JVS_Init>

	while( W25Q64JVS_CheckConnection( &__W25Q64JVS_Data ) != true )
	{
		APP_DEBUG("--- Flash: flash init nok\r\n");
 8004c54:	4d12      	ldr	r5, [pc, #72]	; (8004ca0 <Flash_Init+0x84>)
	while( W25Q64JVS_CheckConnection( &__W25Q64JVS_Data ) != true )
 8004c56:	4620      	mov	r0, r4
 8004c58:	f000 f89c 	bl	8004d94 <W25Q64JVS_CheckConnection>
 8004c5c:	b108      	cbz	r0, 8004c62 <Flash_Init+0x46>
		osDelay(1000);
	}
	return true;
}
 8004c5e:	2001      	movs	r0, #1
 8004c60:	bd38      	pop	{r3, r4, r5, pc}
		APP_DEBUG("--- Flash: flash init nok\r\n");
 8004c62:	4628      	mov	r0, r5
 8004c64:	f003 f81a 	bl	8007c9c <puts>
		osDelay(1000);
 8004c68:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8004c6c:	f7ff f92a 	bl	8003ec4 <osDelay>
 8004c70:	e7f1      	b.n	8004c56 <Flash_Init+0x3a>
 8004c72:	bf00      	nop
 8004c74:	20008500 	.word	0x20008500
 8004c78:	48000400 	.word	0x48000400
 8004c7c:	08007bad 	.word	0x08007bad
 8004c80:	08000fdd 	.word	0x08000fdd
 8004c84:	08004cdd 	.word	0x08004cdd
 8004c88:	08004ce1 	.word	0x08004ce1
 8004c8c:	08004ce5 	.word	0x08004ce5
 8004c90:	08004ce9 	.word	0x08004ce9
 8004c94:	08004cf9 	.word	0x08004cf9
 8004c98:	08004d05 	.word	0x08004d05
 8004c9c:	08004d19 	.word	0x08004d19
 8004ca0:	0800c546 	.word	0x0800c546

08004ca4 <Flash_Read>:
 * 				+ true - successfully
 * 				+ false - failture
*******************************************************************************/
void Flash_Read( uint32_t addr, uint8_t *uBuffer, uint16_t Lenght )
{
	W25Q64JVS_Read( &__W25Q64JVS_Data, addr, uBuffer, Lenght );
 8004ca4:	4613      	mov	r3, r2
 8004ca6:	460a      	mov	r2, r1
 8004ca8:	4601      	mov	r1, r0
 8004caa:	4801      	ldr	r0, [pc, #4]	; (8004cb0 <Flash_Read+0xc>)
 8004cac:	f000 b8a4 	b.w	8004df8 <W25Q64JVS_Read>
 8004cb0:	20008500 	.word	0x20008500

08004cb4 <Flash_Write_to_Page>:
 * Return		:
 * 				+ true - successfully
 * 				+ false - failture
*******************************************************************************/
void Flash_Write_to_Page( uint32_t addr, uint8_t *txBuffer, uint16_t Lenght )
{
 8004cb4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	W25Q64JVS_EraseSector( &__W25Q64JVS_Data, addr );
 8004cb8:	4c07      	ldr	r4, [pc, #28]	; (8004cd8 <Flash_Write_to_Page+0x24>)
{
 8004cba:	4617      	mov	r7, r2
 8004cbc:	4605      	mov	r5, r0
 8004cbe:	460e      	mov	r6, r1
	W25Q64JVS_EraseSector( &__W25Q64JVS_Data, addr );
 8004cc0:	4601      	mov	r1, r0
 8004cc2:	4620      	mov	r0, r4
 8004cc4:	f000 f913 	bl	8004eee <W25Q64JVS_EraseSector>
	W25Q64JVS_Write( &__W25Q64JVS_Data, addr, txBuffer, Lenght );
 8004cc8:	463b      	mov	r3, r7
 8004cca:	4632      	mov	r2, r6
 8004ccc:	4629      	mov	r1, r5
 8004cce:	4620      	mov	r0, r4
}
 8004cd0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	W25Q64JVS_Write( &__W25Q64JVS_Data, addr, txBuffer, Lenght );
 8004cd4:	f000 b8d2 	b.w	8004e7c <W25Q64JVS_Write>
 8004cd8:	20008500 	.word	0x20008500

08004cdc <HW_Flash_Driver_setOutput_Dir>:
 * 				+ Pin  -gpio Pin
 * Return		: None
 * ***************************************************************************/
void HW_Flash_Driver_setOutput_Dir( void *Port, uint16_t Pin )
{
	GPIO_setOutput_NoPull( Port, Pin );
 8004cdc:	f000 bdd5 	b.w	800588a <GPIO_setOutput_NoPull>

08004ce0 <HW_Flash_Driver_setOutput_HighLevel>:
 * 				+ Pin  -gpio Pin
 * Return		: None
 * ***************************************************************************/
void HW_Flash_Driver_setOutput_HighLevel( void *Port, uint16_t Pin )
{
	GPIO_setHighlevel( Port, Pin );
 8004ce0:	f000 bdf5 	b.w	80058ce <GPIO_setHighlevel>

08004ce4 <HW_Flash_Driver_setOutput_LowLevel>:
 * 				+ Pin  -gpio Pin
 * Return		: None
 * ***************************************************************************/
void HW_Flash_Driver_setOutput_LowLevel( void *Port, uint16_t Pin )
{
	GPIO_setLowlevel( Port, Pin );
 8004ce4:	f000 bdf6 	b.w	80058d4 <GPIO_setLowlevel>

08004ce8 <HW_Flash_Driver_SPI_Init>:
 * 				+ Pin  -gpio Pin
 * Return		: None
 * ***************************************************************************/
void HW_Flash_Driver_SPI_Init( void )
{
	SPI_Init( &__SPI2_Flash, SPI2 );
 8004ce8:	4901      	ldr	r1, [pc, #4]	; (8004cf0 <HW_Flash_Driver_SPI_Init+0x8>)
 8004cea:	4802      	ldr	r0, [pc, #8]	; (8004cf4 <HW_Flash_Driver_SPI_Init+0xc>)
 8004cec:	f000 be1e 	b.w	800592c <SPI_Init>
 8004cf0:	40003800 	.word	0x40003800
 8004cf4:	2000852c 	.word	0x2000852c

08004cf8 <HW_Flash_Driver_SPI_Ready>:
 * Param		: None
 * Return		: None
 * ***************************************************************************/
bool HW_Flash_Driver_SPI_Ready( void )
{
	return SPI_State_Ready( &__SPI2_Flash );
 8004cf8:	4801      	ldr	r0, [pc, #4]	; (8004d00 <HW_Flash_Driver_SPI_Ready+0x8>)
 8004cfa:	f000 be41 	b.w	8005980 <SPI_State_Ready>
 8004cfe:	bf00      	nop
 8004d00:	2000852c 	.word	0x2000852c

08004d04 <HW_Flash_Driver_SPI_Write_Bytes>:
 * 				+ txLenght - tx lenght
 * Return		: None
 * ***************************************************************************/
void HW_Flash_Driver_SPI_Write_Bytes( uint8_t *txBuffer, uint16_t txLenght )
{
	SPI_WriteBytes( &__SPI2_Flash, txBuffer, txLenght, 0xffff );
 8004d04:	460a      	mov	r2, r1
 8004d06:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8004d0a:	4601      	mov	r1, r0
 8004d0c:	4801      	ldr	r0, [pc, #4]	; (8004d14 <HW_Flash_Driver_SPI_Write_Bytes+0x10>)
 8004d0e:	f000 be6f 	b.w	80059f0 <SPI_WriteBytes>
 8004d12:	bf00      	nop
 8004d14:	2000852c 	.word	0x2000852c

08004d18 <HW_Flash_Driver_SPI_Read_Bytes>:
 * 				+ rxLenght - rx lenght
 * Return		: None
 * ***************************************************************************/
void HW_Flash_Driver_SPI_Read_Bytes( uint8_t *rxBuffer, uint16_t rxLenght )
{
	SPI_ReadBytes( &__SPI2_Flash, rxBuffer, rxLenght, 0xffff );
 8004d18:	460a      	mov	r2, r1
 8004d1a:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8004d1e:	4601      	mov	r1, r0
 8004d20:	4801      	ldr	r0, [pc, #4]	; (8004d28 <HW_Flash_Driver_SPI_Read_Bytes+0x10>)
 8004d22:	f000 be73 	b.w	8005a0c <SPI_ReadBytes>
 8004d26:	bf00      	nop
 8004d28:	2000852c 	.word	0x2000852c

08004d2c <W25Q64JVS_SetWriteEnable>:
 * Description	: Ham enable che do ghi
 * Param		: none
 * Return		: none
*******************************************************************************/
void W25Q64JVS_SetWriteEnable( W25Q64JVS_Data_t *__W25Q64JVS_Data  )
{
 8004d2c:	b513      	push	{r0, r1, r4, lr}
	uint8_t txBuffer[2] = {0};
 8004d2e:	2300      	movs	r3, #0
{
 8004d30:	4604      	mov	r4, r0
	uint8_t txBuffer[2] = {0};
 8004d32:	f8ad 3004 	strh.w	r3, [sp, #4]

	__W25Q64JVS_Data->GPIO_setOutput_LowLevel( __W25Q64JVS_Data->CS_Port, __W25Q64JVS_Data->CS_Pin );
 8004d36:	8881      	ldrh	r1, [r0, #4]
 8004d38:	6983      	ldr	r3, [r0, #24]
 8004d3a:	6800      	ldr	r0, [r0, #0]
 8004d3c:	4798      	blx	r3
    //Truyen lenh write enable
	txBuffer[0] = macroW25Q64JVS_WRITE_ENABLE;
 8004d3e:	a802      	add	r0, sp, #8
 8004d40:	2306      	movs	r3, #6
 8004d42:	f800 3d04 	strb.w	r3, [r0, #-4]!
	__W25Q64JVS_Data->SPI_Write_Bytes( txBuffer, 1 );
 8004d46:	2101      	movs	r1, #1
 8004d48:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8004d4a:	4798      	blx	r3
	__W25Q64JVS_Data->GPIO_setOutput_HighLevel( __W25Q64JVS_Data->CS_Port, __W25Q64JVS_Data->CS_Pin );
 8004d4c:	6963      	ldr	r3, [r4, #20]
 8004d4e:	88a1      	ldrh	r1, [r4, #4]
 8004d50:	6820      	ldr	r0, [r4, #0]
 8004d52:	4798      	blx	r3
}
 8004d54:	b002      	add	sp, #8
 8004d56:	bd10      	pop	{r4, pc}

08004d58 <W25Q64JVS_Init>:
{
 8004d58:	b510      	push	{r4, lr}
 8004d5a:	4604      	mov	r4, r0
	__W25Q64JVS_Data->GPIO_setOutput_Dir( __W25Q64JVS_Data->CS_Port, __W25Q64JVS_Data->CS_Pin );
 8004d5c:	6903      	ldr	r3, [r0, #16]
 8004d5e:	8881      	ldrh	r1, [r0, #4]
 8004d60:	6800      	ldr	r0, [r0, #0]
 8004d62:	4798      	blx	r3
	__W25Q64JVS_Data->SPI_Init();
 8004d64:	69e3      	ldr	r3, [r4, #28]
 8004d66:	4798      	blx	r3
	while(__W25Q64JVS_Data->SPI_Ready() == false)
 8004d68:	6a23      	ldr	r3, [r4, #32]
 8004d6a:	4798      	blx	r3
 8004d6c:	b160      	cbz	r0, 8004d88 <W25Q64JVS_Init+0x30>
	__W25Q64JVS_Data->GPIO_setOutput_LowLevel( __W25Q64JVS_Data->CS_Port, __W25Q64JVS_Data->CS_Pin );
 8004d6e:	88a1      	ldrh	r1, [r4, #4]
 8004d70:	69a3      	ldr	r3, [r4, #24]
 8004d72:	6820      	ldr	r0, [r4, #0]
 8004d74:	4798      	blx	r3
	__W25Q64JVS_Data->Delay_ms(100);
 8004d76:	68e3      	ldr	r3, [r4, #12]
 8004d78:	2064      	movs	r0, #100	; 0x64
 8004d7a:	4798      	blx	r3
	__W25Q64JVS_Data->GPIO_setOutput_HighLevel( __W25Q64JVS_Data->CS_Port, __W25Q64JVS_Data->CS_Pin );
 8004d7c:	6963      	ldr	r3, [r4, #20]
 8004d7e:	88a1      	ldrh	r1, [r4, #4]
 8004d80:	6820      	ldr	r0, [r4, #0]
}
 8004d82:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	__W25Q64JVS_Data->GPIO_setOutput_HighLevel( __W25Q64JVS_Data->CS_Port, __W25Q64JVS_Data->CS_Pin );
 8004d86:	4718      	bx	r3
		__W25Q64JVS_Data->Delay_ms(1000);
 8004d88:	68e3      	ldr	r3, [r4, #12]
 8004d8a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8004d8e:	4798      	blx	r3
 8004d90:	e7ea      	b.n	8004d68 <W25Q64JVS_Init+0x10>
	...

08004d94 <W25Q64JVS_CheckConnection>:
{
 8004d94:	b537      	push	{r0, r1, r2, r4, r5, lr}
	uint8_t uBuffer[4] = {0};
 8004d96:	2500      	movs	r5, #0
{
 8004d98:	4604      	mov	r4, r0
	__W25Q64JVS_Data->GPIO_setOutput_LowLevel( __W25Q64JVS_Data->CS_Port, __W25Q64JVS_Data->CS_Pin );
 8004d9a:	6983      	ldr	r3, [r0, #24]
 8004d9c:	8881      	ldrh	r1, [r0, #4]
	uint8_t uBuffer[4] = {0};
 8004d9e:	9501      	str	r5, [sp, #4]
	__W25Q64JVS_Data->GPIO_setOutput_LowLevel( __W25Q64JVS_Data->CS_Port, __W25Q64JVS_Data->CS_Pin );
 8004da0:	6800      	ldr	r0, [r0, #0]
 8004da2:	4798      	blx	r3
	uint8_t value = macroW25Q64JVS_JEDECID;
 8004da4:	a802      	add	r0, sp, #8
 8004da6:	239f      	movs	r3, #159	; 0x9f
 8004da8:	f800 3d05 	strb.w	r3, [r0, #-5]!
	__W25Q64JVS_Data->SPI_Write_Bytes( &value, 1 );
 8004dac:	2101      	movs	r1, #1
 8004dae:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8004db0:	4798      	blx	r3
	__W25Q64JVS_Data->SPI_Read_Bytes( uBuffer, 3 );
 8004db2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8004db4:	2103      	movs	r1, #3
 8004db6:	a801      	add	r0, sp, #4
 8004db8:	4798      	blx	r3
	__W25Q64JVS_Data->GPIO_setOutput_HighLevel( __W25Q64JVS_Data->CS_Port, __W25Q64JVS_Data->CS_Pin );
 8004dba:	6963      	ldr	r3, [r4, #20]
 8004dbc:	88a1      	ldrh	r1, [r4, #4]
 8004dbe:	6820      	ldr	r0, [r4, #0]
 8004dc0:	4798      	blx	r3
	__W25Q64JVS_Data->debug("--- %s: flash id = %x%x\r\n", __FILE__, uBuffer[1], uBuffer[2]);
 8004dc2:	f89d 3006 	ldrb.w	r3, [sp, #6]
 8004dc6:	68a4      	ldr	r4, [r4, #8]
 8004dc8:	f89d 2005 	ldrb.w	r2, [sp, #5]
 8004dcc:	4908      	ldr	r1, [pc, #32]	; (8004df0 <W25Q64JVS_CheckConnection+0x5c>)
 8004dce:	4809      	ldr	r0, [pc, #36]	; (8004df4 <W25Q64JVS_CheckConnection+0x60>)
 8004dd0:	47a0      	blx	r4
	if ((uBuffer[1] == 0x40) && (uBuffer[2] == 0x17))
 8004dd2:	f89d 3005 	ldrb.w	r3, [sp, #5]
 8004dd6:	2b40      	cmp	r3, #64	; 0x40
 8004dd8:	d107      	bne.n	8004dea <W25Q64JVS_CheckConnection+0x56>
 8004dda:	f89d 0006 	ldrb.w	r0, [sp, #6]
 8004dde:	f1a0 0317 	sub.w	r3, r0, #23
 8004de2:	4258      	negs	r0, r3
 8004de4:	4158      	adcs	r0, r3
}
 8004de6:	b003      	add	sp, #12
 8004de8:	bd30      	pop	{r4, r5, pc}
    return false;
 8004dea:	4628      	mov	r0, r5
 8004dec:	e7fb      	b.n	8004de6 <W25Q64JVS_CheckConnection+0x52>
 8004dee:	bf00      	nop
 8004df0:	0800c561 	.word	0x0800c561
 8004df4:	0800c584 	.word	0x0800c584

08004df8 <W25Q64JVS_Read>:
{
 8004df8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8004dfa:	460d      	mov	r5, r1
	uint8_t txBuffer[5] = {0};
 8004dfc:	2100      	movs	r1, #0
{
 8004dfe:	4604      	mov	r4, r0
 8004e00:	461f      	mov	r7, r3
	uint8_t txBuffer[5] = {0};
 8004e02:	9100      	str	r1, [sp, #0]
 8004e04:	f88d 1004 	strb.w	r1, [sp, #4]
	__W25Q64JVS_Data->GPIO_setOutput_LowLevel( __W25Q64JVS_Data->CS_Port, __W25Q64JVS_Data->CS_Pin );
 8004e08:	6983      	ldr	r3, [r0, #24]
 8004e0a:	8881      	ldrh	r1, [r0, #4]
 8004e0c:	6800      	ldr	r0, [r0, #0]
{
 8004e0e:	4616      	mov	r6, r2
	__W25Q64JVS_Data->GPIO_setOutput_LowLevel( __W25Q64JVS_Data->CS_Port, __W25Q64JVS_Data->CS_Pin );
 8004e10:	4798      	blx	r3
	txBuffer[0] = macroW25Q64JVS_READ;
 8004e12:	2303      	movs	r3, #3
 8004e14:	f88d 3000 	strb.w	r3, [sp]
	txBuffer[1] = (addr >> 16	) & 0xff;
 8004e18:	0c2b      	lsrs	r3, r5, #16
 8004e1a:	f88d 3001 	strb.w	r3, [sp, #1]
	txBuffer[2] = (addr >> 8	) & 0xff;
 8004e1e:	0a2b      	lsrs	r3, r5, #8
 8004e20:	f88d 3002 	strb.w	r3, [sp, #2]
	txBuffer[3] = (addr			) & 0xff;
 8004e24:	f88d 5003 	strb.w	r5, [sp, #3]
	__W25Q64JVS_Data->SPI_Write_Bytes( txBuffer, 4 );
 8004e28:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8004e2a:	4668      	mov	r0, sp
 8004e2c:	2104      	movs	r1, #4
 8004e2e:	4798      	blx	r3
	__W25Q64JVS_Data->SPI_Read_Bytes( uBuffer, Lenght );
 8004e30:	4639      	mov	r1, r7
 8004e32:	4630      	mov	r0, r6
 8004e34:	6aa5      	ldr	r5, [r4, #40]	; 0x28
 8004e36:	47a8      	blx	r5
    __W25Q64JVS_Data->GPIO_setOutput_HighLevel( __W25Q64JVS_Data->CS_Port, __W25Q64JVS_Data->CS_Pin );
 8004e38:	6963      	ldr	r3, [r4, #20]
 8004e3a:	88a1      	ldrh	r1, [r4, #4]
 8004e3c:	6820      	ldr	r0, [r4, #0]
 8004e3e:	4798      	blx	r3
}
 8004e40:	b003      	add	sp, #12
 8004e42:	bdf0      	pop	{r4, r5, r6, r7, pc}

08004e44 <W25Q64JVS_GetStatus>:
 * Description	: Ham lay trang thai cua flash
 * Param		: none
 * Return		: none
*******************************************************************************/
uint8_t W25Q64JVS_GetStatus( W25Q64JVS_Data_t *__W25Q64JVS_Data  )
{
 8004e44:	b513      	push	{r0, r1, r4, lr}
	//uint8_t txBuffer[2] = {0};
	uint8_t rxBuffer[2] = {0};
 8004e46:	2300      	movs	r3, #0
{
 8004e48:	4604      	mov	r4, r0
	uint8_t rxBuffer[2] = {0};
 8004e4a:	f8ad 3004 	strh.w	r3, [sp, #4]

	__W25Q64JVS_Data->GPIO_setOutput_LowLevel( __W25Q64JVS_Data->CS_Port, __W25Q64JVS_Data->CS_Pin );
 8004e4e:	8881      	ldrh	r1, [r0, #4]
 8004e50:	6983      	ldr	r3, [r0, #24]
 8004e52:	6800      	ldr	r0, [r0, #0]
 8004e54:	4798      	blx	r3
    //Truyen lenh write
	uint8_t value = macroW25Q64JVS_READ_STATUS;
 8004e56:	a802      	add	r0, sp, #8
 8004e58:	2305      	movs	r3, #5
 8004e5a:	f800 3d05 	strb.w	r3, [r0, #-5]!
	__W25Q64JVS_Data->SPI_Write_Bytes( &value, 1 );
 8004e5e:	2101      	movs	r1, #1
 8004e60:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8004e62:	4798      	blx	r3
	__W25Q64JVS_Data->SPI_Read_Bytes( rxBuffer, 1 );
 8004e64:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8004e66:	a801      	add	r0, sp, #4
 8004e68:	2101      	movs	r1, #1
 8004e6a:	4798      	blx	r3
	__W25Q64JVS_Data->GPIO_setOutput_HighLevel( __W25Q64JVS_Data->CS_Port, __W25Q64JVS_Data->CS_Pin );
 8004e6c:	6820      	ldr	r0, [r4, #0]
 8004e6e:	6963      	ldr	r3, [r4, #20]
 8004e70:	88a1      	ldrh	r1, [r4, #4]
 8004e72:	4798      	blx	r3
    return rxBuffer[0];
}
 8004e74:	f89d 0004 	ldrb.w	r0, [sp, #4]
 8004e78:	b002      	add	sp, #8
 8004e7a:	bd10      	pop	{r4, pc}

08004e7c <W25Q64JVS_Write>:
{
 8004e7c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004e7e:	b091      	sub	sp, #68	; 0x44
 8004e80:	4604      	mov	r4, r0
 8004e82:	460e      	mov	r6, r1
 8004e84:	4617      	mov	r7, r2
	uint8_t data[64] = {0};
 8004e86:	2100      	movs	r1, #0
 8004e88:	2240      	movs	r2, #64	; 0x40
 8004e8a:	4668      	mov	r0, sp
{
 8004e8c:	461d      	mov	r5, r3
	uint8_t data[64] = {0};
 8004e8e:	f002 fe78 	bl	8007b82 <memset>
    W25Q64JVS_SetWriteEnable(__W25Q64JVS_Data);
 8004e92:	4620      	mov	r0, r4
 8004e94:	f7ff ff4a 	bl	8004d2c <W25Q64JVS_SetWriteEnable>
    __W25Q64JVS_Data->GPIO_setOutput_LowLevel( __W25Q64JVS_Data->CS_Port, __W25Q64JVS_Data->CS_Pin );
 8004e98:	69a3      	ldr	r3, [r4, #24]
 8004e9a:	88a1      	ldrh	r1, [r4, #4]
 8004e9c:	6820      	ldr	r0, [r4, #0]
 8004e9e:	4798      	blx	r3
    data[0] = macroW25Q64JVS_WRITE;
 8004ea0:	2302      	movs	r3, #2
 8004ea2:	f88d 3000 	strb.w	r3, [sp]
    data[1] = (addr >> 16	) & 0xff;
 8004ea6:	0c33      	lsrs	r3, r6, #16
 8004ea8:	f88d 3001 	strb.w	r3, [sp, #1]
    data[2] = (addr >> 8	) & 0xff;
 8004eac:	0a33      	lsrs	r3, r6, #8
 8004eae:	f88d 3002 	strb.w	r3, [sp, #2]
    data[3] = (addr			) & 0xff;
 8004eb2:	f88d 6003 	strb.w	r6, [sp, #3]
    while(ui < Lenght)
 8004eb6:	2200      	movs	r2, #0
 8004eb8:	1c53      	adds	r3, r2, #1
 8004eba:	b2d2      	uxtb	r2, r2
 8004ebc:	42aa      	cmp	r2, r5
 8004ebe:	d30f      	bcc.n	8004ee0 <W25Q64JVS_Write+0x64>
	__W25Q64JVS_Data->SPI_Write_Bytes( data, Lenght + 4 );
 8004ec0:	1d29      	adds	r1, r5, #4
 8004ec2:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8004ec4:	b289      	uxth	r1, r1
 8004ec6:	4668      	mov	r0, sp
 8004ec8:	4798      	blx	r3
	__W25Q64JVS_Data->GPIO_setOutput_HighLevel( __W25Q64JVS_Data->CS_Port, __W25Q64JVS_Data->CS_Pin );
 8004eca:	6963      	ldr	r3, [r4, #20]
 8004ecc:	88a1      	ldrh	r1, [r4, #4]
 8004ece:	6820      	ldr	r0, [r4, #0]
 8004ed0:	4798      	blx	r3
 * Param		: none
 * Return		: none
*******************************************************************************/
bool W25Q64JVS_IsBusy( W25Q64JVS_Data_t *__W25Q64JVS_Data  )
{
    uint8_t retval = W25Q64JVS_GetStatus(__W25Q64JVS_Data);
 8004ed2:	4620      	mov	r0, r4
 8004ed4:	f7ff ffb6 	bl	8004e44 <W25Q64JVS_GetStatus>
    while(W25Q64JVS_IsBusy(__W25Q64JVS_Data));
 8004ed8:	07c3      	lsls	r3, r0, #31
 8004eda:	d4fa      	bmi.n	8004ed2 <W25Q64JVS_Write+0x56>
}
 8004edc:	b011      	add	sp, #68	; 0x44
 8004ede:	bdf0      	pop	{r4, r5, r6, r7, pc}
    	data[ui+4] = pBuffer[ui];
 8004ee0:	a910      	add	r1, sp, #64	; 0x40
 8004ee2:	4411      	add	r1, r2
 8004ee4:	5cba      	ldrb	r2, [r7, r2]
 8004ee6:	f801 2c3c 	strb.w	r2, [r1, #-60]
 8004eea:	461a      	mov	r2, r3
 8004eec:	e7e4      	b.n	8004eb8 <W25Q64JVS_Write+0x3c>

08004eee <W25Q64JVS_EraseSector>:
{
 8004eee:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8004ef0:	4604      	mov	r4, r0
	uint8_t txBuffer[5] = {0};
 8004ef2:	2300      	movs	r3, #0
{
 8004ef4:	460d      	mov	r5, r1
	uint8_t txBuffer[5] = {0};
 8004ef6:	9300      	str	r3, [sp, #0]
 8004ef8:	f88d 3004 	strb.w	r3, [sp, #4]
    W25Q64JVS_SetWriteEnable(__W25Q64JVS_Data);
 8004efc:	f7ff ff16 	bl	8004d2c <W25Q64JVS_SetWriteEnable>
    __W25Q64JVS_Data->GPIO_setOutput_LowLevel( __W25Q64JVS_Data->CS_Port, __W25Q64JVS_Data->CS_Pin );
 8004f00:	69a3      	ldr	r3, [r4, #24]
 8004f02:	88a1      	ldrh	r1, [r4, #4]
 8004f04:	6820      	ldr	r0, [r4, #0]
 8004f06:	4798      	blx	r3
	txBuffer[0] = macroW25Q64JVS_SECTOR_ERASE;
 8004f08:	2320      	movs	r3, #32
 8004f0a:	f88d 3000 	strb.w	r3, [sp]
	txBuffer[1] = (ulAddress >> 16	) & 0xff;
 8004f0e:	0c2b      	lsrs	r3, r5, #16
 8004f10:	f88d 3001 	strb.w	r3, [sp, #1]
	txBuffer[2] = (ulAddress >> 8	) & 0xff;
 8004f14:	0a2b      	lsrs	r3, r5, #8
 8004f16:	f88d 3002 	strb.w	r3, [sp, #2]
	__W25Q64JVS_Data->SPI_Write_Bytes( txBuffer, 4 );
 8004f1a:	2104      	movs	r1, #4
 8004f1c:	6a63      	ldr	r3, [r4, #36]	; 0x24
	txBuffer[3] = (ulAddress		) & 0xff;
 8004f1e:	f88d 5003 	strb.w	r5, [sp, #3]
	__W25Q64JVS_Data->SPI_Write_Bytes( txBuffer, 4 );
 8004f22:	4668      	mov	r0, sp
 8004f24:	4798      	blx	r3
	__W25Q64JVS_Data->GPIO_setOutput_HighLevel( __W25Q64JVS_Data->CS_Port, __W25Q64JVS_Data->CS_Pin );
 8004f26:	6963      	ldr	r3, [r4, #20]
 8004f28:	88a1      	ldrh	r1, [r4, #4]
 8004f2a:	6820      	ldr	r0, [r4, #0]
 8004f2c:	4798      	blx	r3
    uint8_t retval = W25Q64JVS_GetStatus(__W25Q64JVS_Data);
 8004f2e:	4620      	mov	r0, r4
 8004f30:	f7ff ff88 	bl	8004e44 <W25Q64JVS_GetStatus>
    while(W25Q64JVS_IsBusy(__W25Q64JVS_Data));
 8004f34:	07c3      	lsls	r3, r0, #31
 8004f36:	d4fa      	bmi.n	8004f2e <W25Q64JVS_EraseSector+0x40>
}
 8004f38:	b003      	add	sp, #12
 8004f3a:	bd30      	pop	{r4, r5, pc}

08004f3c <HW_Lora_Driver_Delay_ms>:
 * Param		: None
 * Return		: None
 * ***************************************************************************/
void HW_Lora_Driver_Delay_ms( uint32_t ms )
{
	HAL_Delay(ms);
 8004f3c:	f7fc b84e 	b.w	8000fdc <HAL_Delay>

08004f40 <HW_Lora_Driver_setPin_Output>:
 * Param		: None
 * Return		: None
 * ***************************************************************************/
void HW_Lora_Driver_setPin_Output( void *Port, uint16_t Pin )
{
	GPIO_setOutput_Pullup( (GPIO_TypeDef *)Port, Pin );
 8004f40:	f000 bc7c 	b.w	800583c <GPIO_setOutput_Pullup>

08004f44 <HW_Lora_Driver_setPin_Input>:
 * Param		: None
 * Return		: None
 * ***************************************************************************/
void HW_Lora_Driver_setPin_Input( void *Port, uint16_t Pin )
{
	GPIO_setInput( (GPIO_TypeDef *)Port, Pin );
 8004f44:	f000 bcb3 	b.w	80058ae <GPIO_setInput>

08004f48 <HW_Lora_Driver_ReadPin>:
 * Description	: gpio read pin
 * Param		: None
 * Return		: None
 * ***************************************************************************/
int HW_Lora_Driver_ReadPin( void *Port, uint16_t Pin )
{
 8004f48:	b508      	push	{r3, lr}
	return GPIO_getlevel( (GPIO_TypeDef *)Port, Pin );
 8004f4a:	f000 fcc8 	bl	80058de <GPIO_getlevel>
}
 8004f4e:	bd08      	pop	{r3, pc}

08004f50 <HW_Lora_Driver_setPin_High>:
 * Param		: None
 * Return		: None
 * ***************************************************************************/
void HW_Lora_Driver_setPin_High( void *Port, uint16_t Pin )
{
	GPIO_setHighlevel( (GPIO_TypeDef *)Port, Pin );
 8004f50:	f000 bcbd 	b.w	80058ce <GPIO_setHighlevel>

08004f54 <HW_Lora_Driver_setPin_Low>:
 * Param		: None
 * Return		: None
 * ***************************************************************************/
void HW_Lora_Driver_setPin_Low( void *Port, uint16_t Pin )
{
	GPIO_setLowlevel( (GPIO_TypeDef *)Port, Pin );
 8004f54:	f000 bcbe 	b.w	80058d4 <GPIO_setLowlevel>

08004f58 <HW_Lora_Driver_SPI_Init>:
 * 				+ true - successfully
 * 				+ false - failture
 * ***************************************************************************/
bool HW_Lora_Driver_SPI_Init( void )
{
	return SPI_Init( &_SPI1_Lora, SPI1 );
 8004f58:	4901      	ldr	r1, [pc, #4]	; (8004f60 <HW_Lora_Driver_SPI_Init+0x8>)
 8004f5a:	4802      	ldr	r0, [pc, #8]	; (8004f64 <HW_Lora_Driver_SPI_Init+0xc>)
 8004f5c:	f000 bce6 	b.w	800592c <SPI_Init>
 8004f60:	40013000 	.word	0x40013000
 8004f64:	20008590 	.word	0x20008590

08004f68 <HW_Lora_Driver_SPI_Ready>:
 * 				+ true - spi ready
 * 				+ false - spi busy
 * ***************************************************************************/
bool HW_Lora_Driver_SPI_Ready( void )
{
	return SPI_State_Ready( &_SPI1_Lora );
 8004f68:	4801      	ldr	r0, [pc, #4]	; (8004f70 <HW_Lora_Driver_SPI_Ready+0x8>)
 8004f6a:	f000 bd09 	b.w	8005980 <SPI_State_Ready>
 8004f6e:	bf00      	nop
 8004f70:	20008590 	.word	0x20008590

08004f74 <HW_Lora_Driver_SPI_WriteByte>:
 * Param		: txBuff - byte send
 * Return		: None
 * ***************************************************************************/
bool HW_Lora_Driver_SPI_WriteByte( uint8_t txBuff, uint32_t Timeout )
{
	return SPI_WriteByte( &_SPI1_Lora, txBuff, Timeout );
 8004f74:	460a      	mov	r2, r1
 8004f76:	4601      	mov	r1, r0
 8004f78:	4801      	ldr	r0, [pc, #4]	; (8004f80 <HW_Lora_Driver_SPI_WriteByte+0xc>)
 8004f7a:	f000 bd09 	b.w	8005990 <SPI_WriteByte>
 8004f7e:	bf00      	nop
 8004f80:	20008590 	.word	0x20008590

08004f84 <HW_Lora_Driver_SPI_ReadByte>:
 * Param		: None
 * Return		: byte read
 * ***************************************************************************/
uint8_t HW_Lora_Driver_SPI_ReadByte( uint32_t Timeout )
{
	return SPI_ReadByte( &_SPI1_Lora, 0x00, Timeout );
 8004f84:	4602      	mov	r2, r0
 8004f86:	2100      	movs	r1, #0
 8004f88:	4801      	ldr	r0, [pc, #4]	; (8004f90 <HW_Lora_Driver_SPI_ReadByte+0xc>)
 8004f8a:	f000 bd17 	b.w	80059bc <SPI_ReadByte>
 8004f8e:	bf00      	nop
 8004f90:	20008590 	.word	0x20008590

08004f94 <Lora_Init>:
 * Description	: Lora Init
 * Param		: Message_maxLenght - message max lenght
 * Return		: None
 * ****************************************************************************/
void Lora_Init( uint16_t Message_maxLenght )
{
 8004f94:	b538      	push	{r3, r4, r5, lr}
	//initialize LoRa module
	LR_MSG_Max_Lenght = Message_maxLenght;
	__Lora_SX1278.HW.DIO_0.Port				= macroLR_DIO_0_PORT;
 8004f96:	4c22      	ldr	r4, [pc, #136]	; (8005020 <Lora_Init+0x8c>)
 8004f98:	4a22      	ldr	r2, [pc, #136]	; (8005024 <Lora_Init+0x90>)
 8004f9a:	60e2      	str	r2, [r4, #12]
	__Lora_SX1278.HW.DIO_0.Pin 				= macroLR_DIO_0_PIN;
 8004f9c:	2302      	movs	r3, #2
 8004f9e:	60a3      	str	r3, [r4, #8]
	__Lora_SX1278.HW.NSS.Port				= macroLR_NSS_PORT;
	__Lora_SX1278.HW.NSS.Pin				= macroLR_NSS_PIN;

	__Lora_SX1278.Cfg.Frequency				= SX1278_433MHZ;
	__Lora_SX1278.Cfg.Power					= SX1278_POWER_20DBM;
	__Lora_SX1278.Cfg.LoRa_Rate				= SX1278_LORA_SF_8;
 8004fa0:	76a3      	strb	r3, [r4, #26]
	__Lora_SX1278.Cfg.LoRa_BW				= SX1278_LORA_BW_500KHZ;
 8004fa2:	2309      	movs	r3, #9
 8004fa4:	76e3      	strb	r3, [r4, #27]
	__Lora_SX1278.Cfg.packetLength			= LR_MSG_Max_Lenght;

	__Lora_SX1278.SX1278_Delay_ms			= HW_Lora_Driver_Delay_ms;
 8004fa6:	4b20      	ldr	r3, [pc, #128]	; (8005028 <Lora_Init+0x94>)
 8004fa8:	f8c4 3424 	str.w	r3, [r4, #1060]	; 0x424
	//__Lora_SX1278.SX1278_Delay_us			= LR_HW_Driver_Delay_us;
	__Lora_SX1278.HW_GPIO_Init_Pin_Output	= HW_Lora_Driver_setPin_Output;
 8004fac:	4b1f      	ldr	r3, [pc, #124]	; (800502c <Lora_Init+0x98>)
 8004fae:	f8c4 342c 	str.w	r3, [r4, #1068]	; 0x42c
	__Lora_SX1278.HW_GPIO_Init_Pin_Input	= HW_Lora_Driver_setPin_Input;
 8004fb2:	4b1f      	ldr	r3, [pc, #124]	; (8005030 <Lora_Init+0x9c>)
 8004fb4:	f8c4 3430 	str.w	r3, [r4, #1072]	; 0x430
	__Lora_SX1278.HW_GPIO_Set_Pin			= HW_Lora_Driver_setPin_High;
 8004fb8:	4b1e      	ldr	r3, [pc, #120]	; (8005034 <Lora_Init+0xa0>)
 8004fba:	f8c4 3438 	str.w	r3, [r4, #1080]	; 0x438
	__Lora_SX1278.HW_GPIO_Reset_Pin			= HW_Lora_Driver_setPin_Low;
 8004fbe:	4b1e      	ldr	r3, [pc, #120]	; (8005038 <Lora_Init+0xa4>)
 8004fc0:	f8c4 343c 	str.w	r3, [r4, #1084]	; 0x43c
	__Lora_SX1278.HW_GPIO_Read_Pin			= HW_Lora_Driver_ReadPin;
 8004fc4:	4b1d      	ldr	r3, [pc, #116]	; (800503c <Lora_Init+0xa8>)
 8004fc6:	f8c4 3434 	str.w	r3, [r4, #1076]	; 0x434
	__Lora_SX1278.HW_SPI_Init				= HW_Lora_Driver_SPI_Init;
 8004fca:	4b1d      	ldr	r3, [pc, #116]	; (8005040 <Lora_Init+0xac>)
	__Lora_SX1278.HW.Reset.Port				= macroLR_RESET_PORT;
 8004fcc:	6062      	str	r2, [r4, #4]
	__Lora_SX1278.HW_SPI_Init				= HW_Lora_Driver_SPI_Init;
 8004fce:	f8c4 3440 	str.w	r3, [r4, #1088]	; 0x440
	__Lora_SX1278.HW.Reset.Pin				= macroLR_RESET_PIN;
 8004fd2:	2201      	movs	r2, #1
	__Lora_SX1278.HW_SPI_State_Ready		= HW_Lora_Driver_SPI_Ready;
 8004fd4:	4b1b      	ldr	r3, [pc, #108]	; (8005044 <Lora_Init+0xb0>)
	LR_MSG_Max_Lenght = Message_maxLenght;
 8004fd6:	4d1c      	ldr	r5, [pc, #112]	; (8005048 <Lora_Init+0xb4>)
	__Lora_SX1278.HW.Reset.Pin				= macroLR_RESET_PIN;
 8004fd8:	6022      	str	r2, [r4, #0]
	__Lora_SX1278.HW_SPI_State_Ready		= HW_Lora_Driver_SPI_Ready;
 8004fda:	f8c4 3444 	str.w	r3, [r4, #1092]	; 0x444
	__Lora_SX1278.HW.NSS.Port				= macroLR_NSS_PORT;
 8004fde:	f04f 4290 	mov.w	r2, #1207959552	; 0x48000000
	__Lora_SX1278.HW_SPI_ReadByte			= HW_Lora_Driver_SPI_ReadByte;
 8004fe2:	4b1a      	ldr	r3, [pc, #104]	; (800504c <Lora_Init+0xb8>)
	__Lora_SX1278.HW.NSS.Port				= macroLR_NSS_PORT;
 8004fe4:	6162      	str	r2, [r4, #20]
	__Lora_SX1278.HW_SPI_ReadByte			= HW_Lora_Driver_SPI_ReadByte;
 8004fe6:	f8c4 344c 	str.w	r3, [r4, #1100]	; 0x44c
	__Lora_SX1278.HW.NSS.Pin				= macroLR_NSS_PIN;
 8004fea:	2210      	movs	r2, #16
	__Lora_SX1278.HW_SPI_WriteByte			= HW_Lora_Driver_SPI_WriteByte;
 8004fec:	4b18      	ldr	r3, [pc, #96]	; (8005050 <Lora_Init+0xbc>)
	LR_MSG_Max_Lenght = Message_maxLenght;
 8004fee:	8028      	strh	r0, [r5, #0]
	__Lora_SX1278.HW.NSS.Pin				= macroLR_NSS_PIN;
 8004ff0:	6122      	str	r2, [r4, #16]
	__Lora_SX1278.Cfg.packetLength			= LR_MSG_Max_Lenght;
 8004ff2:	83a0      	strh	r0, [r4, #28]
	__Lora_SX1278.Cfg.Frequency				= SX1278_433MHZ;
 8004ff4:	2200      	movs	r2, #0
	__Lora_SX1278.HW_SPI_WriteByte			= HW_Lora_Driver_SPI_WriteByte;
 8004ff6:	f8c4 3448 	str.w	r3, [r4, #1096]	; 0x448
	__Lora_SX1278.debug						= APP_DEBUG;

	SX1278_Init( &__Lora_SX1278 );
 8004ffa:	4620      	mov	r0, r4
	__Lora_SX1278.debug						= APP_DEBUG;
 8004ffc:	4b15      	ldr	r3, [pc, #84]	; (8005054 <Lora_Init+0xc0>)
	__Lora_SX1278.Cfg.Frequency				= SX1278_433MHZ;
 8004ffe:	7622      	strb	r2, [r4, #24]
	__Lora_SX1278.Cfg.Power					= SX1278_POWER_20DBM;
 8005000:	7662      	strb	r2, [r4, #25]
	__Lora_SX1278.debug						= APP_DEBUG;
 8005002:	f8c4 3450 	str.w	r3, [r4, #1104]	; 0x450
	SX1278_Init( &__Lora_SX1278 );
 8005006:	f000 f98f 	bl	8005328 <SX1278_Init>

	SX1278_LoRaEntryRx( &__Lora_SX1278, LR_MSG_Max_Lenght, 0xffff );
 800500a:	8829      	ldrh	r1, [r5, #0]
 800500c:	4620      	mov	r0, r4
 800500e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8005012:	f000 f9ae 	bl	8005372 <SX1278_LoRaEntryRx>
	APP_DEBUG("\r\n--- Lora: Lora RX Start\r\n");
 8005016:	4810      	ldr	r0, [pc, #64]	; (8005058 <Lora_Init+0xc4>)
}
 8005018:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	APP_DEBUG("\r\n--- Lora: Lora RX Start\r\n");
 800501c:	f002 be3e 	b.w	8007c9c <puts>
 8005020:	200085f4 	.word	0x200085f4
 8005024:	48000400 	.word	0x48000400
 8005028:	08004f3d 	.word	0x08004f3d
 800502c:	08004f41 	.word	0x08004f41
 8005030:	08004f45 	.word	0x08004f45
 8005034:	08004f51 	.word	0x08004f51
 8005038:	08004f55 	.word	0x08004f55
 800503c:	08004f49 	.word	0x08004f49
 8005040:	08004f59 	.word	0x08004f59
 8005044:	08004f69 	.word	0x08004f69
 8005048:	20008034 	.word	0x20008034
 800504c:	08004f85 	.word	0x08004f85
 8005050:	08004f75 	.word	0x08004f75
 8005054:	08007bad 	.word	0x08007bad
 8005058:	0800c59e 	.word	0x0800c59e

0800505c <Lora_Transmit>:
 * Return		:
 * 				+ true - successfully
 * 				+ false - failture
 * ****************************************************************************/
bool Lora_Transmit( uint8_t *TXBuffer, uint16_t TXLenght )
{
 800505c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
//	char Hex[17] = "0123456789ABCDEF";
//	__Lora_SX1278.debug("--- Lora: sending message ");
//	for(uint16_t ui = 0; ui < TXLenght; ui++)
//		__Lora_SX1278.debug("%c%c", Hex[TXBuffer[ui] / 16], Hex[TXBuffer[ui] % 16]);
//	__Lora_SX1278.debug(", lenght = %d\r\n", TXLenght);
	bool Result = SX1278_Transmit( &__Lora_SX1278, TXBuffer, TXLenght, 0xffff );
 800505e:	4c0f      	ldr	r4, [pc, #60]	; (800509c <Lora_Transmit+0x40>)
 8005060:	460a      	mov	r2, r1
 8005062:	f64f 73ff 	movw	r3, #65535	; 0xffff
{
 8005066:	4606      	mov	r6, r0
 8005068:	460f      	mov	r7, r1
	bool Result = SX1278_Transmit( &__Lora_SX1278, TXBuffer, TXLenght, 0xffff );
 800506a:	4601      	mov	r1, r0
 800506c:	4620      	mov	r0, r4
 800506e:	f000 fa82 	bl	8005576 <SX1278_Transmit>
	SX1278_LoRaEntryRx( &__Lora_SX1278, LR_MSG_Max_Lenght, 0xffff );	//goto rx mode
 8005072:	4b0b      	ldr	r3, [pc, #44]	; (80050a0 <Lora_Transmit+0x44>)
	bool Result = SX1278_Transmit( &__Lora_SX1278, TXBuffer, TXLenght, 0xffff );
 8005074:	4605      	mov	r5, r0
	SX1278_LoRaEntryRx( &__Lora_SX1278, LR_MSG_Max_Lenght, 0xffff );	//goto rx mode
 8005076:	8819      	ldrh	r1, [r3, #0]
 8005078:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800507c:	4620      	mov	r0, r4
 800507e:	f000 f978 	bl	8005372 <SX1278_LoRaEntryRx>

	if(Result == true)
		__Lora_SX1278.debug("--- Lora: sent message successfully. \"%s\", lenght = %d\r\n", TXBuffer, TXLenght);
 8005082:	f8d4 3450 	ldr.w	r3, [r4, #1104]	; 0x450
	if(Result == true)
 8005086:	b12d      	cbz	r5, 8005094 <Lora_Transmit+0x38>
		__Lora_SX1278.debug("--- Lora: sent message successfully. \"%s\", lenght = %d\r\n", TXBuffer, TXLenght);
 8005088:	463a      	mov	r2, r7
 800508a:	4631      	mov	r1, r6
 800508c:	4805      	ldr	r0, [pc, #20]	; (80050a4 <Lora_Transmit+0x48>)
 800508e:	4798      	blx	r3
	else
		__Lora_SX1278.debug("--- Lora: sent message failture\r\n");
	return Result;
}
 8005090:	4628      	mov	r0, r5
 8005092:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		__Lora_SX1278.debug("--- Lora: sent message failture\r\n");
 8005094:	4804      	ldr	r0, [pc, #16]	; (80050a8 <Lora_Transmit+0x4c>)
 8005096:	4798      	blx	r3
 8005098:	e7fa      	b.n	8005090 <Lora_Transmit+0x34>
 800509a:	bf00      	nop
 800509c:	200085f4 	.word	0x200085f4
 80050a0:	20008034 	.word	0x20008034
 80050a4:	0800c5b9 	.word	0x0800c5b9
 80050a8:	0800c5f2 	.word	0x0800c5f2

080050ac <Lora_Receive>:
 * Return		:
 * 				+ >0 - successfully
 * 				+ 0 - failture
 * ****************************************************************************/
uint16_t Lora_Receive( uint8_t *RX_Buffer )
{
 80050ac:	b507      	push	{r0, r1, r2, lr}
	uint16_t len = 0;
 80050ae:	aa02      	add	r2, sp, #8
 80050b0:	2300      	movs	r3, #0
	SX1278_Receive( &__Lora_SX1278, RX_Buffer, &len );
 80050b2:	4601      	mov	r1, r0
	uint16_t len = 0;
 80050b4:	f822 3d02 	strh.w	r3, [r2, #-2]!
	SX1278_Receive( &__Lora_SX1278, RX_Buffer, &len );
 80050b8:	4803      	ldr	r0, [pc, #12]	; (80050c8 <Lora_Receive+0x1c>)
 80050ba:	f000 fa71 	bl	80055a0 <SX1278_Receive>
	return len;
}
 80050be:	f8bd 0006 	ldrh.w	r0, [sp, #6]
 80050c2:	b003      	add	sp, #12
 80050c4:	f85d fb04 	ldr.w	pc, [sp], #4
 80050c8:	200085f4 	.word	0x200085f4

080050cc <SX1278_HW_SetNSS.part.0>:


static void SX1278_HW_SetNSS( Lora_SX1278_t *__Lora_SX1278, int Value ) 
{
	if(Value == 1)
		__Lora_SX1278->HW_GPIO_Set_Pin( __Lora_SX1278->HW.NSS.Port, __Lora_SX1278->HW.NSS.Pin );
 80050cc:	f8d0 3438 	ldr.w	r3, [r0, #1080]	; 0x438
 80050d0:	8a01      	ldrh	r1, [r0, #16]
 80050d2:	6940      	ldr	r0, [r0, #20]
 80050d4:	4718      	bx	r3

080050d6 <SX1278_HW_Reset>:
}



static void SX1278_HW_Reset( Lora_SX1278_t *__Lora_SX1278 ) 
{
 80050d6:	b510      	push	{r4, lr}
 80050d8:	4604      	mov	r4, r0
 80050da:	f7ff fff7 	bl	80050cc <SX1278_HW_SetNSS.part.0>
	SX1278_HW_SetNSS( __Lora_SX1278, 1 );
	__Lora_SX1278->HW_GPIO_Reset_Pin( __Lora_SX1278->HW.Reset.Port, __Lora_SX1278->HW.Reset.Pin );
 80050de:	8821      	ldrh	r1, [r4, #0]
 80050e0:	f8d4 343c 	ldr.w	r3, [r4, #1084]	; 0x43c
 80050e4:	6860      	ldr	r0, [r4, #4]
 80050e6:	4798      	blx	r3
	__Lora_SX1278->SX1278_Delay_ms(100);
 80050e8:	f8d4 3424 	ldr.w	r3, [r4, #1060]	; 0x424
 80050ec:	2064      	movs	r0, #100	; 0x64
 80050ee:	4798      	blx	r3
	__Lora_SX1278->HW_GPIO_Set_Pin( __Lora_SX1278->HW.Reset.Port, __Lora_SX1278->HW.Reset.Pin );
 80050f0:	f8d4 3438 	ldr.w	r3, [r4, #1080]	; 0x438
 80050f4:	6860      	ldr	r0, [r4, #4]
 80050f6:	8821      	ldrh	r1, [r4, #0]
 80050f8:	4798      	blx	r3
	__Lora_SX1278->SX1278_Delay_ms(100);
 80050fa:	f8d4 3424 	ldr.w	r3, [r4, #1060]	; 0x424
 80050fe:	2064      	movs	r0, #100	; 0x64
}
 8005100:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	__Lora_SX1278->SX1278_Delay_ms(100);
 8005104:	4718      	bx	r3
	...

08005108 <SX1278_Wait_SPIReady.constprop.5>:
	return __Lora_SX1278->HW_GPIO_Read_Pin( __Lora_SX1278->HW.DIO_0.Port, __Lora_SX1278->HW.DIO_0.Pin );
}



static bool SX1278_Wait_SPIReady( Lora_SX1278_t *__Lora_SX1278, uint32_t Timeout_ms )
 8005108:	b570      	push	{r4, r5, r6, lr}
 800510a:	4c07      	ldr	r4, [pc, #28]	; (8005128 <SX1278_Wait_SPIReady.constprop.5+0x20>)
 800510c:	4606      	mov	r6, r0
	uint32_t TimeCount = 0;

	while( TimeCount < (Timeout_ms * 1000) )
	{
		TimeCount++;
		if( __Lora_SX1278->HW_SPI_State_Ready() == true )
 800510e:	f8d6 3444 	ldr.w	r3, [r6, #1092]	; 0x444
 8005112:	4798      	blx	r3
 8005114:	4605      	mov	r5, r0
 8005116:	b928      	cbnz	r0, 8005124 <SX1278_Wait_SPIReady.constprop.5+0x1c>
			return true;
		__Lora_SX1278->SX1278_Delay_us(1);
 8005118:	f8d6 3428 	ldr.w	r3, [r6, #1064]	; 0x428
 800511c:	2001      	movs	r0, #1
 800511e:	4798      	blx	r3
	while( TimeCount < (Timeout_ms * 1000) )
 8005120:	3c01      	subs	r4, #1
 8005122:	d1f4      	bne.n	800510e <SX1278_Wait_SPIReady.constprop.5+0x6>
	}
	return false;
}
 8005124:	4628      	mov	r0, r5
 8005126:	bd70      	pop	{r4, r5, r6, pc}
 8005128:	002dc6c0 	.word	0x002dc6c0

0800512c <SX1278_HW_SetNSS.constprop.6>:
		__Lora_SX1278->HW_GPIO_Reset_Pin( __Lora_SX1278->HW.NSS.Port, __Lora_SX1278->HW.NSS.Pin );
 800512c:	f8d0 343c 	ldr.w	r3, [r0, #1084]	; 0x43c
 8005130:	8a01      	ldrh	r1, [r0, #16]
 8005132:	6940      	ldr	r0, [r0, #20]
 8005134:	4718      	bx	r3

08005136 <SX1278_SPIBurstWrite.part.1>:
	}
}



static void SX1278_SPIBurstWrite( Lora_SX1278_t *__Lora_SX1278, uint8_t addr, uint8_t* txBuf, uint8_t length ) 
 8005136:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005138:	4604      	mov	r4, r0
 800513a:	460e      	mov	r6, r1
 800513c:	4615      	mov	r5, r2
 800513e:	461f      	mov	r7, r3
	{
		return;
	} 
	else 
	{
		SX1278_HW_SetNSS( __Lora_SX1278, 0 );
 8005140:	f7ff fff4 	bl	800512c <SX1278_HW_SetNSS.constprop.6>
		__Lora_SX1278->HW_SPI_WriteByte( addr | 0x80, 0xffff );
 8005144:	f8d4 3448 	ldr.w	r3, [r4, #1096]	; 0x448
 8005148:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800514c:	f046 0080 	orr.w	r0, r6, #128	; 0x80
 8005150:	4798      	blx	r3
		SX1278_Wait_SPIReady( __Lora_SX1278, 3000 );
 8005152:	4620      	mov	r0, r4
 8005154:	f7ff ffd8 	bl	8005108 <SX1278_Wait_SPIReady.constprop.5>
 8005158:	3f01      	subs	r7, #1
 800515a:	1e6e      	subs	r6, r5, #1
 800515c:	443d      	add	r5, r7

		for (i = 0; i < length; i++) 
 800515e:	42ae      	cmp	r6, r5
 8005160:	d104      	bne.n	800516c <SX1278_SPIBurstWrite.part.1+0x36>
 8005162:	4620      	mov	r0, r4
			__Lora_SX1278->HW_SPI_WriteByte( *(txBuf + i), 0xffff );
			SX1278_Wait_SPIReady( __Lora_SX1278, 3000 );
		}
		SX1278_HW_SetNSS( __Lora_SX1278, 1 );
	}
}
 8005164:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 8005168:	f7ff bfb0 	b.w	80050cc <SX1278_HW_SetNSS.part.0>
			__Lora_SX1278->HW_SPI_WriteByte( *(txBuf + i), 0xffff );
 800516c:	f8d4 3448 	ldr.w	r3, [r4, #1096]	; 0x448
 8005170:	f816 0f01 	ldrb.w	r0, [r6, #1]!
 8005174:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8005178:	4798      	blx	r3
			SX1278_Wait_SPIReady( __Lora_SX1278, 3000 );
 800517a:	4620      	mov	r0, r4
 800517c:	f7ff ffc4 	bl	8005108 <SX1278_Wait_SPIReady.constprop.5>
 8005180:	e7ed      	b.n	800515e <SX1278_SPIBurstWrite.part.1+0x28>

08005182 <SX1278_SPIWrite>:
{
 8005182:	b570      	push	{r4, r5, r6, lr}
 8005184:	4604      	mov	r4, r0
 8005186:	460e      	mov	r6, r1
 8005188:	4615      	mov	r5, r2
	SX1278_HW_SetNSS( __Lora_SX1278, 0 );
 800518a:	f7ff ffcf 	bl	800512c <SX1278_HW_SetNSS.constprop.6>
	__Lora_SX1278->HW_SPI_WriteByte( addr | 0x80, 0xffff );
 800518e:	f8d4 3448 	ldr.w	r3, [r4, #1096]	; 0x448
 8005192:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8005196:	f046 0080 	orr.w	r0, r6, #128	; 0x80
 800519a:	4798      	blx	r3
	SX1278_Wait_SPIReady( __Lora_SX1278, 3000 );
 800519c:	4620      	mov	r0, r4
 800519e:	f7ff ffb3 	bl	8005108 <SX1278_Wait_SPIReady.constprop.5>
	__Lora_SX1278->HW_SPI_WriteByte( cmd, 0xffff );
 80051a2:	f8d4 3448 	ldr.w	r3, [r4, #1096]	; 0x448
 80051a6:	f64f 71ff 	movw	r1, #65535	; 0xffff
 80051aa:	4628      	mov	r0, r5
 80051ac:	4798      	blx	r3
	SX1278_Wait_SPIReady( __Lora_SX1278, 3000 );
 80051ae:	4620      	mov	r0, r4
 80051b0:	f7ff ffaa 	bl	8005108 <SX1278_Wait_SPIReady.constprop.5>
 80051b4:	4620      	mov	r0, r4
}
 80051b6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 80051ba:	f7ff bf87 	b.w	80050cc <SX1278_HW_SetNSS.part.0>

080051be <SX1278_SPIReadByte>:
{
 80051be:	b538      	push	{r3, r4, r5, lr}
 80051c0:	4604      	mov	r4, r0
 80051c2:	460d      	mov	r5, r1
	SX1278_HW_SetNSS( __Lora_SX1278, 0 );
 80051c4:	f7ff ffb2 	bl	800512c <SX1278_HW_SetNSS.constprop.6>
	__Lora_SX1278->HW_SPI_WriteByte( addr, 0xffff );
 80051c8:	f64f 71ff 	movw	r1, #65535	; 0xffff
 80051cc:	f8d4 3448 	ldr.w	r3, [r4, #1096]	; 0x448
 80051d0:	4628      	mov	r0, r5
 80051d2:	4798      	blx	r3
	SX1278_Wait_SPIReady( __Lora_SX1278, 3000 );
 80051d4:	4620      	mov	r0, r4
 80051d6:	f7ff ff97 	bl	8005108 <SX1278_Wait_SPIReady.constprop.5>
	tmp = __Lora_SX1278->HW_SPI_ReadByte( 0xffff );
 80051da:	f8d4 344c 	ldr.w	r3, [r4, #1100]	; 0x44c
 80051de:	f64f 70ff 	movw	r0, #65535	; 0xffff
 80051e2:	4798      	blx	r3
 80051e4:	4605      	mov	r5, r0
	SX1278_Wait_SPIReady( __Lora_SX1278, 3000 );
 80051e6:	4620      	mov	r0, r4
 80051e8:	f7ff ff8e 	bl	8005108 <SX1278_Wait_SPIReady.constprop.5>
 80051ec:	4620      	mov	r0, r4
 80051ee:	f7ff ff6d 	bl	80050cc <SX1278_HW_SetNSS.part.0>
}
 80051f2:	4628      	mov	r0, r5
 80051f4:	bd38      	pop	{r3, r4, r5, pc}

080051f6 <SX1278_Standby>:
}



void SX1278_Standby( Lora_SX1278_t *__Lora_SX1278 ) 
{
 80051f6:	b510      	push	{r4, lr}
	SX1278_SPIWrite( __Lora_SX1278, LR_RegOpMode, 0x09 );
 80051f8:	2209      	movs	r2, #9
{
 80051fa:	4604      	mov	r4, r0
	SX1278_SPIWrite( __Lora_SX1278, LR_RegOpMode, 0x09 );
 80051fc:	2101      	movs	r1, #1
 80051fe:	f7ff ffc0 	bl	8005182 <SX1278_SPIWrite>
	__Lora_SX1278->Cfg.Status = STANDBY;
 8005202:	2301      	movs	r3, #1
 8005204:	77a3      	strb	r3, [r4, #30]
 8005206:	bd10      	pop	{r4, pc}

08005208 <SX1278_Sleep>:
}



void SX1278_Sleep( Lora_SX1278_t *__Lora_SX1278 ) 
{
 8005208:	b510      	push	{r4, lr}
	SX1278_SPIWrite( __Lora_SX1278, LR_RegOpMode, 0x08 );
 800520a:	2208      	movs	r2, #8
{
 800520c:	4604      	mov	r4, r0
	SX1278_SPIWrite( __Lora_SX1278, LR_RegOpMode, 0x08 );
 800520e:	2101      	movs	r1, #1
 8005210:	f7ff ffb7 	bl	8005182 <SX1278_SPIWrite>
	__Lora_SX1278->Cfg.Status = SLEEP;
 8005214:	2300      	movs	r3, #0
 8005216:	77a3      	strb	r3, [r4, #30]
 8005218:	bd10      	pop	{r4, pc}

0800521a <SX1278_entryLoRa>:



void SX1278_entryLoRa( Lora_SX1278_t *__Lora_SX1278 ) 
{
	SX1278_SPIWrite( __Lora_SX1278, LR_RegOpMode, 0x88 );
 800521a:	2288      	movs	r2, #136	; 0x88
 800521c:	2101      	movs	r1, #1
 800521e:	f7ff bfb0 	b.w	8005182 <SX1278_SPIWrite>
	...

08005224 <SX1278_defaultConfig>:
{
 8005224:	b538      	push	{r3, r4, r5, lr}
 8005226:	4604      	mov	r4, r0
	SX1278_Sleep( __Lora_SX1278 ); //Change modem mode Must in Sleep mode
 8005228:	f7ff ffee 	bl	8005208 <SX1278_Sleep>
	__Lora_SX1278->SX1278_Delay_ms(15);
 800522c:	f8d4 3424 	ldr.w	r3, [r4, #1060]	; 0x424
	if (SX1278_SpreadFactor[__Lora_SX1278->Cfg.LoRa_Rate] == 6)	//SFactor=6
 8005230:	4d39      	ldr	r5, [pc, #228]	; (8005318 <SX1278_defaultConfig+0xf4>)
	__Lora_SX1278->SX1278_Delay_ms(15);
 8005232:	200f      	movs	r0, #15
 8005234:	4798      	blx	r3
	SX1278_entryLoRa( __Lora_SX1278 );
 8005236:	4620      	mov	r0, r4
 8005238:	f7ff ffef 	bl	800521a <SX1278_entryLoRa>
	SX1278_SPIBurstWrite( __Lora_SX1278, LR_RegFrMsb, (uint8_t *)SX1278_Frequency[__Lora_SX1278->Cfg.Frequency], 3 );
 800523c:	7e22      	ldrb	r2, [r4, #24]
 800523e:	4937      	ldr	r1, [pc, #220]	; (800531c <SX1278_defaultConfig+0xf8>)
 8005240:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8005244:	440a      	add	r2, r1
 8005246:	2303      	movs	r3, #3
 8005248:	2106      	movs	r1, #6
 800524a:	4620      	mov	r0, r4
 800524c:	f7ff ff73 	bl	8005136 <SX1278_SPIBurstWrite.part.1>
	SX1278_SPIWrite( __Lora_SX1278, LR_RegPaConfig, SX1278_Power[__Lora_SX1278->Cfg.Power] );	//Setting output power parameter
 8005250:	7e63      	ldrb	r3, [r4, #25]
 8005252:	4a33      	ldr	r2, [pc, #204]	; (8005320 <SX1278_defaultConfig+0xfc>)
 8005254:	2109      	movs	r1, #9
 8005256:	5cd2      	ldrb	r2, [r2, r3]
 8005258:	4620      	mov	r0, r4
 800525a:	f7ff ff92 	bl	8005182 <SX1278_SPIWrite>
	SX1278_SPIWrite( __Lora_SX1278, LR_RegOcp, 0x0B );			//RegOcp,Close Ocp
 800525e:	220b      	movs	r2, #11
 8005260:	4611      	mov	r1, r2
 8005262:	4620      	mov	r0, r4
 8005264:	f7ff ff8d 	bl	8005182 <SX1278_SPIWrite>
	SX1278_SPIWrite( __Lora_SX1278, LR_RegLna, 0x23 );			//RegLNA,High & LNA Enable
 8005268:	2223      	movs	r2, #35	; 0x23
 800526a:	210c      	movs	r1, #12
 800526c:	4620      	mov	r0, r4
 800526e:	f7ff ff88 	bl	8005182 <SX1278_SPIWrite>
	if (SX1278_SpreadFactor[__Lora_SX1278->Cfg.LoRa_Rate] == 6)	//SFactor=6
 8005272:	7ea3      	ldrb	r3, [r4, #26]
 8005274:	4a2b      	ldr	r2, [pc, #172]	; (8005324 <SX1278_defaultConfig+0x100>)
 8005276:	5ceb      	ldrb	r3, [r5, r3]
 8005278:	2b06      	cmp	r3, #6
 800527a:	7ee3      	ldrb	r3, [r4, #27]
						((SX1278_LoRaBandwidth[__Lora_SX1278->Cfg.LoRa_BW] << 4) + (SX1278_CR << 1) + 0x01) );//Implicit Enable CRC Enable(0x02) & Error Coding rate 4/5(0x01), 4/6(0x02), 4/7(0x03), 4/8(0x04)
 800527c:	5cd2      	ldrb	r2, [r2, r3]
 800527e:	ea4f 1202 	mov.w	r2, r2, lsl #4
	if (SX1278_SpreadFactor[__Lora_SX1278->Cfg.LoRa_Rate] == 6)	//SFactor=6
 8005282:	d13b      	bne.n	80052fc <SX1278_defaultConfig+0xd8>
		SX1278_SPIWrite( __Lora_SX1278, LR_RegModemConfig1, \
 8005284:	3203      	adds	r2, #3
 8005286:	b2d2      	uxtb	r2, r2
 8005288:	211d      	movs	r1, #29
 800528a:	4620      	mov	r0, r4
 800528c:	f7ff ff79 	bl	8005182 <SX1278_SPIWrite>
						((SX1278_SpreadFactor[__Lora_SX1278->Cfg.LoRa_Rate] << 4) + (SX1278_CRC << 2) + 0x03) );
 8005290:	7ea3      	ldrb	r3, [r4, #26]
 8005292:	5cea      	ldrb	r2, [r5, r3]
 8005294:	0112      	lsls	r2, r2, #4
		SX1278_SPIWrite( __Lora_SX1278, LR_RegModemConfig2, \
 8005296:	3207      	adds	r2, #7
 8005298:	b2d2      	uxtb	r2, r2
 800529a:	211e      	movs	r1, #30
 800529c:	4620      	mov	r0, r4
 800529e:	f7ff ff70 	bl	8005182 <SX1278_SPIWrite>
		tmp = SX1278_SPIReadByte( __Lora_SX1278, 0x31);
 80052a2:	2131      	movs	r1, #49	; 0x31
 80052a4:	4620      	mov	r0, r4
 80052a6:	f7ff ff8a 	bl	80051be <SX1278_SPIReadByte>
		tmp &= 0xF8;
 80052aa:	f000 02f8 	and.w	r2, r0, #248	; 0xf8
		SX1278_SPIWrite( __Lora_SX1278, 0x31, tmp );
 80052ae:	f042 0205 	orr.w	r2, r2, #5
 80052b2:	2131      	movs	r1, #49	; 0x31
 80052b4:	4620      	mov	r0, r4
 80052b6:	f7ff ff64 	bl	8005182 <SX1278_SPIWrite>
		SX1278_SPIWrite( __Lora_SX1278, 0x37, 0x0C );
 80052ba:	220c      	movs	r2, #12
 80052bc:	2137      	movs	r1, #55	; 0x37
		SX1278_SPIWrite( __Lora_SX1278, LR_RegModemConfig2, \
 80052be:	4620      	mov	r0, r4
 80052c0:	f7ff ff5f 	bl	8005182 <SX1278_SPIWrite>
	SX1278_SPIWrite( __Lora_SX1278, LR_RegSymbTimeoutLsb, 0xFF );		//RegSymbTimeoutLsb Timeout = 0x3FF(Max)
 80052c4:	4620      	mov	r0, r4
 80052c6:	22ff      	movs	r2, #255	; 0xff
 80052c8:	211f      	movs	r1, #31
 80052ca:	f7ff ff5a 	bl	8005182 <SX1278_SPIWrite>
	SX1278_SPIWrite( __Lora_SX1278, LR_RegPreambleMsb, 0x00 );			//RegPreambleMsb
 80052ce:	4620      	mov	r0, r4
 80052d0:	2200      	movs	r2, #0
 80052d2:	2120      	movs	r1, #32
 80052d4:	f7ff ff55 	bl	8005182 <SX1278_SPIWrite>
	SX1278_SPIWrite( __Lora_SX1278, LR_RegPreambleLsb, 12 );			//RegPreambleLsb 8+4=12byte Preamble
 80052d8:	4620      	mov	r0, r4
 80052da:	220c      	movs	r2, #12
 80052dc:	2121      	movs	r1, #33	; 0x21
 80052de:	f7ff ff50 	bl	8005182 <SX1278_SPIWrite>
	SX1278_SPIWrite( __Lora_SX1278, REG_LR_DIOMAPPING2, 0x01 );			//RegDioMapping2 DIO5=00, DIO4=01
 80052e2:	4620      	mov	r0, r4
 80052e4:	2201      	movs	r2, #1
 80052e6:	2141      	movs	r1, #65	; 0x41
 80052e8:	f7ff ff4b 	bl	8005182 <SX1278_SPIWrite>
	__Lora_SX1278->Cfg.rxBuffer_Lenght = 0;
 80052ec:	2300      	movs	r3, #0
 80052ee:	f8a4 3420 	strh.w	r3, [r4, #1056]	; 0x420
	SX1278_Standby( __Lora_SX1278 ); //Entry standby mode
 80052f2:	4620      	mov	r0, r4
}
 80052f4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	SX1278_Standby( __Lora_SX1278 ); //Entry standby mode
 80052f8:	f7ff bf7d 	b.w	80051f6 <SX1278_Standby>
		SX1278_SPIWrite( __Lora_SX1278, LR_RegModemConfig1, \
 80052fc:	3202      	adds	r2, #2
 80052fe:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
 8005302:	211d      	movs	r1, #29
 8005304:	4620      	mov	r0, r4
 8005306:	f7ff ff3c 	bl	8005182 <SX1278_SPIWrite>
						((SX1278_SpreadFactor[__Lora_SX1278->Cfg.LoRa_Rate] << 4) + (SX1278_CRC << 2) + 0x03) );//SFactor &  LNA gain set by the internal AGC loop
 800530a:	7ea3      	ldrb	r3, [r4, #26]
 800530c:	5cea      	ldrb	r2, [r5, r3]
 800530e:	0112      	lsls	r2, r2, #4
		SX1278_SPIWrite( __Lora_SX1278, LR_RegModemConfig2, \
 8005310:	3207      	adds	r2, #7
 8005312:	b2d2      	uxtb	r2, r2
 8005314:	211e      	movs	r1, #30
 8005316:	e7d2      	b.n	80052be <SX1278_defaultConfig+0x9a>
 8005318:	0800c625 	.word	0x0800c625
 800531c:	0800c614 	.word	0x0800c614
 8005320:	0800c621 	.word	0x0800c621
 8005324:	0800c617 	.word	0x0800c617

08005328 <SX1278_Init>:
{
 8005328:	b510      	push	{r4, lr}
 800532a:	4604      	mov	r4, r0
	__Lora_SX1278->HW_GPIO_Init_Pin_Output( __Lora_SX1278->HW.Reset.Port, __Lora_SX1278->HW.Reset.Pin );
 800532c:	f8d0 342c 	ldr.w	r3, [r0, #1068]	; 0x42c
 8005330:	8801      	ldrh	r1, [r0, #0]
 8005332:	6840      	ldr	r0, [r0, #4]
 8005334:	4798      	blx	r3
	__Lora_SX1278->HW_GPIO_Init_Pin_Output( __Lora_SX1278->HW.NSS.Port, __Lora_SX1278->HW.NSS.Pin );
 8005336:	f8d4 342c 	ldr.w	r3, [r4, #1068]	; 0x42c
 800533a:	8a21      	ldrh	r1, [r4, #16]
 800533c:	6960      	ldr	r0, [r4, #20]
 800533e:	4798      	blx	r3
	__Lora_SX1278->HW_GPIO_Init_Pin_Input( __Lora_SX1278->HW.DIO_0.Port, __Lora_SX1278->HW.DIO_0.Pin );
 8005340:	f8d4 3430 	ldr.w	r3, [r4, #1072]	; 0x430
 8005344:	8921      	ldrh	r1, [r4, #8]
 8005346:	68e0      	ldr	r0, [r4, #12]
 8005348:	4798      	blx	r3
 800534a:	4620      	mov	r0, r4
 800534c:	f7ff febe 	bl	80050cc <SX1278_HW_SetNSS.part.0>
	__Lora_SX1278->HW_GPIO_Set_Pin( __Lora_SX1278->HW.Reset.Port, __Lora_SX1278->HW.Reset.Pin );
 8005350:	f8d4 3438 	ldr.w	r3, [r4, #1080]	; 0x438
 8005354:	8821      	ldrh	r1, [r4, #0]
 8005356:	6860      	ldr	r0, [r4, #4]
 8005358:	4798      	blx	r3
	__Lora_SX1278->HW_SPI_Init();
 800535a:	f8d4 3440 	ldr.w	r3, [r4, #1088]	; 0x440
 800535e:	4798      	blx	r3
	SX1278_defaultConfig( __Lora_SX1278 );
 8005360:	4620      	mov	r0, r4
}
 8005362:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	SX1278_defaultConfig( __Lora_SX1278 );
 8005366:	f7ff bf5d 	b.w	8005224 <SX1278_defaultConfig>

0800536a <SX1278_ClearLoRaIrq>:



void SX1278_ClearLoRaIrq( Lora_SX1278_t *__Lora_SX1278 )
{
	SX1278_SPIWrite( __Lora_SX1278, LR_RegIrqFlags, 0xFF );
 800536a:	22ff      	movs	r2, #255	; 0xff
 800536c:	2112      	movs	r1, #18
 800536e:	f7ff bf08 	b.w	8005182 <SX1278_SPIWrite>

08005372 <SX1278_LoRaEntryRx>:
}



bool SX1278_LoRaEntryRx( Lora_SX1278_t *__Lora_SX1278, uint16_t Length, uint32_t Timeout) 
{
 8005372:	b538      	push	{r3, r4, r5, lr}
 8005374:	4604      	mov	r4, r0
	uint8_t addr;

	__Lora_SX1278->Cfg.packetLength = Length;
 8005376:	8381      	strh	r1, [r0, #28]
{
 8005378:	4615      	mov	r5, r2

	//SX1278_defaultConfig( __Lora_SX1278 );		//Setting base parameter
	SX1278_SPIWrite( __Lora_SX1278, REG_LR_PADAC, 0x84 );		//Normal and RX
 800537a:	214d      	movs	r1, #77	; 0x4d
 800537c:	2284      	movs	r2, #132	; 0x84
 800537e:	f7ff ff00 	bl	8005182 <SX1278_SPIWrite>
	SX1278_SPIWrite( __Lora_SX1278, LR_RegHopPeriod, 0xFF );	//No FHSS
 8005382:	22ff      	movs	r2, #255	; 0xff
 8005384:	2124      	movs	r1, #36	; 0x24
 8005386:	4620      	mov	r0, r4
 8005388:	f7ff fefb 	bl	8005182 <SX1278_SPIWrite>
	SX1278_SPIWrite( __Lora_SX1278, REG_LR_DIOMAPPING1, 0x01 );	//DIO=00,DIO1=00,DIO2=00, DIO3=01
 800538c:	2201      	movs	r2, #1
 800538e:	2140      	movs	r1, #64	; 0x40
 8005390:	4620      	mov	r0, r4
 8005392:	f7ff fef6 	bl	8005182 <SX1278_SPIWrite>
	SX1278_SPIWrite( __Lora_SX1278, LR_RegIrqFlagsMask, 0x3F );	//Open RxDone interrupt & Timeout
 8005396:	223f      	movs	r2, #63	; 0x3f
 8005398:	2111      	movs	r1, #17
 800539a:	4620      	mov	r0, r4
 800539c:	f7ff fef1 	bl	8005182 <SX1278_SPIWrite>
	SX1278_ClearLoRaIrq( __Lora_SX1278 );
 80053a0:	4620      	mov	r0, r4
 80053a2:	f7ff ffe2 	bl	800536a <SX1278_ClearLoRaIrq>
	SX1278_SPIWrite( __Lora_SX1278, LR_RegPayloadLength, LR_RegPayloadLength );//Payload Length 21byte(this register must difine when the data long of one byte in SF is 6)
 80053a6:	2222      	movs	r2, #34	; 0x22
 80053a8:	4611      	mov	r1, r2
 80053aa:	4620      	mov	r0, r4
 80053ac:	f7ff fee9 	bl	8005182 <SX1278_SPIWrite>
	
	addr = SX1278_SPIReadByte( __Lora_SX1278, LR_RegFifoRxBaseAddr);//Read RxBaseAddr
 80053b0:	210f      	movs	r1, #15
 80053b2:	4620      	mov	r0, r4
 80053b4:	f7ff ff03 	bl	80051be <SX1278_SPIReadByte>
	SX1278_SPIWrite( __Lora_SX1278, LR_RegFifoAddrPtr, addr );		//RxBaseAddr->FiFoAddrPtr
 80053b8:	210d      	movs	r1, #13
 80053ba:	4602      	mov	r2, r0
 80053bc:	4620      	mov	r0, r4
 80053be:	f7ff fee0 	bl	8005182 <SX1278_SPIWrite>
	SX1278_SPIWrite( __Lora_SX1278, LR_RegOpMode, 0x8d );			//Mode//Low Frequency Mode
 80053c2:	228d      	movs	r2, #141	; 0x8d
 80053c4:	2101      	movs	r1, #1
 80053c6:	4620      	mov	r0, r4
 80053c8:	f7ff fedb 	bl	8005182 <SX1278_SPIWrite>
	//SX1278_SPIWrite(module, LR_RegOpMode,0x05);	//Continuous Rx Mode //High Frequency Mode
	__Lora_SX1278->Cfg.rxBuffer_Lenght = 0;
 80053cc:	2300      	movs	r3, #0
 80053ce:	f8a4 3420 	strh.w	r3, [r4, #1056]	; 0x420

	while (1) 
	{
		if( (SX1278_SPIReadByte( __Lora_SX1278, LR_RegModemStat) & 0x04) == 0x04 ) //Rx-on going RegModemStat
 80053d2:	2118      	movs	r1, #24
 80053d4:	4620      	mov	r0, r4
 80053d6:	f7ff fef2 	bl	80051be <SX1278_SPIReadByte>
 80053da:	0743      	lsls	r3, r0, #29
 80053dc:	d503      	bpl.n	80053e6 <SX1278_LoRaEntryRx+0x74>
		{	
			__Lora_SX1278->Cfg.Status = RX;
 80053de:	2303      	movs	r3, #3
 80053e0:	77a3      	strb	r3, [r4, #30]
			return true;
 80053e2:	2001      	movs	r0, #1
 80053e4:	bd38      	pop	{r3, r4, r5, pc}
		}
		
		if(--Timeout == 0) 
 80053e6:	3d01      	subs	r5, #1
 80053e8:	d107      	bne.n	80053fa <SX1278_LoRaEntryRx+0x88>
		{
			SX1278_HW_Reset( __Lora_SX1278 );
 80053ea:	4620      	mov	r0, r4
 80053ec:	f7ff fe73 	bl	80050d6 <SX1278_HW_Reset>
			SX1278_defaultConfig( __Lora_SX1278 );
 80053f0:	4620      	mov	r0, r4
 80053f2:	f7ff ff17 	bl	8005224 <SX1278_defaultConfig>
			return false;
 80053f6:	4628      	mov	r0, r5
 80053f8:	bd38      	pop	{r3, r4, r5, pc}
		}
		__Lora_SX1278->SX1278_Delay_ms(1);
 80053fa:	f8d4 3424 	ldr.w	r3, [r4, #1060]	; 0x424
 80053fe:	2001      	movs	r0, #1
 8005400:	4798      	blx	r3
		if( (SX1278_SPIReadByte( __Lora_SX1278, LR_RegModemStat) & 0x04) == 0x04 ) //Rx-on going RegModemStat
 8005402:	e7e6      	b.n	80053d2 <SX1278_LoRaEntryRx+0x60>

08005404 <SX1278_LoRaRxPacket>:
}



uint16_t SX1278_LoRaRxPacket( Lora_SX1278_t *__Lora_SX1278 ) 
{
 8005404:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return __Lora_SX1278->HW_GPIO_Read_Pin( __Lora_SX1278->HW.DIO_0.Port, __Lora_SX1278->HW.DIO_0.Pin );
 8005408:	f8d0 3434 	ldr.w	r3, [r0, #1076]	; 0x434
 800540c:	8901      	ldrh	r1, [r0, #8]
{
 800540e:	4604      	mov	r4, r0
	return __Lora_SX1278->HW_GPIO_Read_Pin( __Lora_SX1278->HW.DIO_0.Port, __Lora_SX1278->HW.DIO_0.Pin );
 8005410:	68c0      	ldr	r0, [r0, #12]
 8005412:	4798      	blx	r3
	unsigned char addr;
	unsigned char packet_size;

	if( SX1278_HW_GetDIO0( __Lora_SX1278 ) ) 
 8005414:	b3b8      	cbz	r0, 8005486 <SX1278_LoRaRxPacket+0x82>
	{
		memset( __Lora_SX1278->Cfg.rxBuffer, 0x00, __Lora_SX1278->Cfg.rxBuffer_Lenght);
 8005416:	f104 081f 	add.w	r8, r4, #31
 800541a:	f8b4 2420 	ldrh.w	r2, [r4, #1056]	; 0x420
 800541e:	2100      	movs	r1, #0
 8005420:	4640      	mov	r0, r8
 8005422:	f002 fbae 	bl	8007b82 <memset>

		addr = SX1278_SPIReadByte( __Lora_SX1278, LR_RegFifoRxCurrentaddr);//last packet addr
 8005426:	2110      	movs	r1, #16
 8005428:	4620      	mov	r0, r4
 800542a:	f7ff fec8 	bl	80051be <SX1278_SPIReadByte>
		SX1278_SPIWrite( __Lora_SX1278, LR_RegFifoAddrPtr, addr );		//RxBaseAddr -> FiFoAddrPtr
 800542e:	210d      	movs	r1, #13
 8005430:	4602      	mov	r2, r0
 8005432:	4620      	mov	r0, r4
 8005434:	f7ff fea5 	bl	8005182 <SX1278_SPIWrite>

		if( __Lora_SX1278->Cfg.LoRa_Rate == SX1278_LORA_SF_6 ) //When SpreadFactor is six,will used Implicit Header mode(Excluding internal packet length)
 8005438:	7ea3      	ldrb	r3, [r4, #26]
 800543a:	bb43      	cbnz	r3, 800548e <SX1278_LoRaRxPacket+0x8a>
			packet_size = __Lora_SX1278->Cfg.packetLength;
 800543c:	7f25      	ldrb	r5, [r4, #28]
	if (length <= 1) 
 800543e:	2d01      	cmp	r5, #1
 8005440:	d91c      	bls.n	800547c <SX1278_LoRaRxPacket+0x78>
		SX1278_HW_SetNSS( __Lora_SX1278, 0 );
 8005442:	4620      	mov	r0, r4
 8005444:	f7ff fe72 	bl	800512c <SX1278_HW_SetNSS.constprop.6>
		__Lora_SX1278->HW_SPI_WriteByte( addr, 0xffff );
 8005448:	f8d4 3448 	ldr.w	r3, [r4, #1096]	; 0x448
 800544c:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8005450:	2000      	movs	r0, #0
 8005452:	4798      	blx	r3
		SX1278_Wait_SPIReady( __Lora_SX1278, 3000 );
 8005454:	4620      	mov	r0, r4
 8005456:	f7ff fe57 	bl	8005108 <SX1278_Wait_SPIReady.constprop.5>
 800545a:	1e6f      	subs	r7, r5, #1
 800545c:	f104 061e 	add.w	r6, r4, #30
 8005460:	fa58 f787 	uxtab	r7, r8, r7
			*(rxBuf + i) = __Lora_SX1278->HW_SPI_ReadByte( 0xffff );
 8005464:	f8d4 344c 	ldr.w	r3, [r4, #1100]	; 0x44c
 8005468:	f64f 70ff 	movw	r0, #65535	; 0xffff
 800546c:	4798      	blx	r3
 800546e:	f806 0f01 	strb.w	r0, [r6, #1]!
		for (i = 0; i < length; i++) 
 8005472:	42b7      	cmp	r7, r6
 8005474:	d1f6      	bne.n	8005464 <SX1278_LoRaRxPacket+0x60>
 8005476:	4620      	mov	r0, r4
 8005478:	f7ff fe28 	bl	80050cc <SX1278_HW_SetNSS.part.0>
		else 
			packet_size = SX1278_SPIReadByte( __Lora_SX1278, LR_RegRxNbBytes);	//Number for received bytes
		
		SX1278_SPIBurstRead( __Lora_SX1278, 0x00, __Lora_SX1278->Cfg.rxBuffer, packet_size );
		__Lora_SX1278->Cfg.rxBuffer_Lenght = packet_size;
 800547c:	f8a4 5420 	strh.w	r5, [r4, #1056]	; 0x420
		SX1278_ClearLoRaIrq( __Lora_SX1278 );
 8005480:	4620      	mov	r0, r4
 8005482:	f7ff ff72 	bl	800536a <SX1278_ClearLoRaIrq>
	}
	return __Lora_SX1278->Cfg.rxBuffer_Lenght;
}
 8005486:	f8b4 0420 	ldrh.w	r0, [r4, #1056]	; 0x420
 800548a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			packet_size = SX1278_SPIReadByte( __Lora_SX1278, LR_RegRxNbBytes);	//Number for received bytes
 800548e:	2113      	movs	r1, #19
 8005490:	4620      	mov	r0, r4
 8005492:	f7ff fe94 	bl	80051be <SX1278_SPIReadByte>
 8005496:	4605      	mov	r5, r0
 8005498:	e7d1      	b.n	800543e <SX1278_LoRaRxPacket+0x3a>

0800549a <SX1278_LoRaEntryTx>:



bool SX1278_LoRaEntryTx( Lora_SX1278_t *__Lora_SX1278, uint16_t Length, uint32_t Timeout ) 
{
 800549a:	b570      	push	{r4, r5, r6, lr}
 800549c:	4604      	mov	r4, r0
 800549e:	460e      	mov	r6, r1
	uint8_t addr;
	uint8_t temp;

	__Lora_SX1278->Cfg.packetLength = Length;
 80054a0:	83a1      	strh	r1, [r4, #28]
{
 80054a2:	4615      	mov	r5, r2

//	SX1278_defaultConfig( __Lora_SX1278 ); //setting base parameter
	SX1278_SPIWrite( __Lora_SX1278, REG_LR_PADAC, 0x87 );		//Tx for 20dBm
 80054a4:	214d      	movs	r1, #77	; 0x4d
 80054a6:	2287      	movs	r2, #135	; 0x87
 80054a8:	f7ff fe6b 	bl	8005182 <SX1278_SPIWrite>
	SX1278_SPIWrite( __Lora_SX1278, LR_RegHopPeriod, 0x00 );	//RegHopPeriod NO FHSS
 80054ac:	2200      	movs	r2, #0
 80054ae:	2124      	movs	r1, #36	; 0x24
 80054b0:	4620      	mov	r0, r4
 80054b2:	f7ff fe66 	bl	8005182 <SX1278_SPIWrite>
	SX1278_SPIWrite( __Lora_SX1278, REG_LR_DIOMAPPING1, 0x41 );	//DIO0=01, DIO1=00,DIO2=00, DIO3=01
 80054b6:	2241      	movs	r2, #65	; 0x41
 80054b8:	2140      	movs	r1, #64	; 0x40
 80054ba:	4620      	mov	r0, r4
 80054bc:	f7ff fe61 	bl	8005182 <SX1278_SPIWrite>
	SX1278_ClearLoRaIrq( __Lora_SX1278 );
 80054c0:	4620      	mov	r0, r4
 80054c2:	f7ff ff52 	bl	800536a <SX1278_ClearLoRaIrq>
	SX1278_SPIWrite( __Lora_SX1278, LR_RegIrqFlagsMask, 0xF7 );	//Open TxDone interrupt
 80054c6:	22f7      	movs	r2, #247	; 0xf7
 80054c8:	2111      	movs	r1, #17
 80054ca:	4620      	mov	r0, r4
 80054cc:	f7ff fe59 	bl	8005182 <SX1278_SPIWrite>
	SX1278_SPIWrite( __Lora_SX1278, LR_RegPayloadLength, Length );//RegPayloadLength 21byte
 80054d0:	b2f2      	uxtb	r2, r6
 80054d2:	2122      	movs	r1, #34	; 0x22
 80054d4:	4620      	mov	r0, r4
 80054d6:	f7ff fe54 	bl	8005182 <SX1278_SPIWrite>
	
	addr = SX1278_SPIReadByte( __Lora_SX1278, LR_RegFifoTxBaseAddr);//RegFiFoTxBaseAddr
 80054da:	210e      	movs	r1, #14
 80054dc:	4620      	mov	r0, r4
 80054de:	f7ff fe6e 	bl	80051be <SX1278_SPIReadByte>
	SX1278_SPIWrite( __Lora_SX1278, LR_RegFifoAddrPtr, addr );	//RegFifoAddrPtr
 80054e2:	210d      	movs	r1, #13
 80054e4:	4602      	mov	r2, r0
 80054e6:	4620      	mov	r0, r4
 80054e8:	f7ff fe4b 	bl	8005182 <SX1278_SPIWrite>

	while (1) 
	{
		temp = SX1278_SPIReadByte( __Lora_SX1278, LR_RegPayloadLength);
 80054ec:	2122      	movs	r1, #34	; 0x22
 80054ee:	4620      	mov	r0, r4
 80054f0:	f7ff fe65 	bl	80051be <SX1278_SPIReadByte>
		if (temp == Length) 
 80054f4:	b280      	uxth	r0, r0
 80054f6:	4286      	cmp	r6, r0
 80054f8:	d103      	bne.n	8005502 <SX1278_LoRaEntryTx+0x68>
		{
			__Lora_SX1278->Cfg.Status = TX;
 80054fa:	2302      	movs	r3, #2
 80054fc:	77a3      	strb	r3, [r4, #30]
			return true;
 80054fe:	2001      	movs	r0, #1
 8005500:	bd70      	pop	{r4, r5, r6, pc}
		}

		if (--Timeout == 0) 
 8005502:	3d01      	subs	r5, #1
 8005504:	d1f2      	bne.n	80054ec <SX1278_LoRaEntryTx+0x52>
		{
			SX1278_HW_Reset( __Lora_SX1278 );
 8005506:	4620      	mov	r0, r4
 8005508:	f7ff fde5 	bl	80050d6 <SX1278_HW_Reset>
			SX1278_defaultConfig( __Lora_SX1278 );
 800550c:	4620      	mov	r0, r4
 800550e:	f7ff fe89 	bl	8005224 <SX1278_defaultConfig>
			return false;
 8005512:	4628      	mov	r0, r5
		}
	}
}
 8005514:	bd70      	pop	{r4, r5, r6, pc}

08005516 <SX1278_LoRaTxPacket>:



bool SX1278_LoRaTxPacket( Lora_SX1278_t *__Lora_SX1278, uint8_t* txBuffer, uint16_t Length, uint32_t Timeout ) 
{ 
 8005516:	b538      	push	{r3, r4, r5, lr}
 8005518:	461d      	mov	r5, r3
	SX1278_SPIBurstWrite( __Lora_SX1278, 0x00, txBuffer, Length );
 800551a:	b2d3      	uxtb	r3, r2
	if (length <= 1) 
 800551c:	2b01      	cmp	r3, #1
{ 
 800551e:	4604      	mov	r4, r0
	if (length <= 1) 
 8005520:	d903      	bls.n	800552a <SX1278_LoRaTxPacket+0x14>
 8005522:	460a      	mov	r2, r1
 8005524:	2100      	movs	r1, #0
 8005526:	f7ff fe06 	bl	8005136 <SX1278_SPIBurstWrite.part.1>
	SX1278_SPIWrite( __Lora_SX1278, LR_RegOpMode, 0x8b );		//Tx Mode
 800552a:	228b      	movs	r2, #139	; 0x8b
 800552c:	2101      	movs	r1, #1
 800552e:	4620      	mov	r0, r4
 8005530:	f7ff fe27 	bl	8005182 <SX1278_SPIWrite>
	return __Lora_SX1278->HW_GPIO_Read_Pin( __Lora_SX1278->HW.DIO_0.Port, __Lora_SX1278->HW.DIO_0.Pin );
 8005534:	f8d4 3434 	ldr.w	r3, [r4, #1076]	; 0x434
 8005538:	8921      	ldrh	r1, [r4, #8]
 800553a:	68e0      	ldr	r0, [r4, #12]
 800553c:	4798      	blx	r3
	
	while (1)
	{
		if ( SX1278_HW_GetDIO0( __Lora_SX1278 ) ) //Packet send over
 800553e:	b158      	cbz	r0, 8005558 <SX1278_LoRaTxPacket+0x42>
		{ 
			SX1278_SPIReadByte( __Lora_SX1278, LR_RegIrqFlags);
 8005540:	2112      	movs	r1, #18
 8005542:	4620      	mov	r0, r4
 8005544:	f7ff fe3b 	bl	80051be <SX1278_SPIReadByte>
			SX1278_ClearLoRaIrq( __Lora_SX1278 ); //Clear irq
 8005548:	4620      	mov	r0, r4
 800554a:	f7ff ff0e 	bl	800536a <SX1278_ClearLoRaIrq>
			SX1278_Standby( __Lora_SX1278 ); //Entry Standby mode
 800554e:	4620      	mov	r0, r4
 8005550:	f7ff fe51 	bl	80051f6 <SX1278_Standby>
			return true;
 8005554:	2001      	movs	r0, #1
 8005556:	bd38      	pop	{r3, r4, r5, pc}
		}

		if (--Timeout == 0) 
 8005558:	3d01      	subs	r5, #1
 800555a:	d107      	bne.n	800556c <SX1278_LoRaTxPacket+0x56>
		{
			SX1278_HW_Reset( __Lora_SX1278 );
 800555c:	4620      	mov	r0, r4
 800555e:	f7ff fdba 	bl	80050d6 <SX1278_HW_Reset>
			SX1278_defaultConfig( __Lora_SX1278 );
 8005562:	4620      	mov	r0, r4
 8005564:	f7ff fe5e 	bl	8005224 <SX1278_defaultConfig>
 8005568:	4628      	mov	r0, r5
 800556a:	bd38      	pop	{r3, r4, r5, pc}
			return false;
		}
		__Lora_SX1278->SX1278_Delay_ms(1);
 800556c:	f8d4 3424 	ldr.w	r3, [r4, #1060]	; 0x424
 8005570:	2001      	movs	r0, #1
 8005572:	4798      	blx	r3
		if ( SX1278_HW_GetDIO0( __Lora_SX1278 ) ) //Packet send over
 8005574:	e7de      	b.n	8005534 <SX1278_LoRaTxPacket+0x1e>

08005576 <SX1278_Transmit>:
}



bool SX1278_Transmit( Lora_SX1278_t *__Lora_SX1278, uint8_t* txBuf, uint16_t Length, uint32_t Timeout) 
{
 8005576:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800557a:	4614      	mov	r4, r2
 800557c:	460f      	mov	r7, r1
	if( SX1278_LoRaEntryTx( __Lora_SX1278, Length, Timeout) == true )
 800557e:	461a      	mov	r2, r3
 8005580:	4621      	mov	r1, r4
{
 8005582:	4606      	mov	r6, r0
 8005584:	461d      	mov	r5, r3
	if( SX1278_LoRaEntryTx( __Lora_SX1278, Length, Timeout) == true )
 8005586:	f7ff ff88 	bl	800549a <SX1278_LoRaEntryTx>
 800558a:	b138      	cbz	r0, 800559c <SX1278_Transmit+0x26>
		return SX1278_LoRaTxPacket( __Lora_SX1278, txBuf, Length, Timeout );
 800558c:	462b      	mov	r3, r5
 800558e:	4622      	mov	r2, r4
 8005590:	4639      	mov	r1, r7
 8005592:	4630      	mov	r0, r6

	return false;
}
 8005594:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		return SX1278_LoRaTxPacket( __Lora_SX1278, txBuf, Length, Timeout );
 8005598:	f7ff bfbd 	b.w	8005516 <SX1278_LoRaTxPacket>
}
 800559c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080055a0 <SX1278_Receive>:



bool SX1278_Receive( Lora_SX1278_t *__Lora_SX1278, uint8_t* rxBuf, uint16_t *RXBuffer_Lenght )
{
 80055a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__Lora_SX1278->Cfg.rxBuffer_Lenght = 0;
 80055a2:	2700      	movs	r7, #0
 80055a4:	f8a0 7420 	strh.w	r7, [r0, #1056]	; 0x420
{
 80055a8:	4614      	mov	r4, r2
 80055aa:	4605      	mov	r5, r0
 80055ac:	460e      	mov	r6, r1
	if( (*RXBuffer_Lenght = SX1278_LoRaRxPacket( __Lora_SX1278 )) > 0 )
 80055ae:	f7ff ff29 	bl	8005404 <SX1278_LoRaRxPacket>
 80055b2:	8020      	strh	r0, [r4, #0]
 80055b4:	b150      	cbz	r0, 80055cc <SX1278_Receive+0x2c>
	{
		//memset(rxBuf, 0, strlen((char *)rxBuf));
		if (*RXBuffer_Lenght != __Lora_SX1278->Cfg.rxBuffer_Lenght)
 80055b6:	f8b5 2420 	ldrh.w	r2, [r5, #1056]	; 0x420
 80055ba:	8022      	strh	r2, [r4, #0]
			*RXBuffer_Lenght = __Lora_SX1278->Cfg.rxBuffer_Lenght;
		memcpy(rxBuf, __Lora_SX1278->Cfg.rxBuffer, *RXBuffer_Lenght);
 80055bc:	f105 011f 	add.w	r1, r5, #31
 80055c0:	4630      	mov	r0, r6
 80055c2:	f002 fad3 	bl	8007b6c <memcpy>
		rxBuf[*RXBuffer_Lenght] = '\0';
 80055c6:	8823      	ldrh	r3, [r4, #0]
 80055c8:	54f7      	strb	r7, [r6, r3]
		//__Lora_SX1278->Cfg.rxBuffer_Lenght = 0;
		return true;
 80055ca:	2001      	movs	r0, #1
	}
	return false;
}
 80055cc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080055ce <IOControl_WDT_Done>:


/******************************** WDT ********************************/
void IOControl_WDT_Done( void )
{
	GPIO_setToggle( WDT_POWER_CONTROL_PORT, WDT_POWER_CONTROL_PIN );
 80055ce:	2102      	movs	r1, #2
 80055d0:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 80055d4:	f000 b981 	b.w	80058da <GPIO_setToggle>

080055d8 <IOControl_Battery_Charger_ON>:


/******************************* Power *******************************/
void IOControl_Battery_Charger_ON( void )
{
	GPIO_setLowlevel( BATTERY_CHARGER_CONTROL_PORT, BATTERY_CHARGER_CONTROL_PIN );
 80055d8:	f44f 7180 	mov.w	r1, #256	; 0x100
 80055dc:	4801      	ldr	r0, [pc, #4]	; (80055e4 <IOControl_Battery_Charger_ON+0xc>)
 80055de:	f000 b979 	b.w	80058d4 <GPIO_setLowlevel>
 80055e2:	bf00      	nop
 80055e4:	48000800 	.word	0x48000800

080055e8 <IOControl_Lora_ON>:


/******************************* Lora ********************************/
void IOControl_Lora_ON( void )
{
	GPIO_setHighlevel( LR_POWER_CONTROL_PORT, LR_POWER_CONTROL_PIN );
 80055e8:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80055ec:	4801      	ldr	r0, [pc, #4]	; (80055f4 <IOControl_Lora_ON+0xc>)
 80055ee:	f000 b96e 	b.w	80058ce <GPIO_setHighlevel>
 80055f2:	bf00      	nop
 80055f4:	48000400 	.word	0x48000400

080055f8 <IOControl_SS_TH_Soil_ON>:

/****************************** Sensor *******************************/
//temp and humi soil sensor
void IOControl_SS_TH_Soil_ON( void )
{
	GPIO_setHighlevel( SS_THS_POWER_CONTROL_PORT, SS_THS_POWER_CONTROL_PIN );
 80055f8:	2110      	movs	r1, #16
 80055fa:	4801      	ldr	r0, [pc, #4]	; (8005600 <IOControl_SS_TH_Soil_ON+0x8>)
 80055fc:	f000 b967 	b.w	80058ce <GPIO_setHighlevel>
 8005600:	48000400 	.word	0x48000400

08005604 <IOControl_SS_TH_Soil_OFF>:
}

void IOControl_SS_TH_Soil_OFF( void )
{
	GPIO_setLowlevel( SS_THS_POWER_CONTROL_PORT, SS_THS_POWER_CONTROL_PIN );
 8005604:	2110      	movs	r1, #16
 8005606:	4801      	ldr	r0, [pc, #4]	; (800560c <IOControl_SS_TH_Soil_OFF+0x8>)
 8005608:	f000 b964 	b.w	80058d4 <GPIO_setLowlevel>
 800560c:	48000400 	.word	0x48000400

08005610 <IOControl_SS_EC_ON>:


//EC
void IOControl_SS_EC_ON( void )
{
	GPIO_setHighlevel( SS_EC_POWER_CONTROL_PORT, SS_EC_POWER_CONTROL_PIN );
 8005610:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8005614:	4801      	ldr	r0, [pc, #4]	; (800561c <IOControl_SS_EC_ON+0xc>)
 8005616:	f000 b95a 	b.w	80058ce <GPIO_setHighlevel>
 800561a:	bf00      	nop
 800561c:	48000800 	.word	0x48000800

08005620 <IOControl_SS_EC_OFF>:
}

void IOControl_SS_EC_OFF( void )
{
	GPIO_setLowlevel( SS_EC_POWER_CONTROL_PORT, SS_EC_POWER_CONTROL_PIN );
 8005620:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8005624:	4801      	ldr	r0, [pc, #4]	; (800562c <IOControl_SS_EC_OFF+0xc>)
 8005626:	f000 b955 	b.w	80058d4 <GPIO_setLowlevel>
 800562a:	bf00      	nop
 800562c:	48000800 	.word	0x48000800

08005630 <IOControl_SS_PH_ON>:


//PH
void IOControl_SS_PH_ON( void )
{
	GPIO_setHighlevel( SS_PH_POWER_CONTROL_PORT, SS_PH_POWER_CONTROL_PIN );
 8005630:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8005634:	4801      	ldr	r0, [pc, #4]	; (800563c <IOControl_SS_PH_ON+0xc>)
 8005636:	f000 b94a 	b.w	80058ce <GPIO_setHighlevel>
 800563a:	bf00      	nop
 800563c:	48000800 	.word	0x48000800

08005640 <IOControl_SS_PH_OFF>:
}

void IOControl_SS_PH_OFF( void )
{
	GPIO_setLowlevel( SS_PH_POWER_CONTROL_PORT, SS_PH_POWER_CONTROL_PIN );
 8005640:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8005644:	4801      	ldr	r0, [pc, #4]	; (800564c <IOControl_SS_PH_OFF+0xc>)
 8005646:	f000 b945 	b.w	80058d4 <GPIO_setLowlevel>
 800564a:	bf00      	nop
 800564c:	48000800 	.word	0x48000800

08005650 <IOControl_SS_CO2_ON>:


//CO2
void IOControl_SS_CO2_ON( void )
{
	GPIO_setHighlevel( SS_CO2_POWER_CONTROL_PORT, SS_CO2_POWER_CONTROL_PIN );
 8005650:	2140      	movs	r1, #64	; 0x40
 8005652:	4801      	ldr	r0, [pc, #4]	; (8005658 <IOControl_SS_CO2_ON+0x8>)
 8005654:	f000 b93b 	b.w	80058ce <GPIO_setHighlevel>
 8005658:	48000400 	.word	0x48000400

0800565c <IOControl_SS_CO2_OFF>:
}

void IOControl_SS_CO2_OFF( void )
{
	GPIO_setLowlevel( SS_CO2_POWER_CONTROL_PORT, SS_CO2_POWER_CONTROL_PIN );
 800565c:	2140      	movs	r1, #64	; 0x40
 800565e:	4801      	ldr	r0, [pc, #4]	; (8005664 <IOControl_SS_CO2_OFF+0x8>)
 8005660:	f000 b938 	b.w	80058d4 <GPIO_setLowlevel>
 8005664:	48000400 	.word	0x48000400

08005668 <IOControl_SS_THL_ON>:


//Temp Anh humi + light
void IOControl_SS_THL_ON( void )
{
	GPIO_setHighlevel( SS_THL_POWER_CONTROL_PORT, SS_THL_POWER_CONTROL_PIN );
 8005668:	2180      	movs	r1, #128	; 0x80
 800566a:	4801      	ldr	r0, [pc, #4]	; (8005670 <IOControl_SS_THL_ON+0x8>)
 800566c:	f000 b92f 	b.w	80058ce <GPIO_setHighlevel>
 8005670:	48000400 	.word	0x48000400

08005674 <IOControl_SS_THL_OFF>:
}

void IOControl_SS_THL_OFF( void )
{
	GPIO_setLowlevel( SS_THL_POWER_CONTROL_PORT, SS_THL_POWER_CONTROL_PIN );
 8005674:	2180      	movs	r1, #128	; 0x80
 8005676:	4801      	ldr	r0, [pc, #4]	; (800567c <IOControl_SS_THL_OFF+0x8>)
 8005678:	f000 b92c 	b.w	80058d4 <GPIO_setLowlevel>
 800567c:	48000400 	.word	0x48000400

08005680 <IOControl_Init>:
}



void IOControl_Init( void )
{
 8005680:	b538      	push	{r3, r4, r5, lr}
	/******************************** WDT ********************************/
	GPIO_setOutput_Pulldown( WDT_POWER_CONTROL_PORT, WDT_POWER_CONTROL_PIN );
 8005682:	2102      	movs	r1, #2

	/******************************* Power *******************************/
	//input charger
	GPIO_setInput( CHRG_CHARGER_CONTROL_PORT, CHRG_CHARGER_CONTROL_PIN );
	GPIO_setInput( FAULT_CHARGER_CONTROL_PORT, FAULT_CHARGER_CONTROL_PIN );
 8005684:	4d1d      	ldr	r5, [pc, #116]	; (80056fc <IOControl_Init+0x7c>)
	//on/off battery charger
	IOControl_Battery_Charger_ON();


	/******************************* Lora ********************************/
	GPIO_setOutput_Pulldown( LR_POWER_CONTROL_PORT, LR_POWER_CONTROL_PIN );
 8005686:	4c1e      	ldr	r4, [pc, #120]	; (8005700 <IOControl_Init+0x80>)
	GPIO_setOutput_Pulldown( WDT_POWER_CONTROL_PORT, WDT_POWER_CONTROL_PIN );
 8005688:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800568c:	f000 f8e9 	bl	8005862 <GPIO_setOutput_Pulldown>
	GPIO_setInput( CHRG_CHARGER_CONTROL_PORT, CHRG_CHARGER_CONTROL_PIN );
 8005690:	f44f 7180 	mov.w	r1, #256	; 0x100
 8005694:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8005698:	f000 f909 	bl	80058ae <GPIO_setInput>
	GPIO_setInput( FAULT_CHARGER_CONTROL_PORT, FAULT_CHARGER_CONTROL_PIN );
 800569c:	4628      	mov	r0, r5
 800569e:	f44f 7100 	mov.w	r1, #512	; 0x200
 80056a2:	f000 f904 	bl	80058ae <GPIO_setInput>
	IOControl_Battery_Charger_ON();
 80056a6:	f7ff ff97 	bl	80055d8 <IOControl_Battery_Charger_ON>
	GPIO_setOutput_Pulldown( LR_POWER_CONTROL_PORT, LR_POWER_CONTROL_PIN );
 80056aa:	4620      	mov	r0, r4
 80056ac:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80056b0:	f000 f8d7 	bl	8005862 <GPIO_setOutput_Pulldown>
	IOControl_Lora_ON();
 80056b4:	f7ff ff98 	bl	80055e8 <IOControl_Lora_ON>

	/****************************** Sensor *******************************/
	//temp and humi soil sensor
	GPIO_setOutput_Pulldown( SS_THS_POWER_CONTROL_PORT, SS_THS_POWER_CONTROL_PIN );
 80056b8:	4620      	mov	r0, r4
 80056ba:	2110      	movs	r1, #16
 80056bc:	f000 f8d1 	bl	8005862 <GPIO_setOutput_Pulldown>
	IOControl_SS_TH_Soil_OFF();
 80056c0:	f7ff ffa0 	bl	8005604 <IOControl_SS_TH_Soil_OFF>

	//EC
	GPIO_setOutput_Pulldown( SS_EC_POWER_CONTROL_PORT, SS_EC_POWER_CONTROL_PIN );
 80056c4:	4628      	mov	r0, r5
 80056c6:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 80056ca:	f000 f8ca 	bl	8005862 <GPIO_setOutput_Pulldown>
	IOControl_SS_EC_OFF();
 80056ce:	f7ff ffa7 	bl	8005620 <IOControl_SS_EC_OFF>

	//PH
	GPIO_setOutput_Pulldown( SS_PH_POWER_CONTROL_PORT, SS_PH_POWER_CONTROL_PIN );
 80056d2:	4628      	mov	r0, r5
 80056d4:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 80056d8:	f000 f8c3 	bl	8005862 <GPIO_setOutput_Pulldown>
	IOControl_SS_PH_OFF();
 80056dc:	f7ff ffb0 	bl	8005640 <IOControl_SS_PH_OFF>

	//CO2
	GPIO_setOutput_Pulldown( SS_CO2_POWER_CONTROL_PORT, SS_CO2_POWER_CONTROL_PIN );
 80056e0:	4620      	mov	r0, r4
 80056e2:	2140      	movs	r1, #64	; 0x40
 80056e4:	f000 f8bd 	bl	8005862 <GPIO_setOutput_Pulldown>
	IOControl_SS_CO2_OFF();
 80056e8:	f7ff ffb8 	bl	800565c <IOControl_SS_CO2_OFF>

	//Temp Anh humi + light
	GPIO_setOutput_Pulldown( SS_THL_POWER_CONTROL_PORT, SS_THL_POWER_CONTROL_PIN );
 80056ec:	4620      	mov	r0, r4
 80056ee:	2180      	movs	r1, #128	; 0x80
 80056f0:	f000 f8b7 	bl	8005862 <GPIO_setOutput_Pulldown>
	IOControl_SS_THL_OFF();
}
 80056f4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	IOControl_SS_THL_OFF();
 80056f8:	f7ff bfbc 	b.w	8005674 <IOControl_SS_THL_OFF>
 80056fc:	48000800 	.word	0x48000800
 8005700:	48000400 	.word	0x48000400

08005704 <ADC_Init>:
	__ADC_Handle->Instance = ADC1;
	__ADC_Handle->Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
	__ADC_Handle->Init.Resolution = ADC_RESOLUTION_12B;
	__ADC_Handle->Init.DataAlign = ADC_DATAALIGN_RIGHT;
	__ADC_Handle->Init.ScanConvMode = ADC_SCAN_DISABLE;
	__ADC_Handle->Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8005704:	2204      	movs	r2, #4
{
 8005706:	b510      	push	{r4, lr}
	__ADC_Handle->Instance = ADC1;
 8005708:	4b14      	ldr	r3, [pc, #80]	; (800575c <ADC_Init+0x58>)
	__ADC_Handle->Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 800570a:	6142      	str	r2, [r0, #20]
	__ADC_Handle->Init.LowPowerAutoWait = DISABLE;
	__ADC_Handle->Init.ContinuousConvMode = DISABLE;
	__ADC_Handle->Init.NbrOfConversion = 1;
 800570c:	2201      	movs	r2, #1
	__ADC_Handle->Instance = ADC1;
 800570e:	6003      	str	r3, [r0, #0]
	__ADC_Handle->Init.NbrOfConversion = 1;
 8005710:	61c2      	str	r2, [r0, #28]
	__ADC_Handle->Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
 8005712:	2300      	movs	r3, #0
	__ADC_Handle->Init.DiscontinuousConvMode = DISABLE;
	__ADC_Handle->Init.ExternalTrigConv = ADC_SOFTWARE_START;
	__ADC_Handle->Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
	__ADC_Handle->Init.DMAContinuousRequests = DISABLE;
	__ADC_Handle->Init.Overrun = ADC_OVR_DATA_OVERWRITTEN;
 8005714:	f44f 5280 	mov.w	r2, #4096	; 0x1000
	__ADC_Handle->Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
 8005718:	6043      	str	r3, [r0, #4]
	__ADC_Handle->Init.Resolution = ADC_RESOLUTION_12B;
 800571a:	6083      	str	r3, [r0, #8]
	__ADC_Handle->Init.DataAlign = ADC_DATAALIGN_RIGHT;
 800571c:	60c3      	str	r3, [r0, #12]
	__ADC_Handle->Init.ScanConvMode = ADC_SCAN_DISABLE;
 800571e:	6103      	str	r3, [r0, #16]
	__ADC_Handle->Init.LowPowerAutoWait = DISABLE;
 8005720:	7603      	strb	r3, [r0, #24]
	__ADC_Handle->Init.ContinuousConvMode = DISABLE;
 8005722:	7643      	strb	r3, [r0, #25]
	__ADC_Handle->Init.DiscontinuousConvMode = DISABLE;
 8005724:	f880 3020 	strb.w	r3, [r0, #32]
	__ADC_Handle->Init.ExternalTrigConv = ADC_SOFTWARE_START;
 8005728:	6283      	str	r3, [r0, #40]	; 0x28
	__ADC_Handle->Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 800572a:	62c3      	str	r3, [r0, #44]	; 0x2c
	__ADC_Handle->Init.DMAContinuousRequests = DISABLE;
 800572c:	f880 3030 	strb.w	r3, [r0, #48]	; 0x30
	__ADC_Handle->Init.Overrun = ADC_OVR_DATA_OVERWRITTEN;
 8005730:	6342      	str	r2, [r0, #52]	; 0x34
	__ADC_Handle->Init.OversamplingMode = DISABLE;
 8005732:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38
{
 8005736:	4604      	mov	r4, r0

	if (HAL_ADC_Init( __ADC_Handle ) != HAL_OK)
 8005738:	f7fb fc8a 	bl	8001050 <HAL_ADC_Init>
 800573c:	b110      	cbz	r0, 8005744 <ADC_Init+0x40>
		APP_DEBUG("--- ADC: init fail\r\n");
 800573e:	4808      	ldr	r0, [pc, #32]	; (8005760 <ADC_Init+0x5c>)
 8005740:	f002 faac 	bl	8007c9c <puts>

	/*##-3- Calibrate ADC then Start the conversion process ####################*/
	if (HAL_ADCEx_Calibration_Start( __ADC_Handle, ADC_SINGLE_ENDED ) !=  HAL_OK)
 8005744:	217f      	movs	r1, #127	; 0x7f
 8005746:	4620      	mov	r0, r4
 8005748:	f7fc f924 	bl	8001994 <HAL_ADCEx_Calibration_Start>
 800574c:	b120      	cbz	r0, 8005758 <ADC_Init+0x54>
		APP_DEBUG("--- ADC: calibration start error\r\n");
 800574e:	4805      	ldr	r0, [pc, #20]	; (8005764 <ADC_Init+0x60>)

}
 8005750:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		APP_DEBUG("--- ADC: calibration start error\r\n");
 8005754:	f002 baa2 	b.w	8007c9c <puts>
 8005758:	bd10      	pop	{r4, pc}
 800575a:	bf00      	nop
 800575c:	50040000 	.word	0x50040000
 8005760:	0800c62c 	.word	0x0800c62c
 8005764:	0800c640 	.word	0x0800c640

08005768 <ADC_SetChannel>:
 * 				+ __ADC_Handle: adc handle
 * 				+ Channel: adc channel
 * Return		: None
 * ****************************************************************************/
void ADC_SetChannel( ADC_HandleTypeDef *__ADC_Handle, uint32_t Channel )
{
 8005768:	b530      	push	{r4, r5, lr}
 800576a:	b087      	sub	sp, #28
 800576c:	4604      	mov	r4, r0
 800576e:	460d      	mov	r5, r1
	ADC_ChannelConfTypeDef sConfig = {0};
 8005770:	2218      	movs	r2, #24
 8005772:	2100      	movs	r1, #0
 8005774:	4668      	mov	r0, sp
 8005776:	f002 fa04 	bl	8007b82 <memset>

	//Configure Regular Channel
	sConfig.Channel = Channel;
	sConfig.Rank = ADC_REGULAR_RANK_1;
 800577a:	2306      	movs	r3, #6
 800577c:	9301      	str	r3, [sp, #4]
	sConfig.SamplingTime = ADC_SAMPLETIME_2CYCLES_5;
	sConfig.SingleDiff = ADC_SINGLE_ENDED;
 800577e:	237f      	movs	r3, #127	; 0x7f
 8005780:	9303      	str	r3, [sp, #12]
	sConfig.OffsetNumber = ADC_OFFSET_NONE;
	sConfig.Offset = 0;

	if (HAL_ADC_ConfigChannel( __ADC_Handle, &sConfig ) != HAL_OK)
 8005782:	4669      	mov	r1, sp
	sConfig.OffsetNumber = ADC_OFFSET_NONE;
 8005784:	2304      	movs	r3, #4
	if (HAL_ADC_ConfigChannel( __ADC_Handle, &sConfig ) != HAL_OK)
 8005786:	4620      	mov	r0, r4
	sConfig.Channel = Channel;
 8005788:	9500      	str	r5, [sp, #0]
	sConfig.OffsetNumber = ADC_OFFSET_NONE;
 800578a:	9304      	str	r3, [sp, #16]
	if (HAL_ADC_ConfigChannel( __ADC_Handle, &sConfig ) != HAL_OK)
 800578c:	f7fb fdbc 	bl	8001308 <HAL_ADC_ConfigChannel>
 8005790:	b110      	cbz	r0, 8005798 <ADC_SetChannel+0x30>
		APP_DEBUG("--- ADC: config channel fail\r\n");
 8005792:	4802      	ldr	r0, [pc, #8]	; (800579c <ADC_SetChannel+0x34>)
 8005794:	f002 fa82 	bl	8007c9c <puts>
}
 8005798:	b007      	add	sp, #28
 800579a:	bd30      	pop	{r4, r5, pc}
 800579c:	0800c6aa 	.word	0x0800c6aa

080057a0 <ADC_ReadValue>:
 * 				+ __ADC_Handle: adc handle
 * 				+ VOut: adc voltage output
 * Return		: None
 * ****************************************************************************/
void ADC_ReadValue( ADC_HandleTypeDef *__ADC_Handle, uint32_t *VOut )
{
 80057a0:	b538      	push	{r3, r4, r5, lr}
 80057a2:	4604      	mov	r4, r0
 80057a4:	460d      	mov	r5, r1
	if (HAL_ADC_Start( __ADC_Handle ) != HAL_OK)
 80057a6:	f7fc f831 	bl	800180c <HAL_ADC_Start>
 80057aa:	b110      	cbz	r0, 80057b2 <ADC_ReadValue+0x12>
		APP_DEBUG("--- ADC: hal adc start error\r\n");
 80057ac:	480c      	ldr	r0, [pc, #48]	; (80057e0 <ADC_ReadValue+0x40>)
 80057ae:	f002 fa75 	bl	8007c9c <puts>

	if (HAL_ADC_PollForConversion( __ADC_Handle, 100 ) != HAL_OK)
 80057b2:	2164      	movs	r1, #100	; 0x64
 80057b4:	4620      	mov	r0, r4
 80057b6:	f7fb fd2b 	bl	8001210 <HAL_ADC_PollForConversion>
 80057ba:	b110      	cbz	r0, 80057c2 <ADC_ReadValue+0x22>
		APP_DEBUG("--- ADC: HAL_ADC_PollForConversion error\r\n");
 80057bc:	4809      	ldr	r0, [pc, #36]	; (80057e4 <ADC_ReadValue+0x44>)
 80057be:	f002 fa6d 	bl	8007c9c <puts>

	/* Check if the continous conversion of regular channel is finished */
	if ((HAL_ADC_GetState( __ADC_Handle ) & HAL_ADC_STATE_REG_EOC) == HAL_ADC_STATE_REG_EOC)
 80057c2:	4620      	mov	r0, r4
 80057c4:	f7fb ff82 	bl	80016cc <HAL_ADC_GetState>
 80057c8:	0583      	lsls	r3, r0, #22
 80057ca:	d503      	bpl.n	80057d4 <ADC_ReadValue+0x34>
		*VOut = HAL_ADC_GetValue( __ADC_Handle );
 80057cc:	4620      	mov	r0, r4
 80057ce:	f7fb fd97 	bl	8001300 <HAL_ADC_GetValue>
 80057d2:	6028      	str	r0, [r5, #0]

	HAL_ADC_Stop( __ADC_Handle );
 80057d4:	4620      	mov	r0, r4
}
 80057d6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	HAL_ADC_Stop( __ADC_Handle );
 80057da:	f7fc b8bc 	b.w	8001956 <HAL_ADC_Stop>
 80057de:	bf00      	nop
 80057e0:	0800c662 	.word	0x0800c662
 80057e4:	0800c680 	.word	0x0800c680

080057e8 <GPIO_Init>:
 * Return		: None
 * ***************************************************************************/
void GPIO_Init( void )
{
	/* GPIO Ports Clock Enable */
	__HAL_RCC_GPIOA_CLK_ENABLE();
 80057e8:	4b13      	ldr	r3, [pc, #76]	; (8005838 <GPIO_Init+0x50>)
 80057ea:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80057ec:	f042 0201 	orr.w	r2, r2, #1
 80057f0:	64da      	str	r2, [r3, #76]	; 0x4c
 80057f2:	6cda      	ldr	r2, [r3, #76]	; 0x4c
{
 80057f4:	b084      	sub	sp, #16
	__HAL_RCC_GPIOA_CLK_ENABLE();
 80057f6:	f002 0201 	and.w	r2, r2, #1
 80057fa:	9200      	str	r2, [sp, #0]
 80057fc:	9a00      	ldr	r2, [sp, #0]
	__HAL_RCC_GPIOB_CLK_ENABLE();
 80057fe:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8005800:	f042 0202 	orr.w	r2, r2, #2
 8005804:	64da      	str	r2, [r3, #76]	; 0x4c
 8005806:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8005808:	f002 0202 	and.w	r2, r2, #2
 800580c:	9201      	str	r2, [sp, #4]
 800580e:	9a01      	ldr	r2, [sp, #4]
	__HAL_RCC_GPIOC_CLK_ENABLE();
 8005810:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8005812:	f042 0204 	orr.w	r2, r2, #4
 8005816:	64da      	str	r2, [r3, #76]	; 0x4c
 8005818:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800581a:	f002 0204 	and.w	r2, r2, #4
 800581e:	9202      	str	r2, [sp, #8]
 8005820:	9a02      	ldr	r2, [sp, #8]
	__HAL_RCC_GPIOD_CLK_ENABLE();
 8005822:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8005824:	f042 0208 	orr.w	r2, r2, #8
 8005828:	64da      	str	r2, [r3, #76]	; 0x4c
 800582a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800582c:	f003 0308 	and.w	r3, r3, #8
 8005830:	9303      	str	r3, [sp, #12]
 8005832:	9b03      	ldr	r3, [sp, #12]
}
 8005834:	b004      	add	sp, #16
 8005836:	4770      	bx	lr
 8005838:	40021000 	.word	0x40021000

0800583c <GPIO_setOutput_Pullup>:
 * 				+ Pin  -gpio Pin
 * 				+ Pullup - true: pullup, false: pulldown
 * Return		: None
 * ***************************************************************************/
void GPIO_setOutput_Pullup( GPIO_TypeDef *Port, uint16_t Pin )
{
 800583c:	b530      	push	{r4, r5, lr}
 800583e:	b087      	sub	sp, #28
 8005840:	4604      	mov	r4, r0
 8005842:	460d      	mov	r5, r1
	GPIO_InitTypeDef GPIO_InitStruct = {0};
 8005844:	2214      	movs	r2, #20
 8005846:	2100      	movs	r1, #0
 8005848:	a801      	add	r0, sp, #4
 800584a:	f002 f99a 	bl	8007b82 <memset>

	/*Configure GPIO pin*/
	GPIO_InitStruct.Pin = Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800584e:	2301      	movs	r3, #1
	GPIO_InitStruct.Pull = GPIO_PULLUP;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(Port, &GPIO_InitStruct);
 8005850:	a901      	add	r1, sp, #4
 8005852:	4620      	mov	r0, r4
	GPIO_InitStruct.Pin = Pin;
 8005854:	9501      	str	r5, [sp, #4]
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8005856:	9302      	str	r3, [sp, #8]
	GPIO_InitStruct.Pull = GPIO_PULLUP;
 8005858:	9303      	str	r3, [sp, #12]
	HAL_GPIO_Init(Port, &GPIO_InitStruct);
 800585a:	f7fc f94b 	bl	8001af4 <HAL_GPIO_Init>
}
 800585e:	b007      	add	sp, #28
 8005860:	bd30      	pop	{r4, r5, pc}

08005862 <GPIO_setOutput_Pulldown>:
 * 				+ Pin  -gpio Pin
 * 				+ Pullup - true: pullup, false: pulldown
 * Return		: None
 * ***************************************************************************/
void GPIO_setOutput_Pulldown( GPIO_TypeDef *Port, uint16_t Pin )
{
 8005862:	b530      	push	{r4, r5, lr}
 8005864:	b087      	sub	sp, #28
 8005866:	4604      	mov	r4, r0
 8005868:	460d      	mov	r5, r1
	GPIO_InitTypeDef GPIO_InitStruct = {0};
 800586a:	2214      	movs	r2, #20
 800586c:	2100      	movs	r1, #0
 800586e:	a801      	add	r0, sp, #4
 8005870:	f002 f987 	bl	8007b82 <memset>

	/*Configure GPIO pin*/
	GPIO_InitStruct.Pin = Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8005874:	2301      	movs	r3, #1
 8005876:	9302      	str	r3, [sp, #8]
	GPIO_InitStruct.Pull = GPIO_PULLDOWN;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(Port, &GPIO_InitStruct);
 8005878:	a901      	add	r1, sp, #4
	GPIO_InitStruct.Pull = GPIO_PULLDOWN;
 800587a:	2302      	movs	r3, #2
	HAL_GPIO_Init(Port, &GPIO_InitStruct);
 800587c:	4620      	mov	r0, r4
	GPIO_InitStruct.Pin = Pin;
 800587e:	9501      	str	r5, [sp, #4]
	GPIO_InitStruct.Pull = GPIO_PULLDOWN;
 8005880:	9303      	str	r3, [sp, #12]
	HAL_GPIO_Init(Port, &GPIO_InitStruct);
 8005882:	f7fc f937 	bl	8001af4 <HAL_GPIO_Init>
}
 8005886:	b007      	add	sp, #28
 8005888:	bd30      	pop	{r4, r5, pc}

0800588a <GPIO_setOutput_NoPull>:
 * 				+ Pin  -gpio Pin
 * 				+ Pullup - true: pullup, false: pulldown
 * Return		: None
 * ***************************************************************************/
void GPIO_setOutput_NoPull( GPIO_TypeDef *Port, uint16_t Pin )
{
 800588a:	b530      	push	{r4, r5, lr}
 800588c:	b087      	sub	sp, #28
 800588e:	4604      	mov	r4, r0
 8005890:	460d      	mov	r5, r1
	GPIO_InitTypeDef GPIO_InitStruct = {0};
 8005892:	2214      	movs	r2, #20
 8005894:	2100      	movs	r1, #0
 8005896:	a801      	add	r0, sp, #4
 8005898:	f002 f973 	bl	8007b82 <memset>

	/*Configure GPIO pin*/
	GPIO_InitStruct.Pin = Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800589c:	2301      	movs	r3, #1
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(Port, &GPIO_InitStruct);
 800589e:	a901      	add	r1, sp, #4
 80058a0:	4620      	mov	r0, r4
	GPIO_InitStruct.Pin = Pin;
 80058a2:	9501      	str	r5, [sp, #4]
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80058a4:	9302      	str	r3, [sp, #8]
	HAL_GPIO_Init(Port, &GPIO_InitStruct);
 80058a6:	f7fc f925 	bl	8001af4 <HAL_GPIO_Init>
}
 80058aa:	b007      	add	sp, #28
 80058ac:	bd30      	pop	{r4, r5, pc}

080058ae <GPIO_setInput>:
 * 				+ Port - gpio port
 * 				+ Pin  -gpio Pin
 * Return		: None
 * ***************************************************************************/
void GPIO_setInput( GPIO_TypeDef *Port, uint16_t Pin )
{
 80058ae:	b530      	push	{r4, r5, lr}
 80058b0:	b087      	sub	sp, #28
 80058b2:	4604      	mov	r4, r0
 80058b4:	460d      	mov	r5, r1
	GPIO_InitTypeDef GPIO_InitStruct = {0};
 80058b6:	2214      	movs	r2, #20
 80058b8:	2100      	movs	r1, #0
 80058ba:	a801      	add	r0, sp, #4
 80058bc:	f002 f961 	bl	8007b82 <memset>
	/*Configure GPIO pin*/
	GPIO_InitStruct.Pin = Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(Port, &GPIO_InitStruct);
 80058c0:	a901      	add	r1, sp, #4
 80058c2:	4620      	mov	r0, r4
	GPIO_InitStruct.Pin = Pin;
 80058c4:	9501      	str	r5, [sp, #4]
	HAL_GPIO_Init(Port, &GPIO_InitStruct);
 80058c6:	f7fc f915 	bl	8001af4 <HAL_GPIO_Init>
}
 80058ca:	b007      	add	sp, #28
 80058cc:	bd30      	pop	{r4, r5, pc}

080058ce <GPIO_setHighlevel>:
 * 				+ Pin  -gpio Pin
 * Return		: None
 * ***************************************************************************/
void GPIO_setHighlevel( GPIO_TypeDef *Port, uint16_t Pin )
{
	HAL_GPIO_WritePin( Port, Pin, GPIO_PIN_SET );
 80058ce:	2201      	movs	r2, #1
 80058d0:	f7fc b9f2 	b.w	8001cb8 <HAL_GPIO_WritePin>

080058d4 <GPIO_setLowlevel>:
 * 				+ Pin  -gpio Pin
 * Return		: None
 * ***************************************************************************/
void GPIO_setLowlevel( GPIO_TypeDef *Port, uint16_t Pin )
{
	HAL_GPIO_WritePin( Port, Pin, GPIO_PIN_RESET );
 80058d4:	2200      	movs	r2, #0
 80058d6:	f7fc b9ef 	b.w	8001cb8 <HAL_GPIO_WritePin>

080058da <GPIO_setToggle>:
 * 				+ Pin  -gpio Pin
 * Return		: None
 * ***************************************************************************/
void GPIO_setToggle( GPIO_TypeDef *Port, uint16_t Pin )
{
	HAL_GPIO_TogglePin( Port, Pin );
 80058da:	f7fc b9f2 	b.w	8001cc2 <HAL_GPIO_TogglePin>

080058de <GPIO_getlevel>:
 * Return		:
 * 				+ 1 - pin high level
 * 				+ 0 - pin low level
 * ***************************************************************************/
bool GPIO_getlevel( GPIO_TypeDef *Port, uint16_t Pin )
{
 80058de:	b508      	push	{r3, lr}
	return HAL_GPIO_ReadPin( Port, Pin );
 80058e0:	f7fc f9e4 	bl	8001cac <HAL_GPIO_ReadPin>
}
 80058e4:	3000      	adds	r0, #0
 80058e6:	bf18      	it	ne
 80058e8:	2001      	movne	r0, #1
 80058ea:	bd08      	pop	{r3, pc}

080058ec <I2C1_SS_Init>:
 * Description	: i2c init
 * Param		: NOne
 * Return		: None
 * ****************************************************************************/
void I2C1_SS_Init( void )
{
 80058ec:	b538      	push	{r3, r4, r5, lr}
	__I2C1_SS_Handle.Instance 				= I2C1;
	__I2C1_SS_Handle.Init.Timing 			= 0x00000E14;
	__I2C1_SS_Handle.Init.OwnAddress1 		= 0;
 80058ee:	480d      	ldr	r0, [pc, #52]	; (8005924 <I2C1_SS_Init+0x38>)
	__I2C1_SS_Handle.Instance 				= I2C1;
 80058f0:	4c0d      	ldr	r4, [pc, #52]	; (8005928 <I2C1_SS_Init+0x3c>)
	__I2C1_SS_Handle.Init.OwnAddress1 		= 0;
 80058f2:	2500      	movs	r5, #0
 80058f4:	f640 6314 	movw	r3, #3604	; 0xe14
 80058f8:	e884 0029 	stmia.w	r4, {r0, r3, r5}
	__I2C1_SS_Handle.Init.AddressingMode 	= I2C_ADDRESSINGMODE_7BIT;
 80058fc:	2301      	movs	r3, #1
	__I2C1_SS_Handle.Init.DualAddressMode 	= I2C_DUALADDRESS_DISABLE;
	__I2C1_SS_Handle.Init.OwnAddress2 		= 0;
	__I2C1_SS_Handle.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
	__I2C1_SS_Handle.Init.GeneralCallMode 	= I2C_GENERALCALL_DISABLE;
	__I2C1_SS_Handle.Init.NoStretchMode 	= I2C_NOSTRETCH_DISABLE;
	if (HAL_I2C_Init( &__I2C1_SS_Handle ) != HAL_OK)
 80058fe:	4620      	mov	r0, r4
	__I2C1_SS_Handle.Init.AddressingMode 	= I2C_ADDRESSINGMODE_7BIT;
 8005900:	60e3      	str	r3, [r4, #12]
	__I2C1_SS_Handle.Init.DualAddressMode 	= I2C_DUALADDRESS_DISABLE;
 8005902:	6125      	str	r5, [r4, #16]
	__I2C1_SS_Handle.Init.OwnAddress2 		= 0;
 8005904:	6165      	str	r5, [r4, #20]
	__I2C1_SS_Handle.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
 8005906:	61a5      	str	r5, [r4, #24]
	__I2C1_SS_Handle.Init.GeneralCallMode 	= I2C_GENERALCALL_DISABLE;
 8005908:	61e5      	str	r5, [r4, #28]
	__I2C1_SS_Handle.Init.NoStretchMode 	= I2C_NOSTRETCH_DISABLE;
 800590a:	6225      	str	r5, [r4, #32]
	if (HAL_I2C_Init( &__I2C1_SS_Handle ) != HAL_OK)
 800590c:	f7fc f9dd 	bl	8001cca <HAL_I2C_Init>
	{

	}

	//Configure Analogue filter
	if (HAL_I2CEx_ConfigAnalogFilter( &__I2C1_SS_Handle, I2C_ANALOGFILTER_ENABLE ) != HAL_OK);
 8005910:	4629      	mov	r1, r5
 8005912:	4620      	mov	r0, r4
 8005914:	f7fc fa2a 	bl	8001d6c <HAL_I2CEx_ConfigAnalogFilter>

	//Configure Digital filter
	if (HAL_I2CEx_ConfigDigitalFilter( &__I2C1_SS_Handle, 0 ) != HAL_OK);
 8005918:	4629      	mov	r1, r5
 800591a:	4620      	mov	r0, r4
}
 800591c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	if (HAL_I2CEx_ConfigDigitalFilter( &__I2C1_SS_Handle, 0 ) != HAL_OK);
 8005920:	f7fc ba4a 	b.w	8001db8 <HAL_I2CEx_ConfigDigitalFilter>
 8005924:	40005400 	.word	0x40005400
 8005928:	20008a48 	.word	0x20008a48

0800592c <SPI_Init>:
 * Return		:
 * 				+ true - successfully
 * 				+ false - failture
 * ***************************************************************************/
bool SPI_Init( SPI_HandleTypeDef *_SPIHandle, SPI_TypeDef *_SPIBase )
{
 800592c:	b538      	push	{r3, r4, r5, lr}
	/* SPI1 parameter configuration*/
	_SPIHandle->Instance 				= _SPIBase;
	_SPIHandle->Init.Mode 				= SPI_MODE_MASTER;
 800592e:	f44f 7382 	mov.w	r3, #260	; 0x104
 8005932:	6043      	str	r3, [r0, #4]
	_SPIHandle->Init.Direction 			= SPI_DIRECTION_2LINES;
	_SPIHandle->Init.DataSize 			= SPI_DATASIZE_8BIT;
 8005934:	f44f 63e0 	mov.w	r3, #1792	; 0x700
 8005938:	60c3      	str	r3, [r0, #12]
	_SPIHandle->Init.CLKPolarity 		= SPI_POLARITY_LOW; //high
	_SPIHandle->Init.CLKPhase 			= SPI_PHASE_1EDGE;
	_SPIHandle->Init.NSS 				= SPI_NSS_SOFT;
 800593a:	f44f 7300 	mov.w	r3, #512	; 0x200
 800593e:	6183      	str	r3, [r0, #24]
	_SPIHandle->Init.BaudRatePrescaler 	= SPI_BAUDRATEPRESCALER_4;
 8005940:	2308      	movs	r3, #8
	_SPIHandle->Init.Direction 			= SPI_DIRECTION_2LINES;
 8005942:	2500      	movs	r5, #0
	_SPIHandle->Init.BaudRatePrescaler 	= SPI_BAUDRATEPRESCALER_4;
 8005944:	61c3      	str	r3, [r0, #28]
	_SPIHandle->Init.FirstBit 			= SPI_FIRSTBIT_MSB;
	_SPIHandle->Init.TIMode 			= SPI_TIMODE_DISABLE;
	_SPIHandle->Init.CRCCalculation 	= SPI_CRCCALCULATION_DISABLE;
	_SPIHandle->Init.CRCPolynomial 		= 10;
 8005946:	230a      	movs	r3, #10
	_SPIHandle->Instance 				= _SPIBase;
 8005948:	6001      	str	r1, [r0, #0]
	_SPIHandle->Init.Direction 			= SPI_DIRECTION_2LINES;
 800594a:	6085      	str	r5, [r0, #8]
	_SPIHandle->Init.CLKPolarity 		= SPI_POLARITY_LOW; //high
 800594c:	6105      	str	r5, [r0, #16]
	_SPIHandle->Init.CLKPhase 			= SPI_PHASE_1EDGE;
 800594e:	6145      	str	r5, [r0, #20]
	_SPIHandle->Init.FirstBit 			= SPI_FIRSTBIT_MSB;
 8005950:	6205      	str	r5, [r0, #32]
	_SPIHandle->Init.TIMode 			= SPI_TIMODE_DISABLE;
 8005952:	6245      	str	r5, [r0, #36]	; 0x24
	_SPIHandle->Init.CRCCalculation 	= SPI_CRCCALCULATION_DISABLE;
 8005954:	6285      	str	r5, [r0, #40]	; 0x28
	_SPIHandle->Init.CRCPolynomial 		= 10;
 8005956:	62c3      	str	r3, [r0, #44]	; 0x2c
{
 8005958:	4604      	mov	r4, r0
//	_SPIHandle->Init.CRCLength 			= SPI_CRC_LENGTH_DATASIZE;
//	_SPIHandle->Init.NSSPMode 			= SPI_NSS_PULSE_ENABLE;
	if (HAL_SPI_Init( _SPIHandle ) != HAL_OK)
 800595a:	f7fd f986 	bl	8002c6a <HAL_SPI_Init>
 800595e:	b128      	cbz	r0, 800596c <SPI_Init+0x40>
	{
		APP_DEBUG("--- SPI: init spi failture: line %d\r\n", __LINE__);
 8005960:	212c      	movs	r1, #44	; 0x2c
 8005962:	4806      	ldr	r0, [pc, #24]	; (800597c <SPI_Init+0x50>)
 8005964:	f002 f922 	bl	8007bac <printf>
		return false;
 8005968:	4628      	mov	r0, r5
 800596a:	bd38      	pop	{r3, r4, r5, pc}
	}
	__HAL_SPI_ENABLE(_SPIHandle);
 800596c:	6822      	ldr	r2, [r4, #0]
 800596e:	6813      	ldr	r3, [r2, #0]
 8005970:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8005974:	6013      	str	r3, [r2, #0]
	return true;
 8005976:	2001      	movs	r0, #1
}
 8005978:	bd38      	pop	{r3, r4, r5, pc}
 800597a:	bf00      	nop
 800597c:	0800c6c8 	.word	0x0800c6c8

08005980 <SPI_State_Ready>:
 * Return		:
 * 				+ true - spi ready
 * 				+ false - spi busy
 * ***************************************************************************/
bool SPI_State_Ready( SPI_HandleTypeDef *_SPIHandle )
{
 8005980:	b508      	push	{r3, lr}
	if(HAL_SPI_GetState( _SPIHandle ) == HAL_SPI_STATE_READY)
 8005982:	f7fd fc50 	bl	8003226 <HAL_SPI_GetState>
		return true;
	else
		return false;
}
 8005986:	1e43      	subs	r3, r0, #1
 8005988:	4258      	negs	r0, r3
 800598a:	4158      	adcs	r0, r3
 800598c:	bd08      	pop	{r3, pc}
	...

08005990 <SPI_WriteByte>:
 * Description	: spi write byte
 * Param		: txBuff - byte send
 * Return		: None
 * ***************************************************************************/
bool SPI_WriteByte( SPI_HandleTypeDef *_SPIHandle, uint8_t txBuff, uint32_t Timeout )
{
 8005990:	b513      	push	{r0, r1, r4, lr}
 8005992:	ac02      	add	r4, sp, #8
	if( HAL_SPI_Transmit( _SPIHandle, &txBuff, 1, Timeout) == HAL_OK )
 8005994:	4613      	mov	r3, r2
{
 8005996:	f804 1d01 	strb.w	r1, [r4, #-1]!
	if( HAL_SPI_Transmit( _SPIHandle, &txBuff, 1, Timeout) == HAL_OK )
 800599a:	2201      	movs	r2, #1
 800599c:	4621      	mov	r1, r4
 800599e:	f7fd f9b5 	bl	8002d0c <HAL_SPI_Transmit>
 80059a2:	b130      	cbz	r0, 80059b2 <SPI_WriteByte+0x22>
		return true;
	APP_DEBUG("--- SPI: tx error, line: %d\r\n", __LINE__);
 80059a4:	2152      	movs	r1, #82	; 0x52
 80059a6:	4804      	ldr	r0, [pc, #16]	; (80059b8 <SPI_WriteByte+0x28>)
 80059a8:	f002 f900 	bl	8007bac <printf>
	return false;
 80059ac:	2000      	movs	r0, #0
}
 80059ae:	b002      	add	sp, #8
 80059b0:	bd10      	pop	{r4, pc}
		return true;
 80059b2:	2001      	movs	r0, #1
 80059b4:	e7fb      	b.n	80059ae <SPI_WriteByte+0x1e>
 80059b6:	bf00      	nop
 80059b8:	0800c70c 	.word	0x0800c70c

080059bc <SPI_ReadByte>:
 * Description	: spi read byte
 * Param		: None
 * Return		: byte read
 * ***************************************************************************/
uint8_t SPI_ReadByte( SPI_HandleTypeDef *_SPIHandle, uint8_t Addr, uint32_t Timeout )
{
 80059bc:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	uint8_t txByte = Addr;
 80059be:	f88d 100e 	strb.w	r1, [sp, #14]
	uint8_t rxByte = 0;
 80059c2:	a904      	add	r1, sp, #16
 80059c4:	2300      	movs	r3, #0
 80059c6:	f801 3d01 	strb.w	r3, [r1, #-1]!

	if( HAL_SPI_TransmitReceive( _SPIHandle, &txByte, &rxByte, 1, Timeout) != HAL_OK )
 80059ca:	9200      	str	r2, [sp, #0]
 80059cc:	2301      	movs	r3, #1
 80059ce:	460a      	mov	r2, r1
 80059d0:	f10d 010e 	add.w	r1, sp, #14
 80059d4:	f7fd fa58 	bl	8002e88 <HAL_SPI_TransmitReceive>
 80059d8:	b118      	cbz	r0, 80059e2 <SPI_ReadByte+0x26>
		APP_DEBUG("--- SPI: rx error, line: %d\r\n", __LINE__);
 80059da:	2165      	movs	r1, #101	; 0x65
 80059dc:	4803      	ldr	r0, [pc, #12]	; (80059ec <SPI_ReadByte+0x30>)
 80059de:	f002 f8e5 	bl	8007bac <printf>

	return rxByte;
}
 80059e2:	f89d 000f 	ldrb.w	r0, [sp, #15]
 80059e6:	b005      	add	sp, #20
 80059e8:	f85d fb04 	ldr.w	pc, [sp], #4
 80059ec:	0800c6ee 	.word	0x0800c6ee

080059f0 <SPI_WriteBytes>:
 * Description	: spi write byte
 * Param		: txBuff - byte send
 * Return		: None
 * ***************************************************************************/
bool SPI_WriteBytes( SPI_HandleTypeDef *_SPIHandle, uint8_t *txBuff, uint16_t txLenght, uint32_t Timeout )
{
 80059f0:	b508      	push	{r3, lr}
	if( HAL_SPI_Transmit( _SPIHandle, txBuff, txLenght, Timeout) == HAL_OK )
 80059f2:	f7fd f98b 	bl	8002d0c <HAL_SPI_Transmit>
 80059f6:	b128      	cbz	r0, 8005a04 <SPI_WriteBytes+0x14>
		return true;
	APP_DEBUG("--- SPI: tx error, line: %d\r\n", __LINE__);
 80059f8:	2177      	movs	r1, #119	; 0x77
 80059fa:	4803      	ldr	r0, [pc, #12]	; (8005a08 <SPI_WriteBytes+0x18>)
 80059fc:	f002 f8d6 	bl	8007bac <printf>
	return false;
 8005a00:	2000      	movs	r0, #0
 8005a02:	bd08      	pop	{r3, pc}
		return true;
 8005a04:	2001      	movs	r0, #1
}
 8005a06:	bd08      	pop	{r3, pc}
 8005a08:	0800c70c 	.word	0x0800c70c

08005a0c <SPI_ReadBytes>:
 * Description	: spi read byte
 * Param		: None
 * Return		: byte read
 * ***************************************************************************/
void SPI_ReadBytes( SPI_HandleTypeDef *_SPIHandle, uint8_t *rxBuffer, uint16_t rxLenght, uint32_t Timeout )
{
 8005a0c:	b508      	push	{r3, lr}
	if( HAL_SPI_Receive( _SPIHandle, rxBuffer, rxLenght, Timeout) != HAL_OK )
 8005a0e:	f7fd fb5f 	bl	80030d0 <HAL_SPI_Receive>
 8005a12:	b128      	cbz	r0, 8005a20 <SPI_ReadBytes+0x14>
		APP_DEBUG("--- SPI: rx error, line: %d\r\n", __LINE__);
 8005a14:	2187      	movs	r1, #135	; 0x87
 8005a16:	4803      	ldr	r0, [pc, #12]	; (8005a24 <SPI_ReadBytes+0x18>)
}
 8005a18:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		APP_DEBUG("--- SPI: rx error, line: %d\r\n", __LINE__);
 8005a1c:	f002 b8c6 	b.w	8007bac <printf>
 8005a20:	bd08      	pop	{r3, pc}
 8005a22:	bf00      	nop
 8005a24:	0800c6ee 	.word	0x0800c6ee

08005a28 <Uart_Read>:
 * 				+ _UartHandle: uart handle
 * 				+ RXBuffer - received buffer
 * Return		: return data lenght
 *****************************************************************************/
static uint16_t Uart_Read( UART_HandleTypeDef *_UartHandle, uint8_t *RXBuffer, uint16_t RXLenght )
{
 8005a28:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 8005a2c:	4680      	mov	r8, r0
 8005a2e:	460e      	mov	r6, r1
 8005a30:	188f      	adds	r7, r1, r2
	uint16_t RX_Lenght = 0;
	uint8_t c;

	while(RX_Lenght < RXLenght)
 8005a32:	460c      	mov	r4, r1
 8005a34:	1ba5      	subs	r5, r4, r6
 8005a36:	42bc      	cmp	r4, r7
 8005a38:	b2ad      	uxth	r5, r5
 8005a3a:	d103      	bne.n	8005a44 <Uart_Read+0x1c>
		if( HAL_UART_Receive( _UartHandle, &c, 1, 0xff) != HAL_OK )
			return RX_Lenght;
		RXBuffer[RX_Lenght++] = c;
	}
	return RX_Lenght;
}
 8005a3c:	4628      	mov	r0, r5
 8005a3e:	b002      	add	sp, #8
 8005a40:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if( HAL_UART_Receive( _UartHandle, &c, 1, 0xff) != HAL_OK )
 8005a44:	23ff      	movs	r3, #255	; 0xff
 8005a46:	2201      	movs	r2, #1
 8005a48:	f10d 0107 	add.w	r1, sp, #7
 8005a4c:	4640      	mov	r0, r8
 8005a4e:	f7fe f949 	bl	8003ce4 <HAL_UART_Receive>
 8005a52:	2800      	cmp	r0, #0
 8005a54:	d1f2      	bne.n	8005a3c <Uart_Read+0x14>
		RXBuffer[RX_Lenght++] = c;
 8005a56:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8005a5a:	f804 3b01 	strb.w	r3, [r4], #1
 8005a5e:	e7e9      	b.n	8005a34 <Uart_Read+0xc>

08005a60 <Uart_Write>:
{
 8005a60:	b508      	push	{r3, lr}
	if( HAL_UART_Transmit( _UartHandle, TXBuffer, TXLenght, 0xffff ) == HAL_OK )
 8005a62:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8005a66:	f7fe f8e6 	bl	8003c36 <HAL_UART_Transmit>
}
 8005a6a:	fab0 f080 	clz	r0, r0
 8005a6e:	0940      	lsrs	r0, r0, #5
 8005a70:	bd08      	pop	{r3, pc}
	...

08005a74 <Uart_Open>:
{
 8005a74:	b538      	push	{r3, r4, r5, lr}
	_Uart_Handle->_UartHandle.Init.WordLength 				= UART_WORDLENGTH_8B;
 8005a76:	2500      	movs	r5, #0
	_Uart_Handle->_UartHandle.Init.Mode 					= UART_MODE_TX_RX;
 8005a78:	230c      	movs	r3, #12
	_Uart_Handle->_UartHandle.Init.BaudRate 				= Baudrate;
 8005a7a:	e880 0006 	stmia.w	r0, {r1, r2}
	_Uart_Handle->_UartHandle.Init.WordLength 				= UART_WORDLENGTH_8B;
 8005a7e:	6085      	str	r5, [r0, #8]
	_Uart_Handle->_UartHandle.Init.StopBits 				= UART_STOPBITS_1;
 8005a80:	60c5      	str	r5, [r0, #12]
	_Uart_Handle->_UartHandle.Init.Parity 					= UART_PARITY_NONE;
 8005a82:	6105      	str	r5, [r0, #16]
	_Uart_Handle->_UartHandle.Init.Mode 					= UART_MODE_TX_RX;
 8005a84:	6143      	str	r3, [r0, #20]
	_Uart_Handle->_UartHandle.Init.HwFlowCtl 				= UART_HWCONTROL_NONE;
 8005a86:	6185      	str	r5, [r0, #24]
	_Uart_Handle->_UartHandle.Init.OverSampling 			= UART_OVERSAMPLING_16;
 8005a88:	61c5      	str	r5, [r0, #28]
	_Uart_Handle->_UartHandle.Init.OneBitSampling 			= UART_ONE_BIT_SAMPLE_DISABLE;
 8005a8a:	6205      	str	r5, [r0, #32]
{
 8005a8c:	4604      	mov	r4, r0
	if (HAL_UART_Init( &_Uart_Handle->_UartHandle ) != HAL_OK)
 8005a8e:	f7fe f9ca 	bl	8003e26 <HAL_UART_Init>
 8005a92:	b938      	cbnz	r0, 8005aa4 <Uart_Open+0x30>
	_Uart_Handle->Uart_Transmit = Uart_Write;
 8005a94:	4b04      	ldr	r3, [pc, #16]	; (8005aa8 <Uart_Open+0x34>)
 8005a96:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
	_Uart_Handle->Uart_Receive	= Uart_Read;
 8005a9a:	4b04      	ldr	r3, [pc, #16]	; (8005aac <Uart_Open+0x38>)
 8005a9c:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
	return true;
 8005aa0:	2001      	movs	r0, #1
 8005aa2:	bd38      	pop	{r3, r4, r5, pc}
		return false;
 8005aa4:	4628      	mov	r0, r5
}
 8005aa6:	bd38      	pop	{r3, r4, r5, pc}
 8005aa8:	08005a61 	.word	0x08005a61
 8005aac:	08005a29 	.word	0x08005a29

08005ab0 <Message_sendData>:
 * Param		:
 * 				+ _msgData - message data struct
 * Return		: None
 * ****************************************************************************/
static void Message_sendData( msgData_t *_msgData )
{
 8005ab0:	b500      	push	{lr}
 8005ab2:	b0e5      	sub	sp, #404	; 0x194
	uint16_t msgLenght = 0;
 8005ab4:	2300      	movs	r3, #0
	string_msg_t msg_string = Parse_setMsgData(_msgData, &msgLenght);
 8005ab6:	f10d 0206 	add.w	r2, sp, #6
 8005aba:	4601      	mov	r1, r0
 8005abc:	a802      	add	r0, sp, #8
	uint16_t msgLenght = 0;
 8005abe:	f8ad 3006 	strh.w	r3, [sp, #6]
	string_msg_t msg_string = Parse_setMsgData(_msgData, &msgLenght);
 8005ac2:	f000 faf3 	bl	80060ac <Parse_setMsgData>
	//APP_DEBUG("--- Message: preparing packet = \"%s\", lenght = %d\r\n", msg, msgLenght);
	//msg = EDC_Encode( msg, &msgLenght );
	Message_Lora_Transmit( msg_string.msgsTring, msgLenght );
 8005ac6:	4b04      	ldr	r3, [pc, #16]	; (8005ad8 <Message_sendData+0x28>)
 8005ac8:	f8bd 1006 	ldrh.w	r1, [sp, #6]
 8005acc:	681b      	ldr	r3, [r3, #0]
 8005ace:	a802      	add	r0, sp, #8
 8005ad0:	4798      	blx	r3
//	free(msg_string);
}
 8005ad2:	b065      	add	sp, #404	; 0x194
 8005ad4:	f85d fb04 	ldr.w	pc, [sp], #4
 8005ad8:	20008aac 	.word	0x20008aac

08005adc <Message_SendData_Sensor>:
 * Description	: sensor set data
 * Param		: None
 * Return		: None
 * ***************************************************************************/
void Message_SendData_Sensor( void )
{
 8005adc:	b570      	push	{r4, r5, r6, lr}
 8005ade:	b0c8      	sub	sp, #288	; 0x120
	uint8_t index = 0;
	msgData_t __msgData = {0};
 8005ae0:	f44f 728e 	mov.w	r2, #284	; 0x11c
 8005ae4:	2100      	movs	r1, #0
 8005ae6:	a801      	add	r0, sp, #4
 8005ae8:	f002 f84b 	bl	8007b82 <memset>

	APP_DEBUG("\r\n--- Message: set sensor data\r\n");
 8005aec:	4879      	ldr	r0, [pc, #484]	; (8005cd4 <Message_SendData_Sensor+0x1f8>)
	strcpy((char *)__msgData.TypePacket, macroTYPE_PACKET_DATA);
	__msgData.msgID = ++msgID;
	strcpy((char *)__msgData.IDEd, (char *)SerialNumber);

	//temp soil
	if((__fileData.SensorCfg & SS_TempS) == SS_TempS)
 8005aee:	4d7a      	ldr	r5, [pc, #488]	; (8005cd8 <Message_SendData_Sensor+0x1fc>)
	APP_DEBUG("\r\n--- Message: set sensor data\r\n");
 8005af0:	f002 f8d4 	bl	8007c9c <puts>
	strcpy((char *)__msgData.TypePacket, macroTYPE_PACKET_DATA);
 8005af4:	4979      	ldr	r1, [pc, #484]	; (8005cdc <Message_SendData_Sensor+0x200>)
 8005af6:	a801      	add	r0, sp, #4
 8005af8:	f002 f90c 	bl	8007d14 <strcpy>
	__msgData.msgID = ++msgID;
 8005afc:	4a78      	ldr	r2, [pc, #480]	; (8005ce0 <Message_SendData_Sensor+0x204>)
	strcpy((char *)__msgData.IDEd, (char *)SerialNumber);
 8005afe:	4979      	ldr	r1, [pc, #484]	; (8005ce4 <Message_SendData_Sensor+0x208>)
	__msgData.msgID = ++msgID;
 8005b00:	6813      	ldr	r3, [r2, #0]
	strcpy((char *)__msgData.IDEd, (char *)SerialNumber);
 8005b02:	a804      	add	r0, sp, #16
	__msgData.msgID = ++msgID;
 8005b04:	3301      	adds	r3, #1
 8005b06:	6013      	str	r3, [r2, #0]
 8005b08:	9303      	str	r3, [sp, #12]
	strcpy((char *)__msgData.IDEd, (char *)SerialNumber);
 8005b0a:	f002 f903 	bl	8007d14 <strcpy>
	if((__fileData.SensorCfg & SS_TempS) == SS_TempS)
 8005b0e:	886c      	ldrh	r4, [r5, #2]
 8005b10:	f014 0404 	ands.w	r4, r4, #4
 8005b14:	d010      	beq.n	8005b38 <Message_SendData_Sensor+0x5c>
	{
		strcpy((char *)__msgData.Data[index].Name, macroID_DATA_TEMP_S);
 8005b16:	4974      	ldr	r1, [pc, #464]	; (8005ce8 <Message_SendData_Sensor+0x20c>)
 8005b18:	f10d 0023 	add.w	r0, sp, #35	; 0x23
 8005b1c:	f002 f8fa 	bl	8007d14 <strcpy>
		sprintf((char *)__msgData.Data[index].Info, "%.2f", __SensorData.TempS);
 8005b20:	4b72      	ldr	r3, [pc, #456]	; (8005cec <Message_SendData_Sensor+0x210>)
 8005b22:	6898      	ldr	r0, [r3, #8]
 8005b24:	f7fa fd20 	bl	8000568 <__aeabi_f2d>
 8005b28:	4602      	mov	r2, r0
 8005b2a:	460b      	mov	r3, r1
 8005b2c:	f10d 002b 	add.w	r0, sp, #43	; 0x2b
 8005b30:	496f      	ldr	r1, [pc, #444]	; (8005cf0 <Message_SendData_Sensor+0x214>)
 8005b32:	f002 f8cb 	bl	8007ccc <sprintf>
		index++;
 8005b36:	2401      	movs	r4, #1
	}

	//humi soil
	if((__fileData.SensorCfg & SS_HumiS) == SS_HumiS )
 8005b38:	886b      	ldrh	r3, [r5, #2]
 8005b3a:	071a      	lsls	r2, r3, #28
 8005b3c:	d518      	bpl.n	8005b70 <Message_SendData_Sensor+0x94>
 8005b3e:	eb04 0684 	add.w	r6, r4, r4, lsl #2
 8005b42:	eb06 0686 	add.w	r6, r6, r6, lsl #2
	{
		strcpy((char *)__msgData.Data[index].Name, macroID_DATA_HUMI_S);
 8005b46:	ab01      	add	r3, sp, #4
 8005b48:	f106 001f 	add.w	r0, r6, #31
 8005b4c:	4969      	ldr	r1, [pc, #420]	; (8005cf4 <Message_SendData_Sensor+0x218>)
 8005b4e:	4418      	add	r0, r3
 8005b50:	f002 f8e0 	bl	8007d14 <strcpy>
		sprintf((char *)__msgData.Data[index].Info, "%.2f", __SensorData.HumiS);
 8005b54:	4b65      	ldr	r3, [pc, #404]	; (8005cec <Message_SendData_Sensor+0x210>)
 8005b56:	68d8      	ldr	r0, [r3, #12]
 8005b58:	f7fa fd06 	bl	8000568 <__aeabi_f2d>
 8005b5c:	3627      	adds	r6, #39	; 0x27
 8005b5e:	4602      	mov	r2, r0
 8005b60:	a801      	add	r0, sp, #4
 8005b62:	460b      	mov	r3, r1
 8005b64:	4430      	add	r0, r6
 8005b66:	4962      	ldr	r1, [pc, #392]	; (8005cf0 <Message_SendData_Sensor+0x214>)
 8005b68:	f002 f8b0 	bl	8007ccc <sprintf>
		index++;
 8005b6c:	3401      	adds	r4, #1
 8005b6e:	b2e4      	uxtb	r4, r4
	}

	//temp air
	if((__fileData.SensorCfg & SS_TempA) == SS_TempA)
 8005b70:	886b      	ldrh	r3, [r5, #2]
 8005b72:	07db      	lsls	r3, r3, #31
 8005b74:	d518      	bpl.n	8005ba8 <Message_SendData_Sensor+0xcc>
 8005b76:	eb04 0684 	add.w	r6, r4, r4, lsl #2
 8005b7a:	eb06 0686 	add.w	r6, r6, r6, lsl #2
	{
		strcpy((char *)__msgData.Data[index].Name, macroID_DATA_TEMP_A);
 8005b7e:	ab01      	add	r3, sp, #4
 8005b80:	f106 001f 	add.w	r0, r6, #31
 8005b84:	495c      	ldr	r1, [pc, #368]	; (8005cf8 <Message_SendData_Sensor+0x21c>)
 8005b86:	4418      	add	r0, r3
 8005b88:	f002 f8c4 	bl	8007d14 <strcpy>
		sprintf((char *)__msgData.Data[index].Info, "%.2f", __SensorData.TempA);
 8005b8c:	4b57      	ldr	r3, [pc, #348]	; (8005cec <Message_SendData_Sensor+0x210>)
 8005b8e:	6818      	ldr	r0, [r3, #0]
 8005b90:	f7fa fcea 	bl	8000568 <__aeabi_f2d>
 8005b94:	3627      	adds	r6, #39	; 0x27
 8005b96:	4602      	mov	r2, r0
 8005b98:	a801      	add	r0, sp, #4
 8005b9a:	460b      	mov	r3, r1
 8005b9c:	4430      	add	r0, r6
 8005b9e:	4954      	ldr	r1, [pc, #336]	; (8005cf0 <Message_SendData_Sensor+0x214>)
 8005ba0:	f002 f894 	bl	8007ccc <sprintf>
		index++;
 8005ba4:	3401      	adds	r4, #1
 8005ba6:	b2e4      	uxtb	r4, r4
	}

	//humi air
	if((__fileData.SensorCfg & SS_HumiA) == SS_HumiA )
 8005ba8:	886b      	ldrh	r3, [r5, #2]
 8005baa:	079e      	lsls	r6, r3, #30
 8005bac:	d518      	bpl.n	8005be0 <Message_SendData_Sensor+0x104>
 8005bae:	eb04 0684 	add.w	r6, r4, r4, lsl #2
 8005bb2:	eb06 0686 	add.w	r6, r6, r6, lsl #2
	{
		strcpy((char *)__msgData.Data[index].Name, macroID_DATA_HUMI_A);
 8005bb6:	ab01      	add	r3, sp, #4
 8005bb8:	f106 001f 	add.w	r0, r6, #31
 8005bbc:	494f      	ldr	r1, [pc, #316]	; (8005cfc <Message_SendData_Sensor+0x220>)
 8005bbe:	4418      	add	r0, r3
 8005bc0:	f002 f8a8 	bl	8007d14 <strcpy>
		sprintf((char *)__msgData.Data[index].Info, "%.2f", __SensorData.HumiA);
 8005bc4:	4b49      	ldr	r3, [pc, #292]	; (8005cec <Message_SendData_Sensor+0x210>)
 8005bc6:	6858      	ldr	r0, [r3, #4]
 8005bc8:	f7fa fcce 	bl	8000568 <__aeabi_f2d>
 8005bcc:	3627      	adds	r6, #39	; 0x27
 8005bce:	4602      	mov	r2, r0
 8005bd0:	a801      	add	r0, sp, #4
 8005bd2:	460b      	mov	r3, r1
 8005bd4:	4430      	add	r0, r6
 8005bd6:	4946      	ldr	r1, [pc, #280]	; (8005cf0 <Message_SendData_Sensor+0x214>)
 8005bd8:	f002 f878 	bl	8007ccc <sprintf>
		index++;
 8005bdc:	3401      	adds	r4, #1
 8005bde:	b2e4      	uxtb	r4, r4
	}

	//Light
	if((__fileData.SensorCfg & SS_Light) == SS_Light )
 8005be0:	886b      	ldrh	r3, [r5, #2]
 8005be2:	0658      	lsls	r0, r3, #25
 8005be4:	d518      	bpl.n	8005c18 <Message_SendData_Sensor+0x13c>
 8005be6:	eb04 0684 	add.w	r6, r4, r4, lsl #2
 8005bea:	eb06 0686 	add.w	r6, r6, r6, lsl #2
	{
		strcpy((char *)__msgData.Data[index].Name, macroID_DATA_LIGHT);
 8005bee:	ab01      	add	r3, sp, #4
 8005bf0:	f106 001f 	add.w	r0, r6, #31
 8005bf4:	4942      	ldr	r1, [pc, #264]	; (8005d00 <Message_SendData_Sensor+0x224>)
 8005bf6:	4418      	add	r0, r3
 8005bf8:	f002 f88c 	bl	8007d14 <strcpy>
		sprintf((char *)__msgData.Data[index].Info, "%.2f", __SensorData.Light);
 8005bfc:	4b3b      	ldr	r3, [pc, #236]	; (8005cec <Message_SendData_Sensor+0x210>)
 8005bfe:	6998      	ldr	r0, [r3, #24]
 8005c00:	f7fa fcb2 	bl	8000568 <__aeabi_f2d>
 8005c04:	3627      	adds	r6, #39	; 0x27
 8005c06:	4602      	mov	r2, r0
 8005c08:	a801      	add	r0, sp, #4
 8005c0a:	460b      	mov	r3, r1
 8005c0c:	4430      	add	r0, r6
 8005c0e:	4938      	ldr	r1, [pc, #224]	; (8005cf0 <Message_SendData_Sensor+0x214>)
 8005c10:	f002 f85c 	bl	8007ccc <sprintf>
		index++;
 8005c14:	3401      	adds	r4, #1
 8005c16:	b2e4      	uxtb	r4, r4
	}

	//PH
	if((__fileData.SensorCfg & SS_pH) == SS_pH )
 8005c18:	886b      	ldrh	r3, [r5, #2]
 8005c1a:	06d9      	lsls	r1, r3, #27
 8005c1c:	d518      	bpl.n	8005c50 <Message_SendData_Sensor+0x174>
 8005c1e:	eb04 0684 	add.w	r6, r4, r4, lsl #2
 8005c22:	eb06 0686 	add.w	r6, r6, r6, lsl #2
	{
		strcpy((char *)__msgData.Data[index].Name, macroID_DATA_PH);
 8005c26:	ab01      	add	r3, sp, #4
 8005c28:	f106 001f 	add.w	r0, r6, #31
 8005c2c:	4935      	ldr	r1, [pc, #212]	; (8005d04 <Message_SendData_Sensor+0x228>)
 8005c2e:	4418      	add	r0, r3
 8005c30:	f002 f870 	bl	8007d14 <strcpy>
		sprintf((char *)__msgData.Data[index].Info, "%.2f", __SensorData.PH);
 8005c34:	4b2d      	ldr	r3, [pc, #180]	; (8005cec <Message_SendData_Sensor+0x210>)
 8005c36:	6918      	ldr	r0, [r3, #16]
 8005c38:	f7fa fc96 	bl	8000568 <__aeabi_f2d>
 8005c3c:	3627      	adds	r6, #39	; 0x27
 8005c3e:	4602      	mov	r2, r0
 8005c40:	a801      	add	r0, sp, #4
 8005c42:	460b      	mov	r3, r1
 8005c44:	4430      	add	r0, r6
 8005c46:	492a      	ldr	r1, [pc, #168]	; (8005cf0 <Message_SendData_Sensor+0x214>)
 8005c48:	f002 f840 	bl	8007ccc <sprintf>
		index++;
 8005c4c:	3401      	adds	r4, #1
 8005c4e:	b2e4      	uxtb	r4, r4
	}

	//EC
	if((__fileData.SensorCfg & SS_EC) == SS_EC )
 8005c50:	886b      	ldrh	r3, [r5, #2]
 8005c52:	069a      	lsls	r2, r3, #26
 8005c54:	d518      	bpl.n	8005c88 <Message_SendData_Sensor+0x1ac>
 8005c56:	eb04 0684 	add.w	r6, r4, r4, lsl #2
 8005c5a:	eb06 0686 	add.w	r6, r6, r6, lsl #2
	{
		strcpy((char *)__msgData.Data[index].Name, macroID_DATA_EC);
 8005c5e:	ab01      	add	r3, sp, #4
 8005c60:	f106 001f 	add.w	r0, r6, #31
 8005c64:	4928      	ldr	r1, [pc, #160]	; (8005d08 <Message_SendData_Sensor+0x22c>)
 8005c66:	4418      	add	r0, r3
 8005c68:	f002 f854 	bl	8007d14 <strcpy>
		sprintf((char *)__msgData.Data[index].Info, "%.2f", __SensorData.EC);
 8005c6c:	4b1f      	ldr	r3, [pc, #124]	; (8005cec <Message_SendData_Sensor+0x210>)
 8005c6e:	6958      	ldr	r0, [r3, #20]
 8005c70:	f7fa fc7a 	bl	8000568 <__aeabi_f2d>
 8005c74:	3627      	adds	r6, #39	; 0x27
 8005c76:	4602      	mov	r2, r0
 8005c78:	a801      	add	r0, sp, #4
 8005c7a:	460b      	mov	r3, r1
 8005c7c:	4430      	add	r0, r6
 8005c7e:	491c      	ldr	r1, [pc, #112]	; (8005cf0 <Message_SendData_Sensor+0x214>)
 8005c80:	f002 f824 	bl	8007ccc <sprintf>
		index++;
 8005c84:	3401      	adds	r4, #1
 8005c86:	b2e4      	uxtb	r4, r4
	}

	//CO2
	if((__fileData.SensorCfg & SS_CO2) == SS_CO2 )
 8005c88:	886b      	ldrh	r3, [r5, #2]
 8005c8a:	061b      	lsls	r3, r3, #24
 8005c8c:	d518      	bpl.n	8005cc0 <Message_SendData_Sensor+0x1e4>
 8005c8e:	eb04 0584 	add.w	r5, r4, r4, lsl #2
 8005c92:	eb05 0585 	add.w	r5, r5, r5, lsl #2
	{
		strcpy((char *)__msgData.Data[index].Name, macroID_DATA_CO2);
 8005c96:	ab01      	add	r3, sp, #4
 8005c98:	f105 001f 	add.w	r0, r5, #31
 8005c9c:	491b      	ldr	r1, [pc, #108]	; (8005d0c <Message_SendData_Sensor+0x230>)
 8005c9e:	4418      	add	r0, r3
 8005ca0:	f002 f838 	bl	8007d14 <strcpy>
		sprintf((char *)__msgData.Data[index].Info, "%.2f", __SensorData.CO2);
 8005ca4:	4b11      	ldr	r3, [pc, #68]	; (8005cec <Message_SendData_Sensor+0x210>)
 8005ca6:	69d8      	ldr	r0, [r3, #28]
 8005ca8:	f7fa fc5e 	bl	8000568 <__aeabi_f2d>
 8005cac:	3527      	adds	r5, #39	; 0x27
 8005cae:	4602      	mov	r2, r0
 8005cb0:	a801      	add	r0, sp, #4
 8005cb2:	460b      	mov	r3, r1
 8005cb4:	4428      	add	r0, r5
 8005cb6:	490e      	ldr	r1, [pc, #56]	; (8005cf0 <Message_SendData_Sensor+0x214>)
 8005cb8:	f002 f808 	bl	8007ccc <sprintf>
		index++;
 8005cbc:	3401      	adds	r4, #1
 8005cbe:	b2e4      	uxtb	r4, r4
	}

	__msgData.NameIndex = __msgData.InfoIndex = index;

	Message_sendData(&__msgData);
 8005cc0:	a801      	add	r0, sp, #4
	__msgData.NameIndex = __msgData.InfoIndex = index;
 8005cc2:	f88d 4022 	strb.w	r4, [sp, #34]	; 0x22
 8005cc6:	f88d 4021 	strb.w	r4, [sp, #33]	; 0x21
	Message_sendData(&__msgData);
 8005cca:	f7ff fef1 	bl	8005ab0 <Message_sendData>
	//free(__msgData);
}
 8005cce:	b048      	add	sp, #288	; 0x120
 8005cd0:	bd70      	pop	{r4, r5, r6, pc}
 8005cd2:	bf00      	nop
 8005cd4:	0800c8e3 	.word	0x0800c8e3
 8005cd8:	20000010 	.word	0x20000010
 8005cdc:	0800c903 	.word	0x0800c903
 8005ce0:	20008038 	.word	0x20008038
 8005ce4:	200084b0 	.word	0x200084b0
 8005ce8:	0800c908 	.word	0x0800c908
 8005cec:	20008450 	.word	0x20008450
 8005cf0:	0800c90e 	.word	0x0800c90e
 8005cf4:	0800c913 	.word	0x0800c913
 8005cf8:	0800c919 	.word	0x0800c919
 8005cfc:	0800c91f 	.word	0x0800c91f
 8005d00:	0800c925 	.word	0x0800c925
 8005d04:	0800c92b 	.word	0x0800c92b
 8005d08:	0800c92e 	.word	0x0800c92e
 8005d0c:	0800c931 	.word	0x0800c931

08005d10 <Message_Process>:
{
 8005d10:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	APP_DEBUG("--- Message: Received = \"%s\", lenght = %d\r\n", Message, Lenght);
 8005d14:	460a      	mov	r2, r1
{
 8005d16:	b0c9      	sub	sp, #292	; 0x124
 8005d18:	4604      	mov	r4, r0
 8005d1a:	460d      	mov	r5, r1
	APP_DEBUG("--- Message: Received = \"%s\", lenght = %d\r\n", Message, Lenght);
 8005d1c:	4601      	mov	r1, r0
 8005d1e:	4871      	ldr	r0, [pc, #452]	; (8005ee4 <Message_Process+0x1d4>)
 8005d20:	f001 ff44 	bl	8007bac <printf>
	msgData_t _msgData = Parse_getMsgData( Message, Lenght );
 8005d24:	4621      	mov	r1, r4
 8005d26:	a801      	add	r0, sp, #4
 8005d28:	462a      	mov	r2, r5
 8005d2a:	f000 f939 	bl	8005fa0 <Parse_getMsgData>
	if( strcmp((char *)_msgData.IDEd, (char *)SerialNumber) != 0 )
 8005d2e:	496e      	ldr	r1, [pc, #440]	; (8005ee8 <Message_Process+0x1d8>)
 8005d30:	a804      	add	r0, sp, #16
 8005d32:	f7fa fa4d 	bl	80001d0 <strcmp>
 8005d36:	b130      	cbz	r0, 8005d46 <Message_Process+0x36>
		APP_DEBUG("--- Message: IDEd not found\r\n");
 8005d38:	486c      	ldr	r0, [pc, #432]	; (8005eec <Message_Process+0x1dc>)
 8005d3a:	f001 ffaf 	bl	8007c9c <puts>
		return false;
 8005d3e:	2000      	movs	r0, #0
}
 8005d40:	b049      	add	sp, #292	; 0x124
 8005d42:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if( strcmp((char *)_msgData.TypePacket, macroTYPE_PACKET_DATA) == 0 )	//data
 8005d46:	496a      	ldr	r1, [pc, #424]	; (8005ef0 <Message_Process+0x1e0>)
 8005d48:	a801      	add	r0, sp, #4
 8005d4a:	f7fa fa41 	bl	80001d0 <strcmp>
 8005d4e:	b918      	cbnz	r0, 8005d58 <Message_Process+0x48>
	APP_DEBUG("--- Message: type packet data not except\r\n");
 8005d50:	4868      	ldr	r0, [pc, #416]	; (8005ef4 <Message_Process+0x1e4>)
	APP_DEBUG("--- Message: type packet control not except\r\n");
 8005d52:	f001 ffa3 	bl	8007c9c <puts>
 8005d56:	e02b      	b.n	8005db0 <Message_Process+0xa0>
	else if( strcmp((char *)_msgData.TypePacket, macroTYPE_PACKET_CONF) == 0 )	//config
 8005d58:	4967      	ldr	r1, [pc, #412]	; (8005ef8 <Message_Process+0x1e8>)
 8005d5a:	a801      	add	r0, sp, #4
 8005d5c:	f7fa fa38 	bl	80001d0 <strcmp>
 8005d60:	2800      	cmp	r0, #0
 8005d62:	d169      	bne.n	8005e38 <Message_Process+0x128>
		if( strcmp((char *)_msgData->Data[index].Name, macroID_CONF_DATA_UT) == 0 )	//data UT
 8005d64:	4f65      	ldr	r7, [pc, #404]	; (8005efc <Message_Process+0x1ec>)
		else if( strcmp((char *)_msgData->Data[index].Name, macroID_CONF_RESET ) == 0 )	//reset
 8005d66:	f8df 81ec 	ldr.w	r8, [pc, #492]	; 8005f54 <Message_Process+0x244>
		else if( strcmp((char *)_msgData->Data[index].Name, macroID_CONF_OTA ) == 0 )	//OTA
 8005d6a:	f8df 91ec 	ldr.w	r9, [pc, #492]	; 8005f58 <Message_Process+0x248>
 8005d6e:	4605      	mov	r5, r0
	for(index = 0; index < _msgData->NameIndex; index++)
 8005d70:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
 8005d74:	b2e8      	uxtb	r0, r5
 8005d76:	4283      	cmp	r3, r0
 8005d78:	d91a      	bls.n	8005db0 <Message_Process+0xa0>
 8005d7a:	2419      	movs	r4, #25
 8005d7c:	4344      	muls	r4, r0
		if( strcmp((char *)_msgData->Data[index].Name, macroID_CONF_DATA_UT) == 0 )	//data UT
 8005d7e:	f104 061f 	add.w	r6, r4, #31
 8005d82:	ab01      	add	r3, sp, #4
 8005d84:	441e      	add	r6, r3
 8005d86:	4639      	mov	r1, r7
 8005d88:	4630      	mov	r0, r6
 8005d8a:	f7fa fa21 	bl	80001d0 <strcmp>
 8005d8e:	b998      	cbnz	r0, 8005db8 <Message_Process+0xa8>
			uint16_t value = atoi((char *)_msgData->Data[index].Info);
 8005d90:	f104 0027 	add.w	r0, r4, #39	; 0x27
 8005d94:	ab01      	add	r3, sp, #4
 8005d96:	4418      	add	r0, r3
 8005d98:	f001 fca3 	bl	80076e2 <atoi>
 8005d9c:	b284      	uxth	r4, r0
			if( (value > 10) && (value < 60*60*24) )
 8005d9e:	2c0a      	cmp	r4, #10
 8005da0:	d908      	bls.n	8005db4 <Message_Process+0xa4>
				APP_DEBUG("--- Message: rewrite data update time\r\n");
 8005da2:	4857      	ldr	r0, [pc, #348]	; (8005f00 <Message_Process+0x1f0>)
 8005da4:	f001 ff7a 	bl	8007c9c <puts>
				__fileData.DataUT = value;
 8005da8:	4b56      	ldr	r3, [pc, #344]	; (8005f04 <Message_Process+0x1f4>)
 8005daa:	809c      	strh	r4, [r3, #4]
				fileData_Write_DataUT();
 8005dac:	f000 ff26 	bl	8006bfc <fileData_Write_DataUT>
	return true;
 8005db0:	2001      	movs	r0, #1
 8005db2:	e7c5      	b.n	8005d40 <Message_Process+0x30>
				APP_DEBUG("--- Message: dataUT not found\r\n");
 8005db4:	4854      	ldr	r0, [pc, #336]	; (8005f08 <Message_Process+0x1f8>)
 8005db6:	e7cc      	b.n	8005d52 <Message_Process+0x42>
		else if( strcmp((char *)_msgData->Data[index].Name, macroID_CONF_RESET ) == 0 )	//reset
 8005db8:	4641      	mov	r1, r8
 8005dba:	4630      	mov	r0, r6
 8005dbc:	f7fa fa08 	bl	80001d0 <strcmp>
 8005dc0:	b998      	cbnz	r0, 8005dea <Message_Process+0xda>
			APP_DEBUG("--- Message: device reseting...\r\n");
 8005dc2:	4852      	ldr	r0, [pc, #328]	; (8005f0c <Message_Process+0x1fc>)
 8005dc4:	f001 ff6a 	bl	8007c9c <puts>
			HAL_Delay(1000);
 8005dc8:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8005dcc:	f7fb f906 	bl	8000fdc <HAL_Delay>
  __ASM volatile ("dsb 0xF":::"memory");
 8005dd0:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8005dd4:	494e      	ldr	r1, [pc, #312]	; (8005f10 <Message_Process+0x200>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8005dd6:	4b4f      	ldr	r3, [pc, #316]	; (8005f14 <Message_Process+0x204>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8005dd8:	68ca      	ldr	r2, [r1, #12]
 8005dda:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8005dde:	4313      	orrs	r3, r2
 8005de0:	60cb      	str	r3, [r1, #12]
 8005de2:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("nop");
 8005de6:	bf00      	nop
 8005de8:	e7fd      	b.n	8005de6 <Message_Process+0xd6>
		else if( strcmp((char *)_msgData->Data[index].Name, macroID_CONF_OTA ) == 0 )	//OTA
 8005dea:	4649      	mov	r1, r9
 8005dec:	4630      	mov	r0, r6
 8005dee:	f7fa f9ef 	bl	80001d0 <strcmp>
 8005df2:	b920      	cbnz	r0, 8005dfe <Message_Process+0xee>
			Message_OTA_Start_Callback();
 8005df4:	4b48      	ldr	r3, [pc, #288]	; (8005f18 <Message_Process+0x208>)
 8005df6:	681b      	ldr	r3, [r3, #0]
 8005df8:	4798      	blx	r3
 8005dfa:	3501      	adds	r5, #1
 8005dfc:	e7b8      	b.n	8005d70 <Message_Process+0x60>
		else if( strcmp((char *)_msgData->Data[index].Name, macroID_CONF_SENSOR ) == 0 )	//config sensor
 8005dfe:	4947      	ldr	r1, [pc, #284]	; (8005f1c <Message_Process+0x20c>)
 8005e00:	4630      	mov	r0, r6
 8005e02:	f7fa f9e5 	bl	80001d0 <strcmp>
 8005e06:	2800      	cmp	r0, #0
 8005e08:	d1f7      	bne.n	8005dfa <Message_Process+0xea>
			uint16_t value = atoi((char *)_msgData->Data[index].Info);
 8005e0a:	ab01      	add	r3, sp, #4
 8005e0c:	3427      	adds	r4, #39	; 0x27
 8005e0e:	1918      	adds	r0, r3, r4
 8005e10:	f001 fc67 	bl	80076e2 <atoi>
			if( ( value>= 0) && (value < 0xffff) )
 8005e14:	f64f 73ff 	movw	r3, #65535	; 0xffff
			uint16_t value = atoi((char *)_msgData->Data[index].Info);
 8005e18:	b280      	uxth	r0, r0
			if( ( value>= 0) && (value < 0xffff) )
 8005e1a:	4298      	cmp	r0, r3
 8005e1c:	d0ed      	beq.n	8005dfa <Message_Process+0xea>
				__fileData.SensorCfg &= value;
 8005e1e:	4b39      	ldr	r3, [pc, #228]	; (8005f04 <Message_Process+0x1f4>)
 8005e20:	8859      	ldrh	r1, [r3, #2]
 8005e22:	4001      	ands	r1, r0
				APP_DEBUG("--- Message: config sensor type = 0x%.4x\r\n", __fileData.SensorCfg);
 8005e24:	483e      	ldr	r0, [pc, #248]	; (8005f20 <Message_Process+0x210>)
				__fileData.SensorCfg &= value;
 8005e26:	8059      	strh	r1, [r3, #2]
				APP_DEBUG("--- Message: config sensor type = 0x%.4x\r\n", __fileData.SensorCfg);
 8005e28:	f001 fec0 	bl	8007bac <printf>
				fileData_Write_SensorCFG();
 8005e2c:	f000 feb6 	bl	8006b9c <fileData_Write_SensorCFG>
				Message_setTypeSensor();
 8005e30:	4b3c      	ldr	r3, [pc, #240]	; (8005f24 <Message_Process+0x214>)
		Message_sendData_Callback();
 8005e32:	681b      	ldr	r3, [r3, #0]
 8005e34:	4798      	blx	r3
 8005e36:	e7bb      	b.n	8005db0 <Message_Process+0xa0>
	else if( strcmp((char *)_msgData.TypePacket, macroTYPE_PACKET_CTRL) == 0 )	//request
 8005e38:	493b      	ldr	r1, [pc, #236]	; (8005f28 <Message_Process+0x218>)
 8005e3a:	a801      	add	r0, sp, #4
 8005e3c:	f7fa f9c8 	bl	80001d0 <strcmp>
 8005e40:	2800      	cmp	r0, #0
 8005e42:	d136      	bne.n	8005eb2 <Message_Process+0x1a2>
 8005e44:	f89d 5021 	ldrb.w	r5, [sp, #33]	; 0x21
		if( strcmp((char *)_msgData->Data[index].Name, macroID_REQS_ALL ) == 0 )
 8005e48:	4f38      	ldr	r7, [pc, #224]	; (8005f2c <Message_Process+0x21c>)
		else if( strcmp((char *)_msgData->Data[index].Name, macroID_REQS_D_STATE ) == 0 )
 8005e4a:	f8df 8110 	ldr.w	r8, [pc, #272]	; 8005f5c <Message_Process+0x24c>
 8005e4e:	2319      	movs	r3, #25
 8005e50:	aa01      	add	r2, sp, #4
 8005e52:	f10d 0423 	add.w	r4, sp, #35	; 0x23
 8005e56:	fb03 2505 	mla	r5, r3, r5, r2
 8005e5a:	351f      	adds	r5, #31
 8005e5c:	4626      	mov	r6, r4
	for(index = 0; index < _msgData->NameIndex; index++)
 8005e5e:	42ac      	cmp	r4, r5
 8005e60:	d0a6      	beq.n	8005db0 <Message_Process+0xa0>
		if( strcmp((char *)_msgData->Data[index].Name, macroID_REQS_ALL ) == 0 )
 8005e62:	4639      	mov	r1, r7
 8005e64:	4620      	mov	r0, r4
 8005e66:	f7fa f9b3 	bl	80001d0 <strcmp>
 8005e6a:	b910      	cbnz	r0, 8005e72 <Message_Process+0x162>
			Message_SendData_Sensor();
 8005e6c:	f7ff fe36 	bl	8005adc <Message_SendData_Sensor>
 8005e70:	e79e      	b.n	8005db0 <Message_Process+0xa0>
		else if( strcmp((char *)_msgData->Data[index].Name, macroID_REQS_D_STATE ) == 0 )
 8005e72:	4620      	mov	r0, r4
 8005e74:	4641      	mov	r1, r8
 8005e76:	f7fa f9ab 	bl	80001d0 <strcmp>
 8005e7a:	3419      	adds	r4, #25
 8005e7c:	2800      	cmp	r0, #0
 8005e7e:	d1ee      	bne.n	8005e5e <Message_Process+0x14e>
			APP_DEBUG("--- Message: request is D State\r\n");
 8005e80:	482b      	ldr	r0, [pc, #172]	; (8005f30 <Message_Process+0x220>)
 8005e82:	f001 ff0b 	bl	8007c9c <puts>
			strcpy((char *)_msgData->TypePacket, macroTYPE_PACKET_DATA);
 8005e86:	491a      	ldr	r1, [pc, #104]	; (8005ef0 <Message_Process+0x1e0>)
 8005e88:	a801      	add	r0, sp, #4
 8005e8a:	f001 ff43 	bl	8007d14 <strcpy>
			strcpy((char *)_msgData->Data[0].Name, macroID_DATA_DEVICE_STATE);
 8005e8e:	4929      	ldr	r1, [pc, #164]	; (8005f34 <Message_Process+0x224>)
 8005e90:	4630      	mov	r0, r6
 8005e92:	f001 ff3f 	bl	8007d14 <strcpy>
			strcpy((char *)_msgData->Data[0].Info, "OK");
 8005e96:	4928      	ldr	r1, [pc, #160]	; (8005f38 <Message_Process+0x228>)
 8005e98:	f10d 002b 	add.w	r0, sp, #43	; 0x2b
 8005e9c:	f001 ff3a 	bl	8007d14 <strcpy>
			_msgData->NameIndex		= 1;
 8005ea0:	2401      	movs	r4, #1
			Message_sendData( _msgData );
 8005ea2:	a801      	add	r0, sp, #4
			_msgData->NameIndex		= 1;
 8005ea4:	f88d 4021 	strb.w	r4, [sp, #33]	; 0x21
			_msgData->InfoIndex		= 1;
 8005ea8:	f88d 4022 	strb.w	r4, [sp, #34]	; 0x22
			Message_sendData( _msgData );
 8005eac:	f7ff fe00 	bl	8005ab0 <Message_sendData>
 8005eb0:	e77e      	b.n	8005db0 <Message_Process+0xa0>
	else if( strcmp((char *)_msgData.TypePacket, macroTYPE_PACKET_REQS) == 0 )	//control
 8005eb2:	4922      	ldr	r1, [pc, #136]	; (8005f3c <Message_Process+0x22c>)
 8005eb4:	a801      	add	r0, sp, #4
 8005eb6:	f7fa f98b 	bl	80001d0 <strcmp>
 8005eba:	b908      	cbnz	r0, 8005ec0 <Message_Process+0x1b0>
	APP_DEBUG("--- Message: type packet control not except\r\n");
 8005ebc:	4820      	ldr	r0, [pc, #128]	; (8005f40 <Message_Process+0x230>)
 8005ebe:	e748      	b.n	8005d52 <Message_Process+0x42>
	else if( strcmp((char *)_msgData.TypePacket, macroTYPE_PACKET_RESP) == 0 )	//response
 8005ec0:	4920      	ldr	r1, [pc, #128]	; (8005f44 <Message_Process+0x234>)
 8005ec2:	a801      	add	r0, sp, #4
 8005ec4:	f7fa f984 	bl	80001d0 <strcmp>
 8005ec8:	2800      	cmp	r0, #0
 8005eca:	f47f af71 	bne.w	8005db0 <Message_Process+0xa0>
	APP_DEBUG("--- Message: message is response\r\n");
 8005ece:	481e      	ldr	r0, [pc, #120]	; (8005f48 <Message_Process+0x238>)
 8005ed0:	f001 fee4 	bl	8007c9c <puts>
	if(_msgData->msgID == msgID)
 8005ed4:	4b1d      	ldr	r3, [pc, #116]	; (8005f4c <Message_Process+0x23c>)
 8005ed6:	9a03      	ldr	r2, [sp, #12]
 8005ed8:	681b      	ldr	r3, [r3, #0]
 8005eda:	429a      	cmp	r2, r3
 8005edc:	f47f af68 	bne.w	8005db0 <Message_Process+0xa0>
		Message_sendData_Callback();
 8005ee0:	4b1b      	ldr	r3, [pc, #108]	; (8005f50 <Message_Process+0x240>)
 8005ee2:	e7a6      	b.n	8005e32 <Message_Process+0x122>
 8005ee4:	0800c72a 	.word	0x0800c72a
 8005ee8:	200084b0 	.word	0x200084b0
 8005eec:	0800c756 	.word	0x0800c756
 8005ef0:	0800c903 	.word	0x0800c903
 8005ef4:	0800c773 	.word	0x0800c773
 8005ef8:	0800c79d 	.word	0x0800c79d
 8005efc:	0800c7a2 	.word	0x0800c7a2
 8005f00:	0800c7a9 	.word	0x0800c7a9
 8005f04:	20000010 	.word	0x20000010
 8005f08:	0800c7d0 	.word	0x0800c7d0
 8005f0c:	0800c7f5 	.word	0x0800c7f5
 8005f10:	e000ed00 	.word	0xe000ed00
 8005f14:	05fa0004 	.word	0x05fa0004
 8005f18:	20008a9c 	.word	0x20008a9c
 8005f1c:	0800c81a 	.word	0x0800c81a
 8005f20:	0800c821 	.word	0x0800c821
 8005f24:	20008a94 	.word	0x20008a94
 8005f28:	0800c84c 	.word	0x0800c84c
 8005f2c:	0800c851 	.word	0x0800c851
 8005f30:	0800c85e 	.word	0x0800c85e
 8005f34:	0800c87f 	.word	0x0800c87f
 8005f38:	0800c887 	.word	0x0800c887
 8005f3c:	0800c88a 	.word	0x0800c88a
 8005f40:	0800c88f 	.word	0x0800c88f
 8005f44:	0800c8bc 	.word	0x0800c8bc
 8005f48:	0800c8c1 	.word	0x0800c8c1
 8005f4c:	20008038 	.word	0x20008038
 8005f50:	20008aa0 	.word	0x20008aa0
 8005f54:	0800c7ef 	.word	0x0800c7ef
 8005f58:	0800c816 	.word	0x0800c816
 8005f5c:	0800c855 	.word	0x0800c855

08005f60 <Message_set_OTA_Callback>:
/********************************** Call back ***************************/
//OTA callback
void Message_set_OTA_Callback( void ota_start_cb( void ), \
							   void ota_data_cb( uint8_t *, uint16_t ), void ota_data_done_cb( void ) )
{
	Message_OTA_Start_Callback		= ota_start_cb;
 8005f60:	4b03      	ldr	r3, [pc, #12]	; (8005f70 <Message_set_OTA_Callback+0x10>)
 8005f62:	6018      	str	r0, [r3, #0]
	Message_OTA_Data_Callback		= ota_data_cb;
 8005f64:	4b03      	ldr	r3, [pc, #12]	; (8005f74 <Message_set_OTA_Callback+0x14>)
 8005f66:	6019      	str	r1, [r3, #0]
	Message_OTA_DataDone_Callback	= ota_data_done_cb;
 8005f68:	4b03      	ldr	r3, [pc, #12]	; (8005f78 <Message_set_OTA_Callback+0x18>)
 8005f6a:	601a      	str	r2, [r3, #0]
 8005f6c:	4770      	bx	lr
 8005f6e:	bf00      	nop
 8005f70:	20008a9c 	.word	0x20008a9c
 8005f74:	20008aa4 	.word	0x20008aa4
 8005f78:	20008a98 	.word	0x20008a98

08005f7c <Message_set_sendData_Callback>:


//send data callback
void Message_set_sendData_Callback( void send_data_cb( void ) )
{
	Message_sendData_Callback = send_data_cb;
 8005f7c:	4b01      	ldr	r3, [pc, #4]	; (8005f84 <Message_set_sendData_Callback+0x8>)
 8005f7e:	6018      	str	r0, [r3, #0]
 8005f80:	4770      	bx	lr
 8005f82:	bf00      	nop
 8005f84:	20008aa0 	.word	0x20008aa0

08005f88 <Message_set_Lora_Transmit_Callback>:


//lora transmit callback
void Message_set_Lora_Transmit_Callback( bool Lora_Transmit_cb( uint8_t *, uint16_t ) )
{
	Message_Lora_Transmit = Lora_Transmit_cb;
 8005f88:	4b01      	ldr	r3, [pc, #4]	; (8005f90 <Message_set_Lora_Transmit_Callback+0x8>)
 8005f8a:	6018      	str	r0, [r3, #0]
 8005f8c:	4770      	bx	lr
 8005f8e:	bf00      	nop
 8005f90:	20008aac 	.word	0x20008aac

08005f94 <Message_set_Typesensor_Callback>:


//set type sensor call back
void Message_set_Typesensor_Callback( void set_typesensor_cb( void ) )
{
	Message_setTypeSensor = set_typesensor_cb;
 8005f94:	4b01      	ldr	r3, [pc, #4]	; (8005f9c <Message_set_Typesensor_Callback+0x8>)
 8005f96:	6018      	str	r0, [r3, #0]
 8005f98:	4770      	bx	lr
 8005f9a:	bf00      	nop
 8005f9c:	20008a94 	.word	0x20008a94

08005fa0 <Parse_getMsgData>:
 * Return		:
 * 				+ message data struct
 * 				+ if data struct = NULL - failture
 * ****************************************************************************/
msgData_t Parse_getMsgData( uint8_t *Message, uint16_t Lenght )
{
 8005fa0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005fa4:	f5ad 7d50 	sub.w	sp, sp, #832	; 0x340
 8005fa8:	460d      	mov	r5, r1
 8005faa:	4604      	mov	r4, r0
	Array_t Array = {0};
 8005fac:	2100      	movs	r1, #0
{
 8005fae:	4616      	mov	r6, r2
	Array_t Array = {0};
 8005fb0:	a868      	add	r0, sp, #416	; 0x1a0
 8005fb2:	f44f 72cf 	mov.w	r2, #414	; 0x19e
 8005fb6:	f001 fde4 	bl	8007b82 <memset>
	uint8_t Len = 0;
 8005fba:	2100      	movs	r1, #0
		if((*msg == ',') || (*msg == ':') || (*msg == '!'))
 8005fbc:	f8df c0e8 	ldr.w	ip, [pc, #232]	; 80060a8 <Parse_getMsgData+0x108>
	Array_t Array = {0};
 8005fc0:	4628      	mov	r0, r5
	uint8_t index = 0;
 8005fc2:	460a      	mov	r2, r1
			Array.Array[index][Len++] = *msg;
 8005fc4:	f04f 0e12 	mov.w	lr, #18
	while(Count < Lenght)
 8005fc8:	1b43      	subs	r3, r0, r5
 8005fca:	b29b      	uxth	r3, r3
 8005fcc:	429e      	cmp	r6, r3
 8005fce:	d912      	bls.n	8005ff6 <Parse_getMsgData+0x56>
		if((*msg == ',') || (*msg == ':') || (*msg == '!'))
 8005fd0:	f810 7b01 	ldrb.w	r7, [r0], #1
 8005fd4:	f1a7 0321 	sub.w	r3, r7, #33	; 0x21
 8005fd8:	b2db      	uxtb	r3, r3
 8005fda:	2b19      	cmp	r3, #25
 8005fdc:	d82d      	bhi.n	800603a <Parse_getMsgData+0x9a>
 8005fde:	fa2c f303 	lsr.w	r3, ip, r3
 8005fe2:	43db      	mvns	r3, r3
 8005fe4:	f013 0301 	ands.w	r3, r3, #1
 8005fe8:	d127      	bne.n	800603a <Parse_getMsgData+0x9a>
			index++;
 8005fea:	3201      	adds	r2, #1
			if(*msg == '!')
 8005fec:	2f21      	cmp	r7, #33	; 0x21
			index++;
 8005fee:	b2d2      	uxtb	r2, r2
			if(*msg == '!')
 8005ff0:	d001      	beq.n	8005ff6 <Parse_getMsgData+0x56>
			if(index >= MSG_MAX_FIELD)
 8005ff2:	2a16      	cmp	r2, #22
 8005ff4:	d92b      	bls.n	800604e <Parse_getMsgData+0xae>
				return Array;
 8005ff6:	f44f 72cf 	mov.w	r2, #414	; 0x19e
 8005ffa:	a968      	add	r1, sp, #416	; 0x1a0
 8005ffc:	4668      	mov	r0, sp
 8005ffe:	f001 fdb5 	bl	8007b6c <memcpy>
//	uint8_t Array[MSG_MAX_FIELD][MSG_FIELD_MAX_LENGHT + 1] = {0};

	Array_t Array = Parse_UnParking( Message, Lenght );
	msgData_t _msgData = {0};// = malloc(Lenght + 32);
 8006002:	f44f 728e 	mov.w	r2, #284	; 0x11c
 8006006:	2100      	movs	r1, #0
 8006008:	a868      	add	r0, sp, #416	; 0x1a0
 800600a:	f001 fdba 	bl	8007b82 <memset>
//	for(uint8_t ui = 0; Array.Array[ui][0] > 0; ui++)
//		APP_DEBUG("Array[%d] = %s\r\n", ui, Array.Array[ui]);

	//Parse_resetData(_msgData);

	while(Array.Array[index][0] > 0)
 800600e:	2500      	movs	r5, #0
 8006010:	2712      	movs	r7, #18
				break;
			default:
				if(index % 2 == 1)
					strcpy((char *)_msgData.Data[_msgData.NameIndex++].Name, (char *)Array.Array[index]);
				else
					strcpy((char *)_msgData.Data[_msgData.InfoIndex++].Info, (char *)Array.Array[index]);
 8006012:	2619      	movs	r6, #25
 8006014:	b2eb      	uxtb	r3, r5
	while(Array.Array[index][0] > 0)
 8006016:	fb07 f203 	mul.w	r2, r7, r3
 800601a:	eb0d 0102 	add.w	r1, sp, r2
 800601e:	f81d 2002 	ldrb.w	r2, [sp, r2]
 8006022:	b9b2      	cbnz	r2, 8006052 <Parse_getMsgData+0xb2>
				break;
		}
		index++;
	}

	return _msgData;
 8006024:	f44f 728e 	mov.w	r2, #284	; 0x11c
 8006028:	a968      	add	r1, sp, #416	; 0x1a0
 800602a:	4620      	mov	r0, r4
 800602c:	f001 fd9e 	bl	8007b6c <memcpy>
}
 8006030:	4620      	mov	r0, r4
 8006032:	f50d 7d50 	add.w	sp, sp, #832	; 0x340
 8006036:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			Array.Array[index][Len++] = *msg;
 800603a:	f50d 78d0 	add.w	r8, sp, #416	; 0x1a0
 800603e:	1c4b      	adds	r3, r1, #1
 8006040:	fb0e 8802 	mla	r8, lr, r2, r8
 8006044:	b2db      	uxtb	r3, r3
 8006046:	f808 7001 	strb.w	r7, [r8, r1]
			if(Len >= MSG_FIELD_MAX_LENGHT)
 800604a:	2b10      	cmp	r3, #16
 800604c:	e7d2      	b.n	8005ff4 <Parse_getMsgData+0x54>
	uint8_t index = 0;
 800604e:	4619      	mov	r1, r3
 8006050:	e7ba      	b.n	8005fc8 <Parse_getMsgData+0x28>
		switch(index)
 8006052:	2b01      	cmp	r3, #1
 8006054:	d013      	beq.n	800607e <Parse_getMsgData+0xde>
 8006056:	d30d      	bcc.n	8006074 <Parse_getMsgData+0xd4>
 8006058:	2b02      	cmp	r3, #2
 800605a:	d017      	beq.n	800608c <Parse_getMsgData+0xec>
				if(index % 2 == 1)
 800605c:	07db      	lsls	r3, r3, #31
 800605e:	d518      	bpl.n	8006092 <Parse_getMsgData+0xf2>
					strcpy((char *)_msgData.Data[_msgData.NameIndex++].Name, (char *)Array.Array[index]);
 8006060:	f89d 01bd 	ldrb.w	r0, [sp, #445]	; 0x1bd
 8006064:	1c43      	adds	r3, r0, #1
 8006066:	f88d 31bd 	strb.w	r3, [sp, #445]	; 0x1bd
 800606a:	ab68      	add	r3, sp, #416	; 0x1a0
 800606c:	fb06 3000 	mla	r0, r6, r0, r3
 8006070:	301f      	adds	r0, #31
 8006072:	e001      	b.n	8006078 <Parse_getMsgData+0xd8>
				strcpy((char *)_msgData.TypePacket, (char *)Array.Array[0]);
 8006074:	4669      	mov	r1, sp
 8006076:	a868      	add	r0, sp, #416	; 0x1a0
					strcpy((char *)_msgData.Data[_msgData.InfoIndex++].Info, (char *)Array.Array[index]);
 8006078:	f001 fe4c 	bl	8007d14 <strcpy>
 800607c:	e004      	b.n	8006088 <Parse_getMsgData+0xe8>
				_msgData.msgID = atoi((char *)Array.Array[1]);
 800607e:	f10d 0012 	add.w	r0, sp, #18
 8006082:	f001 fb2e 	bl	80076e2 <atoi>
 8006086:	906a      	str	r0, [sp, #424]	; 0x1a8
 8006088:	3501      	adds	r5, #1
 800608a:	e7c3      	b.n	8006014 <Parse_getMsgData+0x74>
				strcpy((char *)_msgData.IDEd, (char *)Array.Array[2]);
 800608c:	a909      	add	r1, sp, #36	; 0x24
 800608e:	a86b      	add	r0, sp, #428	; 0x1ac
 8006090:	e7f2      	b.n	8006078 <Parse_getMsgData+0xd8>
					strcpy((char *)_msgData.Data[_msgData.InfoIndex++].Info, (char *)Array.Array[index]);
 8006092:	f89d 01be 	ldrb.w	r0, [sp, #446]	; 0x1be
 8006096:	1c43      	adds	r3, r0, #1
 8006098:	f88d 31be 	strb.w	r3, [sp, #446]	; 0x1be
 800609c:	ab68      	add	r3, sp, #416	; 0x1a0
 800609e:	fb06 3000 	mla	r0, r6, r0, r3
 80060a2:	3027      	adds	r0, #39	; 0x27
 80060a4:	e7e8      	b.n	8006078 <Parse_getMsgData+0xd8>
 80060a6:	bf00      	nop
 80060a8:	02000801 	.word	0x02000801

080060ac <Parse_setMsgData>:
 * Description	: set message data
 * Param		: _msgData - message data srtuct
 * Return		: message output
 * ****************************************************************************/
string_msg_t Parse_setMsgData( msgData_t *_msgData, uint16_t *Lenght )
{
 80060ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80060b0:	b0e5      	sub	sp, #404	; 0x194
	string_msg_t string_msg = {0};
 80060b2:	ac02      	add	r4, sp, #8
{
 80060b4:	460d      	mov	r5, r1
 80060b6:	4681      	mov	r9, r0
	string_msg_t string_msg = {0};
 80060b8:	2100      	movs	r1, #0
{
 80060ba:	4692      	mov	sl, r2
	string_msg_t string_msg = {0};
 80060bc:	4620      	mov	r0, r4
 80060be:	f44f 72c4 	mov.w	r2, #392	; 0x188
 80060c2:	f001 fd5e 	bl	8007b82 <memset>

	sprintf((char *)string_msg.msgsTring, "%s,%ld,%s", (char *)_msgData->TypePacket, _msgData->msgID, (char *)_msgData->IDEd);
 80060c6:	f105 030c 	add.w	r3, r5, #12
 80060ca:	9300      	str	r3, [sp, #0]
 80060cc:	462a      	mov	r2, r5
 80060ce:	68ab      	ldr	r3, [r5, #8]
 80060d0:	491c      	ldr	r1, [pc, #112]	; (8006144 <Parse_setMsgData+0x98>)
 80060d2:	4620      	mov	r0, r4
 80060d4:	f001 fdfa 	bl	8007ccc <sprintf>
	for(uint8_t ui = 0; ui < _msgData->NameIndex; ui++)
 80060d8:	f04f 0800 	mov.w	r8, #0
 80060dc:	f04f 0b19 	mov.w	fp, #25
 80060e0:	7f6b      	ldrb	r3, [r5, #29]
 80060e2:	fa5f f788 	uxtb.w	r7, r8
 80060e6:	42bb      	cmp	r3, r7
 80060e8:	d813      	bhi.n	8006112 <Parse_setMsgData+0x66>
	{
		sprintf((char *)string_msg.msgsTring, "%s,%s", string_msg.msgsTring, (char *)_msgData->Data[ui].Name);
		if(ui < _msgData->InfoIndex)
			sprintf((char *)string_msg.msgsTring, "%s:%s", string_msg.msgsTring, (char *)_msgData->Data[ui].Info);
	}
	string_msg.msgsTring[strlen((char *)string_msg.msgsTring)] = '!';
 80060ea:	4620      	mov	r0, r4
 80060ec:	f7fa f87a 	bl	80001e4 <strlen>
 80060f0:	2321      	movs	r3, #33	; 0x21
 80060f2:	5423      	strb	r3, [r4, r0]
	*Lenght = strlen((char *)string_msg.msgsTring);
 80060f4:	4620      	mov	r0, r4
 80060f6:	f7fa f875 	bl	80001e4 <strlen>

	return string_msg;
 80060fa:	f44f 72c4 	mov.w	r2, #392	; 0x188
	*Lenght = strlen((char *)string_msg.msgsTring);
 80060fe:	f8aa 0000 	strh.w	r0, [sl]
	return string_msg;
 8006102:	4621      	mov	r1, r4
 8006104:	4648      	mov	r0, r9
 8006106:	f001 fd31 	bl	8007b6c <memcpy>
}
 800610a:	4648      	mov	r0, r9
 800610c:	b065      	add	sp, #404	; 0x194
 800610e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006112:	fb0b f607 	mul.w	r6, fp, r7
		sprintf((char *)string_msg.msgsTring, "%s,%s", string_msg.msgsTring, (char *)_msgData->Data[ui].Name);
 8006116:	f106 031f 	add.w	r3, r6, #31
 800611a:	442b      	add	r3, r5
 800611c:	4622      	mov	r2, r4
 800611e:	490a      	ldr	r1, [pc, #40]	; (8006148 <Parse_setMsgData+0x9c>)
 8006120:	4620      	mov	r0, r4
 8006122:	f001 fdd3 	bl	8007ccc <sprintf>
		if(ui < _msgData->InfoIndex)
 8006126:	7fab      	ldrb	r3, [r5, #30]
 8006128:	42bb      	cmp	r3, r7
 800612a:	d907      	bls.n	800613c <Parse_setMsgData+0x90>
			sprintf((char *)string_msg.msgsTring, "%s:%s", string_msg.msgsTring, (char *)_msgData->Data[ui].Info);
 800612c:	f106 0327 	add.w	r3, r6, #39	; 0x27
 8006130:	442b      	add	r3, r5
 8006132:	4622      	mov	r2, r4
 8006134:	4905      	ldr	r1, [pc, #20]	; (800614c <Parse_setMsgData+0xa0>)
 8006136:	4620      	mov	r0, r4
 8006138:	f001 fdc8 	bl	8007ccc <sprintf>
 800613c:	f108 0801 	add.w	r8, r8, #1
 8006140:	e7ce      	b.n	80060e0 <Parse_setMsgData+0x34>
 8006142:	bf00      	nop
 8006144:	0800c935 	.word	0x0800c935
 8006148:	0800c93f 	.word	0x0800c93f
 800614c:	0800c945 	.word	0x0800c945

08006150 <SS_EC_Init>:
}



void SS_EC_Init( void )
{
 8006150:	b530      	push	{r4, r5, lr}
	TIM_MasterConfigTypeDef sMasterConfig = {0};
 8006152:	2400      	movs	r4, #0
{
 8006154:	b091      	sub	sp, #68	; 0x44
	TIM_OC_InitTypeDef sConfigOC = {0};
 8006156:	4621      	mov	r1, r4
 8006158:	221c      	movs	r2, #28
 800615a:	a809      	add	r0, sp, #36	; 0x24
	TIM_MasterConfigTypeDef sMasterConfig = {0};
 800615c:	9401      	str	r4, [sp, #4]
 800615e:	9402      	str	r4, [sp, #8]
 8006160:	9403      	str	r4, [sp, #12]
	TIM_OC_InitTypeDef sConfigOC = {0};
 8006162:	f001 fd0e 	bl	8007b82 <memset>
	GPIO_InitTypeDef GPIO_InitStruct = {0};
 8006166:	4621      	mov	r1, r4
 8006168:	2214      	movs	r2, #20
 800616a:	a804      	add	r0, sp, #16
 800616c:	f001 fd09 	bl	8007b82 <memset>
	__HAL_RCC_GPIOA_CLK_ENABLE();
 8006170:	4b21      	ldr	r3, [pc, #132]	; (80061f8 <SS_EC_Init+0xa8>)
	htim1.Instance = TIM1;
 8006172:	4d22      	ldr	r5, [pc, #136]	; (80061fc <SS_EC_Init+0xac>)
	__HAL_RCC_GPIOA_CLK_ENABLE();
 8006174:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8006176:	f042 0201 	orr.w	r2, r2, #1
 800617a:	64da      	str	r2, [r3, #76]	; 0x4c
 800617c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800617e:	f003 0301 	and.w	r3, r3, #1
 8006182:	9300      	str	r3, [sp, #0]
 8006184:	9b00      	ldr	r3, [sp, #0]
	GPIO_InitStruct.Pin = GPIO_PIN_11;
 8006186:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800618a:	9304      	str	r3, [sp, #16]
	GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800618c:	2302      	movs	r3, #2
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800618e:	a904      	add	r1, sp, #16
	GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006190:	9305      	str	r3, [sp, #20]
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8006192:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
	GPIO_InitStruct.Alternate = GPIO_AF1_TIM1;
 8006196:	2301      	movs	r3, #1
 8006198:	9308      	str	r3, [sp, #32]
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800619a:	f7fb fcab 	bl	8001af4 <HAL_GPIO_Init>
	htim1.Init.Prescaler = 400-1;
 800619e:	4a18      	ldr	r2, [pc, #96]	; (8006200 <SS_EC_Init+0xb0>)
	htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
 80061a0:	60ac      	str	r4, [r5, #8]
	htim1.Init.Prescaler = 400-1;
 80061a2:	f240 138f 	movw	r3, #399	; 0x18f
 80061a6:	e885 000c 	stmia.w	r5, {r2, r3}
	htim1.Init.Period = 9999-1;
 80061aa:	f242 730e 	movw	r3, #9998	; 0x270e
 80061ae:	60eb      	str	r3, [r5, #12]
	if (HAL_TIM_PWM_Init(&htim1) != HAL_OK)
 80061b0:	4628      	mov	r0, r5
	htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
 80061b2:	2380      	movs	r3, #128	; 0x80
 80061b4:	61ab      	str	r3, [r5, #24]
	htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 80061b6:	612c      	str	r4, [r5, #16]
	htim1.Init.RepetitionCounter = 0;
 80061b8:	616c      	str	r4, [r5, #20]
	if (HAL_TIM_PWM_Init(&htim1) != HAL_OK)
 80061ba:	f7fd f9cb 	bl	8003554 <HAL_TIM_PWM_Init>
	if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
 80061be:	a901      	add	r1, sp, #4
 80061c0:	4628      	mov	r0, r5
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 80061c2:	9401      	str	r4, [sp, #4]
	sMasterConfig.MasterOutputTrigger2 = TIM_TRGO2_RESET;
 80061c4:	9402      	str	r4, [sp, #8]
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 80061c6:	9403      	str	r4, [sp, #12]
	if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
 80061c8:	f7fd faec 	bl	80037a4 <HAL_TIMEx_MasterConfigSynchronization>
	sConfigOC.OCMode = TIM_OCMODE_PWM1;
 80061cc:	2360      	movs	r3, #96	; 0x60
	if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
 80061ce:	220c      	movs	r2, #12
 80061d0:	a909      	add	r1, sp, #36	; 0x24
 80061d2:	4628      	mov	r0, r5
	sConfigOC.OCMode = TIM_OCMODE_PWM1;
 80061d4:	9309      	str	r3, [sp, #36]	; 0x24
	sConfigOC.Pulse = 0;
 80061d6:	940a      	str	r4, [sp, #40]	; 0x28
	sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 80061d8:	940b      	str	r4, [sp, #44]	; 0x2c
	sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 80061da:	940d      	str	r4, [sp, #52]	; 0x34
	sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
 80061dc:	940e      	str	r4, [sp, #56]	; 0x38
	sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
 80061de:	940f      	str	r4, [sp, #60]	; 0x3c
	if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
 80061e0:	f7fd fa18 	bl	8003614 <HAL_TIM_PWM_ConfigChannel>
	HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_4);
 80061e4:	210c      	movs	r1, #12
 80061e6:	4628      	mov	r0, r5
 80061e8:	f7fd faa8 	bl	800373c <HAL_TIM_PWM_Start>
	ADC_Init( &ADC_EC_Handle );
 80061ec:	4805      	ldr	r0, [pc, #20]	; (8006204 <SS_EC_Init+0xb4>)
 80061ee:	f7ff fa89 	bl	8005704 <ADC_Init>
	SS_EC_Init_PWM();
	SS_EC_Init_ADC();
}
 80061f2:	b011      	add	sp, #68	; 0x44
 80061f4:	bd30      	pop	{r4, r5, pc}
 80061f6:	bf00      	nop
 80061f8:	40021000 	.word	0x40021000
 80061fc:	20008b14 	.word	0x20008b14
 8006200:	40012c00 	.word	0x40012c00
 8006204:	20008ab0 	.word	0x20008ab0

08006208 <SS_EC_Read>:



float SS_EC_Read( void )
{
 8006208:	b537      	push	{r0, r1, r2, r4, r5, lr}
	uint32_t EC_VOut = 0;
 800620a:	ac02      	add	r4, sp, #8
 800620c:	2300      	movs	r3, #0

	ADC_SetChannel( &ADC_EC_Handle, ADC_EC_VOUT_CHANNEL );
 800620e:	4d16      	ldr	r5, [pc, #88]	; (8006268 <SS_EC_Read+0x60>)
	uint32_t EC_VOut = 0;
 8006210:	f844 3d04 	str.w	r3, [r4, #-4]!
	ADC_SetChannel( &ADC_EC_Handle, ADC_EC_VOUT_CHANNEL );
 8006214:	4628      	mov	r0, r5
 8006216:	4915      	ldr	r1, [pc, #84]	; (800626c <SS_EC_Read+0x64>)
 8006218:	f7ff faa6 	bl	8005768 <ADC_SetChannel>
	ADC_ReadValue( &ADC_EC_Handle, &EC_VOut );
 800621c:	4621      	mov	r1, r4
 800621e:	4628      	mov	r0, r5
 8006220:	f7ff fabe 	bl	80057a0 <ADC_ReadValue>

	APP_DEBUG("--- SS_EC: EC_Vout = %ld [mV]\r\n", EC_VOut);
 8006224:	9901      	ldr	r1, [sp, #4]
 8006226:	4812      	ldr	r0, [pc, #72]	; (8006270 <SS_EC_Read+0x68>)
 8006228:	f001 fcc0 	bl	8007bac <printf>

	float EC = (float)(EC_VOut / 0.14 / (ADC_EC_REF / 2));
 800622c:	9801      	ldr	r0, [sp, #4]
 800622e:	f7fa f979 	bl	8000524 <__aeabi_ui2d>
 8006232:	a309      	add	r3, pc, #36	; (adr r3, 8006258 <SS_EC_Read+0x50>)
 8006234:	e9d3 2300 	ldrd	r2, r3, [r3]
 8006238:	f7fa fb14 	bl	8000864 <__aeabi_ddiv>
 800623c:	a308      	add	r3, pc, #32	; (adr r3, 8006260 <SS_EC_Read+0x58>)
 800623e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8006242:	f7fa fb0f 	bl	8000864 <__aeabi_ddiv>
 8006246:	f7fa fcbb 	bl	8000bc0 <__aeabi_d2f>

	return EC;
}
 800624a:	ee00 0a10 	vmov	s0, r0
 800624e:	b003      	add	sp, #12
 8006250:	bd30      	pop	{r4, r5, pc}
 8006252:	bf00      	nop
 8006254:	f3af 8000 	nop.w
 8006258:	1eb851ec 	.word	0x1eb851ec
 800625c:	3fc1eb85 	.word	0x3fc1eb85
 8006260:	00000000 	.word	0x00000000
 8006264:	4099c800 	.word	0x4099c800
 8006268:	20008ab0 	.word	0x20008ab0
 800626c:	0c900008 	.word	0x0c900008
 8006270:	0800c94b 	.word	0x0800c94b

08006274 <SS_PH_Init>:



void SS_PH_Init( void )
{
	ADC_Init( &ADC_PH_Handle );
 8006274:	4801      	ldr	r0, [pc, #4]	; (800627c <SS_PH_Init+0x8>)
 8006276:	f7ff ba45 	b.w	8005704 <ADC_Init>
 800627a:	bf00      	nop
 800627c:	20008b54 	.word	0x20008b54

08006280 <SS_PH_Read>:
}



float SS_PH_Read( void )
{
 8006280:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8006284:	ed2d 8b02 	vpush	{d8}
		ADC_ReadValue( &ADC_PH_Handle, &PH_VCom );

		APP_DEBUG("--- SS_PH: PH_Vout = %ld [mV], PH_VCom = %ld [mV]\r\n", PH_VOut, PH_VCom);

		int32_t value = PH_VOut - PH_VCom;
		pH_value = (float)(7 - ((value * 2048 / 4096) / (59.16)));
 8006288:	f20f 1914 	addw	r9, pc, #276	; 0x114
 800628c:	e9d9 8900 	ldrd	r8, r9, [r9]
{
 8006290:	b083      	sub	sp, #12
	uint32_t PH_VOut = 0, PH_VCom = 0;
 8006292:	2300      	movs	r3, #0
	float pH = 0;
 8006294:	ed9f 8a3c 	vldr	s16, [pc, #240]	; 8006388 <SS_PH_Read+0x108>
		ADC_SetChannel( &ADC_PH_Handle, ADC_PH_VOUT_CHANNEL );
 8006298:	4d3c      	ldr	r5, [pc, #240]	; (800638c <SS_PH_Read+0x10c>)
		pH_value = (float)(7 - ((value * 2048 / 4096) / (59.16)));
 800629a:	4f3d      	ldr	r7, [pc, #244]	; (8006390 <SS_PH_Read+0x110>)
	uint32_t PH_VOut = 0, PH_VCom = 0;
 800629c:	9300      	str	r3, [sp, #0]
 800629e:	9301      	str	r3, [sp, #4]
 80062a0:	2405      	movs	r4, #5
		pH_value = (float)(7 - ((value * 2048 / 4096) / (59.16)));
 80062a2:	2600      	movs	r6, #0
		ADC_SetChannel( &ADC_PH_Handle, ADC_PH_VOUT_CHANNEL );
 80062a4:	493b      	ldr	r1, [pc, #236]	; (8006394 <SS_PH_Read+0x114>)
 80062a6:	4628      	mov	r0, r5
 80062a8:	f7ff fa5e 	bl	8005768 <ADC_SetChannel>
		ADC_ReadValue( &ADC_PH_Handle, &PH_VOut );
 80062ac:	4669      	mov	r1, sp
 80062ae:	4628      	mov	r0, r5
 80062b0:	f7ff fa76 	bl	80057a0 <ADC_ReadValue>
		ADC_SetChannel( &ADC_PH_Handle, ADC_PH_VCOM_CHANNEL );
 80062b4:	4938      	ldr	r1, [pc, #224]	; (8006398 <SS_PH_Read+0x118>)
 80062b6:	4628      	mov	r0, r5
 80062b8:	f7ff fa56 	bl	8005768 <ADC_SetChannel>
		ADC_ReadValue( &ADC_PH_Handle, &PH_VCom );
 80062bc:	a901      	add	r1, sp, #4
 80062be:	4628      	mov	r0, r5
 80062c0:	f7ff fa6e 	bl	80057a0 <ADC_ReadValue>
		APP_DEBUG("--- SS_PH: PH_Vout = %ld [mV], PH_VCom = %ld [mV]\r\n", PH_VOut, PH_VCom);
 80062c4:	e89d 0006 	ldmia.w	sp, {r1, r2}
 80062c8:	4834      	ldr	r0, [pc, #208]	; (800639c <SS_PH_Read+0x11c>)
 80062ca:	f001 fc6f 	bl	8007bac <printf>
		int32_t value = PH_VOut - PH_VCom;
 80062ce:	e89d 0009 	ldmia.w	sp, {r0, r3}
 80062d2:	1ac0      	subs	r0, r0, r3
		pH_value = (float)(7 - ((value * 2048 / 4096) / (59.16)));
 80062d4:	2302      	movs	r3, #2
 80062d6:	fb90 f0f3 	sdiv	r0, r0, r3
 80062da:	f7fa f933 	bl	8000544 <__aeabi_i2d>
 80062de:	4642      	mov	r2, r8
 80062e0:	464b      	mov	r3, r9
 80062e2:	f7fa fabf 	bl	8000864 <__aeabi_ddiv>
 80062e6:	4602      	mov	r2, r0
 80062e8:	460b      	mov	r3, r1
 80062ea:	4630      	mov	r0, r6
 80062ec:	4639      	mov	r1, r7
 80062ee:	f7f9 ffdb 	bl	80002a8 <__aeabi_dsub>
 80062f2:	f7fa fc65 	bl	8000bc0 <__aeabi_d2f>
		pH += pH_value;
 80062f6:	ee07 0a90 	vmov	s15, r0
 80062fa:	3c01      	subs	r4, #1
		osDelay(100);
 80062fc:	2064      	movs	r0, #100	; 0x64
		pH += pH_value;
 80062fe:	ee38 8a27 	vadd.f32	s16, s16, s15
		osDelay(100);
 8006302:	f7fd fddf 	bl	8003ec4 <osDelay>
	for(uint8_t ui = 0; ui < 5; ui++)
 8006306:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
 800630a:	d1cb      	bne.n	80062a4 <SS_PH_Read+0x24>
	}
	pH /= 5;
	pH = (CALIB_PH_A_PARAM * pH * pH) + (CALIB_PH_B_PARAM * pH) +  CALIB_PH_C_PARAM;
 800630c:	eef1 7a04 	vmov.f32	s15, #20	; 0x40a00000  5.0
 8006310:	ee88 7a27 	vdiv.f32	s14, s16, s15
 8006314:	ee17 0a10 	vmov	r0, s14
 8006318:	f7fa f926 	bl	8000568 <__aeabi_f2d>
 800631c:	a314      	add	r3, pc, #80	; (adr r3, 8006370 <SS_PH_Read+0xf0>)
 800631e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8006322:	4604      	mov	r4, r0
 8006324:	460d      	mov	r5, r1
 8006326:	f7fa f973 	bl	8000610 <__aeabi_dmul>
 800632a:	4622      	mov	r2, r4
 800632c:	462b      	mov	r3, r5
 800632e:	f7fa f96f 	bl	8000610 <__aeabi_dmul>
 8006332:	a311      	add	r3, pc, #68	; (adr r3, 8006378 <SS_PH_Read+0xf8>)
 8006334:	e9d3 2300 	ldrd	r2, r3, [r3]
 8006338:	4606      	mov	r6, r0
 800633a:	460f      	mov	r7, r1
 800633c:	4620      	mov	r0, r4
 800633e:	4629      	mov	r1, r5
 8006340:	f7fa f966 	bl	8000610 <__aeabi_dmul>
 8006344:	4602      	mov	r2, r0
 8006346:	460b      	mov	r3, r1
 8006348:	4630      	mov	r0, r6
 800634a:	4639      	mov	r1, r7
 800634c:	f7f9 ffae 	bl	80002ac <__adddf3>
 8006350:	a30b      	add	r3, pc, #44	; (adr r3, 8006380 <SS_PH_Read+0x100>)
 8006352:	e9d3 2300 	ldrd	r2, r3, [r3]
 8006356:	f7f9 ffa7 	bl	80002a8 <__aeabi_dsub>
 800635a:	f7fa fc31 	bl	8000bc0 <__aeabi_d2f>

	return pH;
}
 800635e:	ee00 0a10 	vmov	s0, r0
 8006362:	b003      	add	sp, #12
 8006364:	ecbd 8b02 	vpop	{d8}
 8006368:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800636c:	f3af 8000 	nop.w
 8006370:	538ef34d 	.word	0x538ef34d
 8006374:	bfbf2474 	.word	0xbfbf2474
 8006378:	0b780347 	.word	0x0b780347
 800637c:	400ca824 	.word	0x400ca824
 8006380:	85d31338 	.word	0x85d31338
 8006384:	40287d58 	.word	0x40287d58
 8006388:	00000000 	.word	0x00000000
 800638c:	20008b54 	.word	0x20008b54
 8006390:	401c0000 	.word	0x401c0000
 8006394:	04300002 	.word	0x04300002
 8006398:	08600004 	.word	0x08600004
 800639c:	0800c96b 	.word	0x0800c96b
 80063a0:	e147ae14 	.word	0xe147ae14
 80063a4:	404d947a 	.word	0x404d947a

080063a8 <SS_THSoil_Read>:
 * 				+ Temp: temperature
 * 				+ Humi: humidity
 * Return		: None
 *****************************************************************************/
void SS_THSoil_Read( float *Temp, float *Humi )
{
 80063a8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80063ac:	b08a      	sub	sp, #40	; 0x28
 80063ae:	4606      	mov	r6, r0
 80063b0:	460f      	mov	r7, r1
	#define RX_BUFF_LENGHT			32
	uint8_t rxBuff[RX_BUFF_LENGHT + 1] = {0};
 80063b2:	2221      	movs	r2, #33	; 0x21
 80063b4:	2100      	movs	r1, #0
 80063b6:	a801      	add	r0, sp, #4
 80063b8:	f001 fbe3 	bl	8007b82 <memset>

	do
	{
		HAL_Delay(10);
		memset(rxBuff, 0, RX_BUFF_LENGHT);
		_Uart3_SOIL.Uart_Transmit( &_Uart3_SOIL._UartHandle, Cmd_Read_TH, CMD_READ_TH_LENGHT );
 80063bc:	4d2a      	ldr	r5, [pc, #168]	; (8006468 <SS_THSoil_Read+0xc0>)
 80063be:	f8df 80ac 	ldr.w	r8, [pc, #172]	; 800646c <SS_THSoil_Read+0xc4>
	uint8_t rxBuff[RX_BUFF_LENGHT + 1] = {0};
 80063c2:	2415      	movs	r4, #21
		HAL_Delay(10);
 80063c4:	200a      	movs	r0, #10
 80063c6:	f7fa fe09 	bl	8000fdc <HAL_Delay>
		memset(rxBuff, 0, RX_BUFF_LENGHT);
 80063ca:	2220      	movs	r2, #32
 80063cc:	2100      	movs	r1, #0
 80063ce:	a801      	add	r0, sp, #4
 80063d0:	f001 fbd7 	bl	8007b82 <memset>
		_Uart3_SOIL.Uart_Transmit( &_Uart3_SOIL._UartHandle, Cmd_Read_TH, CMD_READ_TH_LENGHT );
 80063d4:	f8d5 3080 	ldr.w	r3, [r5, #128]	; 0x80
 80063d8:	4823      	ldr	r0, [pc, #140]	; (8006468 <SS_THSoil_Read+0xc0>)
 80063da:	2208      	movs	r2, #8
 80063dc:	4641      	mov	r1, r8
 80063de:	4798      	blx	r3
		_Uart3_SOIL.Uart_Receive( &_Uart3_SOIL._UartHandle, rxBuff, RX_BUFF_LENGHT);
 80063e0:	f8d5 3084 	ldr.w	r3, [r5, #132]	; 0x84
 80063e4:	4820      	ldr	r0, [pc, #128]	; (8006468 <SS_THSoil_Read+0xc0>)
 80063e6:	2220      	movs	r2, #32
 80063e8:	a901      	add	r1, sp, #4
 80063ea:	4798      	blx	r3

		if( (rxBuff[0] == 0xFE) && (rxBuff[1] == 0x03) && (rxBuff[2] == 0x04) )
 80063ec:	f89d 3004 	ldrb.w	r3, [sp, #4]
 80063f0:	2bfe      	cmp	r3, #254	; 0xfe
 80063f2:	d113      	bne.n	800641c <SS_THSoil_Read+0x74>
 80063f4:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80063f8:	2b03      	cmp	r3, #3
 80063fa:	d10f      	bne.n	800641c <SS_THSoil_Read+0x74>
 80063fc:	f89d 3006 	ldrb.w	r3, [sp, #6]
 8006400:	2b04      	cmp	r3, #4
 8006402:	d10b      	bne.n	800641c <SS_THSoil_Read+0x74>
		{
			if( ((rxBuff[3] | rxBuff[4]) > 0) && ((rxBuff[5] | rxBuff[6]) > 0) )
 8006404:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8006408:	f89d 3008 	ldrb.w	r3, [sp, #8]
 800640c:	4313      	orrs	r3, r2
 800640e:	d005      	beq.n	800641c <SS_THSoil_Read+0x74>
 8006410:	f89d 2009 	ldrb.w	r2, [sp, #9]
 8006414:	f89d 300a 	ldrb.w	r3, [sp, #10]
 8006418:	4313      	orrs	r3, r2
 800641a:	d103      	bne.n	8006424 <SS_THSoil_Read+0x7c>
 800641c:	3c01      	subs	r4, #1
				break;
		}

		Count++;
		if(Count > 20)
 800641e:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
 8006422:	d1cf      	bne.n	80063c4 <SS_THSoil_Read+0x1c>

//	APP_DEBUG("rxBuff = ");
//	for(uint8_t ui = 0; ui <= 8; ui++)
//		APP_DEBUG("%.2x-", rxBuff[ui]);
//	APP_DEBUG("\r\n");
	*Humi = (float)((rxBuff[3] << 8) | rxBuff[4]) / 10;
 8006424:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8006428:	f89d 3008 	ldrb.w	r3, [sp, #8]
 800642c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8006430:	ee07 3a90 	vmov	s15, r3
 8006434:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8006438:	eeb2 7a04 	vmov.f32	s14, #36	; 0x41200000  10.0
 800643c:	eec7 6a87 	vdiv.f32	s13, s15, s14
	*Temp = (float)((rxBuff[5] << 8) | rxBuff[6]) / 10;
 8006440:	f89d 2009 	ldrb.w	r2, [sp, #9]
 8006444:	f89d 300a 	ldrb.w	r3, [sp, #10]
 8006448:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800644c:	ee07 3a90 	vmov	s15, r3
 8006450:	eef8 7ae7 	vcvt.f32.s32	s15, s15
	*Humi = (float)((rxBuff[3] << 8) | rxBuff[4]) / 10;
 8006454:	edc7 6a00 	vstr	s13, [r7]
	*Temp = (float)((rxBuff[5] << 8) | rxBuff[6]) / 10;
 8006458:	eec7 6a87 	vdiv.f32	s13, s15, s14
 800645c:	edc6 6a00 	vstr	s13, [r6]

//	APP_DEBUG("temp = %f, humi = %f\r\n", *Temp, *Humi);
}
 8006460:	b00a      	add	sp, #40	; 0x28
 8006462:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8006466:	bf00      	nop
 8006468:	20008ce4 	.word	0x20008ce4
 800646c:	20000004 	.word	0x20000004

08006470 <LoraTask>:
 * Description	: lora task
 * Param		: None
 * Return		: None
 * ***************************************************************************/
void LoraTask( void const *agr )
{
 8006470:	b508      	push	{r3, lr}
	APP_DEBUG("--- LoraTask: running...\r\n");
 8006472:	4811      	ldr	r0, [pc, #68]	; (80064b8 <LoraTask+0x48>)
	Message_set_Lora_Transmit_Callback( Lora_Transmit );

	for(;;)
	{
		osDelay(50);
		_TaskHandle.LoraTask_Finish = 1;
 8006474:	4c11      	ldr	r4, [pc, #68]	; (80064bc <LoraTask+0x4c>)
		if( (Lora_RX_Lenght = Lora_Receive( Lora_RX_Buffer )) > 0 )
 8006476:	4d12      	ldr	r5, [pc, #72]	; (80064c0 <LoraTask+0x50>)
	APP_DEBUG("--- LoraTask: running...\r\n");
 8006478:	f001 fc10 	bl	8007c9c <puts>
	osDelay(1000);
 800647c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8006480:	f7fd fd20 	bl	8003ec4 <osDelay>
	Lora_Init( LORA_MAX_LENGHT );
 8006484:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8006488:	f7fe fd84 	bl	8004f94 <Lora_Init>
	Message_set_Lora_Transmit_Callback( Lora_Transmit );
 800648c:	480d      	ldr	r0, [pc, #52]	; (80064c4 <LoraTask+0x54>)
 800648e:	f7ff fd7b 	bl	8005f88 <Message_set_Lora_Transmit_Callback>
 8006492:	4626      	mov	r6, r4
		osDelay(50);
 8006494:	2032      	movs	r0, #50	; 0x32
 8006496:	f7fd fd15 	bl	8003ec4 <osDelay>
		_TaskHandle.LoraTask_Finish = 1;
 800649a:	2301      	movs	r3, #1
		if( (Lora_RX_Lenght = Lora_Receive( Lora_RX_Buffer )) > 0 )
 800649c:	4628      	mov	r0, r5
		_TaskHandle.LoraTask_Finish = 1;
 800649e:	6123      	str	r3, [r4, #16]
		if( (Lora_RX_Lenght = Lora_Receive( Lora_RX_Buffer )) > 0 )
 80064a0:	f7fe fe04 	bl	80050ac <Lora_Receive>
 80064a4:	4b08      	ldr	r3, [pc, #32]	; (80064c8 <LoraTask+0x58>)
 80064a6:	4601      	mov	r1, r0
 80064a8:	8018      	strh	r0, [r3, #0]
 80064aa:	b110      	cbz	r0, 80064b2 <LoraTask+0x42>
			Message_Process( Lora_RX_Buffer, Lora_RX_Lenght );
 80064ac:	4628      	mov	r0, r5
 80064ae:	f7ff fc2f 	bl	8005d10 <Message_Process>
		_TaskHandle.LoraTask_Finish = 0;
 80064b2:	2300      	movs	r3, #0
 80064b4:	6133      	str	r3, [r6, #16]
		osDelay(50);
 80064b6:	e7ed      	b.n	8006494 <LoraTask+0x24>
 80064b8:	0800c99f 	.word	0x0800c99f
 80064bc:	20008cc8 	.word	0x20008cc8
 80064c0:	2000803c 	.word	0x2000803c
 80064c4:	0800505d 	.word	0x0800505d
 80064c8:	2000843e 	.word	0x2000843e

080064cc <OTATask_Start_Callback>:


//OTA start call back
static void OTATask_Start_Callback( void )
{
	OTA_State = OTA_START;
 80064cc:	4b01      	ldr	r3, [pc, #4]	; (80064d4 <OTATask_Start_Callback+0x8>)
 80064ce:	2201      	movs	r2, #1
 80064d0:	701a      	strb	r2, [r3, #0]
 80064d2:	4770      	bx	lr
 80064d4:	20008440 	.word	0x20008440

080064d8 <OTATask_Data_Callback>:



//OTA data call back
static void OTATask_Data_Callback( uint8_t *RXBuffer, uint16_t RXLenght )
{
 80064d8:	4770      	bx	lr
	...

080064dc <OTATask_data_done_Callback>:


//OTA data done call back
static void OTATask_data_done_Callback( void )
{
	OTA_State = OTA_REV_DONE;
 80064dc:	4b01      	ldr	r3, [pc, #4]	; (80064e4 <OTATask_data_done_Callback+0x8>)
 80064de:	2203      	movs	r2, #3
 80064e0:	701a      	strb	r2, [r3, #0]
 80064e2:	4770      	bx	lr
 80064e4:	20008440 	.word	0x20008440

080064e8 <OTATask>:
{
 80064e8:	b580      	push	{r7, lr}
	APP_DEBUG("--- OTATask: running...\r\n");
 80064ea:	4822      	ldr	r0, [pc, #136]	; (8006574 <OTATask+0x8c>)
		_TaskHandle.OTATask_Finish = 1;
 80064ec:	f8df 80b8 	ldr.w	r8, [pc, #184]	; 80065a8 <OTATask+0xc0>
	APP_DEBUG("--- OTATask: running...\r\n");
 80064f0:	f001 fbd4 	bl	8007c9c <puts>
	osDelay(1000);
 80064f4:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80064f8:	f7fd fce4 	bl	8003ec4 <osDelay>
	Message_set_OTA_Callback( OTATask_Start_Callback, OTATask_Data_Callback, OTATask_data_done_Callback );
 80064fc:	4a1e      	ldr	r2, [pc, #120]	; (8006578 <OTATask+0x90>)
 80064fe:	491f      	ldr	r1, [pc, #124]	; (800657c <OTATask+0x94>)
 8006500:	481f      	ldr	r0, [pc, #124]	; (8006580 <OTATask+0x98>)
 8006502:	f7ff fd2d 	bl	8005f60 <Message_set_OTA_Callback>
 8006506:	4647      	mov	r7, r8
			OTA_Timeout_Count = 0;
 8006508:	2400      	movs	r4, #0
		OTA_Timeout_Count++;
 800650a:	4d1e      	ldr	r5, [pc, #120]	; (8006584 <OTATask+0x9c>)
 800650c:	4e1e      	ldr	r6, [pc, #120]	; (8006588 <OTATask+0xa0>)
		osDelay(OTA_LOOP_TIME);
 800650e:	2002      	movs	r0, #2
 8006510:	f7fd fcd8 	bl	8003ec4 <osDelay>
		_TaskHandle.OTATask_Finish = 1;
 8006514:	2301      	movs	r3, #1
 8006516:	f8c8 3018 	str.w	r3, [r8, #24]
		OTA_Timeout_Count++;
 800651a:	682b      	ldr	r3, [r5, #0]
		if(OTA_Timeout_Count >= (OTA_TIMEOUT * 1000 / OTA_LOOP_TIME))
 800651c:	4a1b      	ldr	r2, [pc, #108]	; (800658c <OTATask+0xa4>)
		OTA_Timeout_Count++;
 800651e:	3301      	adds	r3, #1
		if(OTA_Timeout_Count >= (OTA_TIMEOUT * 1000 / OTA_LOOP_TIME))
 8006520:	4293      	cmp	r3, r2
		OTA_Timeout_Count++;
 8006522:	602b      	str	r3, [r5, #0]
		if(OTA_Timeout_Count >= (OTA_TIMEOUT * 1000 / OTA_LOOP_TIME))
 8006524:	d904      	bls.n	8006530 <OTATask+0x48>
			APP_DEBUG("\r\n--- OTATask: OTA time out --> stop\r\n");
 8006526:	481a      	ldr	r0, [pc, #104]	; (8006590 <OTATask+0xa8>)
 8006528:	f001 fbb8 	bl	8007c9c <puts>
			OTA_Timeout_Count = 0;
 800652c:	602c      	str	r4, [r5, #0]
			OTA_State = OTA_STOP;
 800652e:	7034      	strb	r4, [r6, #0]
		switch(OTA_State)
 8006530:	7833      	ldrb	r3, [r6, #0]
 8006532:	2b04      	cmp	r3, #4
 8006534:	d80a      	bhi.n	800654c <OTATask+0x64>
 8006536:	e8df f003 	tbb	[pc, r3]
 800653a:	0313      	.short	0x0313
 800653c:	0f0b      	.short	0x0f0b
 800653e:	11          	.byte	0x11
 800653f:	00          	.byte	0x00
				APP_DEBUG("\r\n--- OTATask: OTA started\r\n");
 8006540:	4814      	ldr	r0, [pc, #80]	; (8006594 <OTATask+0xac>)
 8006542:	f001 fbab 	bl	8007c9c <puts>
				OTA_State = OTA_RECV_FW;
 8006546:	2302      	movs	r3, #2
				OTA_Timeout_Count = 0;
 8006548:	602c      	str	r4, [r5, #0]
				OTA_State = OTA_RECV_FW;
 800654a:	7033      	strb	r3, [r6, #0]
		_TaskHandle.OTATask_Finish = 0;
 800654c:	61bc      	str	r4, [r7, #24]
		osDelay(OTA_LOOP_TIME);
 800654e:	e7dc      	b.n	800650a <OTATask+0x22>
				APP_DEBUG("\r\n--- OTATask: OTA receiving data\r\n");
 8006550:	4811      	ldr	r0, [pc, #68]	; (8006598 <OTATask+0xb0>)
				APP_DEBUG("\r\n--- OTATask: OTA receive done\r\n");
 8006552:	f001 fba3 	bl	8007c9c <puts>
				break;
 8006556:	e7f9      	b.n	800654c <OTATask+0x64>
				APP_DEBUG("\r\n--- OTATask: OTA receive done\r\n");
 8006558:	4810      	ldr	r0, [pc, #64]	; (800659c <OTATask+0xb4>)
 800655a:	e7fa      	b.n	8006552 <OTATask+0x6a>
				APP_DEBUG("\r\n--- OTATask: OTA upgrade\r\n");
 800655c:	4810      	ldr	r0, [pc, #64]	; (80065a0 <OTATask+0xb8>)
 800655e:	e7f8      	b.n	8006552 <OTATask+0x6a>
				APP_DEBUG("\r\n--- OTATask: OTA stopped\r\n");
 8006560:	4810      	ldr	r0, [pc, #64]	; (80065a4 <OTATask+0xbc>)
 8006562:	f001 fb9b 	bl	8007c9c <puts>
				vTaskSuspend(NULL);
 8006566:	2000      	movs	r0, #0
				OTA_Timeout_Count = 0;
 8006568:	602c      	str	r4, [r5, #0]
				_TaskHandle.OTATask_Finish = 0;
 800656a:	61bc      	str	r4, [r7, #24]
				vTaskSuspend(NULL);
 800656c:	f7fe fada 	bl	8004b24 <vTaskSuspend>
				break;
 8006570:	e7ec      	b.n	800654c <OTATask+0x64>
 8006572:	bf00      	nop
 8006574:	0800c9b9 	.word	0x0800c9b9
 8006578:	080064dd 	.word	0x080064dd
 800657c:	080064d9 	.word	0x080064d9
 8006580:	080064cd 	.word	0x080064cd
 8006584:	20008444 	.word	0x20008444
 8006588:	20008440 	.word	0x20008440
 800658c:	000249ef 	.word	0x000249ef
 8006590:	0800c9d2 	.word	0x0800c9d2
 8006594:	0800c9f8 	.word	0x0800c9f8
 8006598:	0800ca14 	.word	0x0800ca14
 800659c:	0800ca37 	.word	0x0800ca37
 80065a0:	0800ca58 	.word	0x0800ca58
 80065a4:	0800ca74 	.word	0x0800ca74
 80065a8:	20008cc8 	.word	0x20008cc8

080065ac <ProcessTask_sendData_Callback>:



static void ProcessTask_sendData_Callback( void )
{
	SendData_Counter = 0;
 80065ac:	4b02      	ldr	r3, [pc, #8]	; (80065b8 <ProcessTask_sendData_Callback+0xc>)
	APP_DEBUG("--- ProcessTask: send data to gw successfully\r\n\r\n");
 80065ae:	4803      	ldr	r0, [pc, #12]	; (80065bc <ProcessTask_sendData_Callback+0x10>)
	SendData_Counter = 0;
 80065b0:	2200      	movs	r2, #0
 80065b2:	601a      	str	r2, [r3, #0]
	APP_DEBUG("--- ProcessTask: send data to gw successfully\r\n\r\n");
 80065b4:	f001 bb72 	b.w	8007c9c <puts>
 80065b8:	2000844c 	.word	0x2000844c
 80065bc:	0800cb09 	.word	0x0800cb09

080065c0 <ProcessTask>:
{
 80065c0:	b580      	push	{r7, lr}
	APP_DEBUG( "--- ProcessTask: running...\r\n" );
 80065c2:	4841      	ldr	r0, [pc, #260]	; (80066c8 <ProcessTask+0x108>)
		Led_Counter++;
 80065c4:	4e41      	ldr	r6, [pc, #260]	; (80066cc <ProcessTask+0x10c>)
			LED_STATUS_LOW();
 80065c6:	4f42      	ldr	r7, [pc, #264]	; (80066d0 <ProcessTask+0x110>)
		if(OTA_State == OTA_STOP)
 80065c8:	f8df 8120 	ldr.w	r8, [pc, #288]	; 80066ec <ProcessTask+0x12c>
	APP_DEBUG( "--- ProcessTask: running...\r\n" );
 80065cc:	f001 fb66 	bl	8007c9c <puts>
	GPIO_setOutput_Pullup( LED_STATUS_PORT, LED_STATUS_PIN );		//led status
 80065d0:	f44f 6100 	mov.w	r1, #2048	; 0x800
 80065d4:	483e      	ldr	r0, [pc, #248]	; (80066d0 <ProcessTask+0x110>)
 80065d6:	f7ff f931 	bl	800583c <GPIO_setOutput_Pullup>
	Message_set_sendData_Callback( ProcessTask_sendData_Callback );
 80065da:	483e      	ldr	r0, [pc, #248]	; (80066d4 <ProcessTask+0x114>)
 80065dc:	f7ff fcce 	bl	8005f7c <Message_set_sendData_Callback>
		osDelay(PROCESS_TASK_DELAY);
 80065e0:	200a      	movs	r0, #10
 80065e2:	f7fd fc6f 	bl	8003ec4 <osDelay>
		Led_Counter++;
 80065e6:	8833      	ldrh	r3, [r6, #0]
 80065e8:	3301      	adds	r3, #1
 80065ea:	b29b      	uxth	r3, r3
		if( Led_Counter <= (LED_STATUS_TIME_OFF / PROCESS_TASK_DELAY) )
 80065ec:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
		Led_Counter++;
 80065f0:	8033      	strh	r3, [r6, #0]
		if( Led_Counter <= (LED_STATUS_TIME_OFF / PROCESS_TASK_DELAY) )
 80065f2:	d847      	bhi.n	8006684 <ProcessTask+0xc4>
			LED_STATUS_HIGH();
 80065f4:	f44f 6100 	mov.w	r1, #2048	; 0x800
 80065f8:	4638      	mov	r0, r7
 80065fa:	f7ff f968 	bl	80058ce <GPIO_setHighlevel>
		if(OTA_State == OTA_STOP)
 80065fe:	f898 3000 	ldrb.w	r3, [r8]
 8006602:	4c35      	ldr	r4, [pc, #212]	; (80066d8 <ProcessTask+0x118>)
 8006604:	2b00      	cmp	r3, #0
 8006606:	d159      	bne.n	80066bc <ProcessTask+0xfc>
			SendData_Counter++;
 8006608:	f8df 90e4 	ldr.w	r9, [pc, #228]	; 80066f0 <ProcessTask+0x130>
			if( SendData_Counter == (__fileData.DataUT * 1000 / PROCESS_TASK_DELAY) )
 800660c:	f8df a0e4 	ldr.w	sl, [pc, #228]	; 80066f4 <ProcessTask+0x134>
			SendData_Counter++;
 8006610:	f8d9 2000 	ldr.w	r2, [r9]
			if( SendData_Counter == (__fileData.DataUT * 1000 / PROCESS_TASK_DELAY) )
 8006614:	f8ba 3004 	ldrh.w	r3, [sl, #4]
 8006618:	2564      	movs	r5, #100	; 0x64
			SendData_Counter++;
 800661a:	3201      	adds	r2, #1
			if( SendData_Counter == (__fileData.DataUT * 1000 / PROCESS_TASK_DELAY) )
 800661c:	436b      	muls	r3, r5
 800661e:	429a      	cmp	r2, r3
			SendData_Counter++;
 8006620:	f8c9 2000 	str.w	r2, [r9]
			if( SendData_Counter == (__fileData.DataUT * 1000 / PROCESS_TASK_DELAY) )
 8006624:	d13c      	bne.n	80066a0 <ProcessTask+0xe0>
				Message_SendData_Sensor();
 8006626:	f7ff fa59 	bl	8005adc <Message_SendData_Sensor>
		if( _TaskHandle.LoraTask_Finish >= 1 )
 800662a:	6923      	ldr	r3, [r4, #16]
 800662c:	b10b      	cbz	r3, 8006632 <ProcessTask+0x72>
			_TaskHandle.LoraTask_Finish++;
 800662e:	3301      	adds	r3, #1
 8006630:	6123      	str	r3, [r4, #16]
		if( _TaskHandle.SensorTask_Finish >= 1 )
 8006632:	6963      	ldr	r3, [r4, #20]
 8006634:	b10b      	cbz	r3, 800663a <ProcessTask+0x7a>
			_TaskHandle.SensorTask_Finish++;
 8006636:	3301      	adds	r3, #1
 8006638:	6163      	str	r3, [r4, #20]
		if( _TaskHandle.OTATask_Finish >= 1 )
 800663a:	69a3      	ldr	r3, [r4, #24]
 800663c:	b10b      	cbz	r3, 8006642 <ProcessTask+0x82>
			_TaskHandle.OTATask_Finish++;
 800663e:	3301      	adds	r3, #1
 8006640:	61a3      	str	r3, [r4, #24]
		if( ( _TaskHandle.LoraTask_Finish >= (90 * 1000 / PROCESS_TASK_DELAY) ) || \
 8006642:	6922      	ldr	r2, [r4, #16]
 8006644:	f242 3327 	movw	r3, #8999	; 0x2327
 8006648:	429a      	cmp	r2, r3
 800664a:	d807      	bhi.n	800665c <ProcessTask+0x9c>
 800664c:	6962      	ldr	r2, [r4, #20]
 800664e:	429a      	cmp	r2, r3
 8006650:	d804      	bhi.n	800665c <ProcessTask+0x9c>
			( _TaskHandle.SensorTask_Finish >= (90 * 1000 / PROCESS_TASK_DELAY) ) || \
 8006652:	69a2      	ldr	r2, [r4, #24]
 8006654:	f247 532f 	movw	r3, #29999	; 0x752f
 8006658:	429a      	cmp	r2, r3
 800665a:	d9c1      	bls.n	80065e0 <ProcessTask+0x20>
			APP_DEBUG("--- ProcessTask: task is died. reseting...\r\n");
 800665c:	481f      	ldr	r0, [pc, #124]	; (80066dc <ProcessTask+0x11c>)
 800665e:	f001 fb1d 	bl	8007c9c <puts>
			osDelay(1000);
 8006662:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8006666:	f7fd fc2d 	bl	8003ec4 <osDelay>
  __ASM volatile ("dsb 0xF":::"memory");
 800666a:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 800666e:	491c      	ldr	r1, [pc, #112]	; (80066e0 <ProcessTask+0x120>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8006670:	4b1c      	ldr	r3, [pc, #112]	; (80066e4 <ProcessTask+0x124>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8006672:	68ca      	ldr	r2, [r1, #12]
 8006674:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8006678:	4313      	orrs	r3, r2
 800667a:	60cb      	str	r3, [r1, #12]
 800667c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("nop");
 8006680:	bf00      	nop
 8006682:	e7fd      	b.n	8006680 <ProcessTask+0xc0>
		else if( Led_Counter <= ((LED_STATUS_TIME_OFF + LED_STATUS_TIME_ON) / PROCESS_TASK_DELAY) )
 8006684:	f5b3 7f98 	cmp.w	r3, #304	; 0x130
 8006688:	d205      	bcs.n	8006696 <ProcessTask+0xd6>
			LED_STATUS_LOW();
 800668a:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800668e:	4638      	mov	r0, r7
 8006690:	f7ff f920 	bl	80058d4 <GPIO_setLowlevel>
 8006694:	e7b3      	b.n	80065fe <ProcessTask+0x3e>
			Led_Counter = 0;
 8006696:	2300      	movs	r3, #0
 8006698:	8033      	strh	r3, [r6, #0]
			IOControl_WDT_Done();	//WDT refresh
 800669a:	f7fe ff98 	bl	80055ce <IOControl_WDT_Done>
 800669e:	e7ae      	b.n	80065fe <ProcessTask+0x3e>
			else if(SendData_Counter >= ((__fileData.DataUT + SEND_DATA_TIMEOUT) * 1000 / PROCESS_TASK_DELAY)) //send timeout
 80066a0:	f503 737a 	add.w	r3, r3, #1000	; 0x3e8
 80066a4:	429a      	cmp	r2, r3
 80066a6:	d3c0      	bcc.n	800662a <ProcessTask+0x6a>
				APP_DEBUG("--- ProcessTask: gw not feedback. resending...\r\n");
 80066a8:	480f      	ldr	r0, [pc, #60]	; (80066e8 <ProcessTask+0x128>)
 80066aa:	f001 faf7 	bl	8007c9c <puts>
				SendData_Counter = __fileData.DataUT * 1000 / PROCESS_TASK_DELAY - 1;
 80066ae:	f8ba 3004 	ldrh.w	r3, [sl, #4]
 80066b2:	435d      	muls	r5, r3
 80066b4:	3d01      	subs	r5, #1
 80066b6:	f8c9 5000 	str.w	r5, [r9]
 80066ba:	e7b6      	b.n	800662a <ProcessTask+0x6a>
		else if(OTA_State == OTA_START)
 80066bc:	2b01      	cmp	r3, #1
 80066be:	d1b4      	bne.n	800662a <ProcessTask+0x6a>
			vTaskResume( _TaskHandle.OTATask_Handle );
 80066c0:	68e0      	ldr	r0, [r4, #12]
 80066c2:	f7fe f841 	bl	8004748 <vTaskResume>
 80066c6:	e7b0      	b.n	800662a <ProcessTask+0x6a>
 80066c8:	0800ca90 	.word	0x0800ca90
 80066cc:	20008448 	.word	0x20008448
 80066d0:	48000400 	.word	0x48000400
 80066d4:	080065ad 	.word	0x080065ad
 80066d8:	20008cc8 	.word	0x20008cc8
 80066dc:	0800cadd 	.word	0x0800cadd
 80066e0:	e000ed00 	.word	0xe000ed00
 80066e4:	05fa0004 	.word	0x05fa0004
 80066e8:	0800caad 	.word	0x0800caad
 80066ec:	20008440 	.word	0x20008440
 80066f0:	2000844c 	.word	0x2000844c
 80066f4:	20000010 	.word	0x20000010

080066f8 <SensorTask_SS_Power_Control>:
 * Description	: sensor read control
 * Param		: None
 * Return		: None
 * ***************************************************************************/
static void SensorTask_SS_Power_Control( void )
{
 80066f8:	b510      	push	{r4, lr}
	//read temp and humi air
	if( (((__fileData.SensorCfg & SS_TempA) == SS_TempA) && ((__fileData.SensorCfg & SS_HumiA) == SS_HumiA )) || \
 80066fa:	4c1c      	ldr	r4, [pc, #112]	; (800676c <SensorTask_SS_Power_Control+0x74>)
 80066fc:	8863      	ldrh	r3, [r4, #2]
 80066fe:	f003 0203 	and.w	r2, r3, #3
 8006702:	2a03      	cmp	r2, #3
 8006704:	d001      	beq.n	800670a <SensorTask_SS_Power_Control+0x12>
 8006706:	0658      	lsls	r0, r3, #25
 8006708:	d520      	bpl.n	800674c <SensorTask_SS_Power_Control+0x54>
		((__fileData.SensorCfg & SS_Light) == SS_Light) )
	{
		IOControl_SS_THL_ON();
 800670a:	f7fe ffad 	bl	8005668 <IOControl_SS_THL_ON>
	{
		IOControl_SS_THL_OFF();
	}

	//read temp and humi soil
	if( ((__fileData.SensorCfg & SS_TempS) == SS_TempS) && ((__fileData.SensorCfg & SS_HumiS) == SS_HumiS) )
 800670e:	8863      	ldrh	r3, [r4, #2]
 8006710:	f003 030c 	and.w	r3, r3, #12
 8006714:	2b0c      	cmp	r3, #12
 8006716:	d11c      	bne.n	8006752 <SensorTask_SS_Power_Control+0x5a>
	{
		IOControl_SS_TH_Soil_ON();
 8006718:	f7fe ff6e 	bl	80055f8 <IOControl_SS_TH_Soil_ON>
	{
		IOControl_SS_TH_Soil_OFF();
	}

	//read pH
	if( (__fileData.SensorCfg & SS_pH) == SS_pH )
 800671c:	8863      	ldrh	r3, [r4, #2]
 800671e:	06d9      	lsls	r1, r3, #27
 8006720:	d51a      	bpl.n	8006758 <SensorTask_SS_Power_Control+0x60>
	{
		IOControl_SS_PH_ON();
 8006722:	f7fe ff85 	bl	8005630 <IOControl_SS_PH_ON>
		SS_PH_Init();
 8006726:	f7ff fda5 	bl	8006274 <SS_PH_Init>
	{
		IOControl_SS_PH_OFF();
	}

	//read EC
	if( (__fileData.SensorCfg & SS_EC) == SS_EC )
 800672a:	8863      	ldrh	r3, [r4, #2]
 800672c:	069a      	lsls	r2, r3, #26
 800672e:	d516      	bpl.n	800675e <SensorTask_SS_Power_Control+0x66>
	{
		IOControl_SS_EC_ON();
 8006730:	f7fe ff6e 	bl	8005610 <IOControl_SS_EC_ON>
		SS_EC_Init();
 8006734:	f7ff fd0c 	bl	8006150 <SS_EC_Init>
		APP_DEBUG("here\r\n");
 8006738:	480d      	ldr	r0, [pc, #52]	; (8006770 <SensorTask_SS_Power_Control+0x78>)
 800673a:	f001 faaf 	bl	8007c9c <puts>
	{
		IOControl_SS_EC_OFF();
	}

	//read CO2
	if( (__fileData.SensorCfg & SS_CO2) == SS_CO2 )
 800673e:	8863      	ldrh	r3, [r4, #2]
 8006740:	061b      	lsls	r3, r3, #24
 8006742:	d50f      	bpl.n	8006764 <SensorTask_SS_Power_Control+0x6c>
	}
	else
	{
		IOControl_SS_CO2_OFF();
	}
}
 8006744:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		IOControl_SS_CO2_ON();
 8006748:	f7fe bf82 	b.w	8005650 <IOControl_SS_CO2_ON>
		IOControl_SS_THL_OFF();
 800674c:	f7fe ff92 	bl	8005674 <IOControl_SS_THL_OFF>
 8006750:	e7dd      	b.n	800670e <SensorTask_SS_Power_Control+0x16>
		IOControl_SS_TH_Soil_OFF();
 8006752:	f7fe ff57 	bl	8005604 <IOControl_SS_TH_Soil_OFF>
 8006756:	e7e1      	b.n	800671c <SensorTask_SS_Power_Control+0x24>
		IOControl_SS_PH_OFF();
 8006758:	f7fe ff72 	bl	8005640 <IOControl_SS_PH_OFF>
 800675c:	e7e5      	b.n	800672a <SensorTask_SS_Power_Control+0x32>
		IOControl_SS_EC_OFF();
 800675e:	f7fe ff5f 	bl	8005620 <IOControl_SS_EC_OFF>
 8006762:	e7ec      	b.n	800673e <SensorTask_SS_Power_Control+0x46>
}
 8006764:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		IOControl_SS_CO2_OFF();
 8006768:	f7fe bf78 	b.w	800565c <IOControl_SS_CO2_OFF>
 800676c:	20000010 	.word	0x20000010
 8006770:	0800ce1c 	.word	0x0800ce1c

08006774 <SensorTask>:
{
 8006774:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006778:	ed2d 8b02 	vpush	{d8}
	APP_DEBUG("--- SensorTask: running...\r\n");
 800677c:	48bc      	ldr	r0, [pc, #752]	; (8006a70 <SensorTask+0x2fc>)
		_TaskHandle.SensorTask_Finish = 1;
 800677e:	4fbd      	ldr	r7, [pc, #756]	; (8006a74 <SensorTask+0x300>)
		APP_DEBUG("--- SensorTask: reading...\r\n");
 8006780:	f8df a334 	ldr.w	sl, [pc, #820]	; 8006ab8 <SensorTask+0x344>
{
 8006784:	b085      	sub	sp, #20
	APP_DEBUG("--- SensorTask: running...\r\n");
 8006786:	f001 fa89 	bl	8007c9c <puts>
	osDelay(1000);
 800678a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800678e:	f7fd fb99 	bl	8003ec4 <osDelay>
	Message_set_Typesensor_Callback( SensorTask_SS_Power_Control );
 8006792:	48b9      	ldr	r0, [pc, #740]	; (8006a78 <SensorTask+0x304>)
 8006794:	f7ff fbfe 	bl	8005f94 <Message_set_Typesensor_Callback>
	SensorTask_SS_Power_Control();
 8006798:	f7ff ffae 	bl	80066f8 <SensorTask_SS_Power_Control>
 800679c:	46bb      	mov	fp, r7
		osDelay(TIME_READ_SENSOR * 1000);
 800679e:	f247 5030 	movw	r0, #30000	; 0x7530
		if( (__fileData.SensorCfg & SS_TempA) == SS_TempA )
 80067a2:	4db6      	ldr	r5, [pc, #728]	; (8006a7c <SensorTask+0x308>)
 80067a4:	4cb6      	ldr	r4, [pc, #728]	; (8006a80 <SensorTask+0x30c>)
		osDelay(TIME_READ_SENSOR * 1000);
 80067a6:	f7fd fb8d 	bl	8003ec4 <osDelay>
		_TaskHandle.SensorTask_Finish = 1;
 80067aa:	2301      	movs	r3, #1
		APP_DEBUG("--- SensorTask: reading...\r\n");
 80067ac:	4650      	mov	r0, sl
		_TaskHandle.SensorTask_Finish = 1;
 80067ae:	617b      	str	r3, [r7, #20]
		APP_DEBUG("--- SensorTask: reading...\r\n");
 80067b0:	f001 fa74 	bl	8007c9c <puts>
		if( (__fileData.SensorCfg & SS_TempS) == SS_TempS )
 80067b4:	886b      	ldrh	r3, [r5, #2]
 80067b6:	f013 0f04 	tst.w	r3, #4
 80067ba:	d05b      	beq.n	8006874 <SensorTask+0x100>
			float Humi = 0;
 80067bc:	a904      	add	r1, sp, #16
			float Temp = 0;
 80067be:	2300      	movs	r3, #0
			float Humi = 0;
 80067c0:	f841 3d04 	str.w	r3, [r1, #-4]!
			SS_THSoil_Read( &Temp, &Humi );
 80067c4:	a802      	add	r0, sp, #8
			float Temp = 0;
 80067c6:	9302      	str	r3, [sp, #8]
			SS_THSoil_Read( &Temp, &Humi );
 80067c8:	f7ff fdee 	bl	80063a8 <SS_THSoil_Read>
			if( (Temp > __fileData.Threshold_TempS.Low) && (Temp < __fileData.Threshold_TempS.High) && \
 80067cc:	eddd 7a02 	vldr	s15, [sp, #8]
 80067d0:	ed95 7a07 	vldr	s14, [r5, #28]
 80067d4:	4eab      	ldr	r6, [pc, #684]	; (8006a84 <SensorTask+0x310>)
 80067d6:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80067da:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80067de:	f140 811f 	bpl.w	8006a20 <SensorTask+0x2ac>
 80067e2:	ed95 7a06 	vldr	s14, [r5, #24]
 80067e6:	eef4 7ac7 	vcmpe.f32	s15, s14
 80067ea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80067ee:	f140 8117 	bpl.w	8006a20 <SensorTask+0x2ac>
				(Humi > __fileData.Threshold_HumiS.Low) && (Humi < __fileData.Threshold_HumiS.High) \
 80067f2:	ed9d 8a03 	vldr	s16, [sp, #12]
			if( (Temp > __fileData.Threshold_TempS.Low) && (Temp < __fileData.Threshold_TempS.High) && \
 80067f6:	ed95 7a09 	vldr	s14, [r5, #36]	; 0x24
 80067fa:	eeb4 7ac8 	vcmpe.f32	s14, s16
 80067fe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006802:	f140 810d 	bpl.w	8006a20 <SensorTask+0x2ac>
				(Humi > __fileData.Threshold_HumiS.Low) && (Humi < __fileData.Threshold_HumiS.High) \
 8006806:	ed95 7a08 	vldr	s14, [r5, #32]
 800680a:	eeb4 8ac7 	vcmpe.f32	s16, s14
 800680e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006812:	f140 8105 	bpl.w	8006a20 <SensorTask+0x2ac>
				__SensorData.TempS = Temp;
 8006816:	edc6 7a02 	vstr	s15, [r6, #8]
				APP_DEBUG("--- SensorTask: Temp soil = %.2f, Humi soil = %.2f\r\n", __SensorData.TempS, __SensorData.HumiS);
 800681a:	ee17 0a90 	vmov	r0, s15
				__SensorData.HumiS = Humi;
 800681e:	ed86 8a03 	vstr	s16, [r6, #12]
				APP_DEBUG("--- SensorTask: Temp soil = %.2f, Humi soil = %.2f\r\n", __SensorData.TempS, __SensorData.HumiS);
 8006822:	f7f9 fea1 	bl	8000568 <__aeabi_f2d>
 8006826:	4680      	mov	r8, r0
 8006828:	ee18 0a10 	vmov	r0, s16
 800682c:	4689      	mov	r9, r1
 800682e:	f7f9 fe9b 	bl	8000568 <__aeabi_f2d>
 8006832:	e9cd 0100 	strd	r0, r1, [sp]
 8006836:	4894      	ldr	r0, [pc, #592]	; (8006a88 <SensorTask+0x314>)
 8006838:	4642      	mov	r2, r8
 800683a:	464b      	mov	r3, r9
				APP_DEBUG("--- SensorTask: read temp & humi soil error, Temp = %.2f, Humi = %.2f\r\n", Temp, Humi);
 800683c:	f001 f9b6 	bl	8007bac <printf>
			if( (__Sensor_Error.TempS_error.value == __SensorData.TempS) && \
 8006840:	ed94 7a04 	vldr	s14, [r4, #16]
 8006844:	edd6 7a02 	vldr	s15, [r6, #8]
 8006848:	eeb4 7a67 	vcmp.f32	s14, s15
 800684c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006850:	f040 80f5 	bne.w	8006a3e <SensorTask+0x2ca>
 8006854:	ed94 7a06 	vldr	s14, [r4, #24]
 8006858:	edd6 7a03 	vldr	s15, [r6, #12]
 800685c:	eeb4 7a67 	vcmp.f32	s14, s15
 8006860:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006864:	f040 80eb 	bne.w	8006a3e <SensorTask+0x2ca>
				__Sensor_Error.TempS_error.Count++;
 8006868:	7d23      	ldrb	r3, [r4, #20]
 800686a:	3301      	adds	r3, #1
 800686c:	7523      	strb	r3, [r4, #20]
				__Sensor_Error.HumiS_error.Count++;
 800686e:	7f23      	ldrb	r3, [r4, #28]
 8006870:	3301      	adds	r3, #1
 8006872:	7723      	strb	r3, [r4, #28]
		if( (__fileData.SensorCfg & SS_pH) == SS_pH )
 8006874:	886b      	ldrh	r3, [r5, #2]
 8006876:	06da      	lsls	r2, r3, #27
 8006878:	d533      	bpl.n	80068e2 <SensorTask+0x16e>
			float pH_value = SS_PH_Read();
 800687a:	f7ff fd01 	bl	8006280 <SS_PH_Read>
			if( (pH_value >= __fileData.Threshold_pH.Low) && (pH_value <= __fileData.Threshold_pH.High) )
 800687e:	edd5 7a0b 	vldr	s15, [r5, #44]	; 0x2c
 8006882:	4e80      	ldr	r6, [pc, #512]	; (8006a84 <SensorTask+0x310>)
 8006884:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8006888:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
			float pH_value = SS_PH_Read();
 800688c:	eeb0 8a40 	vmov.f32	s16, s0
			if( (pH_value >= __fileData.Threshold_pH.Low) && (pH_value <= __fileData.Threshold_pH.High) )
 8006890:	f2c0 80dd 	blt.w	8006a4e <SensorTask+0x2da>
 8006894:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
 8006898:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800689c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80068a0:	f200 80d5 	bhi.w	8006a4e <SensorTask+0x2da>
				__SensorData.PH = pH_value;
 80068a4:	ed86 0a04 	vstr	s0, [r6, #16]
				APP_DEBUG("--- SensorTask: pH = %.2f\r\n", __SensorData.PH);
 80068a8:	ee10 0a10 	vmov	r0, s0
 80068ac:	f7f9 fe5c 	bl	8000568 <__aeabi_f2d>
 80068b0:	4602      	mov	r2, r0
 80068b2:	4876      	ldr	r0, [pc, #472]	; (8006a8c <SensorTask+0x318>)
 80068b4:	460b      	mov	r3, r1
				APP_DEBUG("--- SensorTask: read pH error, value = %.2f\r\n", pH_value);
 80068b6:	f001 f979 	bl	8007bac <printf>
			if( __Sensor_Error.pH_error.value == __SensorData.PH )
 80068ba:	ed94 7a08 	vldr	s14, [r4, #32]
 80068be:	edd6 7a04 	vldr	s15, [r6, #16]
 80068c2:	eeb4 7a67 	vcmp.f32	s14, s15
 80068c6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
				__Sensor_Error.pH_error.Count++;
 80068ca:	bf0b      	itete	eq
 80068cc:	f894 3024 	ldrbeq.w	r3, [r4, #36]	; 0x24
				__Sensor_Error.pH_error.value = pH_value;
 80068d0:	ed84 8a08 	vstrne	s16, [r4, #32]
				__Sensor_Error.pH_error.Count++;
 80068d4:	3301      	addeq	r3, #1
				__Sensor_Error.pH_error.Count = 0;
 80068d6:	2300      	movne	r3, #0
				__Sensor_Error.pH_error.Count++;
 80068d8:	bf0c      	ite	eq
 80068da:	f884 3024 	strbeq.w	r3, [r4, #36]	; 0x24
				__Sensor_Error.pH_error.Count = 0;
 80068de:	f884 3024 	strbne.w	r3, [r4, #36]	; 0x24
		if( (__fileData.SensorCfg & SS_EC) == SS_EC )
 80068e2:	886b      	ldrh	r3, [r5, #2]
 80068e4:	069b      	lsls	r3, r3, #26
 80068e6:	d52d      	bpl.n	8006944 <SensorTask+0x1d0>
			EC_Value = SS_EC_Read();
 80068e8:	f7ff fc8e 	bl	8006208 <SS_EC_Read>
			if( (EC_Value >= __fileData.Threshold_EC.Low) && (EC_Value <= __fileData.Threshold_EC.High) )
 80068ec:	edd5 7a0d 	vldr	s15, [r5, #52]	; 0x34
 80068f0:	4e64      	ldr	r6, [pc, #400]	; (8006a84 <SensorTask+0x310>)
 80068f2:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80068f6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
			EC_Value = SS_EC_Read();
 80068fa:	eeb0 8a40 	vmov.f32	s16, s0
			if( (EC_Value >= __fileData.Threshold_EC.Low) && (EC_Value <= __fileData.Threshold_EC.High) )
 80068fe:	f2c0 80ae 	blt.w	8006a5e <SensorTask+0x2ea>
 8006902:	edd5 7a0c 	vldr	s15, [r5, #48]	; 0x30
 8006906:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800690a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800690e:	f200 80a6 	bhi.w	8006a5e <SensorTask+0x2ea>
				__SensorData.EC = EC_Value;
 8006912:	ed86 0a05 	vstr	s0, [r6, #20]
				APP_DEBUG("--- SensorTask: EC = %.2f\r\n", __SensorData.EC);
 8006916:	ee10 0a10 	vmov	r0, s0
 800691a:	f7f9 fe25 	bl	8000568 <__aeabi_f2d>
 800691e:	4602      	mov	r2, r0
 8006920:	485b      	ldr	r0, [pc, #364]	; (8006a90 <SensorTask+0x31c>)
 8006922:	460b      	mov	r3, r1
				APP_DEBUG("--- SensorTask: read EC error, value = %.2f\r\n", EC_Value);
 8006924:	f001 f942 	bl	8007bac <printf>
			if( __Sensor_Error.EC_error.value == __SensorData.EC )
 8006928:	ed94 7a0a 	vldr	s14, [r4, #40]	; 0x28
 800692c:	edd6 7a05 	vldr	s15, [r6, #20]
 8006930:	eeb4 7a67 	vcmp.f32	s14, s15
 8006934:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
				__Sensor_Error.EC_error.Count = 0;
 8006938:	bf02      	ittt	eq
 800693a:	2300      	moveq	r3, #0
 800693c:	f884 302c 	strbeq.w	r3, [r4, #44]	; 0x2c
				__Sensor_Error.EC_error.value = EC_Value;
 8006940:	ed84 8a0a 	vstreq	s16, [r4, #40]	; 0x28
 * ***************************************************************************/
static void SensorTask_CheckError( void )
{
	//if data read after SENSOR_ERROR_COUNT --> reset sensor

	if( (__Sensor_Error.TempA_error.Count >= SENSOR_ERROR_COUNT) || \
 8006944:	7923      	ldrb	r3, [r4, #4]
 8006946:	2b09      	cmp	r3, #9
 8006948:	d802      	bhi.n	8006950 <SensorTask+0x1dc>
 800694a:	7b23      	ldrb	r3, [r4, #12]
 800694c:	2b09      	cmp	r3, #9
 800694e:	d90c      	bls.n	800696a <SensorTask+0x1f6>
		(__Sensor_Error.HumiA_error.Count >= SENSOR_ERROR_COUNT) \
		)
	{
		__Sensor_Error.TempA_error.Count = 0;
 8006950:	2300      	movs	r3, #0
		__Sensor_Error.HumiA_error.Count = 0;
		APP_DEBUG("--- SensorTask: temp & humi air sensor error \"read count\". Reseting sensor\r\n");
 8006952:	4850      	ldr	r0, [pc, #320]	; (8006a94 <SensorTask+0x320>)
		__Sensor_Error.TempA_error.Count = 0;
 8006954:	7123      	strb	r3, [r4, #4]
		__Sensor_Error.HumiA_error.Count = 0;
 8006956:	7323      	strb	r3, [r4, #12]
		APP_DEBUG("--- SensorTask: temp & humi air sensor error \"read count\". Reseting sensor\r\n");
 8006958:	f001 f9a0 	bl	8007c9c <puts>
		IOControl_SS_THL_OFF();
 800695c:	f7fe fe8a 	bl	8005674 <IOControl_SS_THL_OFF>
		osDelay(200);
 8006960:	20c8      	movs	r0, #200	; 0xc8
 8006962:	f7fd faaf 	bl	8003ec4 <osDelay>
		IOControl_SS_THL_ON();
 8006966:	f7fe fe7f 	bl	8005668 <IOControl_SS_THL_ON>
	}

	if( (__Sensor_Error.TempS_error.Count >= SENSOR_ERROR_COUNT) || \
 800696a:	7d23      	ldrb	r3, [r4, #20]
 800696c:	2b09      	cmp	r3, #9
 800696e:	d802      	bhi.n	8006976 <SensorTask+0x202>
 8006970:	7f23      	ldrb	r3, [r4, #28]
 8006972:	2b09      	cmp	r3, #9
 8006974:	d90c      	bls.n	8006990 <SensorTask+0x21c>
		(__Sensor_Error.HumiS_error.Count >= SENSOR_ERROR_COUNT) \
		)
	{
		__Sensor_Error.TempS_error.Count = 0;
 8006976:	2300      	movs	r3, #0
		__Sensor_Error.HumiS_error.Count = 0;
		APP_DEBUG("--- SensorTask: temp & humi soil sensor error \"read count\". Reseting sensor\r\n");
 8006978:	4847      	ldr	r0, [pc, #284]	; (8006a98 <SensorTask+0x324>)
		__Sensor_Error.TempS_error.Count = 0;
 800697a:	7523      	strb	r3, [r4, #20]
		__Sensor_Error.HumiS_error.Count = 0;
 800697c:	7723      	strb	r3, [r4, #28]
		APP_DEBUG("--- SensorTask: temp & humi soil sensor error \"read count\". Reseting sensor\r\n");
 800697e:	f001 f98d 	bl	8007c9c <puts>
		IOControl_SS_TH_Soil_OFF();
 8006982:	f7fe fe3f 	bl	8005604 <IOControl_SS_TH_Soil_OFF>
		osDelay(200);
 8006986:	20c8      	movs	r0, #200	; 0xc8
 8006988:	f7fd fa9c 	bl	8003ec4 <osDelay>
		IOControl_SS_TH_Soil_ON();
 800698c:	f7fe fe34 	bl	80055f8 <IOControl_SS_TH_Soil_ON>
	}

	if(__Sensor_Error.pH_error.Count >= SENSOR_ERROR_COUNT)
 8006990:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
 8006994:	2b09      	cmp	r3, #9
 8006996:	d90c      	bls.n	80069b2 <SensorTask+0x23e>
	{
		__Sensor_Error.pH_error.Count = 0;
 8006998:	2300      	movs	r3, #0
		APP_DEBUG("--- SensorTask: pH sensor error \"read count\". Reseting sensor\r\n");
 800699a:	4840      	ldr	r0, [pc, #256]	; (8006a9c <SensorTask+0x328>)
		__Sensor_Error.pH_error.Count = 0;
 800699c:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
		APP_DEBUG("--- SensorTask: pH sensor error \"read count\". Reseting sensor\r\n");
 80069a0:	f001 f97c 	bl	8007c9c <puts>
		IOControl_SS_PH_OFF();
 80069a4:	f7fe fe4c 	bl	8005640 <IOControl_SS_PH_OFF>
		osDelay(200);
 80069a8:	20c8      	movs	r0, #200	; 0xc8
 80069aa:	f7fd fa8b 	bl	8003ec4 <osDelay>
		IOControl_SS_PH_ON();
 80069ae:	f7fe fe3f 	bl	8005630 <IOControl_SS_PH_ON>
	}

	if(__Sensor_Error.EC_error.Count >= SENSOR_ERROR_COUNT)
 80069b2:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
 80069b6:	2b09      	cmp	r3, #9
 80069b8:	d90c      	bls.n	80069d4 <SensorTask+0x260>
	{
		__Sensor_Error.EC_error.Count = 0;
 80069ba:	2300      	movs	r3, #0
		APP_DEBUG("--- SensorTask: EC sensor error \"read count\". Reseting sensor\r\n");
 80069bc:	4838      	ldr	r0, [pc, #224]	; (8006aa0 <SensorTask+0x32c>)
		__Sensor_Error.EC_error.Count = 0;
 80069be:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
		APP_DEBUG("--- SensorTask: EC sensor error \"read count\". Reseting sensor\r\n");
 80069c2:	f001 f96b 	bl	8007c9c <puts>
		IOControl_SS_EC_OFF();
 80069c6:	f7fe fe2b 	bl	8005620 <IOControl_SS_EC_OFF>
		osDelay(200);
 80069ca:	20c8      	movs	r0, #200	; 0xc8
 80069cc:	f7fd fa7a 	bl	8003ec4 <osDelay>
		IOControl_SS_EC_ON();
 80069d0:	f7fe fe1e 	bl	8005610 <IOControl_SS_EC_ON>
	}

	if(__Sensor_Error.Light_error.Count >= SENSOR_ERROR_COUNT)
 80069d4:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
 80069d8:	2b09      	cmp	r3, #9
 80069da:	d90c      	bls.n	80069f6 <SensorTask+0x282>
	{
		__Sensor_Error.Light_error.Count = 0;
 80069dc:	2300      	movs	r3, #0
		APP_DEBUG("--- SensorTask: Light sensor error \"read count\". Reseting sensor\r\n");
 80069de:	4831      	ldr	r0, [pc, #196]	; (8006aa4 <SensorTask+0x330>)
		__Sensor_Error.Light_error.Count = 0;
 80069e0:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
		APP_DEBUG("--- SensorTask: Light sensor error \"read count\". Reseting sensor\r\n");
 80069e4:	f001 f95a 	bl	8007c9c <puts>
		IOControl_SS_THL_OFF();
 80069e8:	f7fe fe44 	bl	8005674 <IOControl_SS_THL_OFF>
		osDelay(200);
 80069ec:	20c8      	movs	r0, #200	; 0xc8
 80069ee:	f7fd fa69 	bl	8003ec4 <osDelay>
		IOControl_SS_THL_ON();
 80069f2:	f7fe fe39 	bl	8005668 <IOControl_SS_THL_ON>
	}

	if(__Sensor_Error.CO2_error.Count >= SENSOR_ERROR_COUNT)
 80069f6:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
 80069fa:	2b09      	cmp	r3, #9
 80069fc:	d90c      	bls.n	8006a18 <SensorTask+0x2a4>
	{
		__Sensor_Error.CO2_error.Count = 0;
 80069fe:	2300      	movs	r3, #0
		APP_DEBUG("--- SensorTask: CO2 sensor error \"read count\". Reseting sensor\r\n");
 8006a00:	4829      	ldr	r0, [pc, #164]	; (8006aa8 <SensorTask+0x334>)
		__Sensor_Error.CO2_error.Count = 0;
 8006a02:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
		APP_DEBUG("--- SensorTask: CO2 sensor error \"read count\". Reseting sensor\r\n");
 8006a06:	f001 f949 	bl	8007c9c <puts>
		IOControl_SS_CO2_OFF();
 8006a0a:	f7fe fe27 	bl	800565c <IOControl_SS_CO2_OFF>
		osDelay(200);
 8006a0e:	20c8      	movs	r0, #200	; 0xc8
 8006a10:	f7fd fa58 	bl	8003ec4 <osDelay>
		IOControl_SS_CO2_ON();
 8006a14:	f7fe fe1c 	bl	8005650 <IOControl_SS_CO2_ON>
		_TaskHandle.SensorTask_Finish = 0;
 8006a18:	2300      	movs	r3, #0
 8006a1a:	f8cb 3014 	str.w	r3, [fp, #20]
		osDelay(TIME_READ_SENSOR * 1000);
 8006a1e:	e6be      	b.n	800679e <SensorTask+0x2a>
				APP_DEBUG("--- SensorTask: read temp & humi soil error, Temp = %.2f, Humi = %.2f\r\n", Temp, Humi);
 8006a20:	ee17 0a90 	vmov	r0, s15
 8006a24:	f7f9 fda0 	bl	8000568 <__aeabi_f2d>
 8006a28:	4680      	mov	r8, r0
 8006a2a:	9803      	ldr	r0, [sp, #12]
 8006a2c:	4689      	mov	r9, r1
 8006a2e:	f7f9 fd9b 	bl	8000568 <__aeabi_f2d>
 8006a32:	4642      	mov	r2, r8
 8006a34:	e9cd 0100 	strd	r0, r1, [sp]
 8006a38:	464b      	mov	r3, r9
 8006a3a:	481c      	ldr	r0, [pc, #112]	; (8006aac <SensorTask+0x338>)
 8006a3c:	e6fe      	b.n	800683c <SensorTask+0xc8>
				__Sensor_Error.TempS_error.Count = 0;
 8006a3e:	2300      	movs	r3, #0
 8006a40:	7523      	strb	r3, [r4, #20]
				__Sensor_Error.HumiS_error.Count = 0;
 8006a42:	7723      	strb	r3, [r4, #28]
				__Sensor_Error.TempS_error.value = Temp;
 8006a44:	9b02      	ldr	r3, [sp, #8]
 8006a46:	6123      	str	r3, [r4, #16]
				__Sensor_Error.HumiS_error.value = Humi;
 8006a48:	9b03      	ldr	r3, [sp, #12]
 8006a4a:	61a3      	str	r3, [r4, #24]
 8006a4c:	e712      	b.n	8006874 <SensorTask+0x100>
				APP_DEBUG("--- SensorTask: read pH error, value = %.2f\r\n", pH_value);
 8006a4e:	ee18 0a10 	vmov	r0, s16
 8006a52:	f7f9 fd89 	bl	8000568 <__aeabi_f2d>
 8006a56:	4602      	mov	r2, r0
 8006a58:	460b      	mov	r3, r1
 8006a5a:	4815      	ldr	r0, [pc, #84]	; (8006ab0 <SensorTask+0x33c>)
 8006a5c:	e72b      	b.n	80068b6 <SensorTask+0x142>
				APP_DEBUG("--- SensorTask: read EC error, value = %.2f\r\n", EC_Value);
 8006a5e:	ee18 0a10 	vmov	r0, s16
 8006a62:	f7f9 fd81 	bl	8000568 <__aeabi_f2d>
 8006a66:	4602      	mov	r2, r0
 8006a68:	460b      	mov	r3, r1
 8006a6a:	4812      	ldr	r0, [pc, #72]	; (8006ab4 <SensorTask+0x340>)
 8006a6c:	e75a      	b.n	8006924 <SensorTask+0x1b0>
 8006a6e:	bf00      	nop
 8006a70:	0800cb3a 	.word	0x0800cb3a
 8006a74:	20008cc8 	.word	0x20008cc8
 8006a78:	080066f9 	.word	0x080066f9
 8006a7c:	20000010 	.word	0x20000010
 8006a80:	20008470 	.word	0x20008470
 8006a84:	20008450 	.word	0x20008450
 8006a88:	0800cb72 	.word	0x0800cb72
 8006a8c:	0800cbef 	.word	0x0800cbef
 8006a90:	0800cc39 	.word	0x0800cc39
 8006a94:	0800cc83 	.word	0x0800cc83
 8006a98:	0800cccf 	.word	0x0800cccf
 8006a9c:	0800cd1c 	.word	0x0800cd1c
 8006aa0:	0800cd5b 	.word	0x0800cd5b
 8006aa4:	0800cd9a 	.word	0x0800cd9a
 8006aa8:	0800cddc 	.word	0x0800cddc
 8006aac:	0800cba7 	.word	0x0800cba7
 8006ab0:	0800cc0b 	.word	0x0800cc0b
 8006ab4:	0800cc55 	.word	0x0800cc55
 8006ab8:	0800cb56 	.word	0x0800cb56

08006abc <fileData_Write_Reset>:



//write reset
static void fileData_Write_Reset( void )
{
 8006abc:	b507      	push	{r0, r1, r2, lr}
	uint8_t Buffwrite[RESET_LENGHT + 1] = {0};
 8006abe:	2300      	movs	r3, #0
 8006ac0:	f88d 3006 	strb.w	r3, [sp, #6]
	uint16_t value = __fileData.ResetCount + 1;
 8006ac4:	4b08      	ldr	r3, [pc, #32]	; (8006ae8 <fileData_Write_Reset+0x2c>)
 8006ac6:	881b      	ldrh	r3, [r3, #0]
 8006ac8:	3301      	adds	r3, #1
 8006aca:	b29b      	uxth	r3, r3
	Buffwrite[0] = (value >> 8) & 0xFF;
 8006acc:	0a1a      	lsrs	r2, r3, #8
 8006ace:	f88d 2004 	strb.w	r2, [sp, #4]
	Buffwrite[1] = (value >> 0) & 0xFF;

	Flash_Write_to_Page( address_reset, Buffwrite, RESET_LENGHT );
 8006ad2:	a901      	add	r1, sp, #4
 8006ad4:	2202      	movs	r2, #2
 8006ad6:	f44f 30c0 	mov.w	r0, #98304	; 0x18000
	Buffwrite[1] = (value >> 0) & 0xFF;
 8006ada:	f88d 3005 	strb.w	r3, [sp, #5]
	Flash_Write_to_Page( address_reset, Buffwrite, RESET_LENGHT );
 8006ade:	f7fe f8e9 	bl	8004cb4 <Flash_Write_to_Page>
}
 8006ae2:	b003      	add	sp, #12
 8006ae4:	f85d fb04 	ldr.w	pc, [sp], #4
 8006ae8:	20000010 	.word	0x20000010

08006aec <fileData_Write_Threshold_Component.constprop.0>:
}




static void fileData_Write_Threshold_Component( uint32_t addr, uint8_t Lenght, float Threshold_Low, float Threshold_High )
 8006aec:	b510      	push	{r4, lr}
 8006aee:	ed2d 8b02 	vpush	{d8}
 8006af2:	b086      	sub	sp, #24
 8006af4:	eef0 8a40 	vmov.f32	s17, s0
 8006af8:	4604      	mov	r4, r0
{
	uint8_t Buffwrite[24] = {0};
 8006afa:	2218      	movs	r2, #24
 8006afc:	2100      	movs	r1, #0
 8006afe:	4668      	mov	r0, sp
static void fileData_Write_Threshold_Component( uint32_t addr, uint8_t Lenght, float Threshold_Low, float Threshold_High )
 8006b00:	eeb0 8a60 	vmov.f32	s16, s1
	uint8_t Buffwrite[24] = {0};
 8006b04:	f001 f83d 	bl	8007b82 <memset>
	Buffwrite[0] = ((uint32_t)Threshold_Low 	>> 24	) & 0xFF;
 8006b08:	eefc 7ae8 	vcvt.u32.f32	s15, s17
	Buffwrite[4] = ((uint32_t)Threshold_High 	>> 24	) & 0xFF;
	Buffwrite[5] = ((uint32_t)Threshold_High 	>> 16	) & 0xFF;
	Buffwrite[6] = ((uint32_t)Threshold_High 	>> 8	) & 0xFF;
	Buffwrite[7] = ((uint32_t)Threshold_High			) & 0xFF;

	Flash_Write_to_Page( addr, Buffwrite, Lenght );
 8006b0c:	4669      	mov	r1, sp
	Buffwrite[0] = ((uint32_t)Threshold_Low 	>> 24	) & 0xFF;
 8006b0e:	ee17 3a90 	vmov	r3, s15
	Buffwrite[4] = ((uint32_t)Threshold_High 	>> 24	) & 0xFF;
 8006b12:	eefc 7ac8 	vcvt.u32.f32	s15, s16
	Buffwrite[0] = ((uint32_t)Threshold_Low 	>> 24	) & 0xFF;
 8006b16:	0e1a      	lsrs	r2, r3, #24
 8006b18:	f88d 2000 	strb.w	r2, [sp]
	Buffwrite[1] = ((uint32_t)Threshold_Low 	>> 16	) & 0xFF;
 8006b1c:	0c1a      	lsrs	r2, r3, #16
 8006b1e:	f88d 2001 	strb.w	r2, [sp, #1]
	Buffwrite[3] = ((uint32_t)Threshold_Low				) & 0xFF;
 8006b22:	f88d 3003 	strb.w	r3, [sp, #3]
	Buffwrite[2] = ((uint32_t)Threshold_Low 	>> 8	) & 0xFF;
 8006b26:	0a1a      	lsrs	r2, r3, #8
	Buffwrite[4] = ((uint32_t)Threshold_High 	>> 24	) & 0xFF;
 8006b28:	ee17 3a90 	vmov	r3, s15
	Buffwrite[2] = ((uint32_t)Threshold_Low 	>> 8	) & 0xFF;
 8006b2c:	f88d 2002 	strb.w	r2, [sp, #2]
	Buffwrite[4] = ((uint32_t)Threshold_High 	>> 24	) & 0xFF;
 8006b30:	0e1a      	lsrs	r2, r3, #24
 8006b32:	f88d 2004 	strb.w	r2, [sp, #4]
	Buffwrite[5] = ((uint32_t)Threshold_High 	>> 16	) & 0xFF;
 8006b36:	0c1a      	lsrs	r2, r3, #16
 8006b38:	f88d 2005 	strb.w	r2, [sp, #5]
	Buffwrite[6] = ((uint32_t)Threshold_High 	>> 8	) & 0xFF;
 8006b3c:	0a1a      	lsrs	r2, r3, #8
 8006b3e:	f88d 2006 	strb.w	r2, [sp, #6]
	Flash_Write_to_Page( addr, Buffwrite, Lenght );
 8006b42:	4620      	mov	r0, r4
 8006b44:	2208      	movs	r2, #8
	Buffwrite[7] = ((uint32_t)Threshold_High			) & 0xFF;
 8006b46:	f88d 3007 	strb.w	r3, [sp, #7]
	Flash_Write_to_Page( addr, Buffwrite, Lenght );
 8006b4a:	f7fe f8b3 	bl	8004cb4 <Flash_Write_to_Page>
}
 8006b4e:	b006      	add	sp, #24
 8006b50:	ecbd 8b02 	vpop	{d8}
 8006b54:	bd10      	pop	{r4, pc}

08006b56 <fileData_Read_Threshold_Component.constprop.1>:




static void fileData_Read_Threshold_Component( uint32_t addr, uint8_t Lenght, float *Threshold_Low, float *Threshold_High )
 8006b56:	b570      	push	{r4, r5, r6, lr}
 8006b58:	b086      	sub	sp, #24
 8006b5a:	4606      	mov	r6, r0
 8006b5c:	460c      	mov	r4, r1
 8006b5e:	4615      	mov	r5, r2
{
	uint8_t Buffread[24] = {0};
 8006b60:	2100      	movs	r1, #0
 8006b62:	2218      	movs	r2, #24
 8006b64:	4668      	mov	r0, sp
 8006b66:	f001 f80c 	bl	8007b82 <memset>
	Flash_Read( addr, Buffread, Lenght );
 8006b6a:	2208      	movs	r2, #8
 8006b6c:	4669      	mov	r1, sp
 8006b6e:	4630      	mov	r0, r6
 8006b70:	f7fe f898 	bl	8004ca4 <Flash_Read>
 8006b74:	9b00      	ldr	r3, [sp, #0]
 8006b76:	ba1b      	rev	r3, r3
	*Threshold_High = (float)( (Buffread[0] << 24) | (Buffread[1] << 16) | (Buffread[2] << 8) | Buffread[3] );
 8006b78:	ee07 3a90 	vmov	s15, r3
 8006b7c:	9b01      	ldr	r3, [sp, #4]
 8006b7e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8006b82:	ba1b      	rev	r3, r3
 8006b84:	edc5 7a00 	vstr	s15, [r5]
	*Threshold_Low = (float)( (Buffread[4] << 24) | (Buffread[5] << 16) | (Buffread[6] << 8) | Buffread[7] );
 8006b88:	ee07 3a90 	vmov	s15, r3
 8006b8c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8006b90:	edc4 7a00 	vstr	s15, [r4]
}
 8006b94:	b006      	add	sp, #24
 8006b96:	bd70      	pop	{r4, r5, r6, pc}

08006b98 <fileData_Init>:
	Flash_Init();
 8006b98:	f7fe b840 	b.w	8004c1c <Flash_Init>

08006b9c <fileData_Write_SensorCFG>:
{
 8006b9c:	b507      	push	{r0, r1, r2, lr}
	uint8_t Buffwrite[SENSOR_CFG_FLASH_LENGHT + 1] = {0};
 8006b9e:	2300      	movs	r3, #0
 8006ba0:	f88d 3006 	strb.w	r3, [sp, #6]
	Buffwrite[0] = (__fileData.SensorCfg >> 8) & 0xFF;
 8006ba4:	4b07      	ldr	r3, [pc, #28]	; (8006bc4 <fileData_Write_SensorCFG+0x28>)
 8006ba6:	885b      	ldrh	r3, [r3, #2]
	Buffwrite[1] = __fileData.SensorCfg & 0xFF;
 8006ba8:	f88d 3005 	strb.w	r3, [sp, #5]
	Buffwrite[0] = (__fileData.SensorCfg >> 8) & 0xFF;
 8006bac:	0a1a      	lsrs	r2, r3, #8
 8006bae:	f88d 2004 	strb.w	r2, [sp, #4]
	Flash_Write_to_Page( address_sensor_cfg, Buffwrite, SENSOR_CFG_FLASH_LENGHT );
 8006bb2:	a901      	add	r1, sp, #4
 8006bb4:	2202      	movs	r2, #2
 8006bb6:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8006bba:	f7fe f87b 	bl	8004cb4 <Flash_Write_to_Page>
}
 8006bbe:	b003      	add	sp, #12
 8006bc0:	f85d fb04 	ldr.w	pc, [sp], #4
 8006bc4:	20000010 	.word	0x20000010

08006bc8 <fileData_Read_Sensor_CFG>:
{
 8006bc8:	b507      	push	{r0, r1, r2, lr}
	uint8_t Buffread[SENSOR_CFG_FLASH_LENGHT + 1] = {0};
 8006bca:	2300      	movs	r3, #0
	Flash_Read( address_sensor_cfg, Buffread, SENSOR_CFG_FLASH_LENGHT );
 8006bcc:	2202      	movs	r2, #2
 8006bce:	a901      	add	r1, sp, #4
 8006bd0:	f44f 5080 	mov.w	r0, #4096	; 0x1000
	uint8_t Buffread[SENSOR_CFG_FLASH_LENGHT + 1] = {0};
 8006bd4:	f8ad 3004 	strh.w	r3, [sp, #4]
 8006bd8:	f88d 3006 	strb.w	r3, [sp, #6]
	Flash_Read( address_sensor_cfg, Buffread, SENSOR_CFG_FLASH_LENGHT );
 8006bdc:	f7fe f862 	bl	8004ca4 <Flash_Read>
	__fileData.SensorCfg = ((Buffread[0] << 8) | Buffread[1]);
 8006be0:	f89d 2004 	ldrb.w	r2, [sp, #4]
 8006be4:	f89d 3005 	ldrb.w	r3, [sp, #5]
 8006be8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8006bec:	4a02      	ldr	r2, [pc, #8]	; (8006bf8 <fileData_Read_Sensor_CFG+0x30>)
 8006bee:	8053      	strh	r3, [r2, #2]
}
 8006bf0:	b003      	add	sp, #12
 8006bf2:	f85d fb04 	ldr.w	pc, [sp], #4
 8006bf6:	bf00      	nop
 8006bf8:	20000010 	.word	0x20000010

08006bfc <fileData_Write_DataUT>:
{
 8006bfc:	b507      	push	{r0, r1, r2, lr}
	uint8_t Buffwrite[DATA_UT_FLASH_LENGHT + 1] = {0};
 8006bfe:	2300      	movs	r3, #0
 8006c00:	f88d 3006 	strb.w	r3, [sp, #6]
	Buffwrite[0] = (__fileData.DataUT >> 8) & 0xFF;
 8006c04:	4b07      	ldr	r3, [pc, #28]	; (8006c24 <fileData_Write_DataUT+0x28>)
 8006c06:	889b      	ldrh	r3, [r3, #4]
	Buffwrite[1] = __fileData.DataUT & 0xFF;
 8006c08:	f88d 3005 	strb.w	r3, [sp, #5]
	Buffwrite[0] = (__fileData.DataUT >> 8) & 0xFF;
 8006c0c:	0a1a      	lsrs	r2, r3, #8
 8006c0e:	f88d 2004 	strb.w	r2, [sp, #4]
	Flash_Write_to_Page( address_dataut, Buffwrite, DATA_UT_FLASH_LENGHT );
 8006c12:	a901      	add	r1, sp, #4
 8006c14:	2202      	movs	r2, #2
 8006c16:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8006c1a:	f7fe f84b 	bl	8004cb4 <Flash_Write_to_Page>
}
 8006c1e:	b003      	add	sp, #12
 8006c20:	f85d fb04 	ldr.w	pc, [sp], #4
 8006c24:	20000010 	.word	0x20000010

08006c28 <fileData_Read_DataUT>:
{
 8006c28:	b507      	push	{r0, r1, r2, lr}
	uint8_t Buffread[DATA_UT_FLASH_LENGHT + 1] = {0};
 8006c2a:	2300      	movs	r3, #0
	Flash_Read( address_dataut, Buffread, DATA_UT_FLASH_LENGHT );
 8006c2c:	2202      	movs	r2, #2
 8006c2e:	a901      	add	r1, sp, #4
 8006c30:	f44f 5000 	mov.w	r0, #8192	; 0x2000
	uint8_t Buffread[DATA_UT_FLASH_LENGHT + 1] = {0};
 8006c34:	f8ad 3004 	strh.w	r3, [sp, #4]
 8006c38:	f88d 3006 	strb.w	r3, [sp, #6]
	Flash_Read( address_dataut, Buffread, DATA_UT_FLASH_LENGHT );
 8006c3c:	f7fe f832 	bl	8004ca4 <Flash_Read>
	__fileData.DataUT = ((Buffread[0] << 8) | Buffread[1]);
 8006c40:	f89d 2004 	ldrb.w	r2, [sp, #4]
 8006c44:	f89d 3005 	ldrb.w	r3, [sp, #5]
 8006c48:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8006c4c:	4a02      	ldr	r2, [pc, #8]	; (8006c58 <fileData_Read_DataUT+0x30>)
 8006c4e:	8093      	strh	r3, [r2, #4]
}
 8006c50:	b003      	add	sp, #12
 8006c52:	f85d fb04 	ldr.w	pc, [sp], #4
 8006c56:	bf00      	nop
 8006c58:	20000010 	.word	0x20000010

08006c5c <fileData_Write_Threshold_TempA>:
	fileData_Write_Threshold_Component(address_threshold_temp_a, TEMP_A_FLASH_LENGHT, \
 8006c5c:	4b04      	ldr	r3, [pc, #16]	; (8006c70 <fileData_Write_Threshold_TempA+0x14>)
 8006c5e:	f44f 5040 	mov.w	r0, #12288	; 0x3000
 8006c62:	edd3 0a02 	vldr	s1, [r3, #8]
 8006c66:	ed93 0a03 	vldr	s0, [r3, #12]
 8006c6a:	f7ff bf3f 	b.w	8006aec <fileData_Write_Threshold_Component.constprop.0>
 8006c6e:	bf00      	nop
 8006c70:	20000010 	.word	0x20000010

08006c74 <fileData_Read_Threshold_TempA>:
	fileData_Read_Threshold_Component( address_threshold_temp_a, TEMP_A_FLASH_LENGHT, \
 8006c74:	4903      	ldr	r1, [pc, #12]	; (8006c84 <fileData_Read_Threshold_TempA+0x10>)
 8006c76:	f44f 5040 	mov.w	r0, #12288	; 0x3000
 8006c7a:	f101 0208 	add.w	r2, r1, #8
 8006c7e:	310c      	adds	r1, #12
 8006c80:	f7ff bf69 	b.w	8006b56 <fileData_Read_Threshold_Component.constprop.1>
 8006c84:	20000010 	.word	0x20000010

08006c88 <fileData_Write_Threshold_HumiA>:
	fileData_Write_Threshold_Component(address_threshold_humi_a, HUMI_A_FLASH_LENGHT, \
 8006c88:	4b04      	ldr	r3, [pc, #16]	; (8006c9c <fileData_Write_Threshold_HumiA+0x14>)
 8006c8a:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8006c8e:	edd3 0a04 	vldr	s1, [r3, #16]
 8006c92:	ed93 0a05 	vldr	s0, [r3, #20]
 8006c96:	f7ff bf29 	b.w	8006aec <fileData_Write_Threshold_Component.constprop.0>
 8006c9a:	bf00      	nop
 8006c9c:	20000010 	.word	0x20000010

08006ca0 <fileData_Read_Threshold_HumiA>:
	fileData_Read_Threshold_Component( address_threshold_humi_a, HUMI_A_FLASH_LENGHT, \
 8006ca0:	4903      	ldr	r1, [pc, #12]	; (8006cb0 <fileData_Read_Threshold_HumiA+0x10>)
 8006ca2:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8006ca6:	f101 0210 	add.w	r2, r1, #16
 8006caa:	3114      	adds	r1, #20
 8006cac:	f7ff bf53 	b.w	8006b56 <fileData_Read_Threshold_Component.constprop.1>
 8006cb0:	20000010 	.word	0x20000010

08006cb4 <fileData_Write_Threshold_TempS>:
	fileData_Write_Threshold_Component(address_threshold_temp_s, TEMP_S_FLASH_LENGHT, \
 8006cb4:	4b04      	ldr	r3, [pc, #16]	; (8006cc8 <fileData_Write_Threshold_TempS+0x14>)
 8006cb6:	f44f 40a0 	mov.w	r0, #20480	; 0x5000
 8006cba:	edd3 0a06 	vldr	s1, [r3, #24]
 8006cbe:	ed93 0a07 	vldr	s0, [r3, #28]
 8006cc2:	f7ff bf13 	b.w	8006aec <fileData_Write_Threshold_Component.constprop.0>
 8006cc6:	bf00      	nop
 8006cc8:	20000010 	.word	0x20000010

08006ccc <fileData_Read_Threshold_TempS>:
	fileData_Read_Threshold_Component( address_threshold_temp_s, TEMP_S_FLASH_LENGHT, \
 8006ccc:	4903      	ldr	r1, [pc, #12]	; (8006cdc <fileData_Read_Threshold_TempS+0x10>)
 8006cce:	f44f 40a0 	mov.w	r0, #20480	; 0x5000
 8006cd2:	f101 0218 	add.w	r2, r1, #24
 8006cd6:	311c      	adds	r1, #28
 8006cd8:	f7ff bf3d 	b.w	8006b56 <fileData_Read_Threshold_Component.constprop.1>
 8006cdc:	20000010 	.word	0x20000010

08006ce0 <fileData_Write_Threshold_HumiS>:
	fileData_Write_Threshold_Component(address_threshold_humi_s, HUMI_S_FLASH_LENGHT, \
 8006ce0:	4b04      	ldr	r3, [pc, #16]	; (8006cf4 <fileData_Write_Threshold_HumiS+0x14>)
 8006ce2:	f44f 40c0 	mov.w	r0, #24576	; 0x6000
 8006ce6:	edd3 0a08 	vldr	s1, [r3, #32]
 8006cea:	ed93 0a09 	vldr	s0, [r3, #36]	; 0x24
 8006cee:	f7ff befd 	b.w	8006aec <fileData_Write_Threshold_Component.constprop.0>
 8006cf2:	bf00      	nop
 8006cf4:	20000010 	.word	0x20000010

08006cf8 <fileData_Read_Threshold_HumiS>:
	fileData_Read_Threshold_Component( address_threshold_humi_s, HUMI_S_FLASH_LENGHT, \
 8006cf8:	4903      	ldr	r1, [pc, #12]	; (8006d08 <fileData_Read_Threshold_HumiS+0x10>)
 8006cfa:	f44f 40c0 	mov.w	r0, #24576	; 0x6000
 8006cfe:	f101 0220 	add.w	r2, r1, #32
 8006d02:	3124      	adds	r1, #36	; 0x24
 8006d04:	f7ff bf27 	b.w	8006b56 <fileData_Read_Threshold_Component.constprop.1>
 8006d08:	20000010 	.word	0x20000010

08006d0c <fileData_Write_Threshold_PH>:
	fileData_Write_Threshold_Component(address_threshold_ph, PH_FLASH_LENGHT, \
 8006d0c:	4b04      	ldr	r3, [pc, #16]	; (8006d20 <fileData_Write_Threshold_PH+0x14>)
 8006d0e:	f44f 40e0 	mov.w	r0, #28672	; 0x7000
 8006d12:	edd3 0a0a 	vldr	s1, [r3, #40]	; 0x28
 8006d16:	ed93 0a0b 	vldr	s0, [r3, #44]	; 0x2c
 8006d1a:	f7ff bee7 	b.w	8006aec <fileData_Write_Threshold_Component.constprop.0>
 8006d1e:	bf00      	nop
 8006d20:	20000010 	.word	0x20000010

08006d24 <fileData_Read_Threshold_PH>:
	fileData_Read_Threshold_Component( address_threshold_ph, PH_FLASH_LENGHT, \
 8006d24:	4903      	ldr	r1, [pc, #12]	; (8006d34 <fileData_Read_Threshold_PH+0x10>)
 8006d26:	f44f 40e0 	mov.w	r0, #28672	; 0x7000
 8006d2a:	f101 0228 	add.w	r2, r1, #40	; 0x28
 8006d2e:	312c      	adds	r1, #44	; 0x2c
 8006d30:	f7ff bf11 	b.w	8006b56 <fileData_Read_Threshold_Component.constprop.1>
 8006d34:	20000010 	.word	0x20000010

08006d38 <fileData_Write_Threshold_EC>:
	fileData_Write_Threshold_Component(address_threshold_ec, EC_FLASH_LENGHT, \
 8006d38:	4b04      	ldr	r3, [pc, #16]	; (8006d4c <fileData_Write_Threshold_EC+0x14>)
 8006d3a:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8006d3e:	edd3 0a0c 	vldr	s1, [r3, #48]	; 0x30
 8006d42:	ed93 0a0d 	vldr	s0, [r3, #52]	; 0x34
 8006d46:	f7ff bed1 	b.w	8006aec <fileData_Write_Threshold_Component.constprop.0>
 8006d4a:	bf00      	nop
 8006d4c:	20000010 	.word	0x20000010

08006d50 <fileData_Read_Threshold_EC>:
	fileData_Read_Threshold_Component( address_threshold_ec, EC_FLASH_LENGHT, \
 8006d50:	4903      	ldr	r1, [pc, #12]	; (8006d60 <fileData_Read_Threshold_EC+0x10>)
 8006d52:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8006d56:	f101 0230 	add.w	r2, r1, #48	; 0x30
 8006d5a:	3134      	adds	r1, #52	; 0x34
 8006d5c:	f7ff befb 	b.w	8006b56 <fileData_Read_Threshold_Component.constprop.1>
 8006d60:	20000010 	.word	0x20000010

08006d64 <fileData_Write_Threshold_Light>:
	fileData_Write_Threshold_Component(address_threshold_light, LIGHT_FLASH_LENGHT, \
 8006d64:	4b04      	ldr	r3, [pc, #16]	; (8006d78 <fileData_Write_Threshold_Light+0x14>)
 8006d66:	f44f 4010 	mov.w	r0, #36864	; 0x9000
 8006d6a:	edd3 0a0e 	vldr	s1, [r3, #56]	; 0x38
 8006d6e:	ed93 0a0f 	vldr	s0, [r3, #60]	; 0x3c
 8006d72:	f7ff bebb 	b.w	8006aec <fileData_Write_Threshold_Component.constprop.0>
 8006d76:	bf00      	nop
 8006d78:	20000010 	.word	0x20000010

08006d7c <fileData_Read_Threshold_Light>:
	fileData_Read_Threshold_Component( address_threshold_light, LIGHT_FLASH_LENGHT, \
 8006d7c:	4903      	ldr	r1, [pc, #12]	; (8006d8c <fileData_Read_Threshold_Light+0x10>)
 8006d7e:	f44f 4010 	mov.w	r0, #36864	; 0x9000
 8006d82:	f101 0238 	add.w	r2, r1, #56	; 0x38
 8006d86:	313c      	adds	r1, #60	; 0x3c
 8006d88:	f7ff bee5 	b.w	8006b56 <fileData_Read_Threshold_Component.constprop.1>
 8006d8c:	20000010 	.word	0x20000010

08006d90 <fileData_Write_Threshold_CO2>:
	fileData_Write_Threshold_Component(address_threshold_co2, CO2_FLASH_LENGHT, \
 8006d90:	4b04      	ldr	r3, [pc, #16]	; (8006da4 <fileData_Write_Threshold_CO2+0x14>)
 8006d92:	f44f 4020 	mov.w	r0, #40960	; 0xa000
 8006d96:	edd3 0a10 	vldr	s1, [r3, #64]	; 0x40
 8006d9a:	ed93 0a11 	vldr	s0, [r3, #68]	; 0x44
 8006d9e:	f7ff bea5 	b.w	8006aec <fileData_Write_Threshold_Component.constprop.0>
 8006da2:	bf00      	nop
 8006da4:	20000010 	.word	0x20000010

08006da8 <fileData_WriteAll>:
{
 8006da8:	b507      	push	{r0, r1, r2, lr}
	APP_DEBUG("--- fileData: write all data\r\n");
 8006daa:	4812      	ldr	r0, [pc, #72]	; (8006df4 <fileData_WriteAll+0x4c>)
 8006dac:	f000 ff76 	bl	8007c9c <puts>
	fileData_Write_Reset();
 8006db0:	f7ff fe84 	bl	8006abc <fileData_Write_Reset>
	Buffwrite[0] = 1;
 8006db4:	a902      	add	r1, sp, #8
	uint8_t Buffwrite[FLAGS_FLASH_LENGHT + 1] = {0};
 8006db6:	2000      	movs	r0, #0
	Buffwrite[0] = 1;
 8006db8:	2201      	movs	r2, #1
	uint8_t Buffwrite[FLAGS_FLASH_LENGHT + 1] = {0};
 8006dba:	f8ad 0004 	strh.w	r0, [sp, #4]
	Buffwrite[0] = 1;
 8006dbe:	f801 2d04 	strb.w	r2, [r1, #-4]!
	Flash_Write_to_Page( address_flags, Buffwrite, FLAGS_FLASH_LENGHT );
 8006dc2:	f7fd ff77 	bl	8004cb4 <Flash_Write_to_Page>
	fileData_Write_SensorCFG();
 8006dc6:	f7ff fee9 	bl	8006b9c <fileData_Write_SensorCFG>
	fileData_Write_DataUT();
 8006dca:	f7ff ff17 	bl	8006bfc <fileData_Write_DataUT>
	fileData_Write_Threshold_TempA();
 8006dce:	f7ff ff45 	bl	8006c5c <fileData_Write_Threshold_TempA>
	fileData_Write_Threshold_HumiA();
 8006dd2:	f7ff ff59 	bl	8006c88 <fileData_Write_Threshold_HumiA>
	fileData_Write_Threshold_TempS();
 8006dd6:	f7ff ff6d 	bl	8006cb4 <fileData_Write_Threshold_TempS>
	fileData_Write_Threshold_HumiS();
 8006dda:	f7ff ff81 	bl	8006ce0 <fileData_Write_Threshold_HumiS>
	fileData_Write_Threshold_PH();
 8006dde:	f7ff ff95 	bl	8006d0c <fileData_Write_Threshold_PH>
	fileData_Write_Threshold_EC();
 8006de2:	f7ff ffa9 	bl	8006d38 <fileData_Write_Threshold_EC>
	fileData_Write_Threshold_Light();
 8006de6:	f7ff ffbd 	bl	8006d64 <fileData_Write_Threshold_Light>
	fileData_Write_Threshold_CO2();
 8006dea:	f7ff ffd1 	bl	8006d90 <fileData_Write_Threshold_CO2>
}
 8006dee:	b003      	add	sp, #12
 8006df0:	f85d fb04 	ldr.w	pc, [sp], #4
 8006df4:	0800d013 	.word	0x0800d013

08006df8 <fileData_Read_Threshold_CO2>:
	fileData_Read_Threshold_Component( address_threshold_co2, CO2_FLASH_LENGHT, \
 8006df8:	4903      	ldr	r1, [pc, #12]	; (8006e08 <fileData_Read_Threshold_CO2+0x10>)
 8006dfa:	f44f 4020 	mov.w	r0, #40960	; 0xa000
 8006dfe:	f101 0240 	add.w	r2, r1, #64	; 0x40
 8006e02:	3144      	adds	r1, #68	; 0x44
 8006e04:	f7ff bea7 	b.w	8006b56 <fileData_Read_Threshold_Component.constprop.1>
 8006e08:	20000010 	.word	0x20000010

08006e0c <fileData_ReadAll>:
{
 8006e0c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006e0e:	b085      	sub	sp, #20
	uint8_t Buffread[FLAGS_FLASH_LENGHT + 1] = {0};
 8006e10:	ad04      	add	r5, sp, #16
 8006e12:	2400      	movs	r4, #0
 8006e14:	f825 4d04 	strh.w	r4, [r5, #-4]!
	Flash_Read( address_flags, Buffread, FLAGS_FLASH_LENGHT );
 8006e18:	2201      	movs	r2, #1
 8006e1a:	4629      	mov	r1, r5
 8006e1c:	4620      	mov	r0, r4
 8006e1e:	f7fd ff41 	bl	8004ca4 <Flash_Read>
	return Buffread[0];
 8006e22:	f89d 300c 	ldrb.w	r3, [sp, #12]
	if( fileData_Read_Flags() != 1 )
 8006e26:	2b01      	cmp	r3, #1
 8006e28:	d001      	beq.n	8006e2e <fileData_ReadAll+0x22>
		fileData_WriteAll();
 8006e2a:	f7ff ffbd 	bl	8006da8 <fileData_WriteAll>
	Flash_Read( address_reset, Buffread, RESET_LENGHT );
 8006e2e:	4629      	mov	r1, r5
 8006e30:	f44f 30c0 	mov.w	r0, #98304	; 0x18000
 8006e34:	2202      	movs	r2, #2
	uint8_t Buffread[RESET_LENGHT + 1] = {0};
 8006e36:	f8ad 400c 	strh.w	r4, [sp, #12]
 8006e3a:	70ac      	strb	r4, [r5, #2]
	Flash_Read( address_reset, Buffread, RESET_LENGHT );
 8006e3c:	f7fd ff32 	bl	8004ca4 <Flash_Read>
	__fileData.ResetCount = (Buffread[0] << 8) | Buffread[1];
 8006e40:	f89d 200c 	ldrb.w	r2, [sp, #12]
 8006e44:	f89d 300d 	ldrb.w	r3, [sp, #13]
 8006e48:	4c5b      	ldr	r4, [pc, #364]	; (8006fb8 <fileData_ReadAll+0x1ac>)
 8006e4a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8006e4e:	8023      	strh	r3, [r4, #0]
	fileData_Write_Reset();
 8006e50:	f7ff fe34 	bl	8006abc <fileData_Write_Reset>
	fileData_Read_Sensor_CFG();
 8006e54:	f7ff feb8 	bl	8006bc8 <fileData_Read_Sensor_CFG>
	fileData_Read_DataUT();
 8006e58:	f7ff fee6 	bl	8006c28 <fileData_Read_DataUT>
	APP_DEBUG("\r\n--- fileData: reset count         = %d\r\n", __fileData.ResetCount);
 8006e5c:	8821      	ldrh	r1, [r4, #0]
 8006e5e:	4857      	ldr	r0, [pc, #348]	; (8006fbc <fileData_ReadAll+0x1b0>)
 8006e60:	f000 fea4 	bl	8007bac <printf>
	APP_DEBUG("--- fileData: Sensor cfg          = 0x%.4x\r\n", __fileData.SensorCfg);
 8006e64:	8861      	ldrh	r1, [r4, #2]
 8006e66:	4856      	ldr	r0, [pc, #344]	; (8006fc0 <fileData_ReadAll+0x1b4>)
 8006e68:	f000 fea0 	bl	8007bac <printf>
	APP_DEBUG("--- fileData: Data UT             = %d\r\n", __fileData.DataUT);
 8006e6c:	88a1      	ldrh	r1, [r4, #4]
 8006e6e:	4855      	ldr	r0, [pc, #340]	; (8006fc4 <fileData_ReadAll+0x1b8>)
 8006e70:	f000 fe9c 	bl	8007bac <printf>
	if( (__fileData.SensorCfg & SS_TempA) == SS_TempA )
 8006e74:	8863      	ldrh	r3, [r4, #2]
 8006e76:	07db      	lsls	r3, r3, #31
 8006e78:	d510      	bpl.n	8006e9c <fileData_ReadAll+0x90>
		fileData_Read_Threshold_TempA();
 8006e7a:	f7ff fefb 	bl	8006c74 <fileData_Read_Threshold_TempA>
		APP_DEBUG("--- fileData: Threshold Temp Air  = %f - %f\r\n", \
 8006e7e:	68e0      	ldr	r0, [r4, #12]
 8006e80:	f7f9 fb72 	bl	8000568 <__aeabi_f2d>
 8006e84:	4606      	mov	r6, r0
 8006e86:	68a0      	ldr	r0, [r4, #8]
 8006e88:	460f      	mov	r7, r1
 8006e8a:	f7f9 fb6d 	bl	8000568 <__aeabi_f2d>
 8006e8e:	4632      	mov	r2, r6
 8006e90:	e9cd 0100 	strd	r0, r1, [sp]
 8006e94:	463b      	mov	r3, r7
 8006e96:	484c      	ldr	r0, [pc, #304]	; (8006fc8 <fileData_ReadAll+0x1bc>)
 8006e98:	f000 fe88 	bl	8007bac <printf>
	if( (__fileData.SensorCfg & SS_HumiA) == SS_HumiA )
 8006e9c:	8863      	ldrh	r3, [r4, #2]
 8006e9e:	079f      	lsls	r7, r3, #30
 8006ea0:	d510      	bpl.n	8006ec4 <fileData_ReadAll+0xb8>
		fileData_Read_Threshold_HumiA();
 8006ea2:	f7ff fefd 	bl	8006ca0 <fileData_Read_Threshold_HumiA>
		APP_DEBUG("--- fileData: Threshold Humi Air  = %f - %f\r\n", \
 8006ea6:	6960      	ldr	r0, [r4, #20]
 8006ea8:	f7f9 fb5e 	bl	8000568 <__aeabi_f2d>
 8006eac:	4606      	mov	r6, r0
 8006eae:	6920      	ldr	r0, [r4, #16]
 8006eb0:	460f      	mov	r7, r1
 8006eb2:	f7f9 fb59 	bl	8000568 <__aeabi_f2d>
 8006eb6:	4632      	mov	r2, r6
 8006eb8:	e9cd 0100 	strd	r0, r1, [sp]
 8006ebc:	463b      	mov	r3, r7
 8006ebe:	4843      	ldr	r0, [pc, #268]	; (8006fcc <fileData_ReadAll+0x1c0>)
 8006ec0:	f000 fe74 	bl	8007bac <printf>
	if( (__fileData.SensorCfg & SS_TempS) == SS_TempS )
 8006ec4:	8863      	ldrh	r3, [r4, #2]
 8006ec6:	075e      	lsls	r6, r3, #29
 8006ec8:	d510      	bpl.n	8006eec <fileData_ReadAll+0xe0>
		fileData_Read_Threshold_TempS();
 8006eca:	f7ff feff 	bl	8006ccc <fileData_Read_Threshold_TempS>
		APP_DEBUG("--- fileData: Threshold Temp Soil = %f - %f\r\n", \
 8006ece:	69e0      	ldr	r0, [r4, #28]
 8006ed0:	f7f9 fb4a 	bl	8000568 <__aeabi_f2d>
 8006ed4:	4606      	mov	r6, r0
 8006ed6:	69a0      	ldr	r0, [r4, #24]
 8006ed8:	460f      	mov	r7, r1
 8006eda:	f7f9 fb45 	bl	8000568 <__aeabi_f2d>
 8006ede:	4632      	mov	r2, r6
 8006ee0:	e9cd 0100 	strd	r0, r1, [sp]
 8006ee4:	463b      	mov	r3, r7
 8006ee6:	483a      	ldr	r0, [pc, #232]	; (8006fd0 <fileData_ReadAll+0x1c4>)
 8006ee8:	f000 fe60 	bl	8007bac <printf>
	if( (__fileData.SensorCfg & SS_HumiS) == SS_HumiS )
 8006eec:	8863      	ldrh	r3, [r4, #2]
 8006eee:	071d      	lsls	r5, r3, #28
 8006ef0:	d510      	bpl.n	8006f14 <fileData_ReadAll+0x108>
		fileData_Read_Threshold_HumiS();
 8006ef2:	f7ff ff01 	bl	8006cf8 <fileData_Read_Threshold_HumiS>
		APP_DEBUG("--- fileData: Threshold Humi Soil = %f - %f\r\n", \
 8006ef6:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8006ef8:	f7f9 fb36 	bl	8000568 <__aeabi_f2d>
 8006efc:	4606      	mov	r6, r0
 8006efe:	6a20      	ldr	r0, [r4, #32]
 8006f00:	460f      	mov	r7, r1
 8006f02:	f7f9 fb31 	bl	8000568 <__aeabi_f2d>
 8006f06:	4632      	mov	r2, r6
 8006f08:	e9cd 0100 	strd	r0, r1, [sp]
 8006f0c:	463b      	mov	r3, r7
 8006f0e:	4831      	ldr	r0, [pc, #196]	; (8006fd4 <fileData_ReadAll+0x1c8>)
 8006f10:	f000 fe4c 	bl	8007bac <printf>
	if( (__fileData.SensorCfg & SS_pH) == SS_pH )
 8006f14:	8863      	ldrh	r3, [r4, #2]
 8006f16:	06d8      	lsls	r0, r3, #27
 8006f18:	d510      	bpl.n	8006f3c <fileData_ReadAll+0x130>
		fileData_Read_Threshold_PH();
 8006f1a:	f7ff ff03 	bl	8006d24 <fileData_Read_Threshold_PH>
		APP_DEBUG("--- fileData: Threshold PH        = %f - %f\r\n", \
 8006f1e:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8006f20:	f7f9 fb22 	bl	8000568 <__aeabi_f2d>
 8006f24:	4606      	mov	r6, r0
 8006f26:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8006f28:	460f      	mov	r7, r1
 8006f2a:	f7f9 fb1d 	bl	8000568 <__aeabi_f2d>
 8006f2e:	4632      	mov	r2, r6
 8006f30:	e9cd 0100 	strd	r0, r1, [sp]
 8006f34:	463b      	mov	r3, r7
 8006f36:	4828      	ldr	r0, [pc, #160]	; (8006fd8 <fileData_ReadAll+0x1cc>)
 8006f38:	f000 fe38 	bl	8007bac <printf>
	if( (__fileData.SensorCfg & SS_EC) == SS_EC )
 8006f3c:	8863      	ldrh	r3, [r4, #2]
 8006f3e:	0699      	lsls	r1, r3, #26
 8006f40:	d510      	bpl.n	8006f64 <fileData_ReadAll+0x158>
		fileData_Read_Threshold_EC();
 8006f42:	f7ff ff05 	bl	8006d50 <fileData_Read_Threshold_EC>
		APP_DEBUG("--- fileData: Threshold EC        = %f - %f\r\n", \
 8006f46:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8006f48:	f7f9 fb0e 	bl	8000568 <__aeabi_f2d>
 8006f4c:	4606      	mov	r6, r0
 8006f4e:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8006f50:	460f      	mov	r7, r1
 8006f52:	f7f9 fb09 	bl	8000568 <__aeabi_f2d>
 8006f56:	4632      	mov	r2, r6
 8006f58:	e9cd 0100 	strd	r0, r1, [sp]
 8006f5c:	463b      	mov	r3, r7
 8006f5e:	481f      	ldr	r0, [pc, #124]	; (8006fdc <fileData_ReadAll+0x1d0>)
 8006f60:	f000 fe24 	bl	8007bac <printf>
	if( (__fileData.SensorCfg & SS_Light) == SS_Light )
 8006f64:	8863      	ldrh	r3, [r4, #2]
 8006f66:	065a      	lsls	r2, r3, #25
 8006f68:	d510      	bpl.n	8006f8c <fileData_ReadAll+0x180>
		fileData_Read_Threshold_Light();
 8006f6a:	f7ff ff07 	bl	8006d7c <fileData_Read_Threshold_Light>
		APP_DEBUG("--- fileData: Threshold Light     = %f - %f\r\n", \
 8006f6e:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8006f70:	f7f9 fafa 	bl	8000568 <__aeabi_f2d>
 8006f74:	4606      	mov	r6, r0
 8006f76:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8006f78:	460f      	mov	r7, r1
 8006f7a:	f7f9 faf5 	bl	8000568 <__aeabi_f2d>
 8006f7e:	4632      	mov	r2, r6
 8006f80:	e9cd 0100 	strd	r0, r1, [sp]
 8006f84:	463b      	mov	r3, r7
 8006f86:	4816      	ldr	r0, [pc, #88]	; (8006fe0 <fileData_ReadAll+0x1d4>)
 8006f88:	f000 fe10 	bl	8007bac <printf>
	if( (__fileData.SensorCfg & SS_CO2) == SS_CO2 )
 8006f8c:	8863      	ldrh	r3, [r4, #2]
 8006f8e:	061b      	lsls	r3, r3, #24
 8006f90:	d510      	bpl.n	8006fb4 <fileData_ReadAll+0x1a8>
		fileData_Read_Threshold_CO2();
 8006f92:	f7ff ff31 	bl	8006df8 <fileData_Read_Threshold_CO2>
		APP_DEBUG("--- fileData: Threshold CO2       = %f - %f\r\n", \
 8006f96:	6c60      	ldr	r0, [r4, #68]	; 0x44
 8006f98:	f7f9 fae6 	bl	8000568 <__aeabi_f2d>
 8006f9c:	4606      	mov	r6, r0
 8006f9e:	6c20      	ldr	r0, [r4, #64]	; 0x40
 8006fa0:	460f      	mov	r7, r1
 8006fa2:	f7f9 fae1 	bl	8000568 <__aeabi_f2d>
 8006fa6:	4632      	mov	r2, r6
 8006fa8:	e9cd 0100 	strd	r0, r1, [sp]
 8006fac:	463b      	mov	r3, r7
 8006fae:	480d      	ldr	r0, [pc, #52]	; (8006fe4 <fileData_ReadAll+0x1d8>)
 8006fb0:	f000 fdfc 	bl	8007bac <printf>
}
 8006fb4:	b005      	add	sp, #20
 8006fb6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8006fb8:	20000010 	.word	0x20000010
 8006fbc:	0800ce22 	.word	0x0800ce22
 8006fc0:	0800ce4d 	.word	0x0800ce4d
 8006fc4:	0800ce7a 	.word	0x0800ce7a
 8006fc8:	0800cea3 	.word	0x0800cea3
 8006fcc:	0800ced1 	.word	0x0800ced1
 8006fd0:	0800ceff 	.word	0x0800ceff
 8006fd4:	0800cf2d 	.word	0x0800cf2d
 8006fd8:	0800cf5b 	.word	0x0800cf5b
 8006fdc:	0800cf89 	.word	0x0800cf89
 8006fe0:	0800cfb7 	.word	0x0800cfb7
 8006fe4:	0800cfe5 	.word	0x0800cfe5

08006fe8 <SystemClock_Config>:
 * Description	: System Clock Configuration
 * Param		: None
 * Return		: None
 * ***************************************************************************/
void SystemClock_Config(void)
{
 8006fe8:	b500      	push	{lr}
 8006fea:	b0b9      	sub	sp, #228	; 0xe4
	RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8006fec:	2244      	movs	r2, #68	; 0x44
 8006fee:	2100      	movs	r1, #0
 8006ff0:	a806      	add	r0, sp, #24
 8006ff2:	f000 fdc6 	bl	8007b82 <memset>
	RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8006ff6:	2214      	movs	r2, #20
 8006ff8:	2100      	movs	r1, #0
 8006ffa:	a801      	add	r0, sp, #4
 8006ffc:	f000 fdc1 	bl	8007b82 <memset>
	RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8007000:	2284      	movs	r2, #132	; 0x84
 8007002:	2100      	movs	r1, #0
 8007004:	a817      	add	r0, sp, #92	; 0x5c
 8007006:	f000 fdbc 	bl	8007b82 <memset>

	/**Initializes the CPU, AHB and APB busses clocks
	*/
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
 800700a:	2310      	movs	r3, #16
 800700c:	9306      	str	r3, [sp, #24]
	RCC_OscInitStruct.MSIState = RCC_MSI_ON;
 800700e:	2301      	movs	r3, #1
 8007010:	930c      	str	r3, [sp, #48]	; 0x30
	RCC_OscInitStruct.MSICalibrationValue = 0;
	RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
	if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8007012:	a806      	add	r0, sp, #24
	RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
 8007014:	2360      	movs	r3, #96	; 0x60
 8007016:	930e      	str	r3, [sp, #56]	; 0x38
	if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8007018:	f7fa ffc8 	bl	8001fac <HAL_RCC_OscConfig>
 800701c:	b110      	cbz	r0, 8007024 <SystemClock_Config+0x3c>
		APP_DEBUG("--- Main: HAL_RCC_OscConfig error\r\n");
 800701e:	481d      	ldr	r0, [pc, #116]	; (8007094 <SystemClock_Config+0xac>)
 8007020:	f000 fe3c 	bl	8007c9c <puts>

	/**Initializes the CPU, AHB and APB busses clocks
	*/
	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
						  |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI;
 8007024:	2100      	movs	r1, #0
	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8007026:	230f      	movs	r3, #15
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

	if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
 8007028:	a801      	add	r0, sp, #4
	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 800702a:	9301      	str	r3, [sp, #4]
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI;
 800702c:	9102      	str	r1, [sp, #8]
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 800702e:	9103      	str	r1, [sp, #12]
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 8007030:	9104      	str	r1, [sp, #16]
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8007032:	9105      	str	r1, [sp, #20]
	if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
 8007034:	f7fb f9e0 	bl	80023f8 <HAL_RCC_ClockConfig>
 8007038:	b110      	cbz	r0, 8007040 <SystemClock_Config+0x58>
		APP_DEBUG("--- Main: HAL_RCC_ClockConfig error\r\n");
 800703a:	4817      	ldr	r0, [pc, #92]	; (8007098 <SystemClock_Config+0xb0>)
 800703c:	f000 fe2e 	bl	8007c9c <puts>

	PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1|RCC_PERIPHCLK_USART3 | RCC_PERIPHCLK_UART5|RCC_PERIPHCLK_I2C1 | RCC_PERIPHCLK_ADC;
 8007040:	f244 0355 	movw	r3, #16469	; 0x4055
 8007044:	9317      	str	r3, [sp, #92]	; 0x5c
	PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2;
 8007046:	2300      	movs	r3, #0
 8007048:	9325      	str	r3, [sp, #148]	; 0x94
	PeriphClkInit.Usart3ClockSelection = RCC_USART3CLKSOURCE_PCLK1;
 800704a:	9327      	str	r3, [sp, #156]	; 0x9c
	PeriphClkInit.Uart5ClockSelection = RCC_UART5CLKSOURCE_PCLK1;
 800704c:	9329      	str	r3, [sp, #164]	; 0xa4
	PeriphClkInit.I2c1ClockSelection = RCC_I2C1CLKSOURCE_PCLK1;
 800704e:	932b      	str	r3, [sp, #172]	; 0xac
	PeriphClkInit.AdcClockSelection = RCC_ADCCLKSOURCE_PLLSAI1;
 8007050:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8007054:	9334      	str	r3, [sp, #208]	; 0xd0
	PeriphClkInit.PLLSAI1.PLLSAI1Source = RCC_PLLSOURCE_MSI;
 8007056:	2301      	movs	r3, #1
 8007058:	9318      	str	r3, [sp, #96]	; 0x60
	PeriphClkInit.PLLSAI1.PLLSAI1M = 1;
 800705a:	9319      	str	r3, [sp, #100]	; 0x64
	PeriphClkInit.PLLSAI1.PLLSAI1N = 16;
 800705c:	2310      	movs	r3, #16
 800705e:	931a      	str	r3, [sp, #104]	; 0x68
	PeriphClkInit.PLLSAI1.PLLSAI1P = RCC_PLLP_DIV7;
 8007060:	2307      	movs	r3, #7
 8007062:	931b      	str	r3, [sp, #108]	; 0x6c
	PeriphClkInit.PLLSAI1.PLLSAI1Q = RCC_PLLQ_DIV2;
 8007064:	2302      	movs	r3, #2
 8007066:	931c      	str	r3, [sp, #112]	; 0x70
	PeriphClkInit.PLLSAI1.PLLSAI1R = RCC_PLLR_DIV2;
 8007068:	931d      	str	r3, [sp, #116]	; 0x74
	PeriphClkInit.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_ADC1CLK;
	if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 800706a:	a817      	add	r0, sp, #92	; 0x5c
	PeriphClkInit.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_ADC1CLK;
 800706c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8007070:	931e      	str	r3, [sp, #120]	; 0x78
	if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8007072:	f7fb fb83 	bl	800277c <HAL_RCCEx_PeriphCLKConfig>
 8007076:	b110      	cbz	r0, 800707e <SystemClock_Config+0x96>
		APP_DEBUG("--- Main: HAL_RCCEx_PeriphCLKConfig error\r\n");
 8007078:	4808      	ldr	r0, [pc, #32]	; (800709c <SystemClock_Config+0xb4>)
 800707a:	f000 fe0f 	bl	8007c9c <puts>

	/**Configure the main internal regulator output voltage
	*/
	if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
 800707e:	f44f 7000 	mov.w	r0, #512	; 0x200
 8007082:	f7fa fec7 	bl	8001e14 <HAL_PWREx_ControlVoltageScaling>
 8007086:	b110      	cbz	r0, 800708e <SystemClock_Config+0xa6>
		APP_DEBUG("--- Main: HAL_PWREx_ControlVoltageScaling error\r\n");
 8007088:	4805      	ldr	r0, [pc, #20]	; (80070a0 <SystemClock_Config+0xb8>)
 800708a:	f000 fe07 	bl	8007c9c <puts>
}
 800708e:	b039      	add	sp, #228	; 0xe4
 8007090:	f85d fb04 	ldr.w	pc, [sp], #4
 8007094:	0800d031 	.word	0x0800d031
 8007098:	0800d054 	.word	0x0800d054
 800709c:	0800d079 	.word	0x0800d079
 80070a0:	0800d0a4 	.word	0x0800d0a4

080070a4 <main>:
{
 80070a4:	b580      	push	{r7, lr}
 80070a6:	b0a0      	sub	sp, #128	; 0x80
	HAL_Init();
 80070a8:	f7f9 ff7a 	bl	8000fa0 <HAL_Init>
	SystemClock_Config();
 80070ac:	f7ff ff9c 	bl	8006fe8 <SystemClock_Config>
	GPIO_Init();
 80070b0:	f7fe fb9a 	bl	80057e8 <GPIO_Init>
	Uart_Open( &_Uart1_Debug, USART1, 115200 );
 80070b4:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
 80070b8:	4962      	ldr	r1, [pc, #392]	; (8007244 <main+0x1a0>)
 80070ba:	4863      	ldr	r0, [pc, #396]	; (8007248 <main+0x1a4>)
	_TaskHandle.ProcessTask_Handle = osThreadCreate(osThread(ProcessTask), NULL);
 80070bc:	4f63      	ldr	r7, [pc, #396]	; (800724c <main+0x1a8>)
	Uart_Open( &_Uart1_Debug, USART1, 115200 );
 80070be:	f7fe fcd9 	bl	8005a74 <Uart_Open>
	Uart_Open( &_Uart3_SOIL, USART3, 9600 );
 80070c2:	4963      	ldr	r1, [pc, #396]	; (8007250 <main+0x1ac>)
 80070c4:	4863      	ldr	r0, [pc, #396]	; (8007254 <main+0x1b0>)
 80070c6:	f44f 5216 	mov.w	r2, #9600	; 0x2580
 80070ca:	f7fe fcd3 	bl	8005a74 <Uart_Open>
	I2C1_SS_Init();
 80070ce:	f7fe fc0d 	bl	80058ec <I2C1_SS_Init>
	IOControl_Init();
 80070d2:	f7fe fad5 	bl	8005680 <IOControl_Init>
	APP_DEBUG("\r\n****************** smartfarm sensor v%.1f ******************\r\n", 1.0);
 80070d6:	4b60      	ldr	r3, [pc, #384]	; (8007258 <main+0x1b4>)
 80070d8:	4860      	ldr	r0, [pc, #384]	; (800725c <main+0x1b8>)
 80070da:	2200      	movs	r2, #0
 80070dc:	f000 fd66 	bl	8007bac <printf>
 * Param		: None
 * Return		: None
 * ***************************************************************************/
static void Main_getUID( uint8_t *UID )
{
	uint8_t Hex64[65] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz=@";
 80070e0:	2241      	movs	r2, #65	; 0x41
 80070e2:	495f      	ldr	r1, [pc, #380]	; (8007260 <main+0x1bc>)
 80070e4:	a80f      	add	r0, sp, #60	; 0x3c
 80070e6:	f000 fd41 	bl	8007b6c <memcpy>
	uint8_t index = 0;
	uint32_t Unique_ID_Low = HAL_GetUIDw0();
 80070ea:	f7f9 ff85 	bl	8000ff8 <HAL_GetUIDw0>
 80070ee:	4605      	mov	r5, r0
	uint32_t Unique_ID_Mid = HAL_GetUIDw1();
 80070f0:	f7f9 ff88 	bl	8001004 <HAL_GetUIDw1>
 80070f4:	4604      	mov	r4, r0
	uint32_t Unique_ID_High = HAL_GetUIDw2();
 80070f6:	f7f9 ff8b 	bl	8001010 <HAL_GetUIDw2>

	UID[index++] = Hex64[ ((Unique_ID_Low >> 0) & 0xFFF) / 64 ];
 80070fa:	aa20      	add	r2, sp, #128	; 0x80
 80070fc:	f3c5 1385 	ubfx	r3, r5, #6, #6
 8007100:	4413      	add	r3, r2
 8007102:	4958      	ldr	r1, [pc, #352]	; (8007264 <main+0x1c0>)
 8007104:	f813 3c44 	ldrb.w	r3, [r3, #-68]
 8007108:	700b      	strb	r3, [r1, #0]
	UID[index++] = Hex64[ ((Unique_ID_Low >> 0) & 0xFFF) % 64 ];
 800710a:	f005 033f 	and.w	r3, r5, #63	; 0x3f
 800710e:	4413      	add	r3, r2
	osThreadDef(ProcessTask, ProcessTask, osPriorityHigh, 0, 1500);
 8007110:	466e      	mov	r6, sp
	UID[index++] = Hex64[ ((Unique_ID_Low >> 0) & 0xFFF) % 64 ];
 8007112:	f813 3c44 	ldrb.w	r3, [r3, #-68]
 8007116:	704b      	strb	r3, [r1, #1]
	UID[index++] = Hex64[ ((Unique_ID_Low >> 12) & 0xFFF) / 64 ];
 8007118:	f3c5 4385 	ubfx	r3, r5, #18, #6
 800711c:	4413      	add	r3, r2
 800711e:	f813 3c44 	ldrb.w	r3, [r3, #-68]
 8007122:	708b      	strb	r3, [r1, #2]
	UID[index++] = Hex64[ ((Unique_ID_Low >> 12) & 0xFFF) % 64 ];
 8007124:	f3c5 3305 	ubfx	r3, r5, #12, #6
 8007128:	4413      	add	r3, r2

	UID[index++] = Hex64[ (((Unique_ID_Low >> 24) & 0xFF) | ((Unique_ID_Mid << 8) & 0xF00)) / 64 ];
 800712a:	0222      	lsls	r2, r4, #8
	UID[index++] = Hex64[ ((Unique_ID_Low >> 12) & 0xFFF) % 64 ];
 800712c:	f813 3c44 	ldrb.w	r3, [r3, #-68]
 8007130:	70cb      	strb	r3, [r1, #3]
	UID[index++] = Hex64[ (((Unique_ID_Low >> 24) & 0xFF) | ((Unique_ID_Mid << 8) & 0xF00)) / 64 ];
 8007132:	f402 6270 	and.w	r2, r2, #3840	; 0xf00
 8007136:	ea42 6215 	orr.w	r2, r2, r5, lsr #24
 800713a:	ab20      	add	r3, sp, #128	; 0x80
 800713c:	eb03 1392 	add.w	r3, r3, r2, lsr #6
	UID[index++] = Hex64[ (((Unique_ID_Low >> 24) & 0xFF) | ((Unique_ID_Mid << 8) & 0xF00)) % 64 ];
 8007140:	f002 023f 	and.w	r2, r2, #63	; 0x3f
	UID[index++] = Hex64[ (((Unique_ID_Low >> 24) & 0xFF) | ((Unique_ID_Mid << 8) & 0xF00)) / 64 ];
 8007144:	f813 3c44 	ldrb.w	r3, [r3, #-68]
 8007148:	710b      	strb	r3, [r1, #4]
	UID[index++] = Hex64[ (((Unique_ID_Low >> 24) & 0xFF) | ((Unique_ID_Mid << 8) & 0xF00)) % 64 ];
 800714a:	ab20      	add	r3, sp, #128	; 0x80
 800714c:	441a      	add	r2, r3
 800714e:	f812 3c44 	ldrb.w	r3, [r2, #-68]
 8007152:	714b      	strb	r3, [r1, #5]
	UID[index++] = Hex64[ ((Unique_ID_Mid >> 4) & 0xFFF) / 64 ];
 8007154:	aa20      	add	r2, sp, #128	; 0x80
 8007156:	f3c4 2385 	ubfx	r3, r4, #10, #6
 800715a:	4413      	add	r3, r2
 800715c:	f813 3c44 	ldrb.w	r3, [r3, #-68]
 8007160:	718b      	strb	r3, [r1, #6]
	UID[index++] = Hex64[ ((Unique_ID_Mid >> 4) & 0xFFF) % 64 ];
 8007162:	f3c4 1305 	ubfx	r3, r4, #4, #6
 8007166:	4413      	add	r3, r2
 8007168:	f813 3c44 	ldrb.w	r3, [r3, #-68]
 800716c:	71cb      	strb	r3, [r1, #7]
	UID[index++] = Hex64[ ((Unique_ID_Mid >> 16) & 0xFFF) / 64 ];
 800716e:	f3c4 5385 	ubfx	r3, r4, #22, #6
 8007172:	4413      	add	r3, r2
 8007174:	f813 3c44 	ldrb.w	r3, [r3, #-68]
 8007178:	720b      	strb	r3, [r1, #8]
	UID[index++] = Hex64[ ((Unique_ID_Mid >> 16) & 0xFFF) % 64 ];
 800717a:	f3c4 4305 	ubfx	r3, r4, #16, #6
 800717e:	4413      	add	r3, r2
 8007180:	f813 3c44 	ldrb.w	r3, [r3, #-68]
 8007184:	724b      	strb	r3, [r1, #9]

	UID[index++] = Hex64[ (((Unique_ID_Mid >> 28) & 0xF) | ((Unique_ID_High << 4) & 0xFF0)) / 64 ];
 8007186:	0103      	lsls	r3, r0, #4
 8007188:	f403 637f 	and.w	r3, r3, #4080	; 0xff0
 800718c:	ea43 7314 	orr.w	r3, r3, r4, lsr #28
 8007190:	eb02 1293 	add.w	r2, r2, r3, lsr #6
	UID[index++] = Hex64[ (((Unique_ID_Mid >> 28) & 0xF) | ((Unique_ID_High << 4) & 0xFF0)) % 64 ];
 8007194:	f003 033f 	and.w	r3, r3, #63	; 0x3f
	UID[index++] = Hex64[ (((Unique_ID_Mid >> 28) & 0xF) | ((Unique_ID_High << 4) & 0xFF0)) / 64 ];
 8007198:	f812 2c44 	ldrb.w	r2, [r2, #-68]
 800719c:	728a      	strb	r2, [r1, #10]
	UID[index++] = Hex64[ (((Unique_ID_Mid >> 28) & 0xF) | ((Unique_ID_High << 4) & 0xFF0)) % 64 ];
 800719e:	aa20      	add	r2, sp, #128	; 0x80
 80071a0:	4413      	add	r3, r2
	osThreadDef(ProcessTask, ProcessTask, osPriorityHigh, 0, 1500);
 80071a2:	4c31      	ldr	r4, [pc, #196]	; (8007268 <main+0x1c4>)
	UID[index++] = Hex64[ (((Unique_ID_Mid >> 28) & 0xF) | ((Unique_ID_High << 4) & 0xFF0)) % 64 ];
 80071a4:	f813 3c44 	ldrb.w	r3, [r3, #-68]
 80071a8:	72cb      	strb	r3, [r1, #11]
	UID[index++] = Hex64[ ((Unique_ID_High >> 8) & 0xFFF) / 64 ];
 80071aa:	f3c0 3385 	ubfx	r3, r0, #14, #6
 80071ae:	4413      	add	r3, r2
 80071b0:	f813 3c44 	ldrb.w	r3, [r3, #-68]
 80071b4:	730b      	strb	r3, [r1, #12]
	UID[index++] = Hex64[ ((Unique_ID_High >> 8) & 0xFFF) % 64 ];
 80071b6:	f3c0 2305 	ubfx	r3, r0, #8, #6
 80071ba:	4413      	add	r3, r2
 80071bc:	f813 3c44 	ldrb.w	r3, [r3, #-68]
 80071c0:	734b      	strb	r3, [r1, #13]
	UID[index++] = Hex64[ ((Unique_ID_High >> 20) & 0xFFF) / 64 ];
 80071c2:	eb02 6390 	add.w	r3, r2, r0, lsr #26
	UID[index++] = Hex64[ ((Unique_ID_High >> 20) & 0xFFF) % 64 ];
 80071c6:	f3c0 5005 	ubfx	r0, r0, #20, #6
 80071ca:	4410      	add	r0, r2
	UID[index++] = Hex64[ ((Unique_ID_High >> 20) & 0xFFF) / 64 ];
 80071cc:	f813 3c44 	ldrb.w	r3, [r3, #-68]
 80071d0:	738b      	strb	r3, [r1, #14]
	UID[index++] = Hex64[ ((Unique_ID_High >> 20) & 0xFFF) % 64 ];
 80071d2:	f810 3c44 	ldrb.w	r3, [r0, #-68]
 80071d6:	73cb      	strb	r3, [r1, #15]
	APP_DEBUG("--- Main: serial number = %s\r\n", SerialNumber);
 80071d8:	4824      	ldr	r0, [pc, #144]	; (800726c <main+0x1c8>)
 80071da:	f000 fce7 	bl	8007bac <printf>
	fileData_Init();
 80071de:	f7ff fcdb 	bl	8006b98 <fileData_Init>
	fileData_ReadAll();
 80071e2:	f7ff fe13 	bl	8006e0c <fileData_ReadAll>
	osThreadDef(ProcessTask, ProcessTask, osPriorityHigh, 0, 1500);
 80071e6:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80071e8:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 80071ea:	4625      	mov	r5, r4
	_TaskHandle.ProcessTask_Handle = osThreadCreate(osThread(ProcessTask), NULL);
 80071ec:	2100      	movs	r1, #0
	osThreadDef(ProcessTask, ProcessTask, osPriorityHigh, 0, 1500);
 80071ee:	f855 3b04 	ldr.w	r3, [r5], #4
 80071f2:	6033      	str	r3, [r6, #0]
	_TaskHandle.ProcessTask_Handle = osThreadCreate(osThread(ProcessTask), NULL);
 80071f4:	4668      	mov	r0, sp
 80071f6:	f7fc fe4d 	bl	8003e94 <osThreadCreate>
 80071fa:	6038      	str	r0, [r7, #0]
	osThreadDef(LoraTask, LoraTask, osPriorityNormal, 0, 1200);
 80071fc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80071fe:	ae05      	add	r6, sp, #20
 8007200:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8007202:	682b      	ldr	r3, [r5, #0]
 8007204:	6033      	str	r3, [r6, #0]
	_TaskHandle.LoraTask_Handle = osThreadCreate(osThread(LoraTask), NULL);
 8007206:	2100      	movs	r1, #0
 8007208:	a805      	add	r0, sp, #20
 800720a:	f7fc fe43 	bl	8003e94 <osThreadCreate>
	osThreadDef(SensorTask, SensorTask, osPriorityNormal, 0, 512);
 800720e:	f104 0618 	add.w	r6, r4, #24
	_TaskHandle.LoraTask_Handle = osThreadCreate(osThread(LoraTask), NULL);
 8007212:	6078      	str	r0, [r7, #4]
	osThreadDef(SensorTask, SensorTask, osPriorityNormal, 0, 512);
 8007214:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8007216:	ad0a      	add	r5, sp, #40	; 0x28
 8007218:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800721a:	6833      	ldr	r3, [r6, #0]
 800721c:	602b      	str	r3, [r5, #0]
	_TaskHandle.SensorTask_Handle = osThreadCreate(osThread(SensorTask), NULL);
 800721e:	2100      	movs	r1, #0
 8007220:	a80a      	add	r0, sp, #40	; 0x28
 8007222:	f7fc fe37 	bl	8003e94 <osThreadCreate>
	osThreadDef(OTATask, OTATask, osPriorityAboveNormal, 0, 1024);
 8007226:	342c      	adds	r4, #44	; 0x2c
	_TaskHandle.SensorTask_Handle = osThreadCreate(osThread(SensorTask), NULL);
 8007228:	60b8      	str	r0, [r7, #8]
	osThreadDef(OTATask, OTATask, osPriorityAboveNormal, 0, 1024);
 800722a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800722c:	ad0f      	add	r5, sp, #60	; 0x3c
 800722e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8007230:	6823      	ldr	r3, [r4, #0]
 8007232:	602b      	str	r3, [r5, #0]
	_TaskHandle.OTATask_Handle = osThreadCreate(osThread(OTATask), NULL);
 8007234:	2100      	movs	r1, #0
 8007236:	a80f      	add	r0, sp, #60	; 0x3c
 8007238:	f7fc fe2c 	bl	8003e94 <osThreadCreate>
 800723c:	60f8      	str	r0, [r7, #12]
	osKernelStart();
 800723e:	f7fc fe24 	bl	8003e8a <osKernelStart>
 8007242:	e7fe      	b.n	8007242 <main+0x19e>
 8007244:	40013800 	.word	0x40013800
 8007248:	20008c40 	.word	0x20008c40
 800724c:	20008cc8 	.word	0x20008cc8
 8007250:	40004800 	.word	0x40004800
 8007254:	20008ce4 	.word	0x20008ce4
 8007258:	3ff00000 	.word	0x3ff00000
 800725c:	0800d0d5 	.word	0x0800d0d5
 8007260:	0800d135 	.word	0x0800d135
 8007264:	200084b0 	.word	0x200084b0
 8007268:	0800c4e0 	.word	0x0800c4e0
 800726c:	0800d116 	.word	0x0800d116

08007270 <__io_putchar>:
  * @brief  Retargets the C library printf function to the USART.
  * @param  None
  * @retval None
  */
PUTCHAR_PROTOTYPE
{
 8007270:	b507      	push	{r0, r1, r2, lr}
 8007272:	a902      	add	r1, sp, #8
	//HAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1, 0xFFFF);
	HAL_UART_Transmit(&_Uart1_Debug._UartHandle, (uint8_t *)&ch, 1, 0xFF); // send message via UART
 8007274:	23ff      	movs	r3, #255	; 0xff
{
 8007276:	f841 0d04 	str.w	r0, [r1, #-4]!
	HAL_UART_Transmit(&_Uart1_Debug._UartHandle, (uint8_t *)&ch, 1, 0xFF); // send message via UART
 800727a:	2201      	movs	r2, #1
 800727c:	4803      	ldr	r0, [pc, #12]	; (800728c <__io_putchar+0x1c>)
 800727e:	f7fc fcda 	bl	8003c36 <HAL_UART_Transmit>
	return ch;
}
 8007282:	9801      	ldr	r0, [sp, #4]
 8007284:	b003      	add	sp, #12
 8007286:	f85d fb04 	ldr.w	pc, [sp], #4
 800728a:	bf00      	nop
 800728c:	20008c40 	.word	0x20008c40

08007290 <HAL_MspInit>:
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8007290:	4b0e      	ldr	r3, [pc, #56]	; (80072cc <HAL_MspInit+0x3c>)
{
 8007292:	b507      	push	{r0, r1, r2, lr}
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8007294:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8007296:	f042 0201 	orr.w	r2, r2, #1
 800729a:	661a      	str	r2, [r3, #96]	; 0x60
 800729c:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800729e:	f002 0201 	and.w	r2, r2, #1
 80072a2:	9200      	str	r2, [sp, #0]
 80072a4:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 80072a6:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80072a8:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80072ac:	659a      	str	r2, [r3, #88]	; 0x58
 80072ae:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80072b0:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80072b4:	9301      	str	r3, [sp, #4]

  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 80072b6:	2200      	movs	r2, #0
 80072b8:	210f      	movs	r1, #15
 80072ba:	f06f 0001 	mvn.w	r0, #1
  __HAL_RCC_PWR_CLK_ENABLE();
 80072be:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 80072c0:	f7fa fbc2 	bl	8001a48 <HAL_NVIC_SetPriority>
}
 80072c4:	b003      	add	sp, #12
 80072c6:	f85d fb04 	ldr.w	pc, [sp], #4
 80072ca:	bf00      	nop
 80072cc:	40021000 	.word	0x40021000

080072d0 <HAL_ADC_MspInit>:




void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
{
 80072d0:	b510      	push	{r4, lr}
 80072d2:	4604      	mov	r4, r0
 80072d4:	b088      	sub	sp, #32

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80072d6:	2214      	movs	r2, #20
 80072d8:	2100      	movs	r1, #0
 80072da:	a803      	add	r0, sp, #12
 80072dc:	f000 fc51 	bl	8007b82 <memset>
  if(hadc->Instance==ADC1)
 80072e0:	6822      	ldr	r2, [r4, #0]
 80072e2:	4b11      	ldr	r3, [pc, #68]	; (8007328 <HAL_ADC_MspInit+0x58>)
 80072e4:	429a      	cmp	r2, r3
 80072e6:	d11d      	bne.n	8007324 <HAL_ADC_MspInit+0x54>
  {
  /* USER CODE BEGIN ADC1_MspInit 0 */

  /* USER CODE END ADC1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_ADC_CLK_ENABLE();
 80072e8:	f103 4370 	add.w	r3, r3, #4026531840	; 0xf0000000
 80072ec:	f5a3 33f8 	sub.w	r3, r3, #126976	; 0x1f000
    */
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3 
                          |GPIO_PIN_4|GPIO_PIN_5;
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG_ADC_CONTROL;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80072f0:	a903      	add	r1, sp, #12
    __HAL_RCC_ADC_CLK_ENABLE();
 80072f2:	6cda      	ldr	r2, [r3, #76]	; 0x4c
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80072f4:	480d      	ldr	r0, [pc, #52]	; (800732c <HAL_ADC_MspInit+0x5c>)
    __HAL_RCC_ADC_CLK_ENABLE();
 80072f6:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 80072fa:	64da      	str	r2, [r3, #76]	; 0x4c
 80072fc:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80072fe:	f402 5200 	and.w	r2, r2, #8192	; 0x2000
 8007302:	9201      	str	r2, [sp, #4]
 8007304:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8007306:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8007308:	f042 0204 	orr.w	r2, r2, #4
 800730c:	64da      	str	r2, [r3, #76]	; 0x4c
 800730e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8007310:	f003 0304 	and.w	r3, r3, #4
 8007314:	9302      	str	r3, [sp, #8]
 8007316:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3 
 8007318:	233f      	movs	r3, #63	; 0x3f
 800731a:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG_ADC_CONTROL;
 800731c:	230b      	movs	r3, #11
 800731e:	9304      	str	r3, [sp, #16]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8007320:	f7fa fbe8 	bl	8001af4 <HAL_GPIO_Init>
  /* USER CODE BEGIN ADC1_MspInit 1 */

  /* USER CODE END ADC1_MspInit 1 */
  }

}
 8007324:	b008      	add	sp, #32
 8007326:	bd10      	pop	{r4, pc}
 8007328:	50040000 	.word	0x50040000
 800732c:	48000800 	.word	0x48000800

08007330 <HAL_I2C_MspInit>:
* This function configures the hardware resources used in this example
* @param hi2c: I2C handle pointer
* @retval None
*/
void HAL_I2C_MspInit(I2C_HandleTypeDef* hi2c)
{
 8007330:	b510      	push	{r4, lr}
 8007332:	4604      	mov	r4, r0
 8007334:	b088      	sub	sp, #32

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8007336:	2214      	movs	r2, #20
 8007338:	2100      	movs	r1, #0
 800733a:	a803      	add	r0, sp, #12
 800733c:	f000 fc21 	bl	8007b82 <memset>
  if(hi2c->Instance==I2C1)
 8007340:	6822      	ldr	r2, [r4, #0]
 8007342:	4b13      	ldr	r3, [pc, #76]	; (8007390 <HAL_I2C_MspInit+0x60>)
 8007344:	429a      	cmp	r2, r3
 8007346:	d121      	bne.n	800738c <HAL_I2C_MspInit+0x5c>
  {
  /* USER CODE BEGIN I2C1_MspInit 0 */

  /* USER CODE END I2C1_MspInit 0 */
  
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007348:	4c12      	ldr	r4, [pc, #72]	; (8007394 <HAL_I2C_MspInit+0x64>)
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800734a:	4813      	ldr	r0, [pc, #76]	; (8007398 <HAL_I2C_MspInit+0x68>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800734c:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800734e:	f043 0302 	orr.w	r3, r3, #2
 8007352:	64e3      	str	r3, [r4, #76]	; 0x4c
 8007354:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8007356:	f003 0302 	and.w	r3, r3, #2
 800735a:	9301      	str	r3, [sp, #4]
 800735c:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9;
 800735e:	f44f 7340 	mov.w	r3, #768	; 0x300
 8007362:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8007364:	2312      	movs	r3, #18
 8007366:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8007368:	2301      	movs	r3, #1
 800736a:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800736c:	2303      	movs	r3, #3
 800736e:	9306      	str	r3, [sp, #24]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8007370:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
 8007372:	2304      	movs	r3, #4
 8007374:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8007376:	f7fa fbbd 	bl	8001af4 <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __HAL_RCC_I2C1_CLK_ENABLE();
 800737a:	6da3      	ldr	r3, [r4, #88]	; 0x58
 800737c:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8007380:	65a3      	str	r3, [r4, #88]	; 0x58
 8007382:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8007384:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8007388:	9302      	str	r3, [sp, #8]
 800738a:	9b02      	ldr	r3, [sp, #8]
  /* USER CODE BEGIN I2C1_MspInit 1 */

  /* USER CODE END I2C1_MspInit 1 */
  }

}
 800738c:	b008      	add	sp, #32
 800738e:	bd10      	pop	{r4, pc}
 8007390:	40005400 	.word	0x40005400
 8007394:	40021000 	.word	0x40021000
 8007398:	48000400 	.word	0x48000400

0800739c <HAL_SPI_MspInit>:
* This function configures the hardware resources used in this example
* @param hspi: SPI handle pointer
* @retval None
*/
void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
 800739c:	b510      	push	{r4, lr}

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800739e:	2214      	movs	r2, #20
{
 80073a0:	b08a      	sub	sp, #40	; 0x28
 80073a2:	4604      	mov	r4, r0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80073a4:	2100      	movs	r1, #0
 80073a6:	eb0d 0002 	add.w	r0, sp, r2
 80073aa:	f000 fbea 	bl	8007b82 <memset>
  if(hspi->Instance==SPI1)
 80073ae:	6823      	ldr	r3, [r4, #0]
 80073b0:	4a23      	ldr	r2, [pc, #140]	; (8007440 <HAL_SPI_MspInit+0xa4>)
 80073b2:	4293      	cmp	r3, r2
 80073b4:	d121      	bne.n	80073fa <HAL_SPI_MspInit+0x5e>
  {
  /* USER CODE BEGIN SPI1_MspInit 0 */

  /* USER CODE END SPI1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_SPI1_CLK_ENABLE();
 80073b6:	4b23      	ldr	r3, [pc, #140]	; (8007444 <HAL_SPI_MspInit+0xa8>)
 80073b8:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 80073ba:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 80073be:	661a      	str	r2, [r3, #96]	; 0x60
 80073c0:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 80073c2:	f402 5280 	and.w	r2, r2, #4096	; 0x1000
 80073c6:	9201      	str	r2, [sp, #4]
 80073c8:	9a01      	ldr	r2, [sp, #4]
  
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80073ca:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80073cc:	f042 0201 	orr.w	r2, r2, #1
 80073d0:	64da      	str	r2, [r3, #76]	; 0x4c
 80073d2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80073d4:	f003 0301 	and.w	r3, r3, #1
 80073d8:	9302      	str	r3, [sp, #8]
 80073da:	9b02      	ldr	r3, [sp, #8]
    /**SPI1 GPIO Configuration    
    PA5     ------> SPI1_SCK
    PA6     ------> SPI1_MISO
    PA7     ------> SPI1_MOSI 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7;
 80073dc:	23e0      	movs	r3, #224	; 0xe0
 80073de:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80073e0:	2302      	movs	r3, #2
 80073e2:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80073e4:	2303      	movs	r3, #3
 80073e6:	9308      	str	r3, [sp, #32]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
 80073e8:	2305      	movs	r3, #5
 80073ea:	9309      	str	r3, [sp, #36]	; 0x24
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80073ec:	a905      	add	r1, sp, #20
 80073ee:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    GPIO_InitStruct.Pin = GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80073f2:	f7fa fb7f 	bl	8001af4 <HAL_GPIO_Init>
  /* USER CODE BEGIN SPI2_MspInit 1 */

  /* USER CODE END SPI2_MspInit 1 */
  }

}
 80073f6:	b00a      	add	sp, #40	; 0x28
 80073f8:	bd10      	pop	{r4, pc}
  else if(hspi->Instance==SPI2)
 80073fa:	4a13      	ldr	r2, [pc, #76]	; (8007448 <HAL_SPI_MspInit+0xac>)
 80073fc:	4293      	cmp	r3, r2
 80073fe:	d1fa      	bne.n	80073f6 <HAL_SPI_MspInit+0x5a>
    __HAL_RCC_SPI2_CLK_ENABLE();
 8007400:	4b10      	ldr	r3, [pc, #64]	; (8007444 <HAL_SPI_MspInit+0xa8>)
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8007402:	4812      	ldr	r0, [pc, #72]	; (800744c <HAL_SPI_MspInit+0xb0>)
    __HAL_RCC_SPI2_CLK_ENABLE();
 8007404:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8007406:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800740a:	659a      	str	r2, [r3, #88]	; 0x58
 800740c:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800740e:	f402 4280 	and.w	r2, r2, #16384	; 0x4000
 8007412:	9203      	str	r2, [sp, #12]
 8007414:	9a03      	ldr	r2, [sp, #12]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007416:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8007418:	f042 0202 	orr.w	r2, r2, #2
 800741c:	64da      	str	r2, [r3, #76]	; 0x4c
 800741e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8007420:	f003 0302 	and.w	r3, r3, #2
 8007424:	9304      	str	r3, [sp, #16]
 8007426:	9b04      	ldr	r3, [sp, #16]
    GPIO_InitStruct.Pin = GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;
 8007428:	f44f 4360 	mov.w	r3, #57344	; 0xe000
 800742c:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800742e:	2302      	movs	r3, #2
 8007430:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8007432:	2303      	movs	r3, #3
 8007434:	9308      	str	r3, [sp, #32]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
 8007436:	2305      	movs	r3, #5
 8007438:	9309      	str	r3, [sp, #36]	; 0x24
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800743a:	a905      	add	r1, sp, #20
 800743c:	e7d9      	b.n	80073f2 <HAL_SPI_MspInit+0x56>
 800743e:	bf00      	nop
 8007440:	40013000 	.word	0x40013000
 8007444:	40021000 	.word	0x40021000
 8007448:	40003800 	.word	0x40003800
 800744c:	48000400 	.word	0x48000400

08007450 <HAL_UART_MspInit>:
* This function configures the hardware resources used in this example
* @param huart: UART handle pointer
* @retval None
*/
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 8007450:	b570      	push	{r4, r5, r6, lr}
 8007452:	4604      	mov	r4, r0
 8007454:	b08c      	sub	sp, #48	; 0x30

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8007456:	2214      	movs	r2, #20
 8007458:	2100      	movs	r1, #0
 800745a:	a807      	add	r0, sp, #28
 800745c:	f000 fb91 	bl	8007b82 <memset>
  if(huart->Instance==UART5)
 8007460:	6823      	ldr	r3, [r4, #0]
 8007462:	4a4b      	ldr	r2, [pc, #300]	; (8007590 <HAL_UART_MspInit+0x140>)
 8007464:	4293      	cmp	r3, r2
 8007466:	d13d      	bne.n	80074e4 <HAL_UART_MspInit+0x94>
  {
  /* USER CODE BEGIN UART5_MspInit 0 */

  /* USER CODE END UART5_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_UART5_CLK_ENABLE();
 8007468:	4b4a      	ldr	r3, [pc, #296]	; (8007594 <HAL_UART_MspInit+0x144>)
    GPIO_InitStruct.Pin = GPIO_PIN_12;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF8_UART5;
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800746a:	484b      	ldr	r0, [pc, #300]	; (8007598 <HAL_UART_MspInit+0x148>)
    __HAL_RCC_UART5_CLK_ENABLE();
 800746c:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800746e:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 8007472:	659a      	str	r2, [r3, #88]	; 0x58
 8007474:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8007476:	f402 1280 	and.w	r2, r2, #1048576	; 0x100000
 800747a:	9200      	str	r2, [sp, #0]
 800747c:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 800747e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8007480:	f042 0204 	orr.w	r2, r2, #4
 8007484:	64da      	str	r2, [r3, #76]	; 0x4c
 8007486:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8007488:	f002 0204 	and.w	r2, r2, #4
 800748c:	9201      	str	r2, [sp, #4]
 800748e:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8007490:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8007492:	f042 0208 	orr.w	r2, r2, #8
 8007496:	64da      	str	r2, [r3, #76]	; 0x4c
 8007498:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800749a:	f003 0308 	and.w	r3, r3, #8
 800749e:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80074a0:	2402      	movs	r4, #2
    __HAL_RCC_GPIOD_CLK_ENABLE();
 80074a2:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80074a4:	9408      	str	r4, [sp, #32]
    GPIO_InitStruct.Pin = GPIO_PIN_12;
 80074a6:	f44f 5380 	mov.w	r3, #4096	; 0x1000
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80074aa:	2603      	movs	r6, #3
    GPIO_InitStruct.Alternate = GPIO_AF8_UART5;
 80074ac:	2508      	movs	r5, #8
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80074ae:	a907      	add	r1, sp, #28
    GPIO_InitStruct.Pin = GPIO_PIN_12;
 80074b0:	9307      	str	r3, [sp, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80074b2:	960a      	str	r6, [sp, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF8_UART5;
 80074b4:	950b      	str	r5, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80074b6:	f7fa fb1d 	bl	8001af4 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_2;
 80074ba:	2304      	movs	r3, #4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80074bc:	9408      	str	r4, [sp, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF8_UART5;
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 80074be:	a907      	add	r1, sp, #28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80074c0:	2400      	movs	r4, #0
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 80074c2:	4836      	ldr	r0, [pc, #216]	; (800759c <HAL_UART_MspInit+0x14c>)
    GPIO_InitStruct.Pin = GPIO_PIN_2;
 80074c4:	9307      	str	r3, [sp, #28]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80074c6:	9409      	str	r4, [sp, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80074c8:	960a      	str	r6, [sp, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF8_UART5;
 80074ca:	950b      	str	r5, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 80074cc:	f7fa fb12 	bl	8001af4 <HAL_GPIO_Init>

    /* UART5 interrupt Init */
    HAL_NVIC_SetPriority(UART5_IRQn, 5, 0);
 80074d0:	2035      	movs	r0, #53	; 0x35
 80074d2:	4622      	mov	r2, r4
 80074d4:	2105      	movs	r1, #5
 80074d6:	f7fa fab7 	bl	8001a48 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(UART5_IRQn);
 80074da:	2035      	movs	r0, #53	; 0x35
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

    /* USART3 interrupt Init */
    HAL_NVIC_SetPriority(USART3_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(USART3_IRQn);
 80074dc:	f7fa fae8 	bl	8001ab0 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USART3_MspInit 1 */

  /* USER CODE END USART3_MspInit 1 */
  }

}
 80074e0:	b00c      	add	sp, #48	; 0x30
 80074e2:	bd70      	pop	{r4, r5, r6, pc}
  else if(huart->Instance==USART1)
 80074e4:	4a2e      	ldr	r2, [pc, #184]	; (80075a0 <HAL_UART_MspInit+0x150>)
 80074e6:	4293      	cmp	r3, r2
 80074e8:	d127      	bne.n	800753a <HAL_UART_MspInit+0xea>
    __HAL_RCC_USART1_CLK_ENABLE();
 80074ea:	4b2a      	ldr	r3, [pc, #168]	; (8007594 <HAL_UART_MspInit+0x144>)
 80074ec:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 80074ee:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 80074f2:	661a      	str	r2, [r3, #96]	; 0x60
 80074f4:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 80074f6:	f402 4280 	and.w	r2, r2, #16384	; 0x4000
 80074fa:	9203      	str	r2, [sp, #12]
 80074fc:	9a03      	ldr	r2, [sp, #12]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80074fe:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8007500:	f042 0201 	orr.w	r2, r2, #1
 8007504:	64da      	str	r2, [r3, #76]	; 0x4c
 8007506:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8007508:	f003 0301 	and.w	r3, r3, #1
 800750c:	9304      	str	r3, [sp, #16]
 800750e:	9b04      	ldr	r3, [sp, #16]
    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
 8007510:	f44f 63c0 	mov.w	r3, #1536	; 0x600
 8007514:	9307      	str	r3, [sp, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007516:	2302      	movs	r3, #2
 8007518:	9308      	str	r3, [sp, #32]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800751a:	2303      	movs	r3, #3
 800751c:	930a      	str	r3, [sp, #40]	; 0x28
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800751e:	a907      	add	r1, sp, #28
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
 8007520:	2307      	movs	r3, #7
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8007522:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
 8007526:	930b      	str	r3, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8007528:	f7fa fae4 	bl	8001af4 <HAL_GPIO_Init>
    HAL_NVIC_SetPriority(USART1_IRQn, 5, 0);
 800752c:	2025      	movs	r0, #37	; 0x25
 800752e:	2200      	movs	r2, #0
 8007530:	2105      	movs	r1, #5
 8007532:	f7fa fa89 	bl	8001a48 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART1_IRQn);
 8007536:	2025      	movs	r0, #37	; 0x25
 8007538:	e7d0      	b.n	80074dc <HAL_UART_MspInit+0x8c>
  else if(huart->Instance==USART3)
 800753a:	4a1a      	ldr	r2, [pc, #104]	; (80075a4 <HAL_UART_MspInit+0x154>)
 800753c:	4293      	cmp	r3, r2
 800753e:	d1cf      	bne.n	80074e0 <HAL_UART_MspInit+0x90>
    __HAL_RCC_USART3_CLK_ENABLE();
 8007540:	4b14      	ldr	r3, [pc, #80]	; (8007594 <HAL_UART_MspInit+0x144>)
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8007542:	4815      	ldr	r0, [pc, #84]	; (8007598 <HAL_UART_MspInit+0x148>)
    __HAL_RCC_USART3_CLK_ENABLE();
 8007544:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8007546:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 800754a:	659a      	str	r2, [r3, #88]	; 0x58
 800754c:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800754e:	f402 2280 	and.w	r2, r2, #262144	; 0x40000
 8007552:	9205      	str	r2, [sp, #20]
 8007554:	9a05      	ldr	r2, [sp, #20]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8007556:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8007558:	f042 0204 	orr.w	r2, r2, #4
 800755c:	64da      	str	r2, [r3, #76]	; 0x4c
 800755e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8007560:	f003 0304 	and.w	r3, r3, #4
 8007564:	9306      	str	r3, [sp, #24]
 8007566:	9b06      	ldr	r3, [sp, #24]
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
 8007568:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 800756c:	9307      	str	r3, [sp, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800756e:	2302      	movs	r3, #2
 8007570:	9308      	str	r3, [sp, #32]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8007572:	2303      	movs	r3, #3
 8007574:	930a      	str	r3, [sp, #40]	; 0x28
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8007576:	a907      	add	r1, sp, #28
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
 8007578:	2307      	movs	r3, #7
 800757a:	930b      	str	r3, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800757c:	f7fa faba 	bl	8001af4 <HAL_GPIO_Init>
    HAL_NVIC_SetPriority(USART3_IRQn, 5, 0);
 8007580:	2027      	movs	r0, #39	; 0x27
 8007582:	2200      	movs	r2, #0
 8007584:	2105      	movs	r1, #5
 8007586:	f7fa fa5f 	bl	8001a48 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART3_IRQn);
 800758a:	2027      	movs	r0, #39	; 0x27
 800758c:	e7a6      	b.n	80074dc <HAL_UART_MspInit+0x8c>
 800758e:	bf00      	nop
 8007590:	40005000 	.word	0x40005000
 8007594:	40021000 	.word	0x40021000
 8007598:	48000800 	.word	0x48000800
 800759c:	48000c00 	.word	0x48000c00
 80075a0:	40013800 	.word	0x40013800
 80075a4:	40004800 	.word	0x40004800

080075a8 <NMI_Handler>:
 80075a8:	4770      	bx	lr

080075aa <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 80075aa:	e7fe      	b.n	80075aa <HardFault_Handler>

080075ac <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 80075ac:	e7fe      	b.n	80075ac <MemManage_Handler>

080075ae <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 80075ae:	e7fe      	b.n	80075ae <BusFault_Handler>

080075b0 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 80075b0:	e7fe      	b.n	80075b0 <UsageFault_Handler>

080075b2 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 80075b2:	4770      	bx	lr

080075b4 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 80075b4:	b508      	push	{r3, lr}
	HAL_IncTick();
 80075b6:	f7f9 fd03 	bl	8000fc0 <HAL_IncTick>
	osSystickHandler();
}
 80075ba:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	osSystickHandler();
 80075be:	f7fc bc89 	b.w	8003ed4 <osSystickHandler>

080075c2 <_read>:
	_kill(status, -1);
	while (1) {}		/* Make sure we hang here */
}

int _read (int file, char *ptr, int len)
{
 80075c2:	b570      	push	{r4, r5, r6, lr}
 80075c4:	460e      	mov	r6, r1
 80075c6:	4615      	mov	r5, r2
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 80075c8:	460c      	mov	r4, r1
 80075ca:	1ba3      	subs	r3, r4, r6
 80075cc:	429d      	cmp	r5, r3
 80075ce:	dc01      	bgt.n	80075d4 <_read+0x12>
	{
		*ptr++ = __io_getchar();
	}

return len;
}
 80075d0:	4628      	mov	r0, r5
 80075d2:	bd70      	pop	{r4, r5, r6, pc}
		*ptr++ = __io_getchar();
 80075d4:	f3af 8000 	nop.w
 80075d8:	f804 0b01 	strb.w	r0, [r4], #1
 80075dc:	e7f5      	b.n	80075ca <_read+0x8>

080075de <_write>:

int _write(int file, char *ptr, int len)
{
 80075de:	b570      	push	{r4, r5, r6, lr}
 80075e0:	460e      	mov	r6, r1
 80075e2:	4615      	mov	r5, r2
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 80075e4:	460c      	mov	r4, r1
 80075e6:	1ba3      	subs	r3, r4, r6
 80075e8:	429d      	cmp	r5, r3
 80075ea:	dc01      	bgt.n	80075f0 <_write+0x12>
	{
		__io_putchar(*ptr++);
	}
	return len;
}
 80075ec:	4628      	mov	r0, r5
 80075ee:	bd70      	pop	{r4, r5, r6, pc}
		__io_putchar(*ptr++);
 80075f0:	f814 0b01 	ldrb.w	r0, [r4], #1
 80075f4:	f7ff fe3c 	bl	8007270 <__io_putchar>
 80075f8:	e7f5      	b.n	80075e6 <_write+0x8>
	...

080075fc <_sbrk>:

caddr_t _sbrk(int incr)
{
 80075fc:	b508      	push	{r3, lr}
	extern char end asm("end");
	static char *heap_end;
	char *prev_heap_end;

	if (heap_end == 0)
 80075fe:	4b0a      	ldr	r3, [pc, #40]	; (8007628 <_sbrk+0x2c>)
 8007600:	6819      	ldr	r1, [r3, #0]
{
 8007602:	4602      	mov	r2, r0
	if (heap_end == 0)
 8007604:	b909      	cbnz	r1, 800760a <_sbrk+0xe>
		heap_end = &end;
 8007606:	4909      	ldr	r1, [pc, #36]	; (800762c <_sbrk+0x30>)
 8007608:	6019      	str	r1, [r3, #0]

	prev_heap_end = heap_end;
 800760a:	6818      	ldr	r0, [r3, #0]
	if (heap_end + incr > stack_ptr)
 800760c:	4669      	mov	r1, sp
 800760e:	4402      	add	r2, r0
 8007610:	428a      	cmp	r2, r1
 8007612:	d906      	bls.n	8007622 <_sbrk+0x26>
	{
//		write(1, "Heap and stack collision\n", 25);
//		abort();
		errno = ENOMEM;
 8007614:	f000 f86a 	bl	80076ec <__errno>
 8007618:	230c      	movs	r3, #12
 800761a:	6003      	str	r3, [r0, #0]
		return (caddr_t) -1;
 800761c:	f04f 30ff 	mov.w	r0, #4294967295
 8007620:	bd08      	pop	{r3, pc}
	}

	heap_end += incr;
 8007622:	601a      	str	r2, [r3, #0]

	return (caddr_t) prev_heap_end;
}
 8007624:	bd08      	pop	{r3, pc}
 8007626:	bf00      	nop
 8007628:	200084c4 	.word	0x200084c4
 800762c:	20008d7c 	.word	0x20008d7c

08007630 <_close>:

int _close(int file)
{
	return -1;
}
 8007630:	f04f 30ff 	mov.w	r0, #4294967295
 8007634:	4770      	bx	lr

08007636 <_fstat>:


int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
 8007636:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800763a:	604b      	str	r3, [r1, #4]
	return 0;
}
 800763c:	2000      	movs	r0, #0
 800763e:	4770      	bx	lr

08007640 <_isatty>:

int _isatty(int file)
{
	return 1;
}
 8007640:	2001      	movs	r0, #1
 8007642:	4770      	bx	lr

08007644 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
	return 0;
}
 8007644:	2000      	movs	r0, #0
 8007646:	4770      	bx	lr

08007648 <SystemInit>:

void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8007648:	490f      	ldr	r1, [pc, #60]	; (8007688 <SystemInit+0x40>)
 800764a:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 800764e:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8007652:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  #endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 8007656:	4b0d      	ldr	r3, [pc, #52]	; (800768c <SystemInit+0x44>)
 8007658:	681a      	ldr	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000U;
 800765a:	2000      	movs	r0, #0
  RCC->CR |= RCC_CR_MSION;
 800765c:	f042 0201 	orr.w	r2, r2, #1
 8007660:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0x00000000U;
 8007662:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON , HSION, and PLLON bits */
  RCC->CR &= 0xEAF6FFFFU;
 8007664:	681a      	ldr	r2, [r3, #0]
 8007666:	f022 52a8 	bic.w	r2, r2, #352321536	; 0x15000000
 800766a:	f422 2210 	bic.w	r2, r2, #589824	; 0x90000
 800766e:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x00001000U;
 8007670:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8007674:	60da      	str	r2, [r3, #12]

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
 8007676:	681a      	ldr	r2, [r3, #0]
 8007678:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800767c:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000U;
 800767e:	6198      	str	r0, [r3, #24]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8007680:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8007684:	608b      	str	r3, [r1, #8]
 8007686:	4770      	bx	lr
 8007688:	e000ed00 	.word	0xe000ed00
 800768c:	40021000 	.word	0x40021000

08007690 <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 8007690:	f8df d034 	ldr.w	sp, [pc, #52]	; 80076c8 <LoopForever+0x2>

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
 8007694:	2100      	movs	r1, #0
  b	LoopCopyDataInit
 8007696:	e003      	b.n	80076a0 <LoopCopyDataInit>

08007698 <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 8007698:	4b0c      	ldr	r3, [pc, #48]	; (80076cc <LoopForever+0x6>)
	ldr	r3, [r3, r1]
 800769a:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 800769c:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 800769e:	3104      	adds	r1, #4

080076a0 <LoopCopyDataInit>:

LoopCopyDataInit:
	ldr	r0, =_sdata
 80076a0:	480b      	ldr	r0, [pc, #44]	; (80076d0 <LoopForever+0xa>)
	ldr	r3, =_edata
 80076a2:	4b0c      	ldr	r3, [pc, #48]	; (80076d4 <LoopForever+0xe>)
	adds	r2, r0, r1
 80076a4:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 80076a6:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 80076a8:	d3f6      	bcc.n	8007698 <CopyDataInit>
	ldr	r2, =_sbss
 80076aa:	4a0b      	ldr	r2, [pc, #44]	; (80076d8 <LoopForever+0x12>)
	b	LoopFillZerobss
 80076ac:	e002      	b.n	80076b4 <LoopFillZerobss>

080076ae <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
 80076ae:	2300      	movs	r3, #0
	str	r3, [r2], #4
 80076b0:	f842 3b04 	str.w	r3, [r2], #4

080076b4 <LoopFillZerobss>:

LoopFillZerobss:
	ldr	r3, = _ebss
 80076b4:	4b09      	ldr	r3, [pc, #36]	; (80076dc <LoopForever+0x16>)
	cmp	r2, r3
 80076b6:	429a      	cmp	r2, r3
	bcc	FillZerobss
 80076b8:	d3f9      	bcc.n	80076ae <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 80076ba:	f7ff ffc5 	bl	8007648 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 80076be:	f000 f81b 	bl	80076f8 <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 80076c2:	f7ff fcef 	bl	80070a4 <main>

080076c6 <LoopForever>:

LoopForever:
    b LoopForever
 80076c6:	e7fe      	b.n	80076c6 <LoopForever>
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 80076c8:	20018000 	.word	0x20018000
	ldr	r3, =_sidata
 80076cc:	0800d4e8 	.word	0x0800d4e8
	ldr	r0, =_sdata
 80076d0:	20000000 	.word	0x20000000
	ldr	r3, =_edata
 80076d4:	200006cc 	.word	0x200006cc
	ldr	r2, =_sbss
 80076d8:	200006cc 	.word	0x200006cc
	ldr	r3, = _ebss
 80076dc:	20008d7c 	.word	0x20008d7c

080076e0 <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 80076e0:	e7fe      	b.n	80076e0 <ADC1_2_IRQHandler>

080076e2 <atoi>:
 80076e2:	220a      	movs	r2, #10
 80076e4:	2100      	movs	r1, #0
 80076e6:	f000 bb9d 	b.w	8007e24 <strtol>
	...

080076ec <__errno>:
 80076ec:	4b01      	ldr	r3, [pc, #4]	; (80076f4 <__errno+0x8>)
 80076ee:	6818      	ldr	r0, [r3, #0]
 80076f0:	4770      	bx	lr
 80076f2:	bf00      	nop
 80076f4:	2000005c 	.word	0x2000005c

080076f8 <__libc_init_array>:
 80076f8:	b570      	push	{r4, r5, r6, lr}
 80076fa:	4e0d      	ldr	r6, [pc, #52]	; (8007730 <__libc_init_array+0x38>)
 80076fc:	4c0d      	ldr	r4, [pc, #52]	; (8007734 <__libc_init_array+0x3c>)
 80076fe:	1ba4      	subs	r4, r4, r6
 8007700:	10a4      	asrs	r4, r4, #2
 8007702:	2500      	movs	r5, #0
 8007704:	42a5      	cmp	r5, r4
 8007706:	d109      	bne.n	800771c <__libc_init_array+0x24>
 8007708:	4e0b      	ldr	r6, [pc, #44]	; (8007738 <__libc_init_array+0x40>)
 800770a:	4c0c      	ldr	r4, [pc, #48]	; (800773c <__libc_init_array+0x44>)
 800770c:	f004 fedc 	bl	800c4c8 <_init>
 8007710:	1ba4      	subs	r4, r4, r6
 8007712:	10a4      	asrs	r4, r4, #2
 8007714:	2500      	movs	r5, #0
 8007716:	42a5      	cmp	r5, r4
 8007718:	d105      	bne.n	8007726 <__libc_init_array+0x2e>
 800771a:	bd70      	pop	{r4, r5, r6, pc}
 800771c:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8007720:	4798      	blx	r3
 8007722:	3501      	adds	r5, #1
 8007724:	e7ee      	b.n	8007704 <__libc_init_array+0xc>
 8007726:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 800772a:	4798      	blx	r3
 800772c:	3501      	adds	r5, #1
 800772e:	e7f2      	b.n	8007716 <__libc_init_array+0x1e>
 8007730:	0800d4e0 	.word	0x0800d4e0
 8007734:	0800d4e0 	.word	0x0800d4e0
 8007738:	0800d4e0 	.word	0x0800d4e0
 800773c:	0800d4e4 	.word	0x0800d4e4

08007740 <malloc>:
 8007740:	4b02      	ldr	r3, [pc, #8]	; (800774c <malloc+0xc>)
 8007742:	4601      	mov	r1, r0
 8007744:	6818      	ldr	r0, [r3, #0]
 8007746:	f000 b803 	b.w	8007750 <_malloc_r>
 800774a:	bf00      	nop
 800774c:	2000005c 	.word	0x2000005c

08007750 <_malloc_r>:
 8007750:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007754:	f101 040b 	add.w	r4, r1, #11
 8007758:	2c16      	cmp	r4, #22
 800775a:	4681      	mov	r9, r0
 800775c:	d907      	bls.n	800776e <_malloc_r+0x1e>
 800775e:	f034 0407 	bics.w	r4, r4, #7
 8007762:	d505      	bpl.n	8007770 <_malloc_r+0x20>
 8007764:	230c      	movs	r3, #12
 8007766:	f8c9 3000 	str.w	r3, [r9]
 800776a:	2600      	movs	r6, #0
 800776c:	e131      	b.n	80079d2 <_malloc_r+0x282>
 800776e:	2410      	movs	r4, #16
 8007770:	428c      	cmp	r4, r1
 8007772:	d3f7      	bcc.n	8007764 <_malloc_r+0x14>
 8007774:	4648      	mov	r0, r9
 8007776:	f000 fa0d 	bl	8007b94 <__malloc_lock>
 800777a:	f5b4 7ffc 	cmp.w	r4, #504	; 0x1f8
 800777e:	4d9c      	ldr	r5, [pc, #624]	; (80079f0 <_malloc_r+0x2a0>)
 8007780:	d236      	bcs.n	80077f0 <_malloc_r+0xa0>
 8007782:	f104 0208 	add.w	r2, r4, #8
 8007786:	442a      	add	r2, r5
 8007788:	f1a2 0108 	sub.w	r1, r2, #8
 800778c:	6856      	ldr	r6, [r2, #4]
 800778e:	428e      	cmp	r6, r1
 8007790:	ea4f 03d4 	mov.w	r3, r4, lsr #3
 8007794:	d102      	bne.n	800779c <_malloc_r+0x4c>
 8007796:	68d6      	ldr	r6, [r2, #12]
 8007798:	42b2      	cmp	r2, r6
 800779a:	d010      	beq.n	80077be <_malloc_r+0x6e>
 800779c:	6873      	ldr	r3, [r6, #4]
 800779e:	68f2      	ldr	r2, [r6, #12]
 80077a0:	68b1      	ldr	r1, [r6, #8]
 80077a2:	f023 0303 	bic.w	r3, r3, #3
 80077a6:	60ca      	str	r2, [r1, #12]
 80077a8:	4433      	add	r3, r6
 80077aa:	6091      	str	r1, [r2, #8]
 80077ac:	685a      	ldr	r2, [r3, #4]
 80077ae:	f042 0201 	orr.w	r2, r2, #1
 80077b2:	605a      	str	r2, [r3, #4]
 80077b4:	4648      	mov	r0, r9
 80077b6:	f000 f9f3 	bl	8007ba0 <__malloc_unlock>
 80077ba:	3608      	adds	r6, #8
 80077bc:	e109      	b.n	80079d2 <_malloc_r+0x282>
 80077be:	3302      	adds	r3, #2
 80077c0:	4a8c      	ldr	r2, [pc, #560]	; (80079f4 <_malloc_r+0x2a4>)
 80077c2:	692e      	ldr	r6, [r5, #16]
 80077c4:	4296      	cmp	r6, r2
 80077c6:	4611      	mov	r1, r2
 80077c8:	d06d      	beq.n	80078a6 <_malloc_r+0x156>
 80077ca:	6870      	ldr	r0, [r6, #4]
 80077cc:	f020 0003 	bic.w	r0, r0, #3
 80077d0:	1b07      	subs	r7, r0, r4
 80077d2:	2f0f      	cmp	r7, #15
 80077d4:	dd47      	ble.n	8007866 <_malloc_r+0x116>
 80077d6:	1933      	adds	r3, r6, r4
 80077d8:	f044 0401 	orr.w	r4, r4, #1
 80077dc:	6074      	str	r4, [r6, #4]
 80077de:	616b      	str	r3, [r5, #20]
 80077e0:	612b      	str	r3, [r5, #16]
 80077e2:	60da      	str	r2, [r3, #12]
 80077e4:	609a      	str	r2, [r3, #8]
 80077e6:	f047 0201 	orr.w	r2, r7, #1
 80077ea:	605a      	str	r2, [r3, #4]
 80077ec:	5037      	str	r7, [r6, r0]
 80077ee:	e7e1      	b.n	80077b4 <_malloc_r+0x64>
 80077f0:	0a63      	lsrs	r3, r4, #9
 80077f2:	d02a      	beq.n	800784a <_malloc_r+0xfa>
 80077f4:	2b04      	cmp	r3, #4
 80077f6:	d812      	bhi.n	800781e <_malloc_r+0xce>
 80077f8:	09a3      	lsrs	r3, r4, #6
 80077fa:	3338      	adds	r3, #56	; 0x38
 80077fc:	1c5a      	adds	r2, r3, #1
 80077fe:	eb05 02c2 	add.w	r2, r5, r2, lsl #3
 8007802:	f1a2 0008 	sub.w	r0, r2, #8
 8007806:	6856      	ldr	r6, [r2, #4]
 8007808:	4286      	cmp	r6, r0
 800780a:	d006      	beq.n	800781a <_malloc_r+0xca>
 800780c:	6872      	ldr	r2, [r6, #4]
 800780e:	f022 0203 	bic.w	r2, r2, #3
 8007812:	1b11      	subs	r1, r2, r4
 8007814:	290f      	cmp	r1, #15
 8007816:	dd1c      	ble.n	8007852 <_malloc_r+0x102>
 8007818:	3b01      	subs	r3, #1
 800781a:	3301      	adds	r3, #1
 800781c:	e7d0      	b.n	80077c0 <_malloc_r+0x70>
 800781e:	2b14      	cmp	r3, #20
 8007820:	d801      	bhi.n	8007826 <_malloc_r+0xd6>
 8007822:	335b      	adds	r3, #91	; 0x5b
 8007824:	e7ea      	b.n	80077fc <_malloc_r+0xac>
 8007826:	2b54      	cmp	r3, #84	; 0x54
 8007828:	d802      	bhi.n	8007830 <_malloc_r+0xe0>
 800782a:	0b23      	lsrs	r3, r4, #12
 800782c:	336e      	adds	r3, #110	; 0x6e
 800782e:	e7e5      	b.n	80077fc <_malloc_r+0xac>
 8007830:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
 8007834:	d802      	bhi.n	800783c <_malloc_r+0xec>
 8007836:	0be3      	lsrs	r3, r4, #15
 8007838:	3377      	adds	r3, #119	; 0x77
 800783a:	e7df      	b.n	80077fc <_malloc_r+0xac>
 800783c:	f240 5254 	movw	r2, #1364	; 0x554
 8007840:	4293      	cmp	r3, r2
 8007842:	d804      	bhi.n	800784e <_malloc_r+0xfe>
 8007844:	0ca3      	lsrs	r3, r4, #18
 8007846:	337c      	adds	r3, #124	; 0x7c
 8007848:	e7d8      	b.n	80077fc <_malloc_r+0xac>
 800784a:	233f      	movs	r3, #63	; 0x3f
 800784c:	e7d6      	b.n	80077fc <_malloc_r+0xac>
 800784e:	237e      	movs	r3, #126	; 0x7e
 8007850:	e7d4      	b.n	80077fc <_malloc_r+0xac>
 8007852:	2900      	cmp	r1, #0
 8007854:	68f1      	ldr	r1, [r6, #12]
 8007856:	db04      	blt.n	8007862 <_malloc_r+0x112>
 8007858:	68b3      	ldr	r3, [r6, #8]
 800785a:	60d9      	str	r1, [r3, #12]
 800785c:	608b      	str	r3, [r1, #8]
 800785e:	18b3      	adds	r3, r6, r2
 8007860:	e7a4      	b.n	80077ac <_malloc_r+0x5c>
 8007862:	460e      	mov	r6, r1
 8007864:	e7d0      	b.n	8007808 <_malloc_r+0xb8>
 8007866:	2f00      	cmp	r7, #0
 8007868:	616a      	str	r2, [r5, #20]
 800786a:	612a      	str	r2, [r5, #16]
 800786c:	db05      	blt.n	800787a <_malloc_r+0x12a>
 800786e:	4430      	add	r0, r6
 8007870:	6843      	ldr	r3, [r0, #4]
 8007872:	f043 0301 	orr.w	r3, r3, #1
 8007876:	6043      	str	r3, [r0, #4]
 8007878:	e79c      	b.n	80077b4 <_malloc_r+0x64>
 800787a:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 800787e:	d244      	bcs.n	800790a <_malloc_r+0x1ba>
 8007880:	08c0      	lsrs	r0, r0, #3
 8007882:	1087      	asrs	r7, r0, #2
 8007884:	2201      	movs	r2, #1
 8007886:	fa02 f707 	lsl.w	r7, r2, r7
 800788a:	686a      	ldr	r2, [r5, #4]
 800788c:	3001      	adds	r0, #1
 800788e:	433a      	orrs	r2, r7
 8007890:	606a      	str	r2, [r5, #4]
 8007892:	eb05 02c0 	add.w	r2, r5, r0, lsl #3
 8007896:	f855 7030 	ldr.w	r7, [r5, r0, lsl #3]
 800789a:	60b7      	str	r7, [r6, #8]
 800789c:	3a08      	subs	r2, #8
 800789e:	60f2      	str	r2, [r6, #12]
 80078a0:	f845 6030 	str.w	r6, [r5, r0, lsl #3]
 80078a4:	60fe      	str	r6, [r7, #12]
 80078a6:	2001      	movs	r0, #1
 80078a8:	109a      	asrs	r2, r3, #2
 80078aa:	fa00 f202 	lsl.w	r2, r0, r2
 80078ae:	6868      	ldr	r0, [r5, #4]
 80078b0:	4282      	cmp	r2, r0
 80078b2:	f200 80a1 	bhi.w	80079f8 <_malloc_r+0x2a8>
 80078b6:	4202      	tst	r2, r0
 80078b8:	d106      	bne.n	80078c8 <_malloc_r+0x178>
 80078ba:	f023 0303 	bic.w	r3, r3, #3
 80078be:	0052      	lsls	r2, r2, #1
 80078c0:	4202      	tst	r2, r0
 80078c2:	f103 0304 	add.w	r3, r3, #4
 80078c6:	d0fa      	beq.n	80078be <_malloc_r+0x16e>
 80078c8:	eb05 0cc3 	add.w	ip, r5, r3, lsl #3
 80078cc:	46e0      	mov	r8, ip
 80078ce:	469e      	mov	lr, r3
 80078d0:	f8d8 600c 	ldr.w	r6, [r8, #12]
 80078d4:	4546      	cmp	r6, r8
 80078d6:	d153      	bne.n	8007980 <_malloc_r+0x230>
 80078d8:	f10e 0e01 	add.w	lr, lr, #1
 80078dc:	f01e 0f03 	tst.w	lr, #3
 80078e0:	f108 0808 	add.w	r8, r8, #8
 80078e4:	d1f4      	bne.n	80078d0 <_malloc_r+0x180>
 80078e6:	0798      	lsls	r0, r3, #30
 80078e8:	d179      	bne.n	80079de <_malloc_r+0x28e>
 80078ea:	686b      	ldr	r3, [r5, #4]
 80078ec:	ea23 0302 	bic.w	r3, r3, r2
 80078f0:	606b      	str	r3, [r5, #4]
 80078f2:	6868      	ldr	r0, [r5, #4]
 80078f4:	0052      	lsls	r2, r2, #1
 80078f6:	4282      	cmp	r2, r0
 80078f8:	d87e      	bhi.n	80079f8 <_malloc_r+0x2a8>
 80078fa:	2a00      	cmp	r2, #0
 80078fc:	d07c      	beq.n	80079f8 <_malloc_r+0x2a8>
 80078fe:	4673      	mov	r3, lr
 8007900:	4202      	tst	r2, r0
 8007902:	d1e1      	bne.n	80078c8 <_malloc_r+0x178>
 8007904:	3304      	adds	r3, #4
 8007906:	0052      	lsls	r2, r2, #1
 8007908:	e7fa      	b.n	8007900 <_malloc_r+0x1b0>
 800790a:	0a42      	lsrs	r2, r0, #9
 800790c:	2a04      	cmp	r2, #4
 800790e:	d815      	bhi.n	800793c <_malloc_r+0x1ec>
 8007910:	0982      	lsrs	r2, r0, #6
 8007912:	3238      	adds	r2, #56	; 0x38
 8007914:	1c57      	adds	r7, r2, #1
 8007916:	eb05 0ec2 	add.w	lr, r5, r2, lsl #3
 800791a:	f855 7037 	ldr.w	r7, [r5, r7, lsl #3]
 800791e:	45be      	cmp	lr, r7
 8007920:	d126      	bne.n	8007970 <_malloc_r+0x220>
 8007922:	2001      	movs	r0, #1
 8007924:	1092      	asrs	r2, r2, #2
 8007926:	fa00 f202 	lsl.w	r2, r0, r2
 800792a:	6868      	ldr	r0, [r5, #4]
 800792c:	4310      	orrs	r0, r2
 800792e:	6068      	str	r0, [r5, #4]
 8007930:	f8c6 e00c 	str.w	lr, [r6, #12]
 8007934:	60b7      	str	r7, [r6, #8]
 8007936:	f8ce 6008 	str.w	r6, [lr, #8]
 800793a:	e7b3      	b.n	80078a4 <_malloc_r+0x154>
 800793c:	2a14      	cmp	r2, #20
 800793e:	d801      	bhi.n	8007944 <_malloc_r+0x1f4>
 8007940:	325b      	adds	r2, #91	; 0x5b
 8007942:	e7e7      	b.n	8007914 <_malloc_r+0x1c4>
 8007944:	2a54      	cmp	r2, #84	; 0x54
 8007946:	d802      	bhi.n	800794e <_malloc_r+0x1fe>
 8007948:	0b02      	lsrs	r2, r0, #12
 800794a:	326e      	adds	r2, #110	; 0x6e
 800794c:	e7e2      	b.n	8007914 <_malloc_r+0x1c4>
 800794e:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 8007952:	d802      	bhi.n	800795a <_malloc_r+0x20a>
 8007954:	0bc2      	lsrs	r2, r0, #15
 8007956:	3277      	adds	r2, #119	; 0x77
 8007958:	e7dc      	b.n	8007914 <_malloc_r+0x1c4>
 800795a:	f240 5754 	movw	r7, #1364	; 0x554
 800795e:	42ba      	cmp	r2, r7
 8007960:	bf9a      	itte	ls
 8007962:	0c82      	lsrls	r2, r0, #18
 8007964:	327c      	addls	r2, #124	; 0x7c
 8007966:	227e      	movhi	r2, #126	; 0x7e
 8007968:	e7d4      	b.n	8007914 <_malloc_r+0x1c4>
 800796a:	68bf      	ldr	r7, [r7, #8]
 800796c:	45be      	cmp	lr, r7
 800796e:	d004      	beq.n	800797a <_malloc_r+0x22a>
 8007970:	687a      	ldr	r2, [r7, #4]
 8007972:	f022 0203 	bic.w	r2, r2, #3
 8007976:	4290      	cmp	r0, r2
 8007978:	d3f7      	bcc.n	800796a <_malloc_r+0x21a>
 800797a:	f8d7 e00c 	ldr.w	lr, [r7, #12]
 800797e:	e7d7      	b.n	8007930 <_malloc_r+0x1e0>
 8007980:	6870      	ldr	r0, [r6, #4]
 8007982:	68f7      	ldr	r7, [r6, #12]
 8007984:	f020 0003 	bic.w	r0, r0, #3
 8007988:	eba0 0a04 	sub.w	sl, r0, r4
 800798c:	f1ba 0f0f 	cmp.w	sl, #15
 8007990:	dd10      	ble.n	80079b4 <_malloc_r+0x264>
 8007992:	68b2      	ldr	r2, [r6, #8]
 8007994:	1933      	adds	r3, r6, r4
 8007996:	f044 0401 	orr.w	r4, r4, #1
 800799a:	6074      	str	r4, [r6, #4]
 800799c:	60d7      	str	r7, [r2, #12]
 800799e:	60ba      	str	r2, [r7, #8]
 80079a0:	f04a 0201 	orr.w	r2, sl, #1
 80079a4:	616b      	str	r3, [r5, #20]
 80079a6:	612b      	str	r3, [r5, #16]
 80079a8:	60d9      	str	r1, [r3, #12]
 80079aa:	6099      	str	r1, [r3, #8]
 80079ac:	605a      	str	r2, [r3, #4]
 80079ae:	f846 a000 	str.w	sl, [r6, r0]
 80079b2:	e6ff      	b.n	80077b4 <_malloc_r+0x64>
 80079b4:	f1ba 0f00 	cmp.w	sl, #0
 80079b8:	db0f      	blt.n	80079da <_malloc_r+0x28a>
 80079ba:	4430      	add	r0, r6
 80079bc:	6843      	ldr	r3, [r0, #4]
 80079be:	f043 0301 	orr.w	r3, r3, #1
 80079c2:	6043      	str	r3, [r0, #4]
 80079c4:	f856 3f08 	ldr.w	r3, [r6, #8]!
 80079c8:	4648      	mov	r0, r9
 80079ca:	60df      	str	r7, [r3, #12]
 80079cc:	60bb      	str	r3, [r7, #8]
 80079ce:	f000 f8e7 	bl	8007ba0 <__malloc_unlock>
 80079d2:	4630      	mov	r0, r6
 80079d4:	b003      	add	sp, #12
 80079d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80079da:	463e      	mov	r6, r7
 80079dc:	e77a      	b.n	80078d4 <_malloc_r+0x184>
 80079de:	f85c 0908 	ldr.w	r0, [ip], #-8
 80079e2:	4584      	cmp	ip, r0
 80079e4:	f103 33ff 	add.w	r3, r3, #4294967295
 80079e8:	f43f af7d 	beq.w	80078e6 <_malloc_r+0x196>
 80079ec:	e781      	b.n	80078f2 <_malloc_r+0x1a2>
 80079ee:	bf00      	nop
 80079f0:	20000150 	.word	0x20000150
 80079f4:	20000158 	.word	0x20000158
 80079f8:	f8d5 b008 	ldr.w	fp, [r5, #8]
 80079fc:	f8db 6004 	ldr.w	r6, [fp, #4]
 8007a00:	f026 0603 	bic.w	r6, r6, #3
 8007a04:	42b4      	cmp	r4, r6
 8007a06:	d803      	bhi.n	8007a10 <_malloc_r+0x2c0>
 8007a08:	1b33      	subs	r3, r6, r4
 8007a0a:	2b0f      	cmp	r3, #15
 8007a0c:	f300 8096 	bgt.w	8007b3c <_malloc_r+0x3ec>
 8007a10:	4a4f      	ldr	r2, [pc, #316]	; (8007b50 <_malloc_r+0x400>)
 8007a12:	6817      	ldr	r7, [r2, #0]
 8007a14:	4a4f      	ldr	r2, [pc, #316]	; (8007b54 <_malloc_r+0x404>)
 8007a16:	6811      	ldr	r1, [r2, #0]
 8007a18:	3710      	adds	r7, #16
 8007a1a:	3101      	adds	r1, #1
 8007a1c:	eb0b 0306 	add.w	r3, fp, r6
 8007a20:	4427      	add	r7, r4
 8007a22:	d005      	beq.n	8007a30 <_malloc_r+0x2e0>
 8007a24:	494c      	ldr	r1, [pc, #304]	; (8007b58 <_malloc_r+0x408>)
 8007a26:	3901      	subs	r1, #1
 8007a28:	440f      	add	r7, r1
 8007a2a:	3101      	adds	r1, #1
 8007a2c:	4249      	negs	r1, r1
 8007a2e:	400f      	ands	r7, r1
 8007a30:	4639      	mov	r1, r7
 8007a32:	4648      	mov	r0, r9
 8007a34:	9201      	str	r2, [sp, #4]
 8007a36:	9300      	str	r3, [sp, #0]
 8007a38:	f000 f938 	bl	8007cac <_sbrk_r>
 8007a3c:	f1b0 3fff 	cmp.w	r0, #4294967295
 8007a40:	4680      	mov	r8, r0
 8007a42:	d056      	beq.n	8007af2 <_malloc_r+0x3a2>
 8007a44:	9b00      	ldr	r3, [sp, #0]
 8007a46:	9a01      	ldr	r2, [sp, #4]
 8007a48:	4283      	cmp	r3, r0
 8007a4a:	d901      	bls.n	8007a50 <_malloc_r+0x300>
 8007a4c:	45ab      	cmp	fp, r5
 8007a4e:	d150      	bne.n	8007af2 <_malloc_r+0x3a2>
 8007a50:	4842      	ldr	r0, [pc, #264]	; (8007b5c <_malloc_r+0x40c>)
 8007a52:	6801      	ldr	r1, [r0, #0]
 8007a54:	4543      	cmp	r3, r8
 8007a56:	eb07 0e01 	add.w	lr, r7, r1
 8007a5a:	f8c0 e000 	str.w	lr, [r0]
 8007a5e:	4940      	ldr	r1, [pc, #256]	; (8007b60 <_malloc_r+0x410>)
 8007a60:	4682      	mov	sl, r0
 8007a62:	d113      	bne.n	8007a8c <_malloc_r+0x33c>
 8007a64:	420b      	tst	r3, r1
 8007a66:	d111      	bne.n	8007a8c <_malloc_r+0x33c>
 8007a68:	68ab      	ldr	r3, [r5, #8]
 8007a6a:	443e      	add	r6, r7
 8007a6c:	f046 0601 	orr.w	r6, r6, #1
 8007a70:	605e      	str	r6, [r3, #4]
 8007a72:	4a3c      	ldr	r2, [pc, #240]	; (8007b64 <_malloc_r+0x414>)
 8007a74:	f8da 3000 	ldr.w	r3, [sl]
 8007a78:	6811      	ldr	r1, [r2, #0]
 8007a7a:	428b      	cmp	r3, r1
 8007a7c:	bf88      	it	hi
 8007a7e:	6013      	strhi	r3, [r2, #0]
 8007a80:	4a39      	ldr	r2, [pc, #228]	; (8007b68 <_malloc_r+0x418>)
 8007a82:	6811      	ldr	r1, [r2, #0]
 8007a84:	428b      	cmp	r3, r1
 8007a86:	bf88      	it	hi
 8007a88:	6013      	strhi	r3, [r2, #0]
 8007a8a:	e032      	b.n	8007af2 <_malloc_r+0x3a2>
 8007a8c:	6810      	ldr	r0, [r2, #0]
 8007a8e:	3001      	adds	r0, #1
 8007a90:	bf1b      	ittet	ne
 8007a92:	eba8 0303 	subne.w	r3, r8, r3
 8007a96:	4473      	addne	r3, lr
 8007a98:	f8c2 8000 	streq.w	r8, [r2]
 8007a9c:	f8ca 3000 	strne.w	r3, [sl]
 8007aa0:	f018 0007 	ands.w	r0, r8, #7
 8007aa4:	bf1c      	itt	ne
 8007aa6:	f1c0 0008 	rsbne	r0, r0, #8
 8007aaa:	4480      	addne	r8, r0
 8007aac:	4b2a      	ldr	r3, [pc, #168]	; (8007b58 <_malloc_r+0x408>)
 8007aae:	4447      	add	r7, r8
 8007ab0:	4418      	add	r0, r3
 8007ab2:	400f      	ands	r7, r1
 8007ab4:	1bc7      	subs	r7, r0, r7
 8007ab6:	4639      	mov	r1, r7
 8007ab8:	4648      	mov	r0, r9
 8007aba:	f000 f8f7 	bl	8007cac <_sbrk_r>
 8007abe:	1c43      	adds	r3, r0, #1
 8007ac0:	bf08      	it	eq
 8007ac2:	4640      	moveq	r0, r8
 8007ac4:	f8da 3000 	ldr.w	r3, [sl]
 8007ac8:	f8c5 8008 	str.w	r8, [r5, #8]
 8007acc:	bf08      	it	eq
 8007ace:	2700      	moveq	r7, #0
 8007ad0:	eba0 0008 	sub.w	r0, r0, r8
 8007ad4:	443b      	add	r3, r7
 8007ad6:	4407      	add	r7, r0
 8007ad8:	f047 0701 	orr.w	r7, r7, #1
 8007adc:	45ab      	cmp	fp, r5
 8007ade:	f8ca 3000 	str.w	r3, [sl]
 8007ae2:	f8c8 7004 	str.w	r7, [r8, #4]
 8007ae6:	d0c4      	beq.n	8007a72 <_malloc_r+0x322>
 8007ae8:	2e0f      	cmp	r6, #15
 8007aea:	d810      	bhi.n	8007b0e <_malloc_r+0x3be>
 8007aec:	2301      	movs	r3, #1
 8007aee:	f8c8 3004 	str.w	r3, [r8, #4]
 8007af2:	68ab      	ldr	r3, [r5, #8]
 8007af4:	685a      	ldr	r2, [r3, #4]
 8007af6:	f022 0203 	bic.w	r2, r2, #3
 8007afa:	4294      	cmp	r4, r2
 8007afc:	eba2 0304 	sub.w	r3, r2, r4
 8007b00:	d801      	bhi.n	8007b06 <_malloc_r+0x3b6>
 8007b02:	2b0f      	cmp	r3, #15
 8007b04:	dc1a      	bgt.n	8007b3c <_malloc_r+0x3ec>
 8007b06:	4648      	mov	r0, r9
 8007b08:	f000 f84a 	bl	8007ba0 <__malloc_unlock>
 8007b0c:	e62d      	b.n	800776a <_malloc_r+0x1a>
 8007b0e:	f8db 3004 	ldr.w	r3, [fp, #4]
 8007b12:	3e0c      	subs	r6, #12
 8007b14:	f026 0607 	bic.w	r6, r6, #7
 8007b18:	f003 0301 	and.w	r3, r3, #1
 8007b1c:	4333      	orrs	r3, r6
 8007b1e:	f8cb 3004 	str.w	r3, [fp, #4]
 8007b22:	eb0b 0306 	add.w	r3, fp, r6
 8007b26:	2205      	movs	r2, #5
 8007b28:	2e0f      	cmp	r6, #15
 8007b2a:	605a      	str	r2, [r3, #4]
 8007b2c:	609a      	str	r2, [r3, #8]
 8007b2e:	d9a0      	bls.n	8007a72 <_malloc_r+0x322>
 8007b30:	f10b 0108 	add.w	r1, fp, #8
 8007b34:	4648      	mov	r0, r9
 8007b36:	f003 faa1 	bl	800b07c <_free_r>
 8007b3a:	e79a      	b.n	8007a72 <_malloc_r+0x322>
 8007b3c:	68ae      	ldr	r6, [r5, #8]
 8007b3e:	f044 0201 	orr.w	r2, r4, #1
 8007b42:	4434      	add	r4, r6
 8007b44:	f043 0301 	orr.w	r3, r3, #1
 8007b48:	6072      	str	r2, [r6, #4]
 8007b4a:	60ac      	str	r4, [r5, #8]
 8007b4c:	6063      	str	r3, [r4, #4]
 8007b4e:	e631      	b.n	80077b4 <_malloc_r+0x64>
 8007b50:	200084f8 	.word	0x200084f8
 8007b54:	20000558 	.word	0x20000558
 8007b58:	00000080 	.word	0x00000080
 8007b5c:	200084c8 	.word	0x200084c8
 8007b60:	0000007f 	.word	0x0000007f
 8007b64:	200084f0 	.word	0x200084f0
 8007b68:	200084f4 	.word	0x200084f4

08007b6c <memcpy>:
 8007b6c:	b510      	push	{r4, lr}
 8007b6e:	1e43      	subs	r3, r0, #1
 8007b70:	440a      	add	r2, r1
 8007b72:	4291      	cmp	r1, r2
 8007b74:	d100      	bne.n	8007b78 <memcpy+0xc>
 8007b76:	bd10      	pop	{r4, pc}
 8007b78:	f811 4b01 	ldrb.w	r4, [r1], #1
 8007b7c:	f803 4f01 	strb.w	r4, [r3, #1]!
 8007b80:	e7f7      	b.n	8007b72 <memcpy+0x6>

08007b82 <memset>:
 8007b82:	4402      	add	r2, r0
 8007b84:	4603      	mov	r3, r0
 8007b86:	4293      	cmp	r3, r2
 8007b88:	d100      	bne.n	8007b8c <memset+0xa>
 8007b8a:	4770      	bx	lr
 8007b8c:	f803 1b01 	strb.w	r1, [r3], #1
 8007b90:	e7f9      	b.n	8007b86 <memset+0x4>
	...

08007b94 <__malloc_lock>:
 8007b94:	4801      	ldr	r0, [pc, #4]	; (8007b9c <__malloc_lock+0x8>)
 8007b96:	f003 bcbb 	b.w	800b510 <__retarget_lock_acquire_recursive>
 8007b9a:	bf00      	nop
 8007b9c:	20008d70 	.word	0x20008d70

08007ba0 <__malloc_unlock>:
 8007ba0:	4801      	ldr	r0, [pc, #4]	; (8007ba8 <__malloc_unlock+0x8>)
 8007ba2:	f003 bcb6 	b.w	800b512 <__retarget_lock_release_recursive>
 8007ba6:	bf00      	nop
 8007ba8:	20008d70 	.word	0x20008d70

08007bac <printf>:
 8007bac:	b40f      	push	{r0, r1, r2, r3}
 8007bae:	4b0a      	ldr	r3, [pc, #40]	; (8007bd8 <printf+0x2c>)
 8007bb0:	b513      	push	{r0, r1, r4, lr}
 8007bb2:	681c      	ldr	r4, [r3, #0]
 8007bb4:	b124      	cbz	r4, 8007bc0 <printf+0x14>
 8007bb6:	69a3      	ldr	r3, [r4, #24]
 8007bb8:	b913      	cbnz	r3, 8007bc0 <printf+0x14>
 8007bba:	4620      	mov	r0, r4
 8007bbc:	f003 f988 	bl	800aed0 <__sinit>
 8007bc0:	ab05      	add	r3, sp, #20
 8007bc2:	9a04      	ldr	r2, [sp, #16]
 8007bc4:	68a1      	ldr	r1, [r4, #8]
 8007bc6:	9301      	str	r3, [sp, #4]
 8007bc8:	4620      	mov	r0, r4
 8007bca:	f001 f915 	bl	8008df8 <_vfprintf_r>
 8007bce:	b002      	add	sp, #8
 8007bd0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8007bd4:	b004      	add	sp, #16
 8007bd6:	4770      	bx	lr
 8007bd8:	2000005c 	.word	0x2000005c

08007bdc <_puts_r>:
 8007bdc:	b530      	push	{r4, r5, lr}
 8007bde:	4605      	mov	r5, r0
 8007be0:	b089      	sub	sp, #36	; 0x24
 8007be2:	4608      	mov	r0, r1
 8007be4:	460c      	mov	r4, r1
 8007be6:	f7f8 fafd 	bl	80001e4 <strlen>
 8007bea:	4b28      	ldr	r3, [pc, #160]	; (8007c8c <_puts_r+0xb0>)
 8007bec:	9306      	str	r3, [sp, #24]
 8007bee:	2301      	movs	r3, #1
 8007bf0:	9005      	str	r0, [sp, #20]
 8007bf2:	9307      	str	r3, [sp, #28]
 8007bf4:	4418      	add	r0, r3
 8007bf6:	ab04      	add	r3, sp, #16
 8007bf8:	9301      	str	r3, [sp, #4]
 8007bfa:	2302      	movs	r3, #2
 8007bfc:	9404      	str	r4, [sp, #16]
 8007bfe:	9003      	str	r0, [sp, #12]
 8007c00:	9302      	str	r3, [sp, #8]
 8007c02:	b125      	cbz	r5, 8007c0e <_puts_r+0x32>
 8007c04:	69ab      	ldr	r3, [r5, #24]
 8007c06:	b913      	cbnz	r3, 8007c0e <_puts_r+0x32>
 8007c08:	4628      	mov	r0, r5
 8007c0a:	f003 f961 	bl	800aed0 <__sinit>
 8007c0e:	69ab      	ldr	r3, [r5, #24]
 8007c10:	68ac      	ldr	r4, [r5, #8]
 8007c12:	b913      	cbnz	r3, 8007c1a <_puts_r+0x3e>
 8007c14:	4628      	mov	r0, r5
 8007c16:	f003 f95b 	bl	800aed0 <__sinit>
 8007c1a:	4b1d      	ldr	r3, [pc, #116]	; (8007c90 <_puts_r+0xb4>)
 8007c1c:	429c      	cmp	r4, r3
 8007c1e:	d12a      	bne.n	8007c76 <_puts_r+0x9a>
 8007c20:	686c      	ldr	r4, [r5, #4]
 8007c22:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8007c24:	07db      	lsls	r3, r3, #31
 8007c26:	d405      	bmi.n	8007c34 <_puts_r+0x58>
 8007c28:	89a3      	ldrh	r3, [r4, #12]
 8007c2a:	0598      	lsls	r0, r3, #22
 8007c2c:	d402      	bmi.n	8007c34 <_puts_r+0x58>
 8007c2e:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8007c30:	f003 fc6e 	bl	800b510 <__retarget_lock_acquire_recursive>
 8007c34:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8007c38:	0499      	lsls	r1, r3, #18
 8007c3a:	d406      	bmi.n	8007c4a <_puts_r+0x6e>
 8007c3c:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8007c40:	81a3      	strh	r3, [r4, #12]
 8007c42:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8007c44:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8007c48:	6663      	str	r3, [r4, #100]	; 0x64
 8007c4a:	4628      	mov	r0, r5
 8007c4c:	aa01      	add	r2, sp, #4
 8007c4e:	4621      	mov	r1, r4
 8007c50:	f003 fad0 	bl	800b1f4 <__sfvwrite_r>
 8007c54:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8007c56:	2800      	cmp	r0, #0
 8007c58:	bf14      	ite	ne
 8007c5a:	f04f 35ff 	movne.w	r5, #4294967295
 8007c5e:	250a      	moveq	r5, #10
 8007c60:	07da      	lsls	r2, r3, #31
 8007c62:	d405      	bmi.n	8007c70 <_puts_r+0x94>
 8007c64:	89a3      	ldrh	r3, [r4, #12]
 8007c66:	059b      	lsls	r3, r3, #22
 8007c68:	d402      	bmi.n	8007c70 <_puts_r+0x94>
 8007c6a:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8007c6c:	f003 fc51 	bl	800b512 <__retarget_lock_release_recursive>
 8007c70:	4628      	mov	r0, r5
 8007c72:	b009      	add	sp, #36	; 0x24
 8007c74:	bd30      	pop	{r4, r5, pc}
 8007c76:	4b07      	ldr	r3, [pc, #28]	; (8007c94 <_puts_r+0xb8>)
 8007c78:	429c      	cmp	r4, r3
 8007c7a:	d101      	bne.n	8007c80 <_puts_r+0xa4>
 8007c7c:	68ac      	ldr	r4, [r5, #8]
 8007c7e:	e7d0      	b.n	8007c22 <_puts_r+0x46>
 8007c80:	4b05      	ldr	r3, [pc, #20]	; (8007c98 <_puts_r+0xbc>)
 8007c82:	429c      	cmp	r4, r3
 8007c84:	bf08      	it	eq
 8007c86:	68ec      	ldreq	r4, [r5, #12]
 8007c88:	e7cb      	b.n	8007c22 <_puts_r+0x46>
 8007c8a:	bf00      	nop
 8007c8c:	0800d114 	.word	0x0800d114
 8007c90:	0800d290 	.word	0x0800d290
 8007c94:	0800d2b0 	.word	0x0800d2b0
 8007c98:	0800d270 	.word	0x0800d270

08007c9c <puts>:
 8007c9c:	4b02      	ldr	r3, [pc, #8]	; (8007ca8 <puts+0xc>)
 8007c9e:	4601      	mov	r1, r0
 8007ca0:	6818      	ldr	r0, [r3, #0]
 8007ca2:	f7ff bf9b 	b.w	8007bdc <_puts_r>
 8007ca6:	bf00      	nop
 8007ca8:	2000005c 	.word	0x2000005c

08007cac <_sbrk_r>:
 8007cac:	b538      	push	{r3, r4, r5, lr}
 8007cae:	4c06      	ldr	r4, [pc, #24]	; (8007cc8 <_sbrk_r+0x1c>)
 8007cb0:	2300      	movs	r3, #0
 8007cb2:	4605      	mov	r5, r0
 8007cb4:	4608      	mov	r0, r1
 8007cb6:	6023      	str	r3, [r4, #0]
 8007cb8:	f7ff fca0 	bl	80075fc <_sbrk>
 8007cbc:	1c43      	adds	r3, r0, #1
 8007cbe:	d102      	bne.n	8007cc6 <_sbrk_r+0x1a>
 8007cc0:	6823      	ldr	r3, [r4, #0]
 8007cc2:	b103      	cbz	r3, 8007cc6 <_sbrk_r+0x1a>
 8007cc4:	602b      	str	r3, [r5, #0]
 8007cc6:	bd38      	pop	{r3, r4, r5, pc}
 8007cc8:	20008d78 	.word	0x20008d78

08007ccc <sprintf>:
 8007ccc:	b40e      	push	{r1, r2, r3}
 8007cce:	b500      	push	{lr}
 8007cd0:	b09c      	sub	sp, #112	; 0x70
 8007cd2:	f44f 7102 	mov.w	r1, #520	; 0x208
 8007cd6:	ab1d      	add	r3, sp, #116	; 0x74
 8007cd8:	f8ad 1014 	strh.w	r1, [sp, #20]
 8007cdc:	9002      	str	r0, [sp, #8]
 8007cde:	9006      	str	r0, [sp, #24]
 8007ce0:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 8007ce4:	480a      	ldr	r0, [pc, #40]	; (8007d10 <sprintf+0x44>)
 8007ce6:	9104      	str	r1, [sp, #16]
 8007ce8:	9107      	str	r1, [sp, #28]
 8007cea:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8007cee:	f853 2b04 	ldr.w	r2, [r3], #4
 8007cf2:	f8ad 1016 	strh.w	r1, [sp, #22]
 8007cf6:	6800      	ldr	r0, [r0, #0]
 8007cf8:	9301      	str	r3, [sp, #4]
 8007cfa:	a902      	add	r1, sp, #8
 8007cfc:	f000 f8a8 	bl	8007e50 <_svfprintf_r>
 8007d00:	9b02      	ldr	r3, [sp, #8]
 8007d02:	2200      	movs	r2, #0
 8007d04:	701a      	strb	r2, [r3, #0]
 8007d06:	b01c      	add	sp, #112	; 0x70
 8007d08:	f85d eb04 	ldr.w	lr, [sp], #4
 8007d0c:	b003      	add	sp, #12
 8007d0e:	4770      	bx	lr
 8007d10:	2000005c 	.word	0x2000005c

08007d14 <strcpy>:
 8007d14:	4603      	mov	r3, r0
 8007d16:	f811 2b01 	ldrb.w	r2, [r1], #1
 8007d1a:	f803 2b01 	strb.w	r2, [r3], #1
 8007d1e:	2a00      	cmp	r2, #0
 8007d20:	d1f9      	bne.n	8007d16 <strcpy+0x2>
 8007d22:	4770      	bx	lr

08007d24 <_strtol_l.isra.0>:
 8007d24:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007d28:	4680      	mov	r8, r0
 8007d2a:	4689      	mov	r9, r1
 8007d2c:	4692      	mov	sl, r2
 8007d2e:	461f      	mov	r7, r3
 8007d30:	468b      	mov	fp, r1
 8007d32:	465d      	mov	r5, fp
 8007d34:	980a      	ldr	r0, [sp, #40]	; 0x28
 8007d36:	f815 4b01 	ldrb.w	r4, [r5], #1
 8007d3a:	f003 fbd5 	bl	800b4e8 <__locale_ctype_ptr_l>
 8007d3e:	4420      	add	r0, r4
 8007d40:	7846      	ldrb	r6, [r0, #1]
 8007d42:	f016 0608 	ands.w	r6, r6, #8
 8007d46:	d10b      	bne.n	8007d60 <_strtol_l.isra.0+0x3c>
 8007d48:	2c2d      	cmp	r4, #45	; 0x2d
 8007d4a:	d10b      	bne.n	8007d64 <_strtol_l.isra.0+0x40>
 8007d4c:	782c      	ldrb	r4, [r5, #0]
 8007d4e:	2601      	movs	r6, #1
 8007d50:	f10b 0502 	add.w	r5, fp, #2
 8007d54:	b167      	cbz	r7, 8007d70 <_strtol_l.isra.0+0x4c>
 8007d56:	2f10      	cmp	r7, #16
 8007d58:	d114      	bne.n	8007d84 <_strtol_l.isra.0+0x60>
 8007d5a:	2c30      	cmp	r4, #48	; 0x30
 8007d5c:	d00a      	beq.n	8007d74 <_strtol_l.isra.0+0x50>
 8007d5e:	e011      	b.n	8007d84 <_strtol_l.isra.0+0x60>
 8007d60:	46ab      	mov	fp, r5
 8007d62:	e7e6      	b.n	8007d32 <_strtol_l.isra.0+0xe>
 8007d64:	2c2b      	cmp	r4, #43	; 0x2b
 8007d66:	bf04      	itt	eq
 8007d68:	782c      	ldrbeq	r4, [r5, #0]
 8007d6a:	f10b 0502 	addeq.w	r5, fp, #2
 8007d6e:	e7f1      	b.n	8007d54 <_strtol_l.isra.0+0x30>
 8007d70:	2c30      	cmp	r4, #48	; 0x30
 8007d72:	d127      	bne.n	8007dc4 <_strtol_l.isra.0+0xa0>
 8007d74:	782b      	ldrb	r3, [r5, #0]
 8007d76:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 8007d7a:	2b58      	cmp	r3, #88	; 0x58
 8007d7c:	d14b      	bne.n	8007e16 <_strtol_l.isra.0+0xf2>
 8007d7e:	786c      	ldrb	r4, [r5, #1]
 8007d80:	2710      	movs	r7, #16
 8007d82:	3502      	adds	r5, #2
 8007d84:	2e00      	cmp	r6, #0
 8007d86:	bf0c      	ite	eq
 8007d88:	f06f 4100 	mvneq.w	r1, #2147483648	; 0x80000000
 8007d8c:	f04f 4100 	movne.w	r1, #2147483648	; 0x80000000
 8007d90:	2200      	movs	r2, #0
 8007d92:	fbb1 fef7 	udiv	lr, r1, r7
 8007d96:	4610      	mov	r0, r2
 8007d98:	fb07 1c1e 	mls	ip, r7, lr, r1
 8007d9c:	f1a4 0330 	sub.w	r3, r4, #48	; 0x30
 8007da0:	2b09      	cmp	r3, #9
 8007da2:	d811      	bhi.n	8007dc8 <_strtol_l.isra.0+0xa4>
 8007da4:	461c      	mov	r4, r3
 8007da6:	42a7      	cmp	r7, r4
 8007da8:	dd1d      	ble.n	8007de6 <_strtol_l.isra.0+0xc2>
 8007daa:	1c53      	adds	r3, r2, #1
 8007dac:	d007      	beq.n	8007dbe <_strtol_l.isra.0+0x9a>
 8007dae:	4586      	cmp	lr, r0
 8007db0:	d316      	bcc.n	8007de0 <_strtol_l.isra.0+0xbc>
 8007db2:	d101      	bne.n	8007db8 <_strtol_l.isra.0+0x94>
 8007db4:	45a4      	cmp	ip, r4
 8007db6:	db13      	blt.n	8007de0 <_strtol_l.isra.0+0xbc>
 8007db8:	fb00 4007 	mla	r0, r0, r7, r4
 8007dbc:	2201      	movs	r2, #1
 8007dbe:	f815 4b01 	ldrb.w	r4, [r5], #1
 8007dc2:	e7eb      	b.n	8007d9c <_strtol_l.isra.0+0x78>
 8007dc4:	270a      	movs	r7, #10
 8007dc6:	e7dd      	b.n	8007d84 <_strtol_l.isra.0+0x60>
 8007dc8:	f1a4 0341 	sub.w	r3, r4, #65	; 0x41
 8007dcc:	2b19      	cmp	r3, #25
 8007dce:	d801      	bhi.n	8007dd4 <_strtol_l.isra.0+0xb0>
 8007dd0:	3c37      	subs	r4, #55	; 0x37
 8007dd2:	e7e8      	b.n	8007da6 <_strtol_l.isra.0+0x82>
 8007dd4:	f1a4 0361 	sub.w	r3, r4, #97	; 0x61
 8007dd8:	2b19      	cmp	r3, #25
 8007dda:	d804      	bhi.n	8007de6 <_strtol_l.isra.0+0xc2>
 8007ddc:	3c57      	subs	r4, #87	; 0x57
 8007dde:	e7e2      	b.n	8007da6 <_strtol_l.isra.0+0x82>
 8007de0:	f04f 32ff 	mov.w	r2, #4294967295
 8007de4:	e7eb      	b.n	8007dbe <_strtol_l.isra.0+0x9a>
 8007de6:	1c53      	adds	r3, r2, #1
 8007de8:	d108      	bne.n	8007dfc <_strtol_l.isra.0+0xd8>
 8007dea:	2322      	movs	r3, #34	; 0x22
 8007dec:	f8c8 3000 	str.w	r3, [r8]
 8007df0:	4608      	mov	r0, r1
 8007df2:	f1ba 0f00 	cmp.w	sl, #0
 8007df6:	d107      	bne.n	8007e08 <_strtol_l.isra.0+0xe4>
 8007df8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8007dfc:	b106      	cbz	r6, 8007e00 <_strtol_l.isra.0+0xdc>
 8007dfe:	4240      	negs	r0, r0
 8007e00:	f1ba 0f00 	cmp.w	sl, #0
 8007e04:	d00c      	beq.n	8007e20 <_strtol_l.isra.0+0xfc>
 8007e06:	b122      	cbz	r2, 8007e12 <_strtol_l.isra.0+0xee>
 8007e08:	3d01      	subs	r5, #1
 8007e0a:	f8ca 5000 	str.w	r5, [sl]
 8007e0e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8007e12:	464d      	mov	r5, r9
 8007e14:	e7f9      	b.n	8007e0a <_strtol_l.isra.0+0xe6>
 8007e16:	2430      	movs	r4, #48	; 0x30
 8007e18:	2f00      	cmp	r7, #0
 8007e1a:	d1b3      	bne.n	8007d84 <_strtol_l.isra.0+0x60>
 8007e1c:	2708      	movs	r7, #8
 8007e1e:	e7b1      	b.n	8007d84 <_strtol_l.isra.0+0x60>
 8007e20:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

08007e24 <strtol>:
 8007e24:	4b08      	ldr	r3, [pc, #32]	; (8007e48 <strtol+0x24>)
 8007e26:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8007e28:	681c      	ldr	r4, [r3, #0]
 8007e2a:	4d08      	ldr	r5, [pc, #32]	; (8007e4c <strtol+0x28>)
 8007e2c:	6a23      	ldr	r3, [r4, #32]
 8007e2e:	2b00      	cmp	r3, #0
 8007e30:	bf08      	it	eq
 8007e32:	462b      	moveq	r3, r5
 8007e34:	9300      	str	r3, [sp, #0]
 8007e36:	4613      	mov	r3, r2
 8007e38:	460a      	mov	r2, r1
 8007e3a:	4601      	mov	r1, r0
 8007e3c:	4620      	mov	r0, r4
 8007e3e:	f7ff ff71 	bl	8007d24 <_strtol_l.isra.0>
 8007e42:	b003      	add	sp, #12
 8007e44:	bd30      	pop	{r4, r5, pc}
 8007e46:	bf00      	nop
 8007e48:	2000005c 	.word	0x2000005c
 8007e4c:	20000560 	.word	0x20000560

08007e50 <_svfprintf_r>:
 8007e50:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007e54:	b0bd      	sub	sp, #244	; 0xf4
 8007e56:	468a      	mov	sl, r1
 8007e58:	4615      	mov	r5, r2
 8007e5a:	461f      	mov	r7, r3
 8007e5c:	4683      	mov	fp, r0
 8007e5e:	f003 fb47 	bl	800b4f0 <_localeconv_r>
 8007e62:	6803      	ldr	r3, [r0, #0]
 8007e64:	930d      	str	r3, [sp, #52]	; 0x34
 8007e66:	4618      	mov	r0, r3
 8007e68:	f7f8 f9bc 	bl	80001e4 <strlen>
 8007e6c:	f8ba 300c 	ldrh.w	r3, [sl, #12]
 8007e70:	9008      	str	r0, [sp, #32]
 8007e72:	061b      	lsls	r3, r3, #24
 8007e74:	d518      	bpl.n	8007ea8 <_svfprintf_r+0x58>
 8007e76:	f8da 3010 	ldr.w	r3, [sl, #16]
 8007e7a:	b9ab      	cbnz	r3, 8007ea8 <_svfprintf_r+0x58>
 8007e7c:	2140      	movs	r1, #64	; 0x40
 8007e7e:	4658      	mov	r0, fp
 8007e80:	f7ff fc66 	bl	8007750 <_malloc_r>
 8007e84:	f8ca 0000 	str.w	r0, [sl]
 8007e88:	f8ca 0010 	str.w	r0, [sl, #16]
 8007e8c:	b948      	cbnz	r0, 8007ea2 <_svfprintf_r+0x52>
 8007e8e:	230c      	movs	r3, #12
 8007e90:	f8cb 3000 	str.w	r3, [fp]
 8007e94:	f04f 33ff 	mov.w	r3, #4294967295
 8007e98:	9309      	str	r3, [sp, #36]	; 0x24
 8007e9a:	9809      	ldr	r0, [sp, #36]	; 0x24
 8007e9c:	b03d      	add	sp, #244	; 0xf4
 8007e9e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8007ea2:	2340      	movs	r3, #64	; 0x40
 8007ea4:	f8ca 3014 	str.w	r3, [sl, #20]
 8007ea8:	ed9f 7b99 	vldr	d7, [pc, #612]	; 8008110 <_svfprintf_r+0x2c0>
 8007eac:	ed8d 7b06 	vstr	d7, [sp, #24]
 8007eb0:	2300      	movs	r3, #0
 8007eb2:	ac2c      	add	r4, sp, #176	; 0xb0
 8007eb4:	941f      	str	r4, [sp, #124]	; 0x7c
 8007eb6:	9321      	str	r3, [sp, #132]	; 0x84
 8007eb8:	9320      	str	r3, [sp, #128]	; 0x80
 8007eba:	9505      	str	r5, [sp, #20]
 8007ebc:	9303      	str	r3, [sp, #12]
 8007ebe:	9311      	str	r3, [sp, #68]	; 0x44
 8007ec0:	9310      	str	r3, [sp, #64]	; 0x40
 8007ec2:	9309      	str	r3, [sp, #36]	; 0x24
 8007ec4:	9d05      	ldr	r5, [sp, #20]
 8007ec6:	462b      	mov	r3, r5
 8007ec8:	f813 2b01 	ldrb.w	r2, [r3], #1
 8007ecc:	b112      	cbz	r2, 8007ed4 <_svfprintf_r+0x84>
 8007ece:	2a25      	cmp	r2, #37	; 0x25
 8007ed0:	f040 8083 	bne.w	8007fda <_svfprintf_r+0x18a>
 8007ed4:	9b05      	ldr	r3, [sp, #20]
 8007ed6:	1aee      	subs	r6, r5, r3
 8007ed8:	d00d      	beq.n	8007ef6 <_svfprintf_r+0xa6>
 8007eda:	e884 0048 	stmia.w	r4, {r3, r6}
 8007ede:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8007ee0:	4433      	add	r3, r6
 8007ee2:	9321      	str	r3, [sp, #132]	; 0x84
 8007ee4:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8007ee6:	3301      	adds	r3, #1
 8007ee8:	2b07      	cmp	r3, #7
 8007eea:	9320      	str	r3, [sp, #128]	; 0x80
 8007eec:	dc77      	bgt.n	8007fde <_svfprintf_r+0x18e>
 8007eee:	3408      	adds	r4, #8
 8007ef0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8007ef2:	4433      	add	r3, r6
 8007ef4:	9309      	str	r3, [sp, #36]	; 0x24
 8007ef6:	782b      	ldrb	r3, [r5, #0]
 8007ef8:	2b00      	cmp	r3, #0
 8007efa:	f000 8729 	beq.w	8008d50 <_svfprintf_r+0xf00>
 8007efe:	2300      	movs	r3, #0
 8007f00:	1c69      	adds	r1, r5, #1
 8007f02:	f88d 305f 	strb.w	r3, [sp, #95]	; 0x5f
 8007f06:	461a      	mov	r2, r3
 8007f08:	f04f 39ff 	mov.w	r9, #4294967295
 8007f0c:	930a      	str	r3, [sp, #40]	; 0x28
 8007f0e:	461d      	mov	r5, r3
 8007f10:	200a      	movs	r0, #10
 8007f12:	1c4e      	adds	r6, r1, #1
 8007f14:	7809      	ldrb	r1, [r1, #0]
 8007f16:	9605      	str	r6, [sp, #20]
 8007f18:	9102      	str	r1, [sp, #8]
 8007f1a:	9902      	ldr	r1, [sp, #8]
 8007f1c:	3920      	subs	r1, #32
 8007f1e:	2958      	cmp	r1, #88	; 0x58
 8007f20:	f200 8418 	bhi.w	8008754 <_svfprintf_r+0x904>
 8007f24:	e8df f011 	tbh	[pc, r1, lsl #1]
 8007f28:	041600a6 	.word	0x041600a6
 8007f2c:	00ab0416 	.word	0x00ab0416
 8007f30:	04160416 	.word	0x04160416
 8007f34:	04160416 	.word	0x04160416
 8007f38:	04160416 	.word	0x04160416
 8007f3c:	006500ae 	.word	0x006500ae
 8007f40:	00b70416 	.word	0x00b70416
 8007f44:	041600ba 	.word	0x041600ba
 8007f48:	00da00d7 	.word	0x00da00d7
 8007f4c:	00da00da 	.word	0x00da00da
 8007f50:	00da00da 	.word	0x00da00da
 8007f54:	00da00da 	.word	0x00da00da
 8007f58:	00da00da 	.word	0x00da00da
 8007f5c:	04160416 	.word	0x04160416
 8007f60:	04160416 	.word	0x04160416
 8007f64:	04160416 	.word	0x04160416
 8007f68:	04160416 	.word	0x04160416
 8007f6c:	04160416 	.word	0x04160416
 8007f70:	012b0115 	.word	0x012b0115
 8007f74:	012b0416 	.word	0x012b0416
 8007f78:	04160416 	.word	0x04160416
 8007f7c:	04160416 	.word	0x04160416
 8007f80:	041600ed 	.word	0x041600ed
 8007f84:	03400416 	.word	0x03400416
 8007f88:	04160416 	.word	0x04160416
 8007f8c:	04160416 	.word	0x04160416
 8007f90:	03a80416 	.word	0x03a80416
 8007f94:	04160416 	.word	0x04160416
 8007f98:	04160086 	.word	0x04160086
 8007f9c:	04160416 	.word	0x04160416
 8007fa0:	04160416 	.word	0x04160416
 8007fa4:	04160416 	.word	0x04160416
 8007fa8:	04160416 	.word	0x04160416
 8007fac:	01070416 	.word	0x01070416
 8007fb0:	012b006b 	.word	0x012b006b
 8007fb4:	012b012b 	.word	0x012b012b
 8007fb8:	006b00f0 	.word	0x006b00f0
 8007fbc:	04160416 	.word	0x04160416
 8007fc0:	041600fa 	.word	0x041600fa
 8007fc4:	03420322 	.word	0x03420322
 8007fc8:	01010376 	.word	0x01010376
 8007fcc:	03870416 	.word	0x03870416
 8007fd0:	03aa0416 	.word	0x03aa0416
 8007fd4:	04160416 	.word	0x04160416
 8007fd8:	03c2      	.short	0x03c2
 8007fda:	461d      	mov	r5, r3
 8007fdc:	e773      	b.n	8007ec6 <_svfprintf_r+0x76>
 8007fde:	aa1f      	add	r2, sp, #124	; 0x7c
 8007fe0:	4651      	mov	r1, sl
 8007fe2:	4658      	mov	r0, fp
 8007fe4:	f003 ffc1 	bl	800bf6a <__ssprint_r>
 8007fe8:	2800      	cmp	r0, #0
 8007fea:	f040 8692 	bne.w	8008d12 <_svfprintf_r+0xec2>
 8007fee:	ac2c      	add	r4, sp, #176	; 0xb0
 8007ff0:	e77e      	b.n	8007ef0 <_svfprintf_r+0xa0>
 8007ff2:	2301      	movs	r3, #1
 8007ff4:	222b      	movs	r2, #43	; 0x2b
 8007ff6:	9905      	ldr	r1, [sp, #20]
 8007ff8:	e78b      	b.n	8007f12 <_svfprintf_r+0xc2>
 8007ffa:	460f      	mov	r7, r1
 8007ffc:	e7fb      	b.n	8007ff6 <_svfprintf_r+0x1a6>
 8007ffe:	b10b      	cbz	r3, 8008004 <_svfprintf_r+0x1b4>
 8008000:	f88d 205f 	strb.w	r2, [sp, #95]	; 0x5f
 8008004:	06ae      	lsls	r6, r5, #26
 8008006:	f140 80aa 	bpl.w	800815e <_svfprintf_r+0x30e>
 800800a:	3707      	adds	r7, #7
 800800c:	f027 0707 	bic.w	r7, r7, #7
 8008010:	f107 0308 	add.w	r3, r7, #8
 8008014:	e9d7 6700 	ldrd	r6, r7, [r7]
 8008018:	9304      	str	r3, [sp, #16]
 800801a:	2e00      	cmp	r6, #0
 800801c:	f177 0300 	sbcs.w	r3, r7, #0
 8008020:	da06      	bge.n	8008030 <_svfprintf_r+0x1e0>
 8008022:	4276      	negs	r6, r6
 8008024:	f04f 032d 	mov.w	r3, #45	; 0x2d
 8008028:	eb67 0747 	sbc.w	r7, r7, r7, lsl #1
 800802c:	f88d 305f 	strb.w	r3, [sp, #95]	; 0x5f
 8008030:	2301      	movs	r3, #1
 8008032:	e2ca      	b.n	80085ca <_svfprintf_r+0x77a>
 8008034:	b10b      	cbz	r3, 800803a <_svfprintf_r+0x1ea>
 8008036:	f88d 205f 	strb.w	r2, [sp, #95]	; 0x5f
 800803a:	4b37      	ldr	r3, [pc, #220]	; (8008118 <_svfprintf_r+0x2c8>)
 800803c:	9311      	str	r3, [sp, #68]	; 0x44
 800803e:	06ab      	lsls	r3, r5, #26
 8008040:	f140 8339 	bpl.w	80086b6 <_svfprintf_r+0x866>
 8008044:	3707      	adds	r7, #7
 8008046:	f027 0707 	bic.w	r7, r7, #7
 800804a:	f107 0308 	add.w	r3, r7, #8
 800804e:	e9d7 6700 	ldrd	r6, r7, [r7]
 8008052:	9304      	str	r3, [sp, #16]
 8008054:	07e8      	lsls	r0, r5, #31
 8008056:	d50b      	bpl.n	8008070 <_svfprintf_r+0x220>
 8008058:	ea56 0307 	orrs.w	r3, r6, r7
 800805c:	d008      	beq.n	8008070 <_svfprintf_r+0x220>
 800805e:	2330      	movs	r3, #48	; 0x30
 8008060:	f88d 3060 	strb.w	r3, [sp, #96]	; 0x60
 8008064:	f89d 3008 	ldrb.w	r3, [sp, #8]
 8008068:	f88d 3061 	strb.w	r3, [sp, #97]	; 0x61
 800806c:	f045 0502 	orr.w	r5, r5, #2
 8008070:	2302      	movs	r3, #2
 8008072:	e2a7      	b.n	80085c4 <_svfprintf_r+0x774>
 8008074:	2a00      	cmp	r2, #0
 8008076:	d1be      	bne.n	8007ff6 <_svfprintf_r+0x1a6>
 8008078:	2301      	movs	r3, #1
 800807a:	2220      	movs	r2, #32
 800807c:	e7bb      	b.n	8007ff6 <_svfprintf_r+0x1a6>
 800807e:	f045 0501 	orr.w	r5, r5, #1
 8008082:	e7b8      	b.n	8007ff6 <_svfprintf_r+0x1a6>
 8008084:	683e      	ldr	r6, [r7, #0]
 8008086:	960a      	str	r6, [sp, #40]	; 0x28
 8008088:	2e00      	cmp	r6, #0
 800808a:	f107 0104 	add.w	r1, r7, #4
 800808e:	dab4      	bge.n	8007ffa <_svfprintf_r+0x1aa>
 8008090:	4276      	negs	r6, r6
 8008092:	960a      	str	r6, [sp, #40]	; 0x28
 8008094:	460f      	mov	r7, r1
 8008096:	f045 0504 	orr.w	r5, r5, #4
 800809a:	e7ac      	b.n	8007ff6 <_svfprintf_r+0x1a6>
 800809c:	9905      	ldr	r1, [sp, #20]
 800809e:	1c4e      	adds	r6, r1, #1
 80080a0:	7809      	ldrb	r1, [r1, #0]
 80080a2:	9102      	str	r1, [sp, #8]
 80080a4:	292a      	cmp	r1, #42	; 0x2a
 80080a6:	d010      	beq.n	80080ca <_svfprintf_r+0x27a>
 80080a8:	f04f 0900 	mov.w	r9, #0
 80080ac:	9605      	str	r6, [sp, #20]
 80080ae:	9902      	ldr	r1, [sp, #8]
 80080b0:	3930      	subs	r1, #48	; 0x30
 80080b2:	2909      	cmp	r1, #9
 80080b4:	f63f af31 	bhi.w	8007f1a <_svfprintf_r+0xca>
 80080b8:	fb00 1909 	mla	r9, r0, r9, r1
 80080bc:	9905      	ldr	r1, [sp, #20]
 80080be:	460e      	mov	r6, r1
 80080c0:	f816 1b01 	ldrb.w	r1, [r6], #1
 80080c4:	9102      	str	r1, [sp, #8]
 80080c6:	9605      	str	r6, [sp, #20]
 80080c8:	e7f1      	b.n	80080ae <_svfprintf_r+0x25e>
 80080ca:	6839      	ldr	r1, [r7, #0]
 80080cc:	9605      	str	r6, [sp, #20]
 80080ce:	ea41 79e1 	orr.w	r9, r1, r1, asr #31
 80080d2:	3704      	adds	r7, #4
 80080d4:	e78f      	b.n	8007ff6 <_svfprintf_r+0x1a6>
 80080d6:	f045 0580 	orr.w	r5, r5, #128	; 0x80
 80080da:	e78c      	b.n	8007ff6 <_svfprintf_r+0x1a6>
 80080dc:	2100      	movs	r1, #0
 80080de:	910a      	str	r1, [sp, #40]	; 0x28
 80080e0:	9902      	ldr	r1, [sp, #8]
 80080e2:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 80080e4:	3930      	subs	r1, #48	; 0x30
 80080e6:	fb00 1106 	mla	r1, r0, r6, r1
 80080ea:	910a      	str	r1, [sp, #40]	; 0x28
 80080ec:	9905      	ldr	r1, [sp, #20]
 80080ee:	460e      	mov	r6, r1
 80080f0:	f816 1b01 	ldrb.w	r1, [r6], #1
 80080f4:	9102      	str	r1, [sp, #8]
 80080f6:	9902      	ldr	r1, [sp, #8]
 80080f8:	9605      	str	r6, [sp, #20]
 80080fa:	3930      	subs	r1, #48	; 0x30
 80080fc:	2909      	cmp	r1, #9
 80080fe:	d9ef      	bls.n	80080e0 <_svfprintf_r+0x290>
 8008100:	e70b      	b.n	8007f1a <_svfprintf_r+0xca>
 8008102:	f045 0508 	orr.w	r5, r5, #8
 8008106:	e776      	b.n	8007ff6 <_svfprintf_r+0x1a6>
 8008108:	f045 0540 	orr.w	r5, r5, #64	; 0x40
 800810c:	e773      	b.n	8007ff6 <_svfprintf_r+0x1a6>
 800810e:	bf00      	nop
	...
 8008118:	0800d1fc 	.word	0x0800d1fc
 800811c:	9905      	ldr	r1, [sp, #20]
 800811e:	7809      	ldrb	r1, [r1, #0]
 8008120:	296c      	cmp	r1, #108	; 0x6c
 8008122:	d105      	bne.n	8008130 <_svfprintf_r+0x2e0>
 8008124:	9905      	ldr	r1, [sp, #20]
 8008126:	3101      	adds	r1, #1
 8008128:	9105      	str	r1, [sp, #20]
 800812a:	f045 0520 	orr.w	r5, r5, #32
 800812e:	e762      	b.n	8007ff6 <_svfprintf_r+0x1a6>
 8008130:	f045 0510 	orr.w	r5, r5, #16
 8008134:	e75f      	b.n	8007ff6 <_svfprintf_r+0x1a6>
 8008136:	1d3b      	adds	r3, r7, #4
 8008138:	9304      	str	r3, [sp, #16]
 800813a:	2600      	movs	r6, #0
 800813c:	683b      	ldr	r3, [r7, #0]
 800813e:	f88d 3088 	strb.w	r3, [sp, #136]	; 0x88
 8008142:	f88d 605f 	strb.w	r6, [sp, #95]	; 0x5f
 8008146:	f04f 0901 	mov.w	r9, #1
 800814a:	4637      	mov	r7, r6
 800814c:	f10d 0888 	add.w	r8, sp, #136	; 0x88
 8008150:	e11b      	b.n	800838a <_svfprintf_r+0x53a>
 8008152:	b10b      	cbz	r3, 8008158 <_svfprintf_r+0x308>
 8008154:	f88d 205f 	strb.w	r2, [sp, #95]	; 0x5f
 8008158:	f045 0510 	orr.w	r5, r5, #16
 800815c:	e752      	b.n	8008004 <_svfprintf_r+0x1b4>
 800815e:	f015 0f10 	tst.w	r5, #16
 8008162:	f107 0304 	add.w	r3, r7, #4
 8008166:	d003      	beq.n	8008170 <_svfprintf_r+0x320>
 8008168:	683e      	ldr	r6, [r7, #0]
 800816a:	9304      	str	r3, [sp, #16]
 800816c:	17f7      	asrs	r7, r6, #31
 800816e:	e754      	b.n	800801a <_svfprintf_r+0x1ca>
 8008170:	683e      	ldr	r6, [r7, #0]
 8008172:	9304      	str	r3, [sp, #16]
 8008174:	f015 0f40 	tst.w	r5, #64	; 0x40
 8008178:	bf18      	it	ne
 800817a:	b236      	sxthne	r6, r6
 800817c:	e7f6      	b.n	800816c <_svfprintf_r+0x31c>
 800817e:	b10b      	cbz	r3, 8008184 <_svfprintf_r+0x334>
 8008180:	f88d 205f 	strb.w	r2, [sp, #95]	; 0x5f
 8008184:	3707      	adds	r7, #7
 8008186:	f027 0707 	bic.w	r7, r7, #7
 800818a:	f107 0308 	add.w	r3, r7, #8
 800818e:	9304      	str	r3, [sp, #16]
 8008190:	ed97 7b00 	vldr	d7, [r7]
 8008194:	ed8d 7b06 	vstr	d7, [sp, #24]
 8008198:	9b06      	ldr	r3, [sp, #24]
 800819a:	9312      	str	r3, [sp, #72]	; 0x48
 800819c:	9b07      	ldr	r3, [sp, #28]
 800819e:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 80081a2:	9313      	str	r3, [sp, #76]	; 0x4c
 80081a4:	f04f 32ff 	mov.w	r2, #4294967295
 80081a8:	4b4a      	ldr	r3, [pc, #296]	; (80082d4 <_svfprintf_r+0x484>)
 80081aa:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
 80081ae:	f7f8 fcc9 	bl	8000b44 <__aeabi_dcmpun>
 80081b2:	2800      	cmp	r0, #0
 80081b4:	f040 85d5 	bne.w	8008d62 <_svfprintf_r+0xf12>
 80081b8:	f04f 32ff 	mov.w	r2, #4294967295
 80081bc:	4b45      	ldr	r3, [pc, #276]	; (80082d4 <_svfprintf_r+0x484>)
 80081be:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
 80081c2:	f7f8 fca1 	bl	8000b08 <__aeabi_dcmple>
 80081c6:	2800      	cmp	r0, #0
 80081c8:	f040 85cb 	bne.w	8008d62 <_svfprintf_r+0xf12>
 80081cc:	2200      	movs	r2, #0
 80081ce:	2300      	movs	r3, #0
 80081d0:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 80081d4:	f7f8 fc8e 	bl	8000af4 <__aeabi_dcmplt>
 80081d8:	b110      	cbz	r0, 80081e0 <_svfprintf_r+0x390>
 80081da:	232d      	movs	r3, #45	; 0x2d
 80081dc:	f88d 305f 	strb.w	r3, [sp, #95]	; 0x5f
 80081e0:	4b3d      	ldr	r3, [pc, #244]	; (80082d8 <_svfprintf_r+0x488>)
 80081e2:	4a3e      	ldr	r2, [pc, #248]	; (80082dc <_svfprintf_r+0x48c>)
 80081e4:	9902      	ldr	r1, [sp, #8]
 80081e6:	f025 0580 	bic.w	r5, r5, #128	; 0x80
 80081ea:	2947      	cmp	r1, #71	; 0x47
 80081ec:	bfcc      	ite	gt
 80081ee:	4690      	movgt	r8, r2
 80081f0:	4698      	movle	r8, r3
 80081f2:	f04f 0903 	mov.w	r9, #3
 80081f6:	2600      	movs	r6, #0
 80081f8:	4637      	mov	r7, r6
 80081fa:	e0c6      	b.n	800838a <_svfprintf_r+0x53a>
 80081fc:	f1b9 3fff 	cmp.w	r9, #4294967295
 8008200:	d022      	beq.n	8008248 <_svfprintf_r+0x3f8>
 8008202:	9b02      	ldr	r3, [sp, #8]
 8008204:	f023 0320 	bic.w	r3, r3, #32
 8008208:	2b47      	cmp	r3, #71	; 0x47
 800820a:	d104      	bne.n	8008216 <_svfprintf_r+0x3c6>
 800820c:	f1b9 0f00 	cmp.w	r9, #0
 8008210:	bf08      	it	eq
 8008212:	f04f 0901 	moveq.w	r9, #1
 8008216:	f445 7380 	orr.w	r3, r5, #256	; 0x100
 800821a:	930c      	str	r3, [sp, #48]	; 0x30
 800821c:	9b07      	ldr	r3, [sp, #28]
 800821e:	2b00      	cmp	r3, #0
 8008220:	da15      	bge.n	800824e <_svfprintf_r+0x3fe>
 8008222:	9b06      	ldr	r3, [sp, #24]
 8008224:	930e      	str	r3, [sp, #56]	; 0x38
 8008226:	9b07      	ldr	r3, [sp, #28]
 8008228:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 800822c:	930f      	str	r3, [sp, #60]	; 0x3c
 800822e:	232d      	movs	r3, #45	; 0x2d
 8008230:	930b      	str	r3, [sp, #44]	; 0x2c
 8008232:	9b02      	ldr	r3, [sp, #8]
 8008234:	f023 0720 	bic.w	r7, r3, #32
 8008238:	2f46      	cmp	r7, #70	; 0x46
 800823a:	d00e      	beq.n	800825a <_svfprintf_r+0x40a>
 800823c:	2f45      	cmp	r7, #69	; 0x45
 800823e:	d146      	bne.n	80082ce <_svfprintf_r+0x47e>
 8008240:	f109 0601 	add.w	r6, r9, #1
 8008244:	2102      	movs	r1, #2
 8008246:	e00a      	b.n	800825e <_svfprintf_r+0x40e>
 8008248:	f04f 0906 	mov.w	r9, #6
 800824c:	e7e3      	b.n	8008216 <_svfprintf_r+0x3c6>
 800824e:	ed9d 7b06 	vldr	d7, [sp, #24]
 8008252:	2300      	movs	r3, #0
 8008254:	ed8d 7b0e 	vstr	d7, [sp, #56]	; 0x38
 8008258:	e7ea      	b.n	8008230 <_svfprintf_r+0x3e0>
 800825a:	464e      	mov	r6, r9
 800825c:	2103      	movs	r1, #3
 800825e:	ab1d      	add	r3, sp, #116	; 0x74
 8008260:	9301      	str	r3, [sp, #4]
 8008262:	ab1a      	add	r3, sp, #104	; 0x68
 8008264:	9300      	str	r3, [sp, #0]
 8008266:	4632      	mov	r2, r6
 8008268:	ab19      	add	r3, sp, #100	; 0x64
 800826a:	ed9d 0b0e 	vldr	d0, [sp, #56]	; 0x38
 800826e:	4658      	mov	r0, fp
 8008270:	f001 ff3a 	bl	800a0e8 <_dtoa_r>
 8008274:	2f47      	cmp	r7, #71	; 0x47
 8008276:	4680      	mov	r8, r0
 8008278:	d102      	bne.n	8008280 <_svfprintf_r+0x430>
 800827a:	07e8      	lsls	r0, r5, #31
 800827c:	f140 857e 	bpl.w	8008d7c <_svfprintf_r+0xf2c>
 8008280:	eb08 0306 	add.w	r3, r8, r6
 8008284:	2f46      	cmp	r7, #70	; 0x46
 8008286:	9303      	str	r3, [sp, #12]
 8008288:	d111      	bne.n	80082ae <_svfprintf_r+0x45e>
 800828a:	f898 3000 	ldrb.w	r3, [r8]
 800828e:	2b30      	cmp	r3, #48	; 0x30
 8008290:	d109      	bne.n	80082a6 <_svfprintf_r+0x456>
 8008292:	2200      	movs	r2, #0
 8008294:	2300      	movs	r3, #0
 8008296:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
 800829a:	f7f8 fc21 	bl	8000ae0 <__aeabi_dcmpeq>
 800829e:	b910      	cbnz	r0, 80082a6 <_svfprintf_r+0x456>
 80082a0:	f1c6 0601 	rsb	r6, r6, #1
 80082a4:	9619      	str	r6, [sp, #100]	; 0x64
 80082a6:	9a03      	ldr	r2, [sp, #12]
 80082a8:	9b19      	ldr	r3, [sp, #100]	; 0x64
 80082aa:	441a      	add	r2, r3
 80082ac:	9203      	str	r2, [sp, #12]
 80082ae:	2200      	movs	r2, #0
 80082b0:	2300      	movs	r3, #0
 80082b2:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
 80082b6:	f7f8 fc13 	bl	8000ae0 <__aeabi_dcmpeq>
 80082ba:	b988      	cbnz	r0, 80082e0 <_svfprintf_r+0x490>
 80082bc:	2230      	movs	r2, #48	; 0x30
 80082be:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 80082c0:	9903      	ldr	r1, [sp, #12]
 80082c2:	4299      	cmp	r1, r3
 80082c4:	d90e      	bls.n	80082e4 <_svfprintf_r+0x494>
 80082c6:	1c59      	adds	r1, r3, #1
 80082c8:	911d      	str	r1, [sp, #116]	; 0x74
 80082ca:	701a      	strb	r2, [r3, #0]
 80082cc:	e7f7      	b.n	80082be <_svfprintf_r+0x46e>
 80082ce:	464e      	mov	r6, r9
 80082d0:	e7b8      	b.n	8008244 <_svfprintf_r+0x3f4>
 80082d2:	bf00      	nop
 80082d4:	7fefffff 	.word	0x7fefffff
 80082d8:	0800d1ec 	.word	0x0800d1ec
 80082dc:	0800d1f0 	.word	0x0800d1f0
 80082e0:	9b03      	ldr	r3, [sp, #12]
 80082e2:	931d      	str	r3, [sp, #116]	; 0x74
 80082e4:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 80082e6:	2f47      	cmp	r7, #71	; 0x47
 80082e8:	eba3 0308 	sub.w	r3, r3, r8
 80082ec:	9303      	str	r3, [sp, #12]
 80082ee:	f040 80fa 	bne.w	80084e6 <_svfprintf_r+0x696>
 80082f2:	9b19      	ldr	r3, [sp, #100]	; 0x64
 80082f4:	1cd9      	adds	r1, r3, #3
 80082f6:	db02      	blt.n	80082fe <_svfprintf_r+0x4ae>
 80082f8:	4599      	cmp	r9, r3
 80082fa:	f280 8120 	bge.w	800853e <_svfprintf_r+0x6ee>
 80082fe:	9b02      	ldr	r3, [sp, #8]
 8008300:	3b02      	subs	r3, #2
 8008302:	9302      	str	r3, [sp, #8]
 8008304:	9a19      	ldr	r2, [sp, #100]	; 0x64
 8008306:	f89d 1008 	ldrb.w	r1, [sp, #8]
 800830a:	f88d 106c 	strb.w	r1, [sp, #108]	; 0x6c
 800830e:	1e53      	subs	r3, r2, #1
 8008310:	2b00      	cmp	r3, #0
 8008312:	9319      	str	r3, [sp, #100]	; 0x64
 8008314:	bfb6      	itet	lt
 8008316:	f1c2 0301 	rsblt	r3, r2, #1
 800831a:	222b      	movge	r2, #43	; 0x2b
 800831c:	222d      	movlt	r2, #45	; 0x2d
 800831e:	2b09      	cmp	r3, #9
 8008320:	f88d 206d 	strb.w	r2, [sp, #109]	; 0x6d
 8008324:	f340 80fb 	ble.w	800851e <_svfprintf_r+0x6ce>
 8008328:	f10d 027b 	add.w	r2, sp, #123	; 0x7b
 800832c:	260a      	movs	r6, #10
 800832e:	fb93 f0f6 	sdiv	r0, r3, r6
 8008332:	fb06 3310 	mls	r3, r6, r0, r3
 8008336:	3330      	adds	r3, #48	; 0x30
 8008338:	2809      	cmp	r0, #9
 800833a:	f802 3c01 	strb.w	r3, [r2, #-1]
 800833e:	f102 31ff 	add.w	r1, r2, #4294967295
 8008342:	4603      	mov	r3, r0
 8008344:	f300 80e4 	bgt.w	8008510 <_svfprintf_r+0x6c0>
 8008348:	3330      	adds	r3, #48	; 0x30
 800834a:	f801 3c01 	strb.w	r3, [r1, #-1]
 800834e:	3a02      	subs	r2, #2
 8008350:	f10d 036e 	add.w	r3, sp, #110	; 0x6e
 8008354:	f10d 007b 	add.w	r0, sp, #123	; 0x7b
 8008358:	4282      	cmp	r2, r0
 800835a:	4619      	mov	r1, r3
 800835c:	f0c0 80da 	bcc.w	8008514 <_svfprintf_r+0x6c4>
 8008360:	9a03      	ldr	r2, [sp, #12]
 8008362:	ab1b      	add	r3, sp, #108	; 0x6c
 8008364:	1acb      	subs	r3, r1, r3
 8008366:	2a01      	cmp	r2, #1
 8008368:	9310      	str	r3, [sp, #64]	; 0x40
 800836a:	eb03 0902 	add.w	r9, r3, r2
 800836e:	dc02      	bgt.n	8008376 <_svfprintf_r+0x526>
 8008370:	f015 0701 	ands.w	r7, r5, #1
 8008374:	d002      	beq.n	800837c <_svfprintf_r+0x52c>
 8008376:	9b08      	ldr	r3, [sp, #32]
 8008378:	2700      	movs	r7, #0
 800837a:	4499      	add	r9, r3
 800837c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800837e:	b113      	cbz	r3, 8008386 <_svfprintf_r+0x536>
 8008380:	232d      	movs	r3, #45	; 0x2d
 8008382:	f88d 305f 	strb.w	r3, [sp, #95]	; 0x5f
 8008386:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8008388:	2600      	movs	r6, #0
 800838a:	454e      	cmp	r6, r9
 800838c:	4633      	mov	r3, r6
 800838e:	bfb8      	it	lt
 8008390:	464b      	movlt	r3, r9
 8008392:	930b      	str	r3, [sp, #44]	; 0x2c
 8008394:	f89d 305f 	ldrb.w	r3, [sp, #95]	; 0x5f
 8008398:	b113      	cbz	r3, 80083a0 <_svfprintf_r+0x550>
 800839a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800839c:	3301      	adds	r3, #1
 800839e:	930b      	str	r3, [sp, #44]	; 0x2c
 80083a0:	f015 0302 	ands.w	r3, r5, #2
 80083a4:	9314      	str	r3, [sp, #80]	; 0x50
 80083a6:	bf1e      	ittt	ne
 80083a8:	9b0b      	ldrne	r3, [sp, #44]	; 0x2c
 80083aa:	3302      	addne	r3, #2
 80083ac:	930b      	strne	r3, [sp, #44]	; 0x2c
 80083ae:	f015 0384 	ands.w	r3, r5, #132	; 0x84
 80083b2:	9315      	str	r3, [sp, #84]	; 0x54
 80083b4:	d118      	bne.n	80083e8 <_svfprintf_r+0x598>
 80083b6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80083b8:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80083ba:	1a9b      	subs	r3, r3, r2
 80083bc:	2b00      	cmp	r3, #0
 80083be:	930c      	str	r3, [sp, #48]	; 0x30
 80083c0:	dd12      	ble.n	80083e8 <_svfprintf_r+0x598>
 80083c2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80083c4:	2b10      	cmp	r3, #16
 80083c6:	4ba9      	ldr	r3, [pc, #676]	; (800866c <_svfprintf_r+0x81c>)
 80083c8:	6023      	str	r3, [r4, #0]
 80083ca:	f300 81d5 	bgt.w	8008778 <_svfprintf_r+0x928>
 80083ce:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80083d0:	6063      	str	r3, [r4, #4]
 80083d2:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 80083d4:	9b21      	ldr	r3, [sp, #132]	; 0x84
 80083d6:	4413      	add	r3, r2
 80083d8:	9321      	str	r3, [sp, #132]	; 0x84
 80083da:	9b20      	ldr	r3, [sp, #128]	; 0x80
 80083dc:	3301      	adds	r3, #1
 80083de:	2b07      	cmp	r3, #7
 80083e0:	9320      	str	r3, [sp, #128]	; 0x80
 80083e2:	f300 81e2 	bgt.w	80087aa <_svfprintf_r+0x95a>
 80083e6:	3408      	adds	r4, #8
 80083e8:	f89d 305f 	ldrb.w	r3, [sp, #95]	; 0x5f
 80083ec:	b173      	cbz	r3, 800840c <_svfprintf_r+0x5bc>
 80083ee:	f10d 035f 	add.w	r3, sp, #95	; 0x5f
 80083f2:	6023      	str	r3, [r4, #0]
 80083f4:	2301      	movs	r3, #1
 80083f6:	6063      	str	r3, [r4, #4]
 80083f8:	9b21      	ldr	r3, [sp, #132]	; 0x84
 80083fa:	3301      	adds	r3, #1
 80083fc:	9321      	str	r3, [sp, #132]	; 0x84
 80083fe:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8008400:	3301      	adds	r3, #1
 8008402:	2b07      	cmp	r3, #7
 8008404:	9320      	str	r3, [sp, #128]	; 0x80
 8008406:	f300 81da 	bgt.w	80087be <_svfprintf_r+0x96e>
 800840a:	3408      	adds	r4, #8
 800840c:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800840e:	b16b      	cbz	r3, 800842c <_svfprintf_r+0x5dc>
 8008410:	ab18      	add	r3, sp, #96	; 0x60
 8008412:	6023      	str	r3, [r4, #0]
 8008414:	2302      	movs	r3, #2
 8008416:	6063      	str	r3, [r4, #4]
 8008418:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800841a:	3302      	adds	r3, #2
 800841c:	9321      	str	r3, [sp, #132]	; 0x84
 800841e:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8008420:	3301      	adds	r3, #1
 8008422:	2b07      	cmp	r3, #7
 8008424:	9320      	str	r3, [sp, #128]	; 0x80
 8008426:	f300 81d4 	bgt.w	80087d2 <_svfprintf_r+0x982>
 800842a:	3408      	adds	r4, #8
 800842c:	9b15      	ldr	r3, [sp, #84]	; 0x54
 800842e:	2b80      	cmp	r3, #128	; 0x80
 8008430:	d114      	bne.n	800845c <_svfprintf_r+0x60c>
 8008432:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8008434:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8008436:	1a9b      	subs	r3, r3, r2
 8008438:	2b00      	cmp	r3, #0
 800843a:	dd0f      	ble.n	800845c <_svfprintf_r+0x60c>
 800843c:	4a8c      	ldr	r2, [pc, #560]	; (8008670 <_svfprintf_r+0x820>)
 800843e:	6022      	str	r2, [r4, #0]
 8008440:	2b10      	cmp	r3, #16
 8008442:	f300 81d0 	bgt.w	80087e6 <_svfprintf_r+0x996>
 8008446:	9a21      	ldr	r2, [sp, #132]	; 0x84
 8008448:	6063      	str	r3, [r4, #4]
 800844a:	4413      	add	r3, r2
 800844c:	9321      	str	r3, [sp, #132]	; 0x84
 800844e:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8008450:	3301      	adds	r3, #1
 8008452:	2b07      	cmp	r3, #7
 8008454:	9320      	str	r3, [sp, #128]	; 0x80
 8008456:	f300 81df 	bgt.w	8008818 <_svfprintf_r+0x9c8>
 800845a:	3408      	adds	r4, #8
 800845c:	eba6 0609 	sub.w	r6, r6, r9
 8008460:	2e00      	cmp	r6, #0
 8008462:	dd0f      	ble.n	8008484 <_svfprintf_r+0x634>
 8008464:	4b82      	ldr	r3, [pc, #520]	; (8008670 <_svfprintf_r+0x820>)
 8008466:	6023      	str	r3, [r4, #0]
 8008468:	2e10      	cmp	r6, #16
 800846a:	f300 81df 	bgt.w	800882c <_svfprintf_r+0x9dc>
 800846e:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8008470:	9821      	ldr	r0, [sp, #132]	; 0x84
 8008472:	6066      	str	r6, [r4, #4]
 8008474:	3301      	adds	r3, #1
 8008476:	4406      	add	r6, r0
 8008478:	2b07      	cmp	r3, #7
 800847a:	9621      	str	r6, [sp, #132]	; 0x84
 800847c:	9320      	str	r3, [sp, #128]	; 0x80
 800847e:	f300 81ec 	bgt.w	800885a <_svfprintf_r+0xa0a>
 8008482:	3408      	adds	r4, #8
 8008484:	05eb      	lsls	r3, r5, #23
 8008486:	f100 81f2 	bmi.w	800886e <_svfprintf_r+0xa1e>
 800848a:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800848c:	e884 0300 	stmia.w	r4, {r8, r9}
 8008490:	444b      	add	r3, r9
 8008492:	9321      	str	r3, [sp, #132]	; 0x84
 8008494:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8008496:	3301      	adds	r3, #1
 8008498:	2b07      	cmp	r3, #7
 800849a:	9320      	str	r3, [sp, #128]	; 0x80
 800849c:	f340 8419 	ble.w	8008cd2 <_svfprintf_r+0xe82>
 80084a0:	aa1f      	add	r2, sp, #124	; 0x7c
 80084a2:	4651      	mov	r1, sl
 80084a4:	4658      	mov	r0, fp
 80084a6:	f003 fd60 	bl	800bf6a <__ssprint_r>
 80084aa:	2800      	cmp	r0, #0
 80084ac:	f040 8431 	bne.w	8008d12 <_svfprintf_r+0xec2>
 80084b0:	ac2c      	add	r4, sp, #176	; 0xb0
 80084b2:	076b      	lsls	r3, r5, #29
 80084b4:	f100 8410 	bmi.w	8008cd8 <_svfprintf_r+0xe88>
 80084b8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80084ba:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80084bc:	990b      	ldr	r1, [sp, #44]	; 0x2c
 80084be:	428a      	cmp	r2, r1
 80084c0:	bfac      	ite	ge
 80084c2:	189b      	addge	r3, r3, r2
 80084c4:	185b      	addlt	r3, r3, r1
 80084c6:	9309      	str	r3, [sp, #36]	; 0x24
 80084c8:	9b21      	ldr	r3, [sp, #132]	; 0x84
 80084ca:	b13b      	cbz	r3, 80084dc <_svfprintf_r+0x68c>
 80084cc:	aa1f      	add	r2, sp, #124	; 0x7c
 80084ce:	4651      	mov	r1, sl
 80084d0:	4658      	mov	r0, fp
 80084d2:	f003 fd4a 	bl	800bf6a <__ssprint_r>
 80084d6:	2800      	cmp	r0, #0
 80084d8:	f040 841b 	bne.w	8008d12 <_svfprintf_r+0xec2>
 80084dc:	2300      	movs	r3, #0
 80084de:	9320      	str	r3, [sp, #128]	; 0x80
 80084e0:	9f04      	ldr	r7, [sp, #16]
 80084e2:	ac2c      	add	r4, sp, #176	; 0xb0
 80084e4:	e4ee      	b.n	8007ec4 <_svfprintf_r+0x74>
 80084e6:	9b02      	ldr	r3, [sp, #8]
 80084e8:	2b65      	cmp	r3, #101	; 0x65
 80084ea:	f77f af0b 	ble.w	8008304 <_svfprintf_r+0x4b4>
 80084ee:	9b02      	ldr	r3, [sp, #8]
 80084f0:	2b66      	cmp	r3, #102	; 0x66
 80084f2:	d124      	bne.n	800853e <_svfprintf_r+0x6ee>
 80084f4:	9b19      	ldr	r3, [sp, #100]	; 0x64
 80084f6:	2b00      	cmp	r3, #0
 80084f8:	dd19      	ble.n	800852e <_svfprintf_r+0x6de>
 80084fa:	f1b9 0f00 	cmp.w	r9, #0
 80084fe:	d101      	bne.n	8008504 <_svfprintf_r+0x6b4>
 8008500:	07ea      	lsls	r2, r5, #31
 8008502:	d502      	bpl.n	800850a <_svfprintf_r+0x6ba>
 8008504:	9a08      	ldr	r2, [sp, #32]
 8008506:	4413      	add	r3, r2
 8008508:	444b      	add	r3, r9
 800850a:	9f19      	ldr	r7, [sp, #100]	; 0x64
 800850c:	4699      	mov	r9, r3
 800850e:	e735      	b.n	800837c <_svfprintf_r+0x52c>
 8008510:	460a      	mov	r2, r1
 8008512:	e70c      	b.n	800832e <_svfprintf_r+0x4de>
 8008514:	f812 1b01 	ldrb.w	r1, [r2], #1
 8008518:	f803 1b01 	strb.w	r1, [r3], #1
 800851c:	e71c      	b.n	8008358 <_svfprintf_r+0x508>
 800851e:	2230      	movs	r2, #48	; 0x30
 8008520:	4413      	add	r3, r2
 8008522:	f88d 206e 	strb.w	r2, [sp, #110]	; 0x6e
 8008526:	f88d 306f 	strb.w	r3, [sp, #111]	; 0x6f
 800852a:	a91c      	add	r1, sp, #112	; 0x70
 800852c:	e718      	b.n	8008360 <_svfprintf_r+0x510>
 800852e:	f1b9 0f00 	cmp.w	r9, #0
 8008532:	d101      	bne.n	8008538 <_svfprintf_r+0x6e8>
 8008534:	07eb      	lsls	r3, r5, #31
 8008536:	d515      	bpl.n	8008564 <_svfprintf_r+0x714>
 8008538:	9b08      	ldr	r3, [sp, #32]
 800853a:	3301      	adds	r3, #1
 800853c:	e7e4      	b.n	8008508 <_svfprintf_r+0x6b8>
 800853e:	9a19      	ldr	r2, [sp, #100]	; 0x64
 8008540:	9b03      	ldr	r3, [sp, #12]
 8008542:	429a      	cmp	r2, r3
 8008544:	db06      	blt.n	8008554 <_svfprintf_r+0x704>
 8008546:	07ef      	lsls	r7, r5, #31
 8008548:	d50e      	bpl.n	8008568 <_svfprintf_r+0x718>
 800854a:	9b08      	ldr	r3, [sp, #32]
 800854c:	4413      	add	r3, r2
 800854e:	2267      	movs	r2, #103	; 0x67
 8008550:	9202      	str	r2, [sp, #8]
 8008552:	e7da      	b.n	800850a <_svfprintf_r+0x6ba>
 8008554:	9b03      	ldr	r3, [sp, #12]
 8008556:	9908      	ldr	r1, [sp, #32]
 8008558:	2a00      	cmp	r2, #0
 800855a:	440b      	add	r3, r1
 800855c:	dcf7      	bgt.n	800854e <_svfprintf_r+0x6fe>
 800855e:	f1c2 0201 	rsb	r2, r2, #1
 8008562:	e7f3      	b.n	800854c <_svfprintf_r+0x6fc>
 8008564:	2301      	movs	r3, #1
 8008566:	e7d0      	b.n	800850a <_svfprintf_r+0x6ba>
 8008568:	4613      	mov	r3, r2
 800856a:	e7f0      	b.n	800854e <_svfprintf_r+0x6fe>
 800856c:	b10b      	cbz	r3, 8008572 <_svfprintf_r+0x722>
 800856e:	f88d 205f 	strb.w	r2, [sp, #95]	; 0x5f
 8008572:	f015 0f20 	tst.w	r5, #32
 8008576:	f107 0304 	add.w	r3, r7, #4
 800857a:	d008      	beq.n	800858e <_svfprintf_r+0x73e>
 800857c:	9909      	ldr	r1, [sp, #36]	; 0x24
 800857e:	683a      	ldr	r2, [r7, #0]
 8008580:	17ce      	asrs	r6, r1, #31
 8008582:	4608      	mov	r0, r1
 8008584:	4631      	mov	r1, r6
 8008586:	e9c2 0100 	strd	r0, r1, [r2]
 800858a:	461f      	mov	r7, r3
 800858c:	e49a      	b.n	8007ec4 <_svfprintf_r+0x74>
 800858e:	06ee      	lsls	r6, r5, #27
 8008590:	d503      	bpl.n	800859a <_svfprintf_r+0x74a>
 8008592:	683a      	ldr	r2, [r7, #0]
 8008594:	9909      	ldr	r1, [sp, #36]	; 0x24
 8008596:	6011      	str	r1, [r2, #0]
 8008598:	e7f7      	b.n	800858a <_svfprintf_r+0x73a>
 800859a:	0668      	lsls	r0, r5, #25
 800859c:	d5f9      	bpl.n	8008592 <_svfprintf_r+0x742>
 800859e:	683a      	ldr	r2, [r7, #0]
 80085a0:	f8bd 1024 	ldrh.w	r1, [sp, #36]	; 0x24
 80085a4:	8011      	strh	r1, [r2, #0]
 80085a6:	e7f0      	b.n	800858a <_svfprintf_r+0x73a>
 80085a8:	f045 0510 	orr.w	r5, r5, #16
 80085ac:	f015 0320 	ands.w	r3, r5, #32
 80085b0:	d022      	beq.n	80085f8 <_svfprintf_r+0x7a8>
 80085b2:	3707      	adds	r7, #7
 80085b4:	f027 0707 	bic.w	r7, r7, #7
 80085b8:	f107 0308 	add.w	r3, r7, #8
 80085bc:	e9d7 6700 	ldrd	r6, r7, [r7]
 80085c0:	9304      	str	r3, [sp, #16]
 80085c2:	2300      	movs	r3, #0
 80085c4:	2200      	movs	r2, #0
 80085c6:	f88d 205f 	strb.w	r2, [sp, #95]	; 0x5f
 80085ca:	f1b9 3fff 	cmp.w	r9, #4294967295
 80085ce:	f000 83db 	beq.w	8008d88 <_svfprintf_r+0xf38>
 80085d2:	f025 0280 	bic.w	r2, r5, #128	; 0x80
 80085d6:	920b      	str	r2, [sp, #44]	; 0x2c
 80085d8:	ea56 0207 	orrs.w	r2, r6, r7
 80085dc:	f040 83d9 	bne.w	8008d92 <_svfprintf_r+0xf42>
 80085e0:	f1b9 0f00 	cmp.w	r9, #0
 80085e4:	f000 80aa 	beq.w	800873c <_svfprintf_r+0x8ec>
 80085e8:	2b01      	cmp	r3, #1
 80085ea:	d076      	beq.n	80086da <_svfprintf_r+0x88a>
 80085ec:	2b02      	cmp	r3, #2
 80085ee:	f000 8091 	beq.w	8008714 <_svfprintf_r+0x8c4>
 80085f2:	2600      	movs	r6, #0
 80085f4:	2700      	movs	r7, #0
 80085f6:	e3d2      	b.n	8008d9e <_svfprintf_r+0xf4e>
 80085f8:	1d3a      	adds	r2, r7, #4
 80085fa:	f015 0110 	ands.w	r1, r5, #16
 80085fe:	9204      	str	r2, [sp, #16]
 8008600:	d002      	beq.n	8008608 <_svfprintf_r+0x7b8>
 8008602:	683e      	ldr	r6, [r7, #0]
 8008604:	2700      	movs	r7, #0
 8008606:	e7dd      	b.n	80085c4 <_svfprintf_r+0x774>
 8008608:	f015 0340 	ands.w	r3, r5, #64	; 0x40
 800860c:	d0f9      	beq.n	8008602 <_svfprintf_r+0x7b2>
 800860e:	883e      	ldrh	r6, [r7, #0]
 8008610:	2700      	movs	r7, #0
 8008612:	e7d6      	b.n	80085c2 <_svfprintf_r+0x772>
 8008614:	1d3b      	adds	r3, r7, #4
 8008616:	9304      	str	r3, [sp, #16]
 8008618:	2330      	movs	r3, #48	; 0x30
 800861a:	2278      	movs	r2, #120	; 0x78
 800861c:	f88d 3060 	strb.w	r3, [sp, #96]	; 0x60
 8008620:	4b14      	ldr	r3, [pc, #80]	; (8008674 <_svfprintf_r+0x824>)
 8008622:	683e      	ldr	r6, [r7, #0]
 8008624:	9311      	str	r3, [sp, #68]	; 0x44
 8008626:	2700      	movs	r7, #0
 8008628:	f045 0502 	orr.w	r5, r5, #2
 800862c:	f88d 2061 	strb.w	r2, [sp, #97]	; 0x61
 8008630:	2302      	movs	r3, #2
 8008632:	9202      	str	r2, [sp, #8]
 8008634:	e7c6      	b.n	80085c4 <_svfprintf_r+0x774>
 8008636:	1d3b      	adds	r3, r7, #4
 8008638:	2600      	movs	r6, #0
 800863a:	f1b9 3fff 	cmp.w	r9, #4294967295
 800863e:	9304      	str	r3, [sp, #16]
 8008640:	f8d7 8000 	ldr.w	r8, [r7]
 8008644:	f88d 605f 	strb.w	r6, [sp, #95]	; 0x5f
 8008648:	d00a      	beq.n	8008660 <_svfprintf_r+0x810>
 800864a:	464a      	mov	r2, r9
 800864c:	4631      	mov	r1, r6
 800864e:	4640      	mov	r0, r8
 8008650:	f7f7 fdd6 	bl	8000200 <memchr>
 8008654:	2800      	cmp	r0, #0
 8008656:	f000 808d 	beq.w	8008774 <_svfprintf_r+0x924>
 800865a:	eba0 0908 	sub.w	r9, r0, r8
 800865e:	e5cb      	b.n	80081f8 <_svfprintf_r+0x3a8>
 8008660:	4640      	mov	r0, r8
 8008662:	f7f7 fdbf 	bl	80001e4 <strlen>
 8008666:	4681      	mov	r9, r0
 8008668:	e5c6      	b.n	80081f8 <_svfprintf_r+0x3a8>
 800866a:	bf00      	nop
 800866c:	0800d220 	.word	0x0800d220
 8008670:	0800d230 	.word	0x0800d230
 8008674:	0800d20d 	.word	0x0800d20d
 8008678:	f045 0510 	orr.w	r5, r5, #16
 800867c:	06a9      	lsls	r1, r5, #26
 800867e:	d509      	bpl.n	8008694 <_svfprintf_r+0x844>
 8008680:	3707      	adds	r7, #7
 8008682:	f027 0707 	bic.w	r7, r7, #7
 8008686:	f107 0308 	add.w	r3, r7, #8
 800868a:	e9d7 6700 	ldrd	r6, r7, [r7]
 800868e:	9304      	str	r3, [sp, #16]
 8008690:	2301      	movs	r3, #1
 8008692:	e797      	b.n	80085c4 <_svfprintf_r+0x774>
 8008694:	1d3b      	adds	r3, r7, #4
 8008696:	f015 0f10 	tst.w	r5, #16
 800869a:	9304      	str	r3, [sp, #16]
 800869c:	d001      	beq.n	80086a2 <_svfprintf_r+0x852>
 800869e:	683e      	ldr	r6, [r7, #0]
 80086a0:	e002      	b.n	80086a8 <_svfprintf_r+0x858>
 80086a2:	066a      	lsls	r2, r5, #25
 80086a4:	d5fb      	bpl.n	800869e <_svfprintf_r+0x84e>
 80086a6:	883e      	ldrh	r6, [r7, #0]
 80086a8:	2700      	movs	r7, #0
 80086aa:	e7f1      	b.n	8008690 <_svfprintf_r+0x840>
 80086ac:	b10b      	cbz	r3, 80086b2 <_svfprintf_r+0x862>
 80086ae:	f88d 205f 	strb.w	r2, [sp, #95]	; 0x5f
 80086b2:	4ba3      	ldr	r3, [pc, #652]	; (8008940 <_svfprintf_r+0xaf0>)
 80086b4:	e4c2      	b.n	800803c <_svfprintf_r+0x1ec>
 80086b6:	1d3b      	adds	r3, r7, #4
 80086b8:	f015 0f10 	tst.w	r5, #16
 80086bc:	9304      	str	r3, [sp, #16]
 80086be:	d001      	beq.n	80086c4 <_svfprintf_r+0x874>
 80086c0:	683e      	ldr	r6, [r7, #0]
 80086c2:	e002      	b.n	80086ca <_svfprintf_r+0x87a>
 80086c4:	066e      	lsls	r6, r5, #25
 80086c6:	d5fb      	bpl.n	80086c0 <_svfprintf_r+0x870>
 80086c8:	883e      	ldrh	r6, [r7, #0]
 80086ca:	2700      	movs	r7, #0
 80086cc:	e4c2      	b.n	8008054 <_svfprintf_r+0x204>
 80086ce:	4643      	mov	r3, r8
 80086d0:	e366      	b.n	8008da0 <_svfprintf_r+0xf50>
 80086d2:	2f00      	cmp	r7, #0
 80086d4:	bf08      	it	eq
 80086d6:	2e0a      	cmpeq	r6, #10
 80086d8:	d205      	bcs.n	80086e6 <_svfprintf_r+0x896>
 80086da:	f10d 08f0 	add.w	r8, sp, #240	; 0xf0
 80086de:	3630      	adds	r6, #48	; 0x30
 80086e0:	f808 6d41 	strb.w	r6, [r8, #-65]!
 80086e4:	e377      	b.n	8008dd6 <_svfprintf_r+0xf86>
 80086e6:	f10d 08b0 	add.w	r8, sp, #176	; 0xb0
 80086ea:	4630      	mov	r0, r6
 80086ec:	4639      	mov	r1, r7
 80086ee:	220a      	movs	r2, #10
 80086f0:	2300      	movs	r3, #0
 80086f2:	f7f8 fab5 	bl	8000c60 <__aeabi_uldivmod>
 80086f6:	3230      	adds	r2, #48	; 0x30
 80086f8:	f808 2d01 	strb.w	r2, [r8, #-1]!
 80086fc:	2300      	movs	r3, #0
 80086fe:	4630      	mov	r0, r6
 8008700:	4639      	mov	r1, r7
 8008702:	220a      	movs	r2, #10
 8008704:	f7f8 faac 	bl	8000c60 <__aeabi_uldivmod>
 8008708:	4606      	mov	r6, r0
 800870a:	460f      	mov	r7, r1
 800870c:	ea56 0307 	orrs.w	r3, r6, r7
 8008710:	d1eb      	bne.n	80086ea <_svfprintf_r+0x89a>
 8008712:	e360      	b.n	8008dd6 <_svfprintf_r+0xf86>
 8008714:	2600      	movs	r6, #0
 8008716:	2700      	movs	r7, #0
 8008718:	f10d 08b0 	add.w	r8, sp, #176	; 0xb0
 800871c:	f006 030f 	and.w	r3, r6, #15
 8008720:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8008722:	5cd3      	ldrb	r3, [r2, r3]
 8008724:	f808 3d01 	strb.w	r3, [r8, #-1]!
 8008728:	0933      	lsrs	r3, r6, #4
 800872a:	ea43 7307 	orr.w	r3, r3, r7, lsl #28
 800872e:	093a      	lsrs	r2, r7, #4
 8008730:	461e      	mov	r6, r3
 8008732:	4617      	mov	r7, r2
 8008734:	ea56 0307 	orrs.w	r3, r6, r7
 8008738:	d1f0      	bne.n	800871c <_svfprintf_r+0x8cc>
 800873a:	e34c      	b.n	8008dd6 <_svfprintf_r+0xf86>
 800873c:	b93b      	cbnz	r3, 800874e <_svfprintf_r+0x8fe>
 800873e:	07ea      	lsls	r2, r5, #31
 8008740:	d505      	bpl.n	800874e <_svfprintf_r+0x8fe>
 8008742:	f10d 08f0 	add.w	r8, sp, #240	; 0xf0
 8008746:	2330      	movs	r3, #48	; 0x30
 8008748:	f808 3d41 	strb.w	r3, [r8, #-65]!
 800874c:	e343      	b.n	8008dd6 <_svfprintf_r+0xf86>
 800874e:	f10d 08b0 	add.w	r8, sp, #176	; 0xb0
 8008752:	e340      	b.n	8008dd6 <_svfprintf_r+0xf86>
 8008754:	b10b      	cbz	r3, 800875a <_svfprintf_r+0x90a>
 8008756:	f88d 205f 	strb.w	r2, [sp, #95]	; 0x5f
 800875a:	9b02      	ldr	r3, [sp, #8]
 800875c:	2b00      	cmp	r3, #0
 800875e:	f000 82f7 	beq.w	8008d50 <_svfprintf_r+0xf00>
 8008762:	f89d 3008 	ldrb.w	r3, [sp, #8]
 8008766:	f88d 3088 	strb.w	r3, [sp, #136]	; 0x88
 800876a:	2600      	movs	r6, #0
 800876c:	f88d 605f 	strb.w	r6, [sp, #95]	; 0x5f
 8008770:	9704      	str	r7, [sp, #16]
 8008772:	e4e8      	b.n	8008146 <_svfprintf_r+0x2f6>
 8008774:	4606      	mov	r6, r0
 8008776:	e53f      	b.n	80081f8 <_svfprintf_r+0x3a8>
 8008778:	2310      	movs	r3, #16
 800877a:	6063      	str	r3, [r4, #4]
 800877c:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800877e:	3310      	adds	r3, #16
 8008780:	9321      	str	r3, [sp, #132]	; 0x84
 8008782:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8008784:	3301      	adds	r3, #1
 8008786:	2b07      	cmp	r3, #7
 8008788:	9320      	str	r3, [sp, #128]	; 0x80
 800878a:	dc04      	bgt.n	8008796 <_svfprintf_r+0x946>
 800878c:	3408      	adds	r4, #8
 800878e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8008790:	3b10      	subs	r3, #16
 8008792:	930c      	str	r3, [sp, #48]	; 0x30
 8008794:	e615      	b.n	80083c2 <_svfprintf_r+0x572>
 8008796:	aa1f      	add	r2, sp, #124	; 0x7c
 8008798:	4651      	mov	r1, sl
 800879a:	4658      	mov	r0, fp
 800879c:	f003 fbe5 	bl	800bf6a <__ssprint_r>
 80087a0:	2800      	cmp	r0, #0
 80087a2:	f040 82b6 	bne.w	8008d12 <_svfprintf_r+0xec2>
 80087a6:	ac2c      	add	r4, sp, #176	; 0xb0
 80087a8:	e7f1      	b.n	800878e <_svfprintf_r+0x93e>
 80087aa:	aa1f      	add	r2, sp, #124	; 0x7c
 80087ac:	4651      	mov	r1, sl
 80087ae:	4658      	mov	r0, fp
 80087b0:	f003 fbdb 	bl	800bf6a <__ssprint_r>
 80087b4:	2800      	cmp	r0, #0
 80087b6:	f040 82ac 	bne.w	8008d12 <_svfprintf_r+0xec2>
 80087ba:	ac2c      	add	r4, sp, #176	; 0xb0
 80087bc:	e614      	b.n	80083e8 <_svfprintf_r+0x598>
 80087be:	aa1f      	add	r2, sp, #124	; 0x7c
 80087c0:	4651      	mov	r1, sl
 80087c2:	4658      	mov	r0, fp
 80087c4:	f003 fbd1 	bl	800bf6a <__ssprint_r>
 80087c8:	2800      	cmp	r0, #0
 80087ca:	f040 82a2 	bne.w	8008d12 <_svfprintf_r+0xec2>
 80087ce:	ac2c      	add	r4, sp, #176	; 0xb0
 80087d0:	e61c      	b.n	800840c <_svfprintf_r+0x5bc>
 80087d2:	aa1f      	add	r2, sp, #124	; 0x7c
 80087d4:	4651      	mov	r1, sl
 80087d6:	4658      	mov	r0, fp
 80087d8:	f003 fbc7 	bl	800bf6a <__ssprint_r>
 80087dc:	2800      	cmp	r0, #0
 80087de:	f040 8298 	bne.w	8008d12 <_svfprintf_r+0xec2>
 80087e2:	ac2c      	add	r4, sp, #176	; 0xb0
 80087e4:	e622      	b.n	800842c <_svfprintf_r+0x5dc>
 80087e6:	2210      	movs	r2, #16
 80087e8:	6062      	str	r2, [r4, #4]
 80087ea:	9a21      	ldr	r2, [sp, #132]	; 0x84
 80087ec:	3210      	adds	r2, #16
 80087ee:	9221      	str	r2, [sp, #132]	; 0x84
 80087f0:	9a20      	ldr	r2, [sp, #128]	; 0x80
 80087f2:	3201      	adds	r2, #1
 80087f4:	2a07      	cmp	r2, #7
 80087f6:	9220      	str	r2, [sp, #128]	; 0x80
 80087f8:	dc02      	bgt.n	8008800 <_svfprintf_r+0x9b0>
 80087fa:	3408      	adds	r4, #8
 80087fc:	3b10      	subs	r3, #16
 80087fe:	e61d      	b.n	800843c <_svfprintf_r+0x5ec>
 8008800:	aa1f      	add	r2, sp, #124	; 0x7c
 8008802:	4651      	mov	r1, sl
 8008804:	4658      	mov	r0, fp
 8008806:	930c      	str	r3, [sp, #48]	; 0x30
 8008808:	f003 fbaf 	bl	800bf6a <__ssprint_r>
 800880c:	2800      	cmp	r0, #0
 800880e:	f040 8280 	bne.w	8008d12 <_svfprintf_r+0xec2>
 8008812:	ac2c      	add	r4, sp, #176	; 0xb0
 8008814:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8008816:	e7f1      	b.n	80087fc <_svfprintf_r+0x9ac>
 8008818:	aa1f      	add	r2, sp, #124	; 0x7c
 800881a:	4651      	mov	r1, sl
 800881c:	4658      	mov	r0, fp
 800881e:	f003 fba4 	bl	800bf6a <__ssprint_r>
 8008822:	2800      	cmp	r0, #0
 8008824:	f040 8275 	bne.w	8008d12 <_svfprintf_r+0xec2>
 8008828:	ac2c      	add	r4, sp, #176	; 0xb0
 800882a:	e617      	b.n	800845c <_svfprintf_r+0x60c>
 800882c:	2310      	movs	r3, #16
 800882e:	6063      	str	r3, [r4, #4]
 8008830:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8008832:	3310      	adds	r3, #16
 8008834:	9321      	str	r3, [sp, #132]	; 0x84
 8008836:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8008838:	3301      	adds	r3, #1
 800883a:	2b07      	cmp	r3, #7
 800883c:	9320      	str	r3, [sp, #128]	; 0x80
 800883e:	dc02      	bgt.n	8008846 <_svfprintf_r+0x9f6>
 8008840:	3408      	adds	r4, #8
 8008842:	3e10      	subs	r6, #16
 8008844:	e60e      	b.n	8008464 <_svfprintf_r+0x614>
 8008846:	aa1f      	add	r2, sp, #124	; 0x7c
 8008848:	4651      	mov	r1, sl
 800884a:	4658      	mov	r0, fp
 800884c:	f003 fb8d 	bl	800bf6a <__ssprint_r>
 8008850:	2800      	cmp	r0, #0
 8008852:	f040 825e 	bne.w	8008d12 <_svfprintf_r+0xec2>
 8008856:	ac2c      	add	r4, sp, #176	; 0xb0
 8008858:	e7f3      	b.n	8008842 <_svfprintf_r+0x9f2>
 800885a:	aa1f      	add	r2, sp, #124	; 0x7c
 800885c:	4651      	mov	r1, sl
 800885e:	4658      	mov	r0, fp
 8008860:	f003 fb83 	bl	800bf6a <__ssprint_r>
 8008864:	2800      	cmp	r0, #0
 8008866:	f040 8254 	bne.w	8008d12 <_svfprintf_r+0xec2>
 800886a:	ac2c      	add	r4, sp, #176	; 0xb0
 800886c:	e60a      	b.n	8008484 <_svfprintf_r+0x634>
 800886e:	9b02      	ldr	r3, [sp, #8]
 8008870:	2b65      	cmp	r3, #101	; 0x65
 8008872:	f340 81a9 	ble.w	8008bc8 <_svfprintf_r+0xd78>
 8008876:	2200      	movs	r2, #0
 8008878:	2300      	movs	r3, #0
 800887a:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 800887e:	f7f8 f92f 	bl	8000ae0 <__aeabi_dcmpeq>
 8008882:	2800      	cmp	r0, #0
 8008884:	d062      	beq.n	800894c <_svfprintf_r+0xafc>
 8008886:	4b2f      	ldr	r3, [pc, #188]	; (8008944 <_svfprintf_r+0xaf4>)
 8008888:	6023      	str	r3, [r4, #0]
 800888a:	2301      	movs	r3, #1
 800888c:	6063      	str	r3, [r4, #4]
 800888e:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8008890:	3301      	adds	r3, #1
 8008892:	9321      	str	r3, [sp, #132]	; 0x84
 8008894:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8008896:	3301      	adds	r3, #1
 8008898:	2b07      	cmp	r3, #7
 800889a:	9320      	str	r3, [sp, #128]	; 0x80
 800889c:	dc25      	bgt.n	80088ea <_svfprintf_r+0xa9a>
 800889e:	3408      	adds	r4, #8
 80088a0:	9b19      	ldr	r3, [sp, #100]	; 0x64
 80088a2:	9a03      	ldr	r2, [sp, #12]
 80088a4:	4293      	cmp	r3, r2
 80088a6:	db02      	blt.n	80088ae <_svfprintf_r+0xa5e>
 80088a8:	07ee      	lsls	r6, r5, #31
 80088aa:	f57f ae02 	bpl.w	80084b2 <_svfprintf_r+0x662>
 80088ae:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80088b0:	6023      	str	r3, [r4, #0]
 80088b2:	9b08      	ldr	r3, [sp, #32]
 80088b4:	6063      	str	r3, [r4, #4]
 80088b6:	9a08      	ldr	r2, [sp, #32]
 80088b8:	9b21      	ldr	r3, [sp, #132]	; 0x84
 80088ba:	4413      	add	r3, r2
 80088bc:	9321      	str	r3, [sp, #132]	; 0x84
 80088be:	9b20      	ldr	r3, [sp, #128]	; 0x80
 80088c0:	3301      	adds	r3, #1
 80088c2:	2b07      	cmp	r3, #7
 80088c4:	9320      	str	r3, [sp, #128]	; 0x80
 80088c6:	dc1a      	bgt.n	80088fe <_svfprintf_r+0xaae>
 80088c8:	3408      	adds	r4, #8
 80088ca:	9b03      	ldr	r3, [sp, #12]
 80088cc:	1e5e      	subs	r6, r3, #1
 80088ce:	2e00      	cmp	r6, #0
 80088d0:	f77f adef 	ble.w	80084b2 <_svfprintf_r+0x662>
 80088d4:	4f1c      	ldr	r7, [pc, #112]	; (8008948 <_svfprintf_r+0xaf8>)
 80088d6:	f04f 0810 	mov.w	r8, #16
 80088da:	2e10      	cmp	r6, #16
 80088dc:	6027      	str	r7, [r4, #0]
 80088de:	dc18      	bgt.n	8008912 <_svfprintf_r+0xac2>
 80088e0:	6066      	str	r6, [r4, #4]
 80088e2:	9b21      	ldr	r3, [sp, #132]	; 0x84
 80088e4:	441e      	add	r6, r3
 80088e6:	9621      	str	r6, [sp, #132]	; 0x84
 80088e8:	e5d4      	b.n	8008494 <_svfprintf_r+0x644>
 80088ea:	aa1f      	add	r2, sp, #124	; 0x7c
 80088ec:	4651      	mov	r1, sl
 80088ee:	4658      	mov	r0, fp
 80088f0:	f003 fb3b 	bl	800bf6a <__ssprint_r>
 80088f4:	2800      	cmp	r0, #0
 80088f6:	f040 820c 	bne.w	8008d12 <_svfprintf_r+0xec2>
 80088fa:	ac2c      	add	r4, sp, #176	; 0xb0
 80088fc:	e7d0      	b.n	80088a0 <_svfprintf_r+0xa50>
 80088fe:	aa1f      	add	r2, sp, #124	; 0x7c
 8008900:	4651      	mov	r1, sl
 8008902:	4658      	mov	r0, fp
 8008904:	f003 fb31 	bl	800bf6a <__ssprint_r>
 8008908:	2800      	cmp	r0, #0
 800890a:	f040 8202 	bne.w	8008d12 <_svfprintf_r+0xec2>
 800890e:	ac2c      	add	r4, sp, #176	; 0xb0
 8008910:	e7db      	b.n	80088ca <_svfprintf_r+0xa7a>
 8008912:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8008914:	f8c4 8004 	str.w	r8, [r4, #4]
 8008918:	3310      	adds	r3, #16
 800891a:	9321      	str	r3, [sp, #132]	; 0x84
 800891c:	9b20      	ldr	r3, [sp, #128]	; 0x80
 800891e:	3301      	adds	r3, #1
 8008920:	2b07      	cmp	r3, #7
 8008922:	9320      	str	r3, [sp, #128]	; 0x80
 8008924:	dc02      	bgt.n	800892c <_svfprintf_r+0xadc>
 8008926:	3408      	adds	r4, #8
 8008928:	3e10      	subs	r6, #16
 800892a:	e7d6      	b.n	80088da <_svfprintf_r+0xa8a>
 800892c:	aa1f      	add	r2, sp, #124	; 0x7c
 800892e:	4651      	mov	r1, sl
 8008930:	4658      	mov	r0, fp
 8008932:	f003 fb1a 	bl	800bf6a <__ssprint_r>
 8008936:	2800      	cmp	r0, #0
 8008938:	f040 81eb 	bne.w	8008d12 <_svfprintf_r+0xec2>
 800893c:	ac2c      	add	r4, sp, #176	; 0xb0
 800893e:	e7f3      	b.n	8008928 <_svfprintf_r+0xad8>
 8008940:	0800d20d 	.word	0x0800d20d
 8008944:	0800d21e 	.word	0x0800d21e
 8008948:	0800d230 	.word	0x0800d230
 800894c:	9b19      	ldr	r3, [sp, #100]	; 0x64
 800894e:	2b00      	cmp	r3, #0
 8008950:	dc7a      	bgt.n	8008a48 <_svfprintf_r+0xbf8>
 8008952:	4b9b      	ldr	r3, [pc, #620]	; (8008bc0 <_svfprintf_r+0xd70>)
 8008954:	6023      	str	r3, [r4, #0]
 8008956:	2301      	movs	r3, #1
 8008958:	6063      	str	r3, [r4, #4]
 800895a:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800895c:	3301      	adds	r3, #1
 800895e:	9321      	str	r3, [sp, #132]	; 0x84
 8008960:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8008962:	3301      	adds	r3, #1
 8008964:	2b07      	cmp	r3, #7
 8008966:	9320      	str	r3, [sp, #128]	; 0x80
 8008968:	dc44      	bgt.n	80089f4 <_svfprintf_r+0xba4>
 800896a:	3408      	adds	r4, #8
 800896c:	9b19      	ldr	r3, [sp, #100]	; 0x64
 800896e:	b923      	cbnz	r3, 800897a <_svfprintf_r+0xb2a>
 8008970:	9b03      	ldr	r3, [sp, #12]
 8008972:	b913      	cbnz	r3, 800897a <_svfprintf_r+0xb2a>
 8008974:	07e8      	lsls	r0, r5, #31
 8008976:	f57f ad9c 	bpl.w	80084b2 <_svfprintf_r+0x662>
 800897a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800897c:	6023      	str	r3, [r4, #0]
 800897e:	9b08      	ldr	r3, [sp, #32]
 8008980:	6063      	str	r3, [r4, #4]
 8008982:	9a08      	ldr	r2, [sp, #32]
 8008984:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8008986:	4413      	add	r3, r2
 8008988:	9321      	str	r3, [sp, #132]	; 0x84
 800898a:	9b20      	ldr	r3, [sp, #128]	; 0x80
 800898c:	3301      	adds	r3, #1
 800898e:	2b07      	cmp	r3, #7
 8008990:	9320      	str	r3, [sp, #128]	; 0x80
 8008992:	dc39      	bgt.n	8008a08 <_svfprintf_r+0xbb8>
 8008994:	f104 0308 	add.w	r3, r4, #8
 8008998:	9e19      	ldr	r6, [sp, #100]	; 0x64
 800899a:	2e00      	cmp	r6, #0
 800899c:	da19      	bge.n	80089d2 <_svfprintf_r+0xb82>
 800899e:	4f89      	ldr	r7, [pc, #548]	; (8008bc4 <_svfprintf_r+0xd74>)
 80089a0:	4276      	negs	r6, r6
 80089a2:	2410      	movs	r4, #16
 80089a4:	2e10      	cmp	r6, #16
 80089a6:	601f      	str	r7, [r3, #0]
 80089a8:	dc38      	bgt.n	8008a1c <_svfprintf_r+0xbcc>
 80089aa:	9a21      	ldr	r2, [sp, #132]	; 0x84
 80089ac:	605e      	str	r6, [r3, #4]
 80089ae:	4416      	add	r6, r2
 80089b0:	9a20      	ldr	r2, [sp, #128]	; 0x80
 80089b2:	9621      	str	r6, [sp, #132]	; 0x84
 80089b4:	3201      	adds	r2, #1
 80089b6:	2a07      	cmp	r2, #7
 80089b8:	f103 0308 	add.w	r3, r3, #8
 80089bc:	9220      	str	r2, [sp, #128]	; 0x80
 80089be:	dd08      	ble.n	80089d2 <_svfprintf_r+0xb82>
 80089c0:	aa1f      	add	r2, sp, #124	; 0x7c
 80089c2:	4651      	mov	r1, sl
 80089c4:	4658      	mov	r0, fp
 80089c6:	f003 fad0 	bl	800bf6a <__ssprint_r>
 80089ca:	2800      	cmp	r0, #0
 80089cc:	f040 81a1 	bne.w	8008d12 <_svfprintf_r+0xec2>
 80089d0:	ab2c      	add	r3, sp, #176	; 0xb0
 80089d2:	9a03      	ldr	r2, [sp, #12]
 80089d4:	605a      	str	r2, [r3, #4]
 80089d6:	9903      	ldr	r1, [sp, #12]
 80089d8:	9a21      	ldr	r2, [sp, #132]	; 0x84
 80089da:	f8c3 8000 	str.w	r8, [r3]
 80089de:	440a      	add	r2, r1
 80089e0:	9221      	str	r2, [sp, #132]	; 0x84
 80089e2:	9a20      	ldr	r2, [sp, #128]	; 0x80
 80089e4:	3201      	adds	r2, #1
 80089e6:	2a07      	cmp	r2, #7
 80089e8:	9220      	str	r2, [sp, #128]	; 0x80
 80089ea:	f73f ad59 	bgt.w	80084a0 <_svfprintf_r+0x650>
 80089ee:	f103 0408 	add.w	r4, r3, #8
 80089f2:	e55e      	b.n	80084b2 <_svfprintf_r+0x662>
 80089f4:	aa1f      	add	r2, sp, #124	; 0x7c
 80089f6:	4651      	mov	r1, sl
 80089f8:	4658      	mov	r0, fp
 80089fa:	f003 fab6 	bl	800bf6a <__ssprint_r>
 80089fe:	2800      	cmp	r0, #0
 8008a00:	f040 8187 	bne.w	8008d12 <_svfprintf_r+0xec2>
 8008a04:	ac2c      	add	r4, sp, #176	; 0xb0
 8008a06:	e7b1      	b.n	800896c <_svfprintf_r+0xb1c>
 8008a08:	aa1f      	add	r2, sp, #124	; 0x7c
 8008a0a:	4651      	mov	r1, sl
 8008a0c:	4658      	mov	r0, fp
 8008a0e:	f003 faac 	bl	800bf6a <__ssprint_r>
 8008a12:	2800      	cmp	r0, #0
 8008a14:	f040 817d 	bne.w	8008d12 <_svfprintf_r+0xec2>
 8008a18:	ab2c      	add	r3, sp, #176	; 0xb0
 8008a1a:	e7bd      	b.n	8008998 <_svfprintf_r+0xb48>
 8008a1c:	9a21      	ldr	r2, [sp, #132]	; 0x84
 8008a1e:	605c      	str	r4, [r3, #4]
 8008a20:	3210      	adds	r2, #16
 8008a22:	9221      	str	r2, [sp, #132]	; 0x84
 8008a24:	9a20      	ldr	r2, [sp, #128]	; 0x80
 8008a26:	3201      	adds	r2, #1
 8008a28:	2a07      	cmp	r2, #7
 8008a2a:	9220      	str	r2, [sp, #128]	; 0x80
 8008a2c:	dc02      	bgt.n	8008a34 <_svfprintf_r+0xbe4>
 8008a2e:	3308      	adds	r3, #8
 8008a30:	3e10      	subs	r6, #16
 8008a32:	e7b7      	b.n	80089a4 <_svfprintf_r+0xb54>
 8008a34:	aa1f      	add	r2, sp, #124	; 0x7c
 8008a36:	4651      	mov	r1, sl
 8008a38:	4658      	mov	r0, fp
 8008a3a:	f003 fa96 	bl	800bf6a <__ssprint_r>
 8008a3e:	2800      	cmp	r0, #0
 8008a40:	f040 8167 	bne.w	8008d12 <_svfprintf_r+0xec2>
 8008a44:	ab2c      	add	r3, sp, #176	; 0xb0
 8008a46:	e7f3      	b.n	8008a30 <_svfprintf_r+0xbe0>
 8008a48:	9b03      	ldr	r3, [sp, #12]
 8008a4a:	42bb      	cmp	r3, r7
 8008a4c:	bfa8      	it	ge
 8008a4e:	463b      	movge	r3, r7
 8008a50:	2b00      	cmp	r3, #0
 8008a52:	461e      	mov	r6, r3
 8008a54:	dd0b      	ble.n	8008a6e <_svfprintf_r+0xc1e>
 8008a56:	6063      	str	r3, [r4, #4]
 8008a58:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8008a5a:	f8c4 8000 	str.w	r8, [r4]
 8008a5e:	4433      	add	r3, r6
 8008a60:	9321      	str	r3, [sp, #132]	; 0x84
 8008a62:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8008a64:	3301      	adds	r3, #1
 8008a66:	2b07      	cmp	r3, #7
 8008a68:	9320      	str	r3, [sp, #128]	; 0x80
 8008a6a:	dc5f      	bgt.n	8008b2c <_svfprintf_r+0xcdc>
 8008a6c:	3408      	adds	r4, #8
 8008a6e:	2e00      	cmp	r6, #0
 8008a70:	bfac      	ite	ge
 8008a72:	1bbe      	subge	r6, r7, r6
 8008a74:	463e      	movlt	r6, r7
 8008a76:	2e00      	cmp	r6, #0
 8008a78:	dd0f      	ble.n	8008a9a <_svfprintf_r+0xc4a>
 8008a7a:	f8df 9148 	ldr.w	r9, [pc, #328]	; 8008bc4 <_svfprintf_r+0xd74>
 8008a7e:	f8c4 9000 	str.w	r9, [r4]
 8008a82:	2e10      	cmp	r6, #16
 8008a84:	dc5c      	bgt.n	8008b40 <_svfprintf_r+0xcf0>
 8008a86:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8008a88:	6066      	str	r6, [r4, #4]
 8008a8a:	441e      	add	r6, r3
 8008a8c:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8008a8e:	9621      	str	r6, [sp, #132]	; 0x84
 8008a90:	3301      	adds	r3, #1
 8008a92:	2b07      	cmp	r3, #7
 8008a94:	9320      	str	r3, [sp, #128]	; 0x80
 8008a96:	dc6a      	bgt.n	8008b6e <_svfprintf_r+0xd1e>
 8008a98:	3408      	adds	r4, #8
 8008a9a:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8008a9c:	9a03      	ldr	r2, [sp, #12]
 8008a9e:	4293      	cmp	r3, r2
 8008aa0:	db01      	blt.n	8008aa6 <_svfprintf_r+0xc56>
 8008aa2:	07e9      	lsls	r1, r5, #31
 8008aa4:	d50d      	bpl.n	8008ac2 <_svfprintf_r+0xc72>
 8008aa6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8008aa8:	6023      	str	r3, [r4, #0]
 8008aaa:	9b08      	ldr	r3, [sp, #32]
 8008aac:	6063      	str	r3, [r4, #4]
 8008aae:	9a08      	ldr	r2, [sp, #32]
 8008ab0:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8008ab2:	4413      	add	r3, r2
 8008ab4:	9321      	str	r3, [sp, #132]	; 0x84
 8008ab6:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8008ab8:	3301      	adds	r3, #1
 8008aba:	2b07      	cmp	r3, #7
 8008abc:	9320      	str	r3, [sp, #128]	; 0x80
 8008abe:	dc60      	bgt.n	8008b82 <_svfprintf_r+0xd32>
 8008ac0:	3408      	adds	r4, #8
 8008ac2:	9b03      	ldr	r3, [sp, #12]
 8008ac4:	9a03      	ldr	r2, [sp, #12]
 8008ac6:	1bde      	subs	r6, r3, r7
 8008ac8:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8008aca:	1ad3      	subs	r3, r2, r3
 8008acc:	429e      	cmp	r6, r3
 8008ace:	bfa8      	it	ge
 8008ad0:	461e      	movge	r6, r3
 8008ad2:	2e00      	cmp	r6, #0
 8008ad4:	dd0b      	ble.n	8008aee <_svfprintf_r+0xc9e>
 8008ad6:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8008ad8:	6066      	str	r6, [r4, #4]
 8008ada:	4433      	add	r3, r6
 8008adc:	9321      	str	r3, [sp, #132]	; 0x84
 8008ade:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8008ae0:	3301      	adds	r3, #1
 8008ae2:	4447      	add	r7, r8
 8008ae4:	2b07      	cmp	r3, #7
 8008ae6:	6027      	str	r7, [r4, #0]
 8008ae8:	9320      	str	r3, [sp, #128]	; 0x80
 8008aea:	dc54      	bgt.n	8008b96 <_svfprintf_r+0xd46>
 8008aec:	3408      	adds	r4, #8
 8008aee:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8008af0:	9a03      	ldr	r2, [sp, #12]
 8008af2:	2e00      	cmp	r6, #0
 8008af4:	eba2 0303 	sub.w	r3, r2, r3
 8008af8:	bfac      	ite	ge
 8008afa:	1b9e      	subge	r6, r3, r6
 8008afc:	461e      	movlt	r6, r3
 8008afe:	2e00      	cmp	r6, #0
 8008b00:	f77f acd7 	ble.w	80084b2 <_svfprintf_r+0x662>
 8008b04:	4f2f      	ldr	r7, [pc, #188]	; (8008bc4 <_svfprintf_r+0xd74>)
 8008b06:	f04f 0810 	mov.w	r8, #16
 8008b0a:	2e10      	cmp	r6, #16
 8008b0c:	6027      	str	r7, [r4, #0]
 8008b0e:	f77f aee7 	ble.w	80088e0 <_svfprintf_r+0xa90>
 8008b12:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8008b14:	f8c4 8004 	str.w	r8, [r4, #4]
 8008b18:	3310      	adds	r3, #16
 8008b1a:	9321      	str	r3, [sp, #132]	; 0x84
 8008b1c:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8008b1e:	3301      	adds	r3, #1
 8008b20:	2b07      	cmp	r3, #7
 8008b22:	9320      	str	r3, [sp, #128]	; 0x80
 8008b24:	dc41      	bgt.n	8008baa <_svfprintf_r+0xd5a>
 8008b26:	3408      	adds	r4, #8
 8008b28:	3e10      	subs	r6, #16
 8008b2a:	e7ee      	b.n	8008b0a <_svfprintf_r+0xcba>
 8008b2c:	aa1f      	add	r2, sp, #124	; 0x7c
 8008b2e:	4651      	mov	r1, sl
 8008b30:	4658      	mov	r0, fp
 8008b32:	f003 fa1a 	bl	800bf6a <__ssprint_r>
 8008b36:	2800      	cmp	r0, #0
 8008b38:	f040 80eb 	bne.w	8008d12 <_svfprintf_r+0xec2>
 8008b3c:	ac2c      	add	r4, sp, #176	; 0xb0
 8008b3e:	e796      	b.n	8008a6e <_svfprintf_r+0xc1e>
 8008b40:	2310      	movs	r3, #16
 8008b42:	6063      	str	r3, [r4, #4]
 8008b44:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8008b46:	3310      	adds	r3, #16
 8008b48:	9321      	str	r3, [sp, #132]	; 0x84
 8008b4a:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8008b4c:	3301      	adds	r3, #1
 8008b4e:	2b07      	cmp	r3, #7
 8008b50:	9320      	str	r3, [sp, #128]	; 0x80
 8008b52:	dc02      	bgt.n	8008b5a <_svfprintf_r+0xd0a>
 8008b54:	3408      	adds	r4, #8
 8008b56:	3e10      	subs	r6, #16
 8008b58:	e791      	b.n	8008a7e <_svfprintf_r+0xc2e>
 8008b5a:	aa1f      	add	r2, sp, #124	; 0x7c
 8008b5c:	4651      	mov	r1, sl
 8008b5e:	4658      	mov	r0, fp
 8008b60:	f003 fa03 	bl	800bf6a <__ssprint_r>
 8008b64:	2800      	cmp	r0, #0
 8008b66:	f040 80d4 	bne.w	8008d12 <_svfprintf_r+0xec2>
 8008b6a:	ac2c      	add	r4, sp, #176	; 0xb0
 8008b6c:	e7f3      	b.n	8008b56 <_svfprintf_r+0xd06>
 8008b6e:	aa1f      	add	r2, sp, #124	; 0x7c
 8008b70:	4651      	mov	r1, sl
 8008b72:	4658      	mov	r0, fp
 8008b74:	f003 f9f9 	bl	800bf6a <__ssprint_r>
 8008b78:	2800      	cmp	r0, #0
 8008b7a:	f040 80ca 	bne.w	8008d12 <_svfprintf_r+0xec2>
 8008b7e:	ac2c      	add	r4, sp, #176	; 0xb0
 8008b80:	e78b      	b.n	8008a9a <_svfprintf_r+0xc4a>
 8008b82:	aa1f      	add	r2, sp, #124	; 0x7c
 8008b84:	4651      	mov	r1, sl
 8008b86:	4658      	mov	r0, fp
 8008b88:	f003 f9ef 	bl	800bf6a <__ssprint_r>
 8008b8c:	2800      	cmp	r0, #0
 8008b8e:	f040 80c0 	bne.w	8008d12 <_svfprintf_r+0xec2>
 8008b92:	ac2c      	add	r4, sp, #176	; 0xb0
 8008b94:	e795      	b.n	8008ac2 <_svfprintf_r+0xc72>
 8008b96:	aa1f      	add	r2, sp, #124	; 0x7c
 8008b98:	4651      	mov	r1, sl
 8008b9a:	4658      	mov	r0, fp
 8008b9c:	f003 f9e5 	bl	800bf6a <__ssprint_r>
 8008ba0:	2800      	cmp	r0, #0
 8008ba2:	f040 80b6 	bne.w	8008d12 <_svfprintf_r+0xec2>
 8008ba6:	ac2c      	add	r4, sp, #176	; 0xb0
 8008ba8:	e7a1      	b.n	8008aee <_svfprintf_r+0xc9e>
 8008baa:	aa1f      	add	r2, sp, #124	; 0x7c
 8008bac:	4651      	mov	r1, sl
 8008bae:	4658      	mov	r0, fp
 8008bb0:	f003 f9db 	bl	800bf6a <__ssprint_r>
 8008bb4:	2800      	cmp	r0, #0
 8008bb6:	f040 80ac 	bne.w	8008d12 <_svfprintf_r+0xec2>
 8008bba:	ac2c      	add	r4, sp, #176	; 0xb0
 8008bbc:	e7b4      	b.n	8008b28 <_svfprintf_r+0xcd8>
 8008bbe:	bf00      	nop
 8008bc0:	0800d21e 	.word	0x0800d21e
 8008bc4:	0800d230 	.word	0x0800d230
 8008bc8:	9b03      	ldr	r3, [sp, #12]
 8008bca:	2b01      	cmp	r3, #1
 8008bcc:	dc01      	bgt.n	8008bd2 <_svfprintf_r+0xd82>
 8008bce:	07ea      	lsls	r2, r5, #31
 8008bd0:	d576      	bpl.n	8008cc0 <_svfprintf_r+0xe70>
 8008bd2:	2301      	movs	r3, #1
 8008bd4:	6063      	str	r3, [r4, #4]
 8008bd6:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8008bd8:	f8c4 8000 	str.w	r8, [r4]
 8008bdc:	3301      	adds	r3, #1
 8008bde:	9321      	str	r3, [sp, #132]	; 0x84
 8008be0:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8008be2:	3301      	adds	r3, #1
 8008be4:	2b07      	cmp	r3, #7
 8008be6:	9320      	str	r3, [sp, #128]	; 0x80
 8008be8:	dc36      	bgt.n	8008c58 <_svfprintf_r+0xe08>
 8008bea:	3408      	adds	r4, #8
 8008bec:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8008bee:	6023      	str	r3, [r4, #0]
 8008bf0:	9b08      	ldr	r3, [sp, #32]
 8008bf2:	6063      	str	r3, [r4, #4]
 8008bf4:	9a08      	ldr	r2, [sp, #32]
 8008bf6:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8008bf8:	4413      	add	r3, r2
 8008bfa:	9321      	str	r3, [sp, #132]	; 0x84
 8008bfc:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8008bfe:	3301      	adds	r3, #1
 8008c00:	2b07      	cmp	r3, #7
 8008c02:	9320      	str	r3, [sp, #128]	; 0x80
 8008c04:	dc31      	bgt.n	8008c6a <_svfprintf_r+0xe1a>
 8008c06:	3408      	adds	r4, #8
 8008c08:	2300      	movs	r3, #0
 8008c0a:	2200      	movs	r2, #0
 8008c0c:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 8008c10:	f7f7 ff66 	bl	8000ae0 <__aeabi_dcmpeq>
 8008c14:	9b03      	ldr	r3, [sp, #12]
 8008c16:	1e5e      	subs	r6, r3, #1
 8008c18:	2800      	cmp	r0, #0
 8008c1a:	d12f      	bne.n	8008c7c <_svfprintf_r+0xe2c>
 8008c1c:	f108 0301 	add.w	r3, r8, #1
 8008c20:	e884 0048 	stmia.w	r4, {r3, r6}
 8008c24:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8008c26:	9a03      	ldr	r2, [sp, #12]
 8008c28:	3b01      	subs	r3, #1
 8008c2a:	4413      	add	r3, r2
 8008c2c:	9321      	str	r3, [sp, #132]	; 0x84
 8008c2e:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8008c30:	3301      	adds	r3, #1
 8008c32:	2b07      	cmp	r3, #7
 8008c34:	9320      	str	r3, [sp, #128]	; 0x80
 8008c36:	dd4a      	ble.n	8008cce <_svfprintf_r+0xe7e>
 8008c38:	aa1f      	add	r2, sp, #124	; 0x7c
 8008c3a:	4651      	mov	r1, sl
 8008c3c:	4658      	mov	r0, fp
 8008c3e:	f003 f994 	bl	800bf6a <__ssprint_r>
 8008c42:	2800      	cmp	r0, #0
 8008c44:	d165      	bne.n	8008d12 <_svfprintf_r+0xec2>
 8008c46:	ac2c      	add	r4, sp, #176	; 0xb0
 8008c48:	ab1b      	add	r3, sp, #108	; 0x6c
 8008c4a:	6023      	str	r3, [r4, #0]
 8008c4c:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8008c4e:	6063      	str	r3, [r4, #4]
 8008c50:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8008c52:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8008c54:	4413      	add	r3, r2
 8008c56:	e41c      	b.n	8008492 <_svfprintf_r+0x642>
 8008c58:	aa1f      	add	r2, sp, #124	; 0x7c
 8008c5a:	4651      	mov	r1, sl
 8008c5c:	4658      	mov	r0, fp
 8008c5e:	f003 f984 	bl	800bf6a <__ssprint_r>
 8008c62:	2800      	cmp	r0, #0
 8008c64:	d155      	bne.n	8008d12 <_svfprintf_r+0xec2>
 8008c66:	ac2c      	add	r4, sp, #176	; 0xb0
 8008c68:	e7c0      	b.n	8008bec <_svfprintf_r+0xd9c>
 8008c6a:	aa1f      	add	r2, sp, #124	; 0x7c
 8008c6c:	4651      	mov	r1, sl
 8008c6e:	4658      	mov	r0, fp
 8008c70:	f003 f97b 	bl	800bf6a <__ssprint_r>
 8008c74:	2800      	cmp	r0, #0
 8008c76:	d14c      	bne.n	8008d12 <_svfprintf_r+0xec2>
 8008c78:	ac2c      	add	r4, sp, #176	; 0xb0
 8008c7a:	e7c5      	b.n	8008c08 <_svfprintf_r+0xdb8>
 8008c7c:	2e00      	cmp	r6, #0
 8008c7e:	dde3      	ble.n	8008c48 <_svfprintf_r+0xdf8>
 8008c80:	4f59      	ldr	r7, [pc, #356]	; (8008de8 <_svfprintf_r+0xf98>)
 8008c82:	f04f 0810 	mov.w	r8, #16
 8008c86:	2e10      	cmp	r6, #16
 8008c88:	6027      	str	r7, [r4, #0]
 8008c8a:	dc04      	bgt.n	8008c96 <_svfprintf_r+0xe46>
 8008c8c:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8008c8e:	6066      	str	r6, [r4, #4]
 8008c90:	441e      	add	r6, r3
 8008c92:	9621      	str	r6, [sp, #132]	; 0x84
 8008c94:	e7cb      	b.n	8008c2e <_svfprintf_r+0xdde>
 8008c96:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8008c98:	f8c4 8004 	str.w	r8, [r4, #4]
 8008c9c:	3310      	adds	r3, #16
 8008c9e:	9321      	str	r3, [sp, #132]	; 0x84
 8008ca0:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8008ca2:	3301      	adds	r3, #1
 8008ca4:	2b07      	cmp	r3, #7
 8008ca6:	9320      	str	r3, [sp, #128]	; 0x80
 8008ca8:	dc02      	bgt.n	8008cb0 <_svfprintf_r+0xe60>
 8008caa:	3408      	adds	r4, #8
 8008cac:	3e10      	subs	r6, #16
 8008cae:	e7ea      	b.n	8008c86 <_svfprintf_r+0xe36>
 8008cb0:	aa1f      	add	r2, sp, #124	; 0x7c
 8008cb2:	4651      	mov	r1, sl
 8008cb4:	4658      	mov	r0, fp
 8008cb6:	f003 f958 	bl	800bf6a <__ssprint_r>
 8008cba:	bb50      	cbnz	r0, 8008d12 <_svfprintf_r+0xec2>
 8008cbc:	ac2c      	add	r4, sp, #176	; 0xb0
 8008cbe:	e7f5      	b.n	8008cac <_svfprintf_r+0xe5c>
 8008cc0:	2301      	movs	r3, #1
 8008cc2:	6063      	str	r3, [r4, #4]
 8008cc4:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8008cc6:	f8c4 8000 	str.w	r8, [r4]
 8008cca:	3301      	adds	r3, #1
 8008ccc:	e7ae      	b.n	8008c2c <_svfprintf_r+0xddc>
 8008cce:	3408      	adds	r4, #8
 8008cd0:	e7ba      	b.n	8008c48 <_svfprintf_r+0xdf8>
 8008cd2:	3408      	adds	r4, #8
 8008cd4:	f7ff bbed 	b.w	80084b2 <_svfprintf_r+0x662>
 8008cd8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8008cda:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8008cdc:	1a9d      	subs	r5, r3, r2
 8008cde:	2d00      	cmp	r5, #0
 8008ce0:	f77f abea 	ble.w	80084b8 <_svfprintf_r+0x668>
 8008ce4:	2610      	movs	r6, #16
 8008ce6:	4b41      	ldr	r3, [pc, #260]	; (8008dec <_svfprintf_r+0xf9c>)
 8008ce8:	6023      	str	r3, [r4, #0]
 8008cea:	2d10      	cmp	r5, #16
 8008cec:	dc1b      	bgt.n	8008d26 <_svfprintf_r+0xed6>
 8008cee:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8008cf0:	6065      	str	r5, [r4, #4]
 8008cf2:	441d      	add	r5, r3
 8008cf4:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8008cf6:	9521      	str	r5, [sp, #132]	; 0x84
 8008cf8:	3301      	adds	r3, #1
 8008cfa:	2b07      	cmp	r3, #7
 8008cfc:	9320      	str	r3, [sp, #128]	; 0x80
 8008cfe:	f77f abdb 	ble.w	80084b8 <_svfprintf_r+0x668>
 8008d02:	aa1f      	add	r2, sp, #124	; 0x7c
 8008d04:	4651      	mov	r1, sl
 8008d06:	4658      	mov	r0, fp
 8008d08:	f003 f92f 	bl	800bf6a <__ssprint_r>
 8008d0c:	2800      	cmp	r0, #0
 8008d0e:	f43f abd3 	beq.w	80084b8 <_svfprintf_r+0x668>
 8008d12:	f8ba 300c 	ldrh.w	r3, [sl, #12]
 8008d16:	f013 0f40 	tst.w	r3, #64	; 0x40
 8008d1a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008d1c:	bf18      	it	ne
 8008d1e:	f04f 33ff 	movne.w	r3, #4294967295
 8008d22:	f7ff b8b9 	b.w	8007e98 <_svfprintf_r+0x48>
 8008d26:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8008d28:	6066      	str	r6, [r4, #4]
 8008d2a:	3310      	adds	r3, #16
 8008d2c:	9321      	str	r3, [sp, #132]	; 0x84
 8008d2e:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8008d30:	3301      	adds	r3, #1
 8008d32:	2b07      	cmp	r3, #7
 8008d34:	9320      	str	r3, [sp, #128]	; 0x80
 8008d36:	dc02      	bgt.n	8008d3e <_svfprintf_r+0xeee>
 8008d38:	3408      	adds	r4, #8
 8008d3a:	3d10      	subs	r5, #16
 8008d3c:	e7d3      	b.n	8008ce6 <_svfprintf_r+0xe96>
 8008d3e:	aa1f      	add	r2, sp, #124	; 0x7c
 8008d40:	4651      	mov	r1, sl
 8008d42:	4658      	mov	r0, fp
 8008d44:	f003 f911 	bl	800bf6a <__ssprint_r>
 8008d48:	2800      	cmp	r0, #0
 8008d4a:	d1e2      	bne.n	8008d12 <_svfprintf_r+0xec2>
 8008d4c:	ac2c      	add	r4, sp, #176	; 0xb0
 8008d4e:	e7f4      	b.n	8008d3a <_svfprintf_r+0xeea>
 8008d50:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8008d52:	2b00      	cmp	r3, #0
 8008d54:	d0dd      	beq.n	8008d12 <_svfprintf_r+0xec2>
 8008d56:	aa1f      	add	r2, sp, #124	; 0x7c
 8008d58:	4651      	mov	r1, sl
 8008d5a:	4658      	mov	r0, fp
 8008d5c:	f003 f905 	bl	800bf6a <__ssprint_r>
 8008d60:	e7d7      	b.n	8008d12 <_svfprintf_r+0xec2>
 8008d62:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 8008d66:	4610      	mov	r0, r2
 8008d68:	4619      	mov	r1, r3
 8008d6a:	f7f7 feeb 	bl	8000b44 <__aeabi_dcmpun>
 8008d6e:	2800      	cmp	r0, #0
 8008d70:	f43f aa44 	beq.w	80081fc <_svfprintf_r+0x3ac>
 8008d74:	4b1e      	ldr	r3, [pc, #120]	; (8008df0 <_svfprintf_r+0xfa0>)
 8008d76:	4a1f      	ldr	r2, [pc, #124]	; (8008df4 <_svfprintf_r+0xfa4>)
 8008d78:	f7ff ba34 	b.w	80081e4 <_svfprintf_r+0x394>
 8008d7c:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8008d7e:	eba3 0308 	sub.w	r3, r3, r8
 8008d82:	9303      	str	r3, [sp, #12]
 8008d84:	f7ff bab5 	b.w	80082f2 <_svfprintf_r+0x4a2>
 8008d88:	ea56 0207 	orrs.w	r2, r6, r7
 8008d8c:	950b      	str	r5, [sp, #44]	; 0x2c
 8008d8e:	f43f ac2b 	beq.w	80085e8 <_svfprintf_r+0x798>
 8008d92:	2b01      	cmp	r3, #1
 8008d94:	f43f ac9d 	beq.w	80086d2 <_svfprintf_r+0x882>
 8008d98:	2b02      	cmp	r3, #2
 8008d9a:	f43f acbd 	beq.w	8008718 <_svfprintf_r+0x8c8>
 8008d9e:	ab2c      	add	r3, sp, #176	; 0xb0
 8008da0:	08f1      	lsrs	r1, r6, #3
 8008da2:	ea41 7147 	orr.w	r1, r1, r7, lsl #29
 8008da6:	08f8      	lsrs	r0, r7, #3
 8008da8:	f006 0207 	and.w	r2, r6, #7
 8008dac:	4607      	mov	r7, r0
 8008dae:	460e      	mov	r6, r1
 8008db0:	3230      	adds	r2, #48	; 0x30
 8008db2:	ea56 0107 	orrs.w	r1, r6, r7
 8008db6:	f103 38ff 	add.w	r8, r3, #4294967295
 8008dba:	f803 2c01 	strb.w	r2, [r3, #-1]
 8008dbe:	f47f ac86 	bne.w	80086ce <_svfprintf_r+0x87e>
 8008dc2:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8008dc4:	07c9      	lsls	r1, r1, #31
 8008dc6:	d506      	bpl.n	8008dd6 <_svfprintf_r+0xf86>
 8008dc8:	2a30      	cmp	r2, #48	; 0x30
 8008dca:	d004      	beq.n	8008dd6 <_svfprintf_r+0xf86>
 8008dcc:	2230      	movs	r2, #48	; 0x30
 8008dce:	f808 2c01 	strb.w	r2, [r8, #-1]
 8008dd2:	f1a3 0802 	sub.w	r8, r3, #2
 8008dd6:	464e      	mov	r6, r9
 8008dd8:	f10d 09b0 	add.w	r9, sp, #176	; 0xb0
 8008ddc:	eba9 0908 	sub.w	r9, r9, r8
 8008de0:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 8008de2:	2700      	movs	r7, #0
 8008de4:	f7ff bad1 	b.w	800838a <_svfprintf_r+0x53a>
 8008de8:	0800d230 	.word	0x0800d230
 8008dec:	0800d220 	.word	0x0800d220
 8008df0:	0800d1f4 	.word	0x0800d1f4
 8008df4:	0800d1f8 	.word	0x0800d1f8

08008df8 <_vfprintf_r>:
 8008df8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008dfc:	b0bd      	sub	sp, #244	; 0xf4
 8008dfe:	4688      	mov	r8, r1
 8008e00:	4615      	mov	r5, r2
 8008e02:	461c      	mov	r4, r3
 8008e04:	461f      	mov	r7, r3
 8008e06:	4683      	mov	fp, r0
 8008e08:	f002 fb72 	bl	800b4f0 <_localeconv_r>
 8008e0c:	6803      	ldr	r3, [r0, #0]
 8008e0e:	930d      	str	r3, [sp, #52]	; 0x34
 8008e10:	4618      	mov	r0, r3
 8008e12:	f7f7 f9e7 	bl	80001e4 <strlen>
 8008e16:	9009      	str	r0, [sp, #36]	; 0x24
 8008e18:	f1bb 0f00 	cmp.w	fp, #0
 8008e1c:	d005      	beq.n	8008e2a <_vfprintf_r+0x32>
 8008e1e:	f8db 3018 	ldr.w	r3, [fp, #24]
 8008e22:	b913      	cbnz	r3, 8008e2a <_vfprintf_r+0x32>
 8008e24:	4658      	mov	r0, fp
 8008e26:	f002 f853 	bl	800aed0 <__sinit>
 8008e2a:	4b99      	ldr	r3, [pc, #612]	; (8009090 <_vfprintf_r+0x298>)
 8008e2c:	4598      	cmp	r8, r3
 8008e2e:	d137      	bne.n	8008ea0 <_vfprintf_r+0xa8>
 8008e30:	f8db 8004 	ldr.w	r8, [fp, #4]
 8008e34:	f8d8 3064 	ldr.w	r3, [r8, #100]	; 0x64
 8008e38:	07d8      	lsls	r0, r3, #31
 8008e3a:	d407      	bmi.n	8008e4c <_vfprintf_r+0x54>
 8008e3c:	f8b8 300c 	ldrh.w	r3, [r8, #12]
 8008e40:	0599      	lsls	r1, r3, #22
 8008e42:	d403      	bmi.n	8008e4c <_vfprintf_r+0x54>
 8008e44:	f8d8 0058 	ldr.w	r0, [r8, #88]	; 0x58
 8008e48:	f002 fb62 	bl	800b510 <__retarget_lock_acquire_recursive>
 8008e4c:	f9b8 300c 	ldrsh.w	r3, [r8, #12]
 8008e50:	049a      	lsls	r2, r3, #18
 8008e52:	d409      	bmi.n	8008e68 <_vfprintf_r+0x70>
 8008e54:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8008e58:	f8a8 300c 	strh.w	r3, [r8, #12]
 8008e5c:	f8d8 3064 	ldr.w	r3, [r8, #100]	; 0x64
 8008e60:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8008e64:	f8c8 3064 	str.w	r3, [r8, #100]	; 0x64
 8008e68:	f8b8 300c 	ldrh.w	r3, [r8, #12]
 8008e6c:	071e      	lsls	r6, r3, #28
 8008e6e:	d502      	bpl.n	8008e76 <_vfprintf_r+0x7e>
 8008e70:	f8d8 3010 	ldr.w	r3, [r8, #16]
 8008e74:	bb03      	cbnz	r3, 8008eb8 <_vfprintf_r+0xc0>
 8008e76:	4641      	mov	r1, r8
 8008e78:	4658      	mov	r0, fp
 8008e7a:	f001 f839 	bl	8009ef0 <__swsetup_r>
 8008e7e:	b1d8      	cbz	r0, 8008eb8 <_vfprintf_r+0xc0>
 8008e80:	f8d8 3064 	ldr.w	r3, [r8, #100]	; 0x64
 8008e84:	07dd      	lsls	r5, r3, #31
 8008e86:	d407      	bmi.n	8008e98 <_vfprintf_r+0xa0>
 8008e88:	f8b8 300c 	ldrh.w	r3, [r8, #12]
 8008e8c:	059c      	lsls	r4, r3, #22
 8008e8e:	d403      	bmi.n	8008e98 <_vfprintf_r+0xa0>
 8008e90:	f8d8 0058 	ldr.w	r0, [r8, #88]	; 0x58
 8008e94:	f002 fb3d 	bl	800b512 <__retarget_lock_release_recursive>
 8008e98:	f04f 33ff 	mov.w	r3, #4294967295
 8008e9c:	930a      	str	r3, [sp, #40]	; 0x28
 8008e9e:	e026      	b.n	8008eee <_vfprintf_r+0xf6>
 8008ea0:	4b7c      	ldr	r3, [pc, #496]	; (8009094 <_vfprintf_r+0x29c>)
 8008ea2:	4598      	cmp	r8, r3
 8008ea4:	d102      	bne.n	8008eac <_vfprintf_r+0xb4>
 8008ea6:	f8db 8008 	ldr.w	r8, [fp, #8]
 8008eaa:	e7c3      	b.n	8008e34 <_vfprintf_r+0x3c>
 8008eac:	4b7a      	ldr	r3, [pc, #488]	; (8009098 <_vfprintf_r+0x2a0>)
 8008eae:	4598      	cmp	r8, r3
 8008eb0:	bf08      	it	eq
 8008eb2:	f8db 800c 	ldreq.w	r8, [fp, #12]
 8008eb6:	e7bd      	b.n	8008e34 <_vfprintf_r+0x3c>
 8008eb8:	f8b8 300c 	ldrh.w	r3, [r8, #12]
 8008ebc:	f003 021a 	and.w	r2, r3, #26
 8008ec0:	2a0a      	cmp	r2, #10
 8008ec2:	d118      	bne.n	8008ef6 <_vfprintf_r+0xfe>
 8008ec4:	f9b8 200e 	ldrsh.w	r2, [r8, #14]
 8008ec8:	2a00      	cmp	r2, #0
 8008eca:	db14      	blt.n	8008ef6 <_vfprintf_r+0xfe>
 8008ecc:	f8d8 2064 	ldr.w	r2, [r8, #100]	; 0x64
 8008ed0:	07d0      	lsls	r0, r2, #31
 8008ed2:	d405      	bmi.n	8008ee0 <_vfprintf_r+0xe8>
 8008ed4:	0599      	lsls	r1, r3, #22
 8008ed6:	d403      	bmi.n	8008ee0 <_vfprintf_r+0xe8>
 8008ed8:	f8d8 0058 	ldr.w	r0, [r8, #88]	; 0x58
 8008edc:	f002 fb19 	bl	800b512 <__retarget_lock_release_recursive>
 8008ee0:	4623      	mov	r3, r4
 8008ee2:	462a      	mov	r2, r5
 8008ee4:	4641      	mov	r1, r8
 8008ee6:	4658      	mov	r0, fp
 8008ee8:	f000 ffc2 	bl	8009e70 <__sbprintf>
 8008eec:	900a      	str	r0, [sp, #40]	; 0x28
 8008eee:	980a      	ldr	r0, [sp, #40]	; 0x28
 8008ef0:	b03d      	add	sp, #244	; 0xf4
 8008ef2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8008ef6:	ed9f 7b64 	vldr	d7, [pc, #400]	; 8009088 <_vfprintf_r+0x290>
 8008efa:	ed8d 7b06 	vstr	d7, [sp, #24]
 8008efe:	2300      	movs	r3, #0
 8008f00:	ac2c      	add	r4, sp, #176	; 0xb0
 8008f02:	941f      	str	r4, [sp, #124]	; 0x7c
 8008f04:	9321      	str	r3, [sp, #132]	; 0x84
 8008f06:	9320      	str	r3, [sp, #128]	; 0x80
 8008f08:	9505      	str	r5, [sp, #20]
 8008f0a:	9303      	str	r3, [sp, #12]
 8008f0c:	9311      	str	r3, [sp, #68]	; 0x44
 8008f0e:	9310      	str	r3, [sp, #64]	; 0x40
 8008f10:	930a      	str	r3, [sp, #40]	; 0x28
 8008f12:	9d05      	ldr	r5, [sp, #20]
 8008f14:	462b      	mov	r3, r5
 8008f16:	f813 2b01 	ldrb.w	r2, [r3], #1
 8008f1a:	b112      	cbz	r2, 8008f22 <_vfprintf_r+0x12a>
 8008f1c:	2a25      	cmp	r2, #37	; 0x25
 8008f1e:	f040 8083 	bne.w	8009028 <_vfprintf_r+0x230>
 8008f22:	9b05      	ldr	r3, [sp, #20]
 8008f24:	1aee      	subs	r6, r5, r3
 8008f26:	d00d      	beq.n	8008f44 <_vfprintf_r+0x14c>
 8008f28:	e884 0048 	stmia.w	r4, {r3, r6}
 8008f2c:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8008f2e:	4433      	add	r3, r6
 8008f30:	9321      	str	r3, [sp, #132]	; 0x84
 8008f32:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8008f34:	3301      	adds	r3, #1
 8008f36:	2b07      	cmp	r3, #7
 8008f38:	9320      	str	r3, [sp, #128]	; 0x80
 8008f3a:	dc77      	bgt.n	800902c <_vfprintf_r+0x234>
 8008f3c:	3408      	adds	r4, #8
 8008f3e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8008f40:	4433      	add	r3, r6
 8008f42:	930a      	str	r3, [sp, #40]	; 0x28
 8008f44:	782b      	ldrb	r3, [r5, #0]
 8008f46:	2b00      	cmp	r3, #0
 8008f48:	f000 8739 	beq.w	8009dbe <_vfprintf_r+0xfc6>
 8008f4c:	2300      	movs	r3, #0
 8008f4e:	1c69      	adds	r1, r5, #1
 8008f50:	f88d 305f 	strb.w	r3, [sp, #95]	; 0x5f
 8008f54:	461a      	mov	r2, r3
 8008f56:	f04f 3aff 	mov.w	sl, #4294967295
 8008f5a:	930b      	str	r3, [sp, #44]	; 0x2c
 8008f5c:	461d      	mov	r5, r3
 8008f5e:	200a      	movs	r0, #10
 8008f60:	1c4e      	adds	r6, r1, #1
 8008f62:	7809      	ldrb	r1, [r1, #0]
 8008f64:	9605      	str	r6, [sp, #20]
 8008f66:	9102      	str	r1, [sp, #8]
 8008f68:	9902      	ldr	r1, [sp, #8]
 8008f6a:	3920      	subs	r1, #32
 8008f6c:	2958      	cmp	r1, #88	; 0x58
 8008f6e:	f200 841d 	bhi.w	80097ac <_vfprintf_r+0x9b4>
 8008f72:	e8df f011 	tbh	[pc, r1, lsl #1]
 8008f76:	00b3      	.short	0x00b3
 8008f78:	041b041b 	.word	0x041b041b
 8008f7c:	041b00b8 	.word	0x041b00b8
 8008f80:	041b041b 	.word	0x041b041b
 8008f84:	041b041b 	.word	0x041b041b
 8008f88:	00bb041b 	.word	0x00bb041b
 8008f8c:	041b0065 	.word	0x041b0065
 8008f90:	00c700c4 	.word	0x00c700c4
 8008f94:	00e4041b 	.word	0x00e4041b
 8008f98:	00e700e7 	.word	0x00e700e7
 8008f9c:	00e700e7 	.word	0x00e700e7
 8008fa0:	00e700e7 	.word	0x00e700e7
 8008fa4:	00e700e7 	.word	0x00e700e7
 8008fa8:	041b00e7 	.word	0x041b00e7
 8008fac:	041b041b 	.word	0x041b041b
 8008fb0:	041b041b 	.word	0x041b041b
 8008fb4:	041b041b 	.word	0x041b041b
 8008fb8:	041b041b 	.word	0x041b041b
 8008fbc:	011b041b 	.word	0x011b041b
 8008fc0:	041b0131 	.word	0x041b0131
 8008fc4:	041b0131 	.word	0x041b0131
 8008fc8:	041b041b 	.word	0x041b041b
 8008fcc:	00fa041b 	.word	0x00fa041b
 8008fd0:	041b041b 	.word	0x041b041b
 8008fd4:	041b0346 	.word	0x041b0346
 8008fd8:	041b041b 	.word	0x041b041b
 8008fdc:	041b041b 	.word	0x041b041b
 8008fe0:	041b03ad 	.word	0x041b03ad
 8008fe4:	0093041b 	.word	0x0093041b
 8008fe8:	041b041b 	.word	0x041b041b
 8008fec:	041b041b 	.word	0x041b041b
 8008ff0:	041b041b 	.word	0x041b041b
 8008ff4:	041b041b 	.word	0x041b041b
 8008ff8:	041b041b 	.word	0x041b041b
 8008ffc:	006b010d 	.word	0x006b010d
 8009000:	01310131 	.word	0x01310131
 8009004:	00fd0131 	.word	0x00fd0131
 8009008:	041b006b 	.word	0x041b006b
 800900c:	0100041b 	.word	0x0100041b
 8009010:	0328041b 	.word	0x0328041b
 8009014:	037c0348 	.word	0x037c0348
 8009018:	041b0107 	.word	0x041b0107
 800901c:	041b038d 	.word	0x041b038d
 8009020:	041b03af 	.word	0x041b03af
 8009024:	03c7041b 	.word	0x03c7041b
 8009028:	461d      	mov	r5, r3
 800902a:	e773      	b.n	8008f14 <_vfprintf_r+0x11c>
 800902c:	aa1f      	add	r2, sp, #124	; 0x7c
 800902e:	4641      	mov	r1, r8
 8009030:	4658      	mov	r0, fp
 8009032:	f003 f814 	bl	800c05e <__sprint_r>
 8009036:	2800      	cmp	r0, #0
 8009038:	f040 8699 	bne.w	8009d6e <_vfprintf_r+0xf76>
 800903c:	ac2c      	add	r4, sp, #176	; 0xb0
 800903e:	e77e      	b.n	8008f3e <_vfprintf_r+0x146>
 8009040:	2301      	movs	r3, #1
 8009042:	222b      	movs	r2, #43	; 0x2b
 8009044:	9905      	ldr	r1, [sp, #20]
 8009046:	e78b      	b.n	8008f60 <_vfprintf_r+0x168>
 8009048:	460f      	mov	r7, r1
 800904a:	e7fb      	b.n	8009044 <_vfprintf_r+0x24c>
 800904c:	b10b      	cbz	r3, 8009052 <_vfprintf_r+0x25a>
 800904e:	f88d 205f 	strb.w	r2, [sp, #95]	; 0x5f
 8009052:	06aa      	lsls	r2, r5, #26
 8009054:	f140 80b0 	bpl.w	80091b8 <_vfprintf_r+0x3c0>
 8009058:	3707      	adds	r7, #7
 800905a:	f027 0707 	bic.w	r7, r7, #7
 800905e:	f107 0308 	add.w	r3, r7, #8
 8009062:	e9d7 6700 	ldrd	r6, r7, [r7]
 8009066:	9304      	str	r3, [sp, #16]
 8009068:	2e00      	cmp	r6, #0
 800906a:	f177 0300 	sbcs.w	r3, r7, #0
 800906e:	da06      	bge.n	800907e <_vfprintf_r+0x286>
 8009070:	4276      	negs	r6, r6
 8009072:	f04f 032d 	mov.w	r3, #45	; 0x2d
 8009076:	eb67 0747 	sbc.w	r7, r7, r7, lsl #1
 800907a:	f88d 305f 	strb.w	r3, [sp, #95]	; 0x5f
 800907e:	2301      	movs	r3, #1
 8009080:	e2d0      	b.n	8009624 <_vfprintf_r+0x82c>
 8009082:	bf00      	nop
 8009084:	f3af 8000 	nop.w
	...
 8009090:	0800d290 	.word	0x0800d290
 8009094:	0800d2b0 	.word	0x0800d2b0
 8009098:	0800d270 	.word	0x0800d270
 800909c:	b10b      	cbz	r3, 80090a2 <_vfprintf_r+0x2aa>
 800909e:	f88d 205f 	strb.w	r2, [sp, #95]	; 0x5f
 80090a2:	4ba2      	ldr	r3, [pc, #648]	; (800932c <_vfprintf_r+0x534>)
 80090a4:	9311      	str	r3, [sp, #68]	; 0x44
 80090a6:	06a9      	lsls	r1, r5, #26
 80090a8:	f140 8331 	bpl.w	800970e <_vfprintf_r+0x916>
 80090ac:	3707      	adds	r7, #7
 80090ae:	f027 0707 	bic.w	r7, r7, #7
 80090b2:	f107 0308 	add.w	r3, r7, #8
 80090b6:	e9d7 6700 	ldrd	r6, r7, [r7]
 80090ba:	9304      	str	r3, [sp, #16]
 80090bc:	07eb      	lsls	r3, r5, #31
 80090be:	d50b      	bpl.n	80090d8 <_vfprintf_r+0x2e0>
 80090c0:	ea56 0307 	orrs.w	r3, r6, r7
 80090c4:	d008      	beq.n	80090d8 <_vfprintf_r+0x2e0>
 80090c6:	2330      	movs	r3, #48	; 0x30
 80090c8:	f88d 3060 	strb.w	r3, [sp, #96]	; 0x60
 80090cc:	f89d 3008 	ldrb.w	r3, [sp, #8]
 80090d0:	f88d 3061 	strb.w	r3, [sp, #97]	; 0x61
 80090d4:	f045 0502 	orr.w	r5, r5, #2
 80090d8:	2302      	movs	r3, #2
 80090da:	e2a0      	b.n	800961e <_vfprintf_r+0x826>
 80090dc:	2a00      	cmp	r2, #0
 80090de:	d1b1      	bne.n	8009044 <_vfprintf_r+0x24c>
 80090e0:	2301      	movs	r3, #1
 80090e2:	2220      	movs	r2, #32
 80090e4:	e7ae      	b.n	8009044 <_vfprintf_r+0x24c>
 80090e6:	f045 0501 	orr.w	r5, r5, #1
 80090ea:	e7ab      	b.n	8009044 <_vfprintf_r+0x24c>
 80090ec:	683e      	ldr	r6, [r7, #0]
 80090ee:	960b      	str	r6, [sp, #44]	; 0x2c
 80090f0:	2e00      	cmp	r6, #0
 80090f2:	f107 0104 	add.w	r1, r7, #4
 80090f6:	daa7      	bge.n	8009048 <_vfprintf_r+0x250>
 80090f8:	4276      	negs	r6, r6
 80090fa:	960b      	str	r6, [sp, #44]	; 0x2c
 80090fc:	460f      	mov	r7, r1
 80090fe:	f045 0504 	orr.w	r5, r5, #4
 8009102:	e79f      	b.n	8009044 <_vfprintf_r+0x24c>
 8009104:	9905      	ldr	r1, [sp, #20]
 8009106:	1c4e      	adds	r6, r1, #1
 8009108:	7809      	ldrb	r1, [r1, #0]
 800910a:	9102      	str	r1, [sp, #8]
 800910c:	292a      	cmp	r1, #42	; 0x2a
 800910e:	d010      	beq.n	8009132 <_vfprintf_r+0x33a>
 8009110:	f04f 0a00 	mov.w	sl, #0
 8009114:	9605      	str	r6, [sp, #20]
 8009116:	9902      	ldr	r1, [sp, #8]
 8009118:	3930      	subs	r1, #48	; 0x30
 800911a:	2909      	cmp	r1, #9
 800911c:	f63f af24 	bhi.w	8008f68 <_vfprintf_r+0x170>
 8009120:	fb00 1a0a 	mla	sl, r0, sl, r1
 8009124:	9905      	ldr	r1, [sp, #20]
 8009126:	460e      	mov	r6, r1
 8009128:	f816 1b01 	ldrb.w	r1, [r6], #1
 800912c:	9102      	str	r1, [sp, #8]
 800912e:	9605      	str	r6, [sp, #20]
 8009130:	e7f1      	b.n	8009116 <_vfprintf_r+0x31e>
 8009132:	6839      	ldr	r1, [r7, #0]
 8009134:	9605      	str	r6, [sp, #20]
 8009136:	ea41 7ae1 	orr.w	sl, r1, r1, asr #31
 800913a:	3704      	adds	r7, #4
 800913c:	e782      	b.n	8009044 <_vfprintf_r+0x24c>
 800913e:	f045 0580 	orr.w	r5, r5, #128	; 0x80
 8009142:	e77f      	b.n	8009044 <_vfprintf_r+0x24c>
 8009144:	2100      	movs	r1, #0
 8009146:	910b      	str	r1, [sp, #44]	; 0x2c
 8009148:	9902      	ldr	r1, [sp, #8]
 800914a:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 800914c:	3930      	subs	r1, #48	; 0x30
 800914e:	fb00 1106 	mla	r1, r0, r6, r1
 8009152:	910b      	str	r1, [sp, #44]	; 0x2c
 8009154:	9905      	ldr	r1, [sp, #20]
 8009156:	460e      	mov	r6, r1
 8009158:	f816 1b01 	ldrb.w	r1, [r6], #1
 800915c:	9102      	str	r1, [sp, #8]
 800915e:	9902      	ldr	r1, [sp, #8]
 8009160:	9605      	str	r6, [sp, #20]
 8009162:	3930      	subs	r1, #48	; 0x30
 8009164:	2909      	cmp	r1, #9
 8009166:	d9ef      	bls.n	8009148 <_vfprintf_r+0x350>
 8009168:	e6fe      	b.n	8008f68 <_vfprintf_r+0x170>
 800916a:	f045 0508 	orr.w	r5, r5, #8
 800916e:	e769      	b.n	8009044 <_vfprintf_r+0x24c>
 8009170:	f045 0540 	orr.w	r5, r5, #64	; 0x40
 8009174:	e766      	b.n	8009044 <_vfprintf_r+0x24c>
 8009176:	9905      	ldr	r1, [sp, #20]
 8009178:	7809      	ldrb	r1, [r1, #0]
 800917a:	296c      	cmp	r1, #108	; 0x6c
 800917c:	d105      	bne.n	800918a <_vfprintf_r+0x392>
 800917e:	9905      	ldr	r1, [sp, #20]
 8009180:	3101      	adds	r1, #1
 8009182:	9105      	str	r1, [sp, #20]
 8009184:	f045 0520 	orr.w	r5, r5, #32
 8009188:	e75c      	b.n	8009044 <_vfprintf_r+0x24c>
 800918a:	f045 0510 	orr.w	r5, r5, #16
 800918e:	e759      	b.n	8009044 <_vfprintf_r+0x24c>
 8009190:	1d3b      	adds	r3, r7, #4
 8009192:	9304      	str	r3, [sp, #16]
 8009194:	2600      	movs	r6, #0
 8009196:	683b      	ldr	r3, [r7, #0]
 8009198:	f88d 3088 	strb.w	r3, [sp, #136]	; 0x88
 800919c:	f88d 605f 	strb.w	r6, [sp, #95]	; 0x5f
 80091a0:	f04f 0a01 	mov.w	sl, #1
 80091a4:	9608      	str	r6, [sp, #32]
 80091a6:	f10d 0988 	add.w	r9, sp, #136	; 0x88
 80091aa:	e11e      	b.n	80093ea <_vfprintf_r+0x5f2>
 80091ac:	b10b      	cbz	r3, 80091b2 <_vfprintf_r+0x3ba>
 80091ae:	f88d 205f 	strb.w	r2, [sp, #95]	; 0x5f
 80091b2:	f045 0510 	orr.w	r5, r5, #16
 80091b6:	e74c      	b.n	8009052 <_vfprintf_r+0x25a>
 80091b8:	f015 0f10 	tst.w	r5, #16
 80091bc:	f107 0304 	add.w	r3, r7, #4
 80091c0:	d003      	beq.n	80091ca <_vfprintf_r+0x3d2>
 80091c2:	683e      	ldr	r6, [r7, #0]
 80091c4:	9304      	str	r3, [sp, #16]
 80091c6:	17f7      	asrs	r7, r6, #31
 80091c8:	e74e      	b.n	8009068 <_vfprintf_r+0x270>
 80091ca:	683e      	ldr	r6, [r7, #0]
 80091cc:	9304      	str	r3, [sp, #16]
 80091ce:	f015 0f40 	tst.w	r5, #64	; 0x40
 80091d2:	bf18      	it	ne
 80091d4:	b236      	sxthne	r6, r6
 80091d6:	e7f6      	b.n	80091c6 <_vfprintf_r+0x3ce>
 80091d8:	b10b      	cbz	r3, 80091de <_vfprintf_r+0x3e6>
 80091da:	f88d 205f 	strb.w	r2, [sp, #95]	; 0x5f
 80091de:	3707      	adds	r7, #7
 80091e0:	f027 0707 	bic.w	r7, r7, #7
 80091e4:	f107 0308 	add.w	r3, r7, #8
 80091e8:	9304      	str	r3, [sp, #16]
 80091ea:	ed97 7b00 	vldr	d7, [r7]
 80091ee:	ed8d 7b06 	vstr	d7, [sp, #24]
 80091f2:	9b06      	ldr	r3, [sp, #24]
 80091f4:	9312      	str	r3, [sp, #72]	; 0x48
 80091f6:	9b07      	ldr	r3, [sp, #28]
 80091f8:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 80091fc:	9313      	str	r3, [sp, #76]	; 0x4c
 80091fe:	f04f 32ff 	mov.w	r2, #4294967295
 8009202:	4b4b      	ldr	r3, [pc, #300]	; (8009330 <_vfprintf_r+0x538>)
 8009204:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
 8009208:	f7f7 fc9c 	bl	8000b44 <__aeabi_dcmpun>
 800920c:	2800      	cmp	r0, #0
 800920e:	f040 85e3 	bne.w	8009dd8 <_vfprintf_r+0xfe0>
 8009212:	f04f 32ff 	mov.w	r2, #4294967295
 8009216:	4b46      	ldr	r3, [pc, #280]	; (8009330 <_vfprintf_r+0x538>)
 8009218:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
 800921c:	f7f7 fc74 	bl	8000b08 <__aeabi_dcmple>
 8009220:	2800      	cmp	r0, #0
 8009222:	f040 85d9 	bne.w	8009dd8 <_vfprintf_r+0xfe0>
 8009226:	2200      	movs	r2, #0
 8009228:	2300      	movs	r3, #0
 800922a:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 800922e:	f7f7 fc61 	bl	8000af4 <__aeabi_dcmplt>
 8009232:	b110      	cbz	r0, 800923a <_vfprintf_r+0x442>
 8009234:	232d      	movs	r3, #45	; 0x2d
 8009236:	f88d 305f 	strb.w	r3, [sp, #95]	; 0x5f
 800923a:	4b3e      	ldr	r3, [pc, #248]	; (8009334 <_vfprintf_r+0x53c>)
 800923c:	4a3e      	ldr	r2, [pc, #248]	; (8009338 <_vfprintf_r+0x540>)
 800923e:	9902      	ldr	r1, [sp, #8]
 8009240:	f025 0580 	bic.w	r5, r5, #128	; 0x80
 8009244:	2947      	cmp	r1, #71	; 0x47
 8009246:	bfcc      	ite	gt
 8009248:	4691      	movgt	r9, r2
 800924a:	4699      	movle	r9, r3
 800924c:	f04f 0a03 	mov.w	sl, #3
 8009250:	2600      	movs	r6, #0
 8009252:	9608      	str	r6, [sp, #32]
 8009254:	e0c9      	b.n	80093ea <_vfprintf_r+0x5f2>
 8009256:	f1ba 3fff 	cmp.w	sl, #4294967295
 800925a:	d022      	beq.n	80092a2 <_vfprintf_r+0x4aa>
 800925c:	9b02      	ldr	r3, [sp, #8]
 800925e:	f023 0320 	bic.w	r3, r3, #32
 8009262:	2b47      	cmp	r3, #71	; 0x47
 8009264:	d104      	bne.n	8009270 <_vfprintf_r+0x478>
 8009266:	f1ba 0f00 	cmp.w	sl, #0
 800926a:	bf08      	it	eq
 800926c:	f04f 0a01 	moveq.w	sl, #1
 8009270:	f445 7380 	orr.w	r3, r5, #256	; 0x100
 8009274:	9314      	str	r3, [sp, #80]	; 0x50
 8009276:	9b07      	ldr	r3, [sp, #28]
 8009278:	2b00      	cmp	r3, #0
 800927a:	da15      	bge.n	80092a8 <_vfprintf_r+0x4b0>
 800927c:	9b06      	ldr	r3, [sp, #24]
 800927e:	930e      	str	r3, [sp, #56]	; 0x38
 8009280:	9b07      	ldr	r3, [sp, #28]
 8009282:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 8009286:	930f      	str	r3, [sp, #60]	; 0x3c
 8009288:	232d      	movs	r3, #45	; 0x2d
 800928a:	930c      	str	r3, [sp, #48]	; 0x30
 800928c:	9b02      	ldr	r3, [sp, #8]
 800928e:	f023 0720 	bic.w	r7, r3, #32
 8009292:	2f46      	cmp	r7, #70	; 0x46
 8009294:	d00e      	beq.n	80092b4 <_vfprintf_r+0x4bc>
 8009296:	2f45      	cmp	r7, #69	; 0x45
 8009298:	d146      	bne.n	8009328 <_vfprintf_r+0x530>
 800929a:	f10a 0601 	add.w	r6, sl, #1
 800929e:	2102      	movs	r1, #2
 80092a0:	e00a      	b.n	80092b8 <_vfprintf_r+0x4c0>
 80092a2:	f04f 0a06 	mov.w	sl, #6
 80092a6:	e7e3      	b.n	8009270 <_vfprintf_r+0x478>
 80092a8:	ed9d 7b06 	vldr	d7, [sp, #24]
 80092ac:	2300      	movs	r3, #0
 80092ae:	ed8d 7b0e 	vstr	d7, [sp, #56]	; 0x38
 80092b2:	e7ea      	b.n	800928a <_vfprintf_r+0x492>
 80092b4:	4656      	mov	r6, sl
 80092b6:	2103      	movs	r1, #3
 80092b8:	ab1d      	add	r3, sp, #116	; 0x74
 80092ba:	9301      	str	r3, [sp, #4]
 80092bc:	ab1a      	add	r3, sp, #104	; 0x68
 80092be:	9300      	str	r3, [sp, #0]
 80092c0:	4632      	mov	r2, r6
 80092c2:	ab19      	add	r3, sp, #100	; 0x64
 80092c4:	ed9d 0b0e 	vldr	d0, [sp, #56]	; 0x38
 80092c8:	4658      	mov	r0, fp
 80092ca:	f000 ff0d 	bl	800a0e8 <_dtoa_r>
 80092ce:	2f47      	cmp	r7, #71	; 0x47
 80092d0:	4681      	mov	r9, r0
 80092d2:	d102      	bne.n	80092da <_vfprintf_r+0x4e2>
 80092d4:	07eb      	lsls	r3, r5, #31
 80092d6:	f140 858c 	bpl.w	8009df2 <_vfprintf_r+0xffa>
 80092da:	eb09 0306 	add.w	r3, r9, r6
 80092de:	2f46      	cmp	r7, #70	; 0x46
 80092e0:	9303      	str	r3, [sp, #12]
 80092e2:	d111      	bne.n	8009308 <_vfprintf_r+0x510>
 80092e4:	f899 3000 	ldrb.w	r3, [r9]
 80092e8:	2b30      	cmp	r3, #48	; 0x30
 80092ea:	d109      	bne.n	8009300 <_vfprintf_r+0x508>
 80092ec:	2200      	movs	r2, #0
 80092ee:	2300      	movs	r3, #0
 80092f0:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
 80092f4:	f7f7 fbf4 	bl	8000ae0 <__aeabi_dcmpeq>
 80092f8:	b910      	cbnz	r0, 8009300 <_vfprintf_r+0x508>
 80092fa:	f1c6 0601 	rsb	r6, r6, #1
 80092fe:	9619      	str	r6, [sp, #100]	; 0x64
 8009300:	9a03      	ldr	r2, [sp, #12]
 8009302:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8009304:	441a      	add	r2, r3
 8009306:	9203      	str	r2, [sp, #12]
 8009308:	2200      	movs	r2, #0
 800930a:	2300      	movs	r3, #0
 800930c:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
 8009310:	f7f7 fbe6 	bl	8000ae0 <__aeabi_dcmpeq>
 8009314:	b990      	cbnz	r0, 800933c <_vfprintf_r+0x544>
 8009316:	2230      	movs	r2, #48	; 0x30
 8009318:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 800931a:	9903      	ldr	r1, [sp, #12]
 800931c:	4299      	cmp	r1, r3
 800931e:	d90f      	bls.n	8009340 <_vfprintf_r+0x548>
 8009320:	1c59      	adds	r1, r3, #1
 8009322:	911d      	str	r1, [sp, #116]	; 0x74
 8009324:	701a      	strb	r2, [r3, #0]
 8009326:	e7f7      	b.n	8009318 <_vfprintf_r+0x520>
 8009328:	4656      	mov	r6, sl
 800932a:	e7b8      	b.n	800929e <_vfprintf_r+0x4a6>
 800932c:	0800d1fc 	.word	0x0800d1fc
 8009330:	7fefffff 	.word	0x7fefffff
 8009334:	0800d1ec 	.word	0x0800d1ec
 8009338:	0800d1f0 	.word	0x0800d1f0
 800933c:	9b03      	ldr	r3, [sp, #12]
 800933e:	931d      	str	r3, [sp, #116]	; 0x74
 8009340:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8009342:	2f47      	cmp	r7, #71	; 0x47
 8009344:	eba3 0309 	sub.w	r3, r3, r9
 8009348:	9303      	str	r3, [sp, #12]
 800934a:	f040 80f8 	bne.w	800953e <_vfprintf_r+0x746>
 800934e:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8009350:	1cdf      	adds	r7, r3, #3
 8009352:	db02      	blt.n	800935a <_vfprintf_r+0x562>
 8009354:	459a      	cmp	sl, r3
 8009356:	f280 811f 	bge.w	8009598 <_vfprintf_r+0x7a0>
 800935a:	9b02      	ldr	r3, [sp, #8]
 800935c:	3b02      	subs	r3, #2
 800935e:	9302      	str	r3, [sp, #8]
 8009360:	9a19      	ldr	r2, [sp, #100]	; 0x64
 8009362:	f89d 1008 	ldrb.w	r1, [sp, #8]
 8009366:	f88d 106c 	strb.w	r1, [sp, #108]	; 0x6c
 800936a:	1e53      	subs	r3, r2, #1
 800936c:	2b00      	cmp	r3, #0
 800936e:	9319      	str	r3, [sp, #100]	; 0x64
 8009370:	bfb6      	itet	lt
 8009372:	f1c2 0301 	rsblt	r3, r2, #1
 8009376:	222b      	movge	r2, #43	; 0x2b
 8009378:	222d      	movlt	r2, #45	; 0x2d
 800937a:	2b09      	cmp	r3, #9
 800937c:	f88d 206d 	strb.w	r2, [sp, #109]	; 0x6d
 8009380:	f340 80fa 	ble.w	8009578 <_vfprintf_r+0x780>
 8009384:	f10d 027b 	add.w	r2, sp, #123	; 0x7b
 8009388:	260a      	movs	r6, #10
 800938a:	fb93 f0f6 	sdiv	r0, r3, r6
 800938e:	fb06 3310 	mls	r3, r6, r0, r3
 8009392:	3330      	adds	r3, #48	; 0x30
 8009394:	2809      	cmp	r0, #9
 8009396:	f802 3c01 	strb.w	r3, [r2, #-1]
 800939a:	f102 31ff 	add.w	r1, r2, #4294967295
 800939e:	4603      	mov	r3, r0
 80093a0:	f300 80e3 	bgt.w	800956a <_vfprintf_r+0x772>
 80093a4:	3330      	adds	r3, #48	; 0x30
 80093a6:	f801 3c01 	strb.w	r3, [r1, #-1]
 80093aa:	3a02      	subs	r2, #2
 80093ac:	f10d 036e 	add.w	r3, sp, #110	; 0x6e
 80093b0:	f10d 007b 	add.w	r0, sp, #123	; 0x7b
 80093b4:	4282      	cmp	r2, r0
 80093b6:	4619      	mov	r1, r3
 80093b8:	f0c0 80d9 	bcc.w	800956e <_vfprintf_r+0x776>
 80093bc:	9a03      	ldr	r2, [sp, #12]
 80093be:	ab1b      	add	r3, sp, #108	; 0x6c
 80093c0:	1acb      	subs	r3, r1, r3
 80093c2:	2a01      	cmp	r2, #1
 80093c4:	9310      	str	r3, [sp, #64]	; 0x40
 80093c6:	eb03 0a02 	add.w	sl, r3, r2
 80093ca:	dc03      	bgt.n	80093d4 <_vfprintf_r+0x5dc>
 80093cc:	f015 0301 	ands.w	r3, r5, #1
 80093d0:	9308      	str	r3, [sp, #32]
 80093d2:	d003      	beq.n	80093dc <_vfprintf_r+0x5e4>
 80093d4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80093d6:	449a      	add	sl, r3
 80093d8:	2300      	movs	r3, #0
 80093da:	9308      	str	r3, [sp, #32]
 80093dc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80093de:	b113      	cbz	r3, 80093e6 <_vfprintf_r+0x5ee>
 80093e0:	232d      	movs	r3, #45	; 0x2d
 80093e2:	f88d 305f 	strb.w	r3, [sp, #95]	; 0x5f
 80093e6:	9d14      	ldr	r5, [sp, #80]	; 0x50
 80093e8:	2600      	movs	r6, #0
 80093ea:	4556      	cmp	r6, sl
 80093ec:	4633      	mov	r3, r6
 80093ee:	bfb8      	it	lt
 80093f0:	4653      	movlt	r3, sl
 80093f2:	930c      	str	r3, [sp, #48]	; 0x30
 80093f4:	f89d 305f 	ldrb.w	r3, [sp, #95]	; 0x5f
 80093f8:	b113      	cbz	r3, 8009400 <_vfprintf_r+0x608>
 80093fa:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80093fc:	3301      	adds	r3, #1
 80093fe:	930c      	str	r3, [sp, #48]	; 0x30
 8009400:	f015 0302 	ands.w	r3, r5, #2
 8009404:	9314      	str	r3, [sp, #80]	; 0x50
 8009406:	bf1e      	ittt	ne
 8009408:	9b0c      	ldrne	r3, [sp, #48]	; 0x30
 800940a:	3302      	addne	r3, #2
 800940c:	930c      	strne	r3, [sp, #48]	; 0x30
 800940e:	f015 0384 	ands.w	r3, r5, #132	; 0x84
 8009412:	9315      	str	r3, [sp, #84]	; 0x54
 8009414:	d114      	bne.n	8009440 <_vfprintf_r+0x648>
 8009416:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8009418:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800941a:	1a9f      	subs	r7, r3, r2
 800941c:	2f00      	cmp	r7, #0
 800941e:	dd0f      	ble.n	8009440 <_vfprintf_r+0x648>
 8009420:	4ba8      	ldr	r3, [pc, #672]	; (80096c4 <_vfprintf_r+0x8cc>)
 8009422:	6023      	str	r3, [r4, #0]
 8009424:	2f10      	cmp	r7, #16
 8009426:	f300 81d3 	bgt.w	80097d0 <_vfprintf_r+0x9d8>
 800942a:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800942c:	6067      	str	r7, [r4, #4]
 800942e:	441f      	add	r7, r3
 8009430:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8009432:	9721      	str	r7, [sp, #132]	; 0x84
 8009434:	3301      	adds	r3, #1
 8009436:	2b07      	cmp	r3, #7
 8009438:	9320      	str	r3, [sp, #128]	; 0x80
 800943a:	f300 81e0 	bgt.w	80097fe <_vfprintf_r+0xa06>
 800943e:	3408      	adds	r4, #8
 8009440:	f89d 305f 	ldrb.w	r3, [sp, #95]	; 0x5f
 8009444:	b173      	cbz	r3, 8009464 <_vfprintf_r+0x66c>
 8009446:	f10d 035f 	add.w	r3, sp, #95	; 0x5f
 800944a:	6023      	str	r3, [r4, #0]
 800944c:	2301      	movs	r3, #1
 800944e:	6063      	str	r3, [r4, #4]
 8009450:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8009452:	3301      	adds	r3, #1
 8009454:	9321      	str	r3, [sp, #132]	; 0x84
 8009456:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8009458:	3301      	adds	r3, #1
 800945a:	2b07      	cmp	r3, #7
 800945c:	9320      	str	r3, [sp, #128]	; 0x80
 800945e:	f300 81d8 	bgt.w	8009812 <_vfprintf_r+0xa1a>
 8009462:	3408      	adds	r4, #8
 8009464:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8009466:	b16b      	cbz	r3, 8009484 <_vfprintf_r+0x68c>
 8009468:	ab18      	add	r3, sp, #96	; 0x60
 800946a:	6023      	str	r3, [r4, #0]
 800946c:	2302      	movs	r3, #2
 800946e:	6063      	str	r3, [r4, #4]
 8009470:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8009472:	3302      	adds	r3, #2
 8009474:	9321      	str	r3, [sp, #132]	; 0x84
 8009476:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8009478:	3301      	adds	r3, #1
 800947a:	2b07      	cmp	r3, #7
 800947c:	9320      	str	r3, [sp, #128]	; 0x80
 800947e:	f300 81d2 	bgt.w	8009826 <_vfprintf_r+0xa2e>
 8009482:	3408      	adds	r4, #8
 8009484:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8009486:	2b80      	cmp	r3, #128	; 0x80
 8009488:	d114      	bne.n	80094b4 <_vfprintf_r+0x6bc>
 800948a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800948c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800948e:	1a9f      	subs	r7, r3, r2
 8009490:	2f00      	cmp	r7, #0
 8009492:	dd0f      	ble.n	80094b4 <_vfprintf_r+0x6bc>
 8009494:	4b8c      	ldr	r3, [pc, #560]	; (80096c8 <_vfprintf_r+0x8d0>)
 8009496:	6023      	str	r3, [r4, #0]
 8009498:	2f10      	cmp	r7, #16
 800949a:	f300 81ce 	bgt.w	800983a <_vfprintf_r+0xa42>
 800949e:	9b21      	ldr	r3, [sp, #132]	; 0x84
 80094a0:	6067      	str	r7, [r4, #4]
 80094a2:	441f      	add	r7, r3
 80094a4:	9b20      	ldr	r3, [sp, #128]	; 0x80
 80094a6:	9721      	str	r7, [sp, #132]	; 0x84
 80094a8:	3301      	adds	r3, #1
 80094aa:	2b07      	cmp	r3, #7
 80094ac:	9320      	str	r3, [sp, #128]	; 0x80
 80094ae:	f300 81dd 	bgt.w	800986c <_vfprintf_r+0xa74>
 80094b2:	3408      	adds	r4, #8
 80094b4:	eba6 060a 	sub.w	r6, r6, sl
 80094b8:	2e00      	cmp	r6, #0
 80094ba:	dd0f      	ble.n	80094dc <_vfprintf_r+0x6e4>
 80094bc:	4f82      	ldr	r7, [pc, #520]	; (80096c8 <_vfprintf_r+0x8d0>)
 80094be:	6027      	str	r7, [r4, #0]
 80094c0:	2e10      	cmp	r6, #16
 80094c2:	f300 81dd 	bgt.w	8009880 <_vfprintf_r+0xa88>
 80094c6:	9b20      	ldr	r3, [sp, #128]	; 0x80
 80094c8:	9821      	ldr	r0, [sp, #132]	; 0x84
 80094ca:	6066      	str	r6, [r4, #4]
 80094cc:	3301      	adds	r3, #1
 80094ce:	4406      	add	r6, r0
 80094d0:	2b07      	cmp	r3, #7
 80094d2:	9621      	str	r6, [sp, #132]	; 0x84
 80094d4:	9320      	str	r3, [sp, #128]	; 0x80
 80094d6:	f300 81ea 	bgt.w	80098ae <_vfprintf_r+0xab6>
 80094da:	3408      	adds	r4, #8
 80094dc:	05e9      	lsls	r1, r5, #23
 80094de:	f100 81f0 	bmi.w	80098c2 <_vfprintf_r+0xaca>
 80094e2:	9b21      	ldr	r3, [sp, #132]	; 0x84
 80094e4:	e884 0600 	stmia.w	r4, {r9, sl}
 80094e8:	4453      	add	r3, sl
 80094ea:	9321      	str	r3, [sp, #132]	; 0x84
 80094ec:	9b20      	ldr	r3, [sp, #128]	; 0x80
 80094ee:	3301      	adds	r3, #1
 80094f0:	2b07      	cmp	r3, #7
 80094f2:	9320      	str	r3, [sp, #128]	; 0x80
 80094f4:	f340 841b 	ble.w	8009d2e <_vfprintf_r+0xf36>
 80094f8:	aa1f      	add	r2, sp, #124	; 0x7c
 80094fa:	4641      	mov	r1, r8
 80094fc:	4658      	mov	r0, fp
 80094fe:	f002 fdae 	bl	800c05e <__sprint_r>
 8009502:	2800      	cmp	r0, #0
 8009504:	f040 8433 	bne.w	8009d6e <_vfprintf_r+0xf76>
 8009508:	ac2c      	add	r4, sp, #176	; 0xb0
 800950a:	0768      	lsls	r0, r5, #29
 800950c:	f100 8412 	bmi.w	8009d34 <_vfprintf_r+0xf3c>
 8009510:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8009512:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8009514:	990c      	ldr	r1, [sp, #48]	; 0x30
 8009516:	428a      	cmp	r2, r1
 8009518:	bfac      	ite	ge
 800951a:	189b      	addge	r3, r3, r2
 800951c:	185b      	addlt	r3, r3, r1
 800951e:	930a      	str	r3, [sp, #40]	; 0x28
 8009520:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8009522:	b13b      	cbz	r3, 8009534 <_vfprintf_r+0x73c>
 8009524:	aa1f      	add	r2, sp, #124	; 0x7c
 8009526:	4641      	mov	r1, r8
 8009528:	4658      	mov	r0, fp
 800952a:	f002 fd98 	bl	800c05e <__sprint_r>
 800952e:	2800      	cmp	r0, #0
 8009530:	f040 841d 	bne.w	8009d6e <_vfprintf_r+0xf76>
 8009534:	2300      	movs	r3, #0
 8009536:	9320      	str	r3, [sp, #128]	; 0x80
 8009538:	9f04      	ldr	r7, [sp, #16]
 800953a:	ac2c      	add	r4, sp, #176	; 0xb0
 800953c:	e4e9      	b.n	8008f12 <_vfprintf_r+0x11a>
 800953e:	9b02      	ldr	r3, [sp, #8]
 8009540:	2b65      	cmp	r3, #101	; 0x65
 8009542:	f77f af0d 	ble.w	8009360 <_vfprintf_r+0x568>
 8009546:	9b02      	ldr	r3, [sp, #8]
 8009548:	2b66      	cmp	r3, #102	; 0x66
 800954a:	d125      	bne.n	8009598 <_vfprintf_r+0x7a0>
 800954c:	9b19      	ldr	r3, [sp, #100]	; 0x64
 800954e:	2b00      	cmp	r3, #0
 8009550:	dd1a      	ble.n	8009588 <_vfprintf_r+0x790>
 8009552:	f1ba 0f00 	cmp.w	sl, #0
 8009556:	d101      	bne.n	800955c <_vfprintf_r+0x764>
 8009558:	07ee      	lsls	r6, r5, #31
 800955a:	d502      	bpl.n	8009562 <_vfprintf_r+0x76a>
 800955c:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800955e:	4413      	add	r3, r2
 8009560:	4453      	add	r3, sl
 8009562:	9a19      	ldr	r2, [sp, #100]	; 0x64
 8009564:	9208      	str	r2, [sp, #32]
 8009566:	469a      	mov	sl, r3
 8009568:	e738      	b.n	80093dc <_vfprintf_r+0x5e4>
 800956a:	460a      	mov	r2, r1
 800956c:	e70d      	b.n	800938a <_vfprintf_r+0x592>
 800956e:	f812 1b01 	ldrb.w	r1, [r2], #1
 8009572:	f803 1b01 	strb.w	r1, [r3], #1
 8009576:	e71d      	b.n	80093b4 <_vfprintf_r+0x5bc>
 8009578:	2230      	movs	r2, #48	; 0x30
 800957a:	4413      	add	r3, r2
 800957c:	f88d 206e 	strb.w	r2, [sp, #110]	; 0x6e
 8009580:	f88d 306f 	strb.w	r3, [sp, #111]	; 0x6f
 8009584:	a91c      	add	r1, sp, #112	; 0x70
 8009586:	e719      	b.n	80093bc <_vfprintf_r+0x5c4>
 8009588:	f1ba 0f00 	cmp.w	sl, #0
 800958c:	d101      	bne.n	8009592 <_vfprintf_r+0x79a>
 800958e:	07ed      	lsls	r5, r5, #31
 8009590:	d515      	bpl.n	80095be <_vfprintf_r+0x7c6>
 8009592:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8009594:	3301      	adds	r3, #1
 8009596:	e7e3      	b.n	8009560 <_vfprintf_r+0x768>
 8009598:	9a19      	ldr	r2, [sp, #100]	; 0x64
 800959a:	9b03      	ldr	r3, [sp, #12]
 800959c:	429a      	cmp	r2, r3
 800959e:	db06      	blt.n	80095ae <_vfprintf_r+0x7b6>
 80095a0:	07e8      	lsls	r0, r5, #31
 80095a2:	d50e      	bpl.n	80095c2 <_vfprintf_r+0x7ca>
 80095a4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80095a6:	4413      	add	r3, r2
 80095a8:	2267      	movs	r2, #103	; 0x67
 80095aa:	9202      	str	r2, [sp, #8]
 80095ac:	e7d9      	b.n	8009562 <_vfprintf_r+0x76a>
 80095ae:	9b03      	ldr	r3, [sp, #12]
 80095b0:	9909      	ldr	r1, [sp, #36]	; 0x24
 80095b2:	2a00      	cmp	r2, #0
 80095b4:	440b      	add	r3, r1
 80095b6:	dcf7      	bgt.n	80095a8 <_vfprintf_r+0x7b0>
 80095b8:	f1c2 0201 	rsb	r2, r2, #1
 80095bc:	e7f3      	b.n	80095a6 <_vfprintf_r+0x7ae>
 80095be:	2301      	movs	r3, #1
 80095c0:	e7cf      	b.n	8009562 <_vfprintf_r+0x76a>
 80095c2:	4613      	mov	r3, r2
 80095c4:	e7f0      	b.n	80095a8 <_vfprintf_r+0x7b0>
 80095c6:	b10b      	cbz	r3, 80095cc <_vfprintf_r+0x7d4>
 80095c8:	f88d 205f 	strb.w	r2, [sp, #95]	; 0x5f
 80095cc:	f015 0f20 	tst.w	r5, #32
 80095d0:	f107 0304 	add.w	r3, r7, #4
 80095d4:	d008      	beq.n	80095e8 <_vfprintf_r+0x7f0>
 80095d6:	990a      	ldr	r1, [sp, #40]	; 0x28
 80095d8:	683a      	ldr	r2, [r7, #0]
 80095da:	17ce      	asrs	r6, r1, #31
 80095dc:	4608      	mov	r0, r1
 80095de:	4631      	mov	r1, r6
 80095e0:	e9c2 0100 	strd	r0, r1, [r2]
 80095e4:	461f      	mov	r7, r3
 80095e6:	e494      	b.n	8008f12 <_vfprintf_r+0x11a>
 80095e8:	06e9      	lsls	r1, r5, #27
 80095ea:	d503      	bpl.n	80095f4 <_vfprintf_r+0x7fc>
 80095ec:	683a      	ldr	r2, [r7, #0]
 80095ee:	990a      	ldr	r1, [sp, #40]	; 0x28
 80095f0:	6011      	str	r1, [r2, #0]
 80095f2:	e7f7      	b.n	80095e4 <_vfprintf_r+0x7ec>
 80095f4:	066a      	lsls	r2, r5, #25
 80095f6:	d5f9      	bpl.n	80095ec <_vfprintf_r+0x7f4>
 80095f8:	683a      	ldr	r2, [r7, #0]
 80095fa:	f8bd 1028 	ldrh.w	r1, [sp, #40]	; 0x28
 80095fe:	8011      	strh	r1, [r2, #0]
 8009600:	e7f0      	b.n	80095e4 <_vfprintf_r+0x7ec>
 8009602:	f045 0510 	orr.w	r5, r5, #16
 8009606:	f015 0320 	ands.w	r3, r5, #32
 800960a:	d022      	beq.n	8009652 <_vfprintf_r+0x85a>
 800960c:	3707      	adds	r7, #7
 800960e:	f027 0707 	bic.w	r7, r7, #7
 8009612:	f107 0308 	add.w	r3, r7, #8
 8009616:	e9d7 6700 	ldrd	r6, r7, [r7]
 800961a:	9304      	str	r3, [sp, #16]
 800961c:	2300      	movs	r3, #0
 800961e:	2200      	movs	r2, #0
 8009620:	f88d 205f 	strb.w	r2, [sp, #95]	; 0x5f
 8009624:	f1ba 3fff 	cmp.w	sl, #4294967295
 8009628:	f000 83e8 	beq.w	8009dfc <_vfprintf_r+0x1004>
 800962c:	f025 0280 	bic.w	r2, r5, #128	; 0x80
 8009630:	9208      	str	r2, [sp, #32]
 8009632:	ea56 0207 	orrs.w	r2, r6, r7
 8009636:	f040 83e6 	bne.w	8009e06 <_vfprintf_r+0x100e>
 800963a:	f1ba 0f00 	cmp.w	sl, #0
 800963e:	f000 80a9 	beq.w	8009794 <_vfprintf_r+0x99c>
 8009642:	2b01      	cmp	r3, #1
 8009644:	d075      	beq.n	8009732 <_vfprintf_r+0x93a>
 8009646:	2b02      	cmp	r3, #2
 8009648:	f000 8090 	beq.w	800976c <_vfprintf_r+0x974>
 800964c:	2600      	movs	r6, #0
 800964e:	2700      	movs	r7, #0
 8009650:	e3df      	b.n	8009e12 <_vfprintf_r+0x101a>
 8009652:	1d3a      	adds	r2, r7, #4
 8009654:	f015 0110 	ands.w	r1, r5, #16
 8009658:	9204      	str	r2, [sp, #16]
 800965a:	d002      	beq.n	8009662 <_vfprintf_r+0x86a>
 800965c:	683e      	ldr	r6, [r7, #0]
 800965e:	2700      	movs	r7, #0
 8009660:	e7dd      	b.n	800961e <_vfprintf_r+0x826>
 8009662:	f015 0340 	ands.w	r3, r5, #64	; 0x40
 8009666:	d0f9      	beq.n	800965c <_vfprintf_r+0x864>
 8009668:	883e      	ldrh	r6, [r7, #0]
 800966a:	2700      	movs	r7, #0
 800966c:	e7d6      	b.n	800961c <_vfprintf_r+0x824>
 800966e:	1d3b      	adds	r3, r7, #4
 8009670:	9304      	str	r3, [sp, #16]
 8009672:	2330      	movs	r3, #48	; 0x30
 8009674:	2278      	movs	r2, #120	; 0x78
 8009676:	f88d 3060 	strb.w	r3, [sp, #96]	; 0x60
 800967a:	4b14      	ldr	r3, [pc, #80]	; (80096cc <_vfprintf_r+0x8d4>)
 800967c:	683e      	ldr	r6, [r7, #0]
 800967e:	9311      	str	r3, [sp, #68]	; 0x44
 8009680:	2700      	movs	r7, #0
 8009682:	f045 0502 	orr.w	r5, r5, #2
 8009686:	f88d 2061 	strb.w	r2, [sp, #97]	; 0x61
 800968a:	2302      	movs	r3, #2
 800968c:	9202      	str	r2, [sp, #8]
 800968e:	e7c6      	b.n	800961e <_vfprintf_r+0x826>
 8009690:	1d3b      	adds	r3, r7, #4
 8009692:	2600      	movs	r6, #0
 8009694:	f1ba 3fff 	cmp.w	sl, #4294967295
 8009698:	9304      	str	r3, [sp, #16]
 800969a:	f8d7 9000 	ldr.w	r9, [r7]
 800969e:	f88d 605f 	strb.w	r6, [sp, #95]	; 0x5f
 80096a2:	d00a      	beq.n	80096ba <_vfprintf_r+0x8c2>
 80096a4:	4652      	mov	r2, sl
 80096a6:	4631      	mov	r1, r6
 80096a8:	4648      	mov	r0, r9
 80096aa:	f7f6 fda9 	bl	8000200 <memchr>
 80096ae:	2800      	cmp	r0, #0
 80096b0:	f000 808c 	beq.w	80097cc <_vfprintf_r+0x9d4>
 80096b4:	eba0 0a09 	sub.w	sl, r0, r9
 80096b8:	e5cb      	b.n	8009252 <_vfprintf_r+0x45a>
 80096ba:	4648      	mov	r0, r9
 80096bc:	f7f6 fd92 	bl	80001e4 <strlen>
 80096c0:	4682      	mov	sl, r0
 80096c2:	e5c6      	b.n	8009252 <_vfprintf_r+0x45a>
 80096c4:	0800d240 	.word	0x0800d240
 80096c8:	0800d250 	.word	0x0800d250
 80096cc:	0800d20d 	.word	0x0800d20d
 80096d0:	f045 0510 	orr.w	r5, r5, #16
 80096d4:	06ae      	lsls	r6, r5, #26
 80096d6:	d509      	bpl.n	80096ec <_vfprintf_r+0x8f4>
 80096d8:	3707      	adds	r7, #7
 80096da:	f027 0707 	bic.w	r7, r7, #7
 80096de:	f107 0308 	add.w	r3, r7, #8
 80096e2:	e9d7 6700 	ldrd	r6, r7, [r7]
 80096e6:	9304      	str	r3, [sp, #16]
 80096e8:	2301      	movs	r3, #1
 80096ea:	e798      	b.n	800961e <_vfprintf_r+0x826>
 80096ec:	1d3b      	adds	r3, r7, #4
 80096ee:	f015 0f10 	tst.w	r5, #16
 80096f2:	9304      	str	r3, [sp, #16]
 80096f4:	d001      	beq.n	80096fa <_vfprintf_r+0x902>
 80096f6:	683e      	ldr	r6, [r7, #0]
 80096f8:	e002      	b.n	8009700 <_vfprintf_r+0x908>
 80096fa:	0668      	lsls	r0, r5, #25
 80096fc:	d5fb      	bpl.n	80096f6 <_vfprintf_r+0x8fe>
 80096fe:	883e      	ldrh	r6, [r7, #0]
 8009700:	2700      	movs	r7, #0
 8009702:	e7f1      	b.n	80096e8 <_vfprintf_r+0x8f0>
 8009704:	b10b      	cbz	r3, 800970a <_vfprintf_r+0x912>
 8009706:	f88d 205f 	strb.w	r2, [sp, #95]	; 0x5f
 800970a:	4ba2      	ldr	r3, [pc, #648]	; (8009994 <_vfprintf_r+0xb9c>)
 800970c:	e4ca      	b.n	80090a4 <_vfprintf_r+0x2ac>
 800970e:	1d3b      	adds	r3, r7, #4
 8009710:	f015 0f10 	tst.w	r5, #16
 8009714:	9304      	str	r3, [sp, #16]
 8009716:	d001      	beq.n	800971c <_vfprintf_r+0x924>
 8009718:	683e      	ldr	r6, [r7, #0]
 800971a:	e002      	b.n	8009722 <_vfprintf_r+0x92a>
 800971c:	066a      	lsls	r2, r5, #25
 800971e:	d5fb      	bpl.n	8009718 <_vfprintf_r+0x920>
 8009720:	883e      	ldrh	r6, [r7, #0]
 8009722:	2700      	movs	r7, #0
 8009724:	e4ca      	b.n	80090bc <_vfprintf_r+0x2c4>
 8009726:	464b      	mov	r3, r9
 8009728:	e374      	b.n	8009e14 <_vfprintf_r+0x101c>
 800972a:	2f00      	cmp	r7, #0
 800972c:	bf08      	it	eq
 800972e:	2e0a      	cmpeq	r6, #10
 8009730:	d205      	bcs.n	800973e <_vfprintf_r+0x946>
 8009732:	f10d 09f0 	add.w	r9, sp, #240	; 0xf0
 8009736:	3630      	adds	r6, #48	; 0x30
 8009738:	f809 6d41 	strb.w	r6, [r9, #-65]!
 800973c:	e385      	b.n	8009e4a <_vfprintf_r+0x1052>
 800973e:	f10d 09b0 	add.w	r9, sp, #176	; 0xb0
 8009742:	4630      	mov	r0, r6
 8009744:	4639      	mov	r1, r7
 8009746:	220a      	movs	r2, #10
 8009748:	2300      	movs	r3, #0
 800974a:	f7f7 fa89 	bl	8000c60 <__aeabi_uldivmod>
 800974e:	3230      	adds	r2, #48	; 0x30
 8009750:	f809 2d01 	strb.w	r2, [r9, #-1]!
 8009754:	2300      	movs	r3, #0
 8009756:	4630      	mov	r0, r6
 8009758:	4639      	mov	r1, r7
 800975a:	220a      	movs	r2, #10
 800975c:	f7f7 fa80 	bl	8000c60 <__aeabi_uldivmod>
 8009760:	4606      	mov	r6, r0
 8009762:	460f      	mov	r7, r1
 8009764:	ea56 0307 	orrs.w	r3, r6, r7
 8009768:	d1eb      	bne.n	8009742 <_vfprintf_r+0x94a>
 800976a:	e36e      	b.n	8009e4a <_vfprintf_r+0x1052>
 800976c:	2600      	movs	r6, #0
 800976e:	2700      	movs	r7, #0
 8009770:	f10d 09b0 	add.w	r9, sp, #176	; 0xb0
 8009774:	f006 030f 	and.w	r3, r6, #15
 8009778:	9a11      	ldr	r2, [sp, #68]	; 0x44
 800977a:	5cd3      	ldrb	r3, [r2, r3]
 800977c:	f809 3d01 	strb.w	r3, [r9, #-1]!
 8009780:	0933      	lsrs	r3, r6, #4
 8009782:	ea43 7307 	orr.w	r3, r3, r7, lsl #28
 8009786:	093a      	lsrs	r2, r7, #4
 8009788:	461e      	mov	r6, r3
 800978a:	4617      	mov	r7, r2
 800978c:	ea56 0307 	orrs.w	r3, r6, r7
 8009790:	d1f0      	bne.n	8009774 <_vfprintf_r+0x97c>
 8009792:	e35a      	b.n	8009e4a <_vfprintf_r+0x1052>
 8009794:	b93b      	cbnz	r3, 80097a6 <_vfprintf_r+0x9ae>
 8009796:	07e8      	lsls	r0, r5, #31
 8009798:	d505      	bpl.n	80097a6 <_vfprintf_r+0x9ae>
 800979a:	f10d 09f0 	add.w	r9, sp, #240	; 0xf0
 800979e:	2330      	movs	r3, #48	; 0x30
 80097a0:	f809 3d41 	strb.w	r3, [r9, #-65]!
 80097a4:	e351      	b.n	8009e4a <_vfprintf_r+0x1052>
 80097a6:	f10d 09b0 	add.w	r9, sp, #176	; 0xb0
 80097aa:	e34e      	b.n	8009e4a <_vfprintf_r+0x1052>
 80097ac:	b10b      	cbz	r3, 80097b2 <_vfprintf_r+0x9ba>
 80097ae:	f88d 205f 	strb.w	r2, [sp, #95]	; 0x5f
 80097b2:	9b02      	ldr	r3, [sp, #8]
 80097b4:	2b00      	cmp	r3, #0
 80097b6:	f000 8302 	beq.w	8009dbe <_vfprintf_r+0xfc6>
 80097ba:	f89d 3008 	ldrb.w	r3, [sp, #8]
 80097be:	f88d 3088 	strb.w	r3, [sp, #136]	; 0x88
 80097c2:	2600      	movs	r6, #0
 80097c4:	f88d 605f 	strb.w	r6, [sp, #95]	; 0x5f
 80097c8:	9704      	str	r7, [sp, #16]
 80097ca:	e4e9      	b.n	80091a0 <_vfprintf_r+0x3a8>
 80097cc:	4606      	mov	r6, r0
 80097ce:	e540      	b.n	8009252 <_vfprintf_r+0x45a>
 80097d0:	2310      	movs	r3, #16
 80097d2:	6063      	str	r3, [r4, #4]
 80097d4:	9b21      	ldr	r3, [sp, #132]	; 0x84
 80097d6:	3310      	adds	r3, #16
 80097d8:	9321      	str	r3, [sp, #132]	; 0x84
 80097da:	9b20      	ldr	r3, [sp, #128]	; 0x80
 80097dc:	3301      	adds	r3, #1
 80097de:	2b07      	cmp	r3, #7
 80097e0:	9320      	str	r3, [sp, #128]	; 0x80
 80097e2:	dc02      	bgt.n	80097ea <_vfprintf_r+0x9f2>
 80097e4:	3408      	adds	r4, #8
 80097e6:	3f10      	subs	r7, #16
 80097e8:	e61a      	b.n	8009420 <_vfprintf_r+0x628>
 80097ea:	aa1f      	add	r2, sp, #124	; 0x7c
 80097ec:	4641      	mov	r1, r8
 80097ee:	4658      	mov	r0, fp
 80097f0:	f002 fc35 	bl	800c05e <__sprint_r>
 80097f4:	2800      	cmp	r0, #0
 80097f6:	f040 82ba 	bne.w	8009d6e <_vfprintf_r+0xf76>
 80097fa:	ac2c      	add	r4, sp, #176	; 0xb0
 80097fc:	e7f3      	b.n	80097e6 <_vfprintf_r+0x9ee>
 80097fe:	aa1f      	add	r2, sp, #124	; 0x7c
 8009800:	4641      	mov	r1, r8
 8009802:	4658      	mov	r0, fp
 8009804:	f002 fc2b 	bl	800c05e <__sprint_r>
 8009808:	2800      	cmp	r0, #0
 800980a:	f040 82b0 	bne.w	8009d6e <_vfprintf_r+0xf76>
 800980e:	ac2c      	add	r4, sp, #176	; 0xb0
 8009810:	e616      	b.n	8009440 <_vfprintf_r+0x648>
 8009812:	aa1f      	add	r2, sp, #124	; 0x7c
 8009814:	4641      	mov	r1, r8
 8009816:	4658      	mov	r0, fp
 8009818:	f002 fc21 	bl	800c05e <__sprint_r>
 800981c:	2800      	cmp	r0, #0
 800981e:	f040 82a6 	bne.w	8009d6e <_vfprintf_r+0xf76>
 8009822:	ac2c      	add	r4, sp, #176	; 0xb0
 8009824:	e61e      	b.n	8009464 <_vfprintf_r+0x66c>
 8009826:	aa1f      	add	r2, sp, #124	; 0x7c
 8009828:	4641      	mov	r1, r8
 800982a:	4658      	mov	r0, fp
 800982c:	f002 fc17 	bl	800c05e <__sprint_r>
 8009830:	2800      	cmp	r0, #0
 8009832:	f040 829c 	bne.w	8009d6e <_vfprintf_r+0xf76>
 8009836:	ac2c      	add	r4, sp, #176	; 0xb0
 8009838:	e624      	b.n	8009484 <_vfprintf_r+0x68c>
 800983a:	2210      	movs	r2, #16
 800983c:	6062      	str	r2, [r4, #4]
 800983e:	9a21      	ldr	r2, [sp, #132]	; 0x84
 8009840:	3210      	adds	r2, #16
 8009842:	9221      	str	r2, [sp, #132]	; 0x84
 8009844:	9a20      	ldr	r2, [sp, #128]	; 0x80
 8009846:	3201      	adds	r2, #1
 8009848:	2a07      	cmp	r2, #7
 800984a:	9220      	str	r2, [sp, #128]	; 0x80
 800984c:	dc02      	bgt.n	8009854 <_vfprintf_r+0xa5c>
 800984e:	3408      	adds	r4, #8
 8009850:	3f10      	subs	r7, #16
 8009852:	e620      	b.n	8009496 <_vfprintf_r+0x69e>
 8009854:	aa1f      	add	r2, sp, #124	; 0x7c
 8009856:	4641      	mov	r1, r8
 8009858:	4658      	mov	r0, fp
 800985a:	9314      	str	r3, [sp, #80]	; 0x50
 800985c:	f002 fbff 	bl	800c05e <__sprint_r>
 8009860:	2800      	cmp	r0, #0
 8009862:	f040 8284 	bne.w	8009d6e <_vfprintf_r+0xf76>
 8009866:	ac2c      	add	r4, sp, #176	; 0xb0
 8009868:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800986a:	e7f1      	b.n	8009850 <_vfprintf_r+0xa58>
 800986c:	aa1f      	add	r2, sp, #124	; 0x7c
 800986e:	4641      	mov	r1, r8
 8009870:	4658      	mov	r0, fp
 8009872:	f002 fbf4 	bl	800c05e <__sprint_r>
 8009876:	2800      	cmp	r0, #0
 8009878:	f040 8279 	bne.w	8009d6e <_vfprintf_r+0xf76>
 800987c:	ac2c      	add	r4, sp, #176	; 0xb0
 800987e:	e619      	b.n	80094b4 <_vfprintf_r+0x6bc>
 8009880:	2310      	movs	r3, #16
 8009882:	6063      	str	r3, [r4, #4]
 8009884:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8009886:	3310      	adds	r3, #16
 8009888:	9321      	str	r3, [sp, #132]	; 0x84
 800988a:	9b20      	ldr	r3, [sp, #128]	; 0x80
 800988c:	3301      	adds	r3, #1
 800988e:	2b07      	cmp	r3, #7
 8009890:	9320      	str	r3, [sp, #128]	; 0x80
 8009892:	dc02      	bgt.n	800989a <_vfprintf_r+0xaa2>
 8009894:	3408      	adds	r4, #8
 8009896:	3e10      	subs	r6, #16
 8009898:	e611      	b.n	80094be <_vfprintf_r+0x6c6>
 800989a:	aa1f      	add	r2, sp, #124	; 0x7c
 800989c:	4641      	mov	r1, r8
 800989e:	4658      	mov	r0, fp
 80098a0:	f002 fbdd 	bl	800c05e <__sprint_r>
 80098a4:	2800      	cmp	r0, #0
 80098a6:	f040 8262 	bne.w	8009d6e <_vfprintf_r+0xf76>
 80098aa:	ac2c      	add	r4, sp, #176	; 0xb0
 80098ac:	e7f3      	b.n	8009896 <_vfprintf_r+0xa9e>
 80098ae:	aa1f      	add	r2, sp, #124	; 0x7c
 80098b0:	4641      	mov	r1, r8
 80098b2:	4658      	mov	r0, fp
 80098b4:	f002 fbd3 	bl	800c05e <__sprint_r>
 80098b8:	2800      	cmp	r0, #0
 80098ba:	f040 8258 	bne.w	8009d6e <_vfprintf_r+0xf76>
 80098be:	ac2c      	add	r4, sp, #176	; 0xb0
 80098c0:	e60c      	b.n	80094dc <_vfprintf_r+0x6e4>
 80098c2:	9b02      	ldr	r3, [sp, #8]
 80098c4:	2b65      	cmp	r3, #101	; 0x65
 80098c6:	f340 81ad 	ble.w	8009c24 <_vfprintf_r+0xe2c>
 80098ca:	2200      	movs	r2, #0
 80098cc:	2300      	movs	r3, #0
 80098ce:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 80098d2:	f7f7 f905 	bl	8000ae0 <__aeabi_dcmpeq>
 80098d6:	2800      	cmp	r0, #0
 80098d8:	d062      	beq.n	80099a0 <_vfprintf_r+0xba8>
 80098da:	4b2f      	ldr	r3, [pc, #188]	; (8009998 <_vfprintf_r+0xba0>)
 80098dc:	6023      	str	r3, [r4, #0]
 80098de:	2301      	movs	r3, #1
 80098e0:	6063      	str	r3, [r4, #4]
 80098e2:	9b21      	ldr	r3, [sp, #132]	; 0x84
 80098e4:	3301      	adds	r3, #1
 80098e6:	9321      	str	r3, [sp, #132]	; 0x84
 80098e8:	9b20      	ldr	r3, [sp, #128]	; 0x80
 80098ea:	3301      	adds	r3, #1
 80098ec:	2b07      	cmp	r3, #7
 80098ee:	9320      	str	r3, [sp, #128]	; 0x80
 80098f0:	dc25      	bgt.n	800993e <_vfprintf_r+0xb46>
 80098f2:	3408      	adds	r4, #8
 80098f4:	9b19      	ldr	r3, [sp, #100]	; 0x64
 80098f6:	9a03      	ldr	r2, [sp, #12]
 80098f8:	4293      	cmp	r3, r2
 80098fa:	db02      	blt.n	8009902 <_vfprintf_r+0xb0a>
 80098fc:	07ea      	lsls	r2, r5, #31
 80098fe:	f57f ae04 	bpl.w	800950a <_vfprintf_r+0x712>
 8009902:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8009904:	6023      	str	r3, [r4, #0]
 8009906:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8009908:	6063      	str	r3, [r4, #4]
 800990a:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800990c:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800990e:	4413      	add	r3, r2
 8009910:	9321      	str	r3, [sp, #132]	; 0x84
 8009912:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8009914:	3301      	adds	r3, #1
 8009916:	2b07      	cmp	r3, #7
 8009918:	9320      	str	r3, [sp, #128]	; 0x80
 800991a:	dc1a      	bgt.n	8009952 <_vfprintf_r+0xb5a>
 800991c:	3408      	adds	r4, #8
 800991e:	9b03      	ldr	r3, [sp, #12]
 8009920:	1e5e      	subs	r6, r3, #1
 8009922:	2e00      	cmp	r6, #0
 8009924:	f77f adf1 	ble.w	800950a <_vfprintf_r+0x712>
 8009928:	4f1c      	ldr	r7, [pc, #112]	; (800999c <_vfprintf_r+0xba4>)
 800992a:	f04f 0910 	mov.w	r9, #16
 800992e:	2e10      	cmp	r6, #16
 8009930:	6027      	str	r7, [r4, #0]
 8009932:	dc18      	bgt.n	8009966 <_vfprintf_r+0xb6e>
 8009934:	6066      	str	r6, [r4, #4]
 8009936:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8009938:	441e      	add	r6, r3
 800993a:	9621      	str	r6, [sp, #132]	; 0x84
 800993c:	e5d6      	b.n	80094ec <_vfprintf_r+0x6f4>
 800993e:	aa1f      	add	r2, sp, #124	; 0x7c
 8009940:	4641      	mov	r1, r8
 8009942:	4658      	mov	r0, fp
 8009944:	f002 fb8b 	bl	800c05e <__sprint_r>
 8009948:	2800      	cmp	r0, #0
 800994a:	f040 8210 	bne.w	8009d6e <_vfprintf_r+0xf76>
 800994e:	ac2c      	add	r4, sp, #176	; 0xb0
 8009950:	e7d0      	b.n	80098f4 <_vfprintf_r+0xafc>
 8009952:	aa1f      	add	r2, sp, #124	; 0x7c
 8009954:	4641      	mov	r1, r8
 8009956:	4658      	mov	r0, fp
 8009958:	f002 fb81 	bl	800c05e <__sprint_r>
 800995c:	2800      	cmp	r0, #0
 800995e:	f040 8206 	bne.w	8009d6e <_vfprintf_r+0xf76>
 8009962:	ac2c      	add	r4, sp, #176	; 0xb0
 8009964:	e7db      	b.n	800991e <_vfprintf_r+0xb26>
 8009966:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8009968:	f8c4 9004 	str.w	r9, [r4, #4]
 800996c:	3310      	adds	r3, #16
 800996e:	9321      	str	r3, [sp, #132]	; 0x84
 8009970:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8009972:	3301      	adds	r3, #1
 8009974:	2b07      	cmp	r3, #7
 8009976:	9320      	str	r3, [sp, #128]	; 0x80
 8009978:	dc02      	bgt.n	8009980 <_vfprintf_r+0xb88>
 800997a:	3408      	adds	r4, #8
 800997c:	3e10      	subs	r6, #16
 800997e:	e7d6      	b.n	800992e <_vfprintf_r+0xb36>
 8009980:	aa1f      	add	r2, sp, #124	; 0x7c
 8009982:	4641      	mov	r1, r8
 8009984:	4658      	mov	r0, fp
 8009986:	f002 fb6a 	bl	800c05e <__sprint_r>
 800998a:	2800      	cmp	r0, #0
 800998c:	f040 81ef 	bne.w	8009d6e <_vfprintf_r+0xf76>
 8009990:	ac2c      	add	r4, sp, #176	; 0xb0
 8009992:	e7f3      	b.n	800997c <_vfprintf_r+0xb84>
 8009994:	0800d20d 	.word	0x0800d20d
 8009998:	0800d21e 	.word	0x0800d21e
 800999c:	0800d250 	.word	0x0800d250
 80099a0:	9b19      	ldr	r3, [sp, #100]	; 0x64
 80099a2:	2b00      	cmp	r3, #0
 80099a4:	dc7a      	bgt.n	8009a9c <_vfprintf_r+0xca4>
 80099a6:	4b9d      	ldr	r3, [pc, #628]	; (8009c1c <_vfprintf_r+0xe24>)
 80099a8:	6023      	str	r3, [r4, #0]
 80099aa:	2301      	movs	r3, #1
 80099ac:	6063      	str	r3, [r4, #4]
 80099ae:	9b21      	ldr	r3, [sp, #132]	; 0x84
 80099b0:	3301      	adds	r3, #1
 80099b2:	9321      	str	r3, [sp, #132]	; 0x84
 80099b4:	9b20      	ldr	r3, [sp, #128]	; 0x80
 80099b6:	3301      	adds	r3, #1
 80099b8:	2b07      	cmp	r3, #7
 80099ba:	9320      	str	r3, [sp, #128]	; 0x80
 80099bc:	dc44      	bgt.n	8009a48 <_vfprintf_r+0xc50>
 80099be:	3408      	adds	r4, #8
 80099c0:	9b19      	ldr	r3, [sp, #100]	; 0x64
 80099c2:	b923      	cbnz	r3, 80099ce <_vfprintf_r+0xbd6>
 80099c4:	9b03      	ldr	r3, [sp, #12]
 80099c6:	b913      	cbnz	r3, 80099ce <_vfprintf_r+0xbd6>
 80099c8:	07eb      	lsls	r3, r5, #31
 80099ca:	f57f ad9e 	bpl.w	800950a <_vfprintf_r+0x712>
 80099ce:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80099d0:	6023      	str	r3, [r4, #0]
 80099d2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80099d4:	6063      	str	r3, [r4, #4]
 80099d6:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80099d8:	9b21      	ldr	r3, [sp, #132]	; 0x84
 80099da:	4413      	add	r3, r2
 80099dc:	9321      	str	r3, [sp, #132]	; 0x84
 80099de:	9b20      	ldr	r3, [sp, #128]	; 0x80
 80099e0:	3301      	adds	r3, #1
 80099e2:	2b07      	cmp	r3, #7
 80099e4:	9320      	str	r3, [sp, #128]	; 0x80
 80099e6:	dc39      	bgt.n	8009a5c <_vfprintf_r+0xc64>
 80099e8:	f104 0308 	add.w	r3, r4, #8
 80099ec:	9e19      	ldr	r6, [sp, #100]	; 0x64
 80099ee:	2e00      	cmp	r6, #0
 80099f0:	da19      	bge.n	8009a26 <_vfprintf_r+0xc2e>
 80099f2:	4f8b      	ldr	r7, [pc, #556]	; (8009c20 <_vfprintf_r+0xe28>)
 80099f4:	4276      	negs	r6, r6
 80099f6:	2410      	movs	r4, #16
 80099f8:	2e10      	cmp	r6, #16
 80099fa:	601f      	str	r7, [r3, #0]
 80099fc:	dc38      	bgt.n	8009a70 <_vfprintf_r+0xc78>
 80099fe:	9a21      	ldr	r2, [sp, #132]	; 0x84
 8009a00:	605e      	str	r6, [r3, #4]
 8009a02:	4416      	add	r6, r2
 8009a04:	9a20      	ldr	r2, [sp, #128]	; 0x80
 8009a06:	9621      	str	r6, [sp, #132]	; 0x84
 8009a08:	3201      	adds	r2, #1
 8009a0a:	2a07      	cmp	r2, #7
 8009a0c:	f103 0308 	add.w	r3, r3, #8
 8009a10:	9220      	str	r2, [sp, #128]	; 0x80
 8009a12:	dd08      	ble.n	8009a26 <_vfprintf_r+0xc2e>
 8009a14:	aa1f      	add	r2, sp, #124	; 0x7c
 8009a16:	4641      	mov	r1, r8
 8009a18:	4658      	mov	r0, fp
 8009a1a:	f002 fb20 	bl	800c05e <__sprint_r>
 8009a1e:	2800      	cmp	r0, #0
 8009a20:	f040 81a5 	bne.w	8009d6e <_vfprintf_r+0xf76>
 8009a24:	ab2c      	add	r3, sp, #176	; 0xb0
 8009a26:	9a03      	ldr	r2, [sp, #12]
 8009a28:	605a      	str	r2, [r3, #4]
 8009a2a:	9903      	ldr	r1, [sp, #12]
 8009a2c:	9a21      	ldr	r2, [sp, #132]	; 0x84
 8009a2e:	f8c3 9000 	str.w	r9, [r3]
 8009a32:	440a      	add	r2, r1
 8009a34:	9221      	str	r2, [sp, #132]	; 0x84
 8009a36:	9a20      	ldr	r2, [sp, #128]	; 0x80
 8009a38:	3201      	adds	r2, #1
 8009a3a:	2a07      	cmp	r2, #7
 8009a3c:	9220      	str	r2, [sp, #128]	; 0x80
 8009a3e:	f73f ad5b 	bgt.w	80094f8 <_vfprintf_r+0x700>
 8009a42:	f103 0408 	add.w	r4, r3, #8
 8009a46:	e560      	b.n	800950a <_vfprintf_r+0x712>
 8009a48:	aa1f      	add	r2, sp, #124	; 0x7c
 8009a4a:	4641      	mov	r1, r8
 8009a4c:	4658      	mov	r0, fp
 8009a4e:	f002 fb06 	bl	800c05e <__sprint_r>
 8009a52:	2800      	cmp	r0, #0
 8009a54:	f040 818b 	bne.w	8009d6e <_vfprintf_r+0xf76>
 8009a58:	ac2c      	add	r4, sp, #176	; 0xb0
 8009a5a:	e7b1      	b.n	80099c0 <_vfprintf_r+0xbc8>
 8009a5c:	aa1f      	add	r2, sp, #124	; 0x7c
 8009a5e:	4641      	mov	r1, r8
 8009a60:	4658      	mov	r0, fp
 8009a62:	f002 fafc 	bl	800c05e <__sprint_r>
 8009a66:	2800      	cmp	r0, #0
 8009a68:	f040 8181 	bne.w	8009d6e <_vfprintf_r+0xf76>
 8009a6c:	ab2c      	add	r3, sp, #176	; 0xb0
 8009a6e:	e7bd      	b.n	80099ec <_vfprintf_r+0xbf4>
 8009a70:	9a21      	ldr	r2, [sp, #132]	; 0x84
 8009a72:	605c      	str	r4, [r3, #4]
 8009a74:	3210      	adds	r2, #16
 8009a76:	9221      	str	r2, [sp, #132]	; 0x84
 8009a78:	9a20      	ldr	r2, [sp, #128]	; 0x80
 8009a7a:	3201      	adds	r2, #1
 8009a7c:	2a07      	cmp	r2, #7
 8009a7e:	9220      	str	r2, [sp, #128]	; 0x80
 8009a80:	dc02      	bgt.n	8009a88 <_vfprintf_r+0xc90>
 8009a82:	3308      	adds	r3, #8
 8009a84:	3e10      	subs	r6, #16
 8009a86:	e7b7      	b.n	80099f8 <_vfprintf_r+0xc00>
 8009a88:	aa1f      	add	r2, sp, #124	; 0x7c
 8009a8a:	4641      	mov	r1, r8
 8009a8c:	4658      	mov	r0, fp
 8009a8e:	f002 fae6 	bl	800c05e <__sprint_r>
 8009a92:	2800      	cmp	r0, #0
 8009a94:	f040 816b 	bne.w	8009d6e <_vfprintf_r+0xf76>
 8009a98:	ab2c      	add	r3, sp, #176	; 0xb0
 8009a9a:	e7f3      	b.n	8009a84 <_vfprintf_r+0xc8c>
 8009a9c:	9b08      	ldr	r3, [sp, #32]
 8009a9e:	9a03      	ldr	r2, [sp, #12]
 8009aa0:	4293      	cmp	r3, r2
 8009aa2:	bfa8      	it	ge
 8009aa4:	4613      	movge	r3, r2
 8009aa6:	2b00      	cmp	r3, #0
 8009aa8:	461e      	mov	r6, r3
 8009aaa:	dd0b      	ble.n	8009ac4 <_vfprintf_r+0xccc>
 8009aac:	6063      	str	r3, [r4, #4]
 8009aae:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8009ab0:	f8c4 9000 	str.w	r9, [r4]
 8009ab4:	4433      	add	r3, r6
 8009ab6:	9321      	str	r3, [sp, #132]	; 0x84
 8009ab8:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8009aba:	3301      	adds	r3, #1
 8009abc:	2b07      	cmp	r3, #7
 8009abe:	9320      	str	r3, [sp, #128]	; 0x80
 8009ac0:	dc62      	bgt.n	8009b88 <_vfprintf_r+0xd90>
 8009ac2:	3408      	adds	r4, #8
 8009ac4:	9b08      	ldr	r3, [sp, #32]
 8009ac6:	2e00      	cmp	r6, #0
 8009ac8:	bfa8      	it	ge
 8009aca:	1b9b      	subge	r3, r3, r6
 8009acc:	2b00      	cmp	r3, #0
 8009ace:	461e      	mov	r6, r3
 8009ad0:	dd0f      	ble.n	8009af2 <_vfprintf_r+0xcfa>
 8009ad2:	4f53      	ldr	r7, [pc, #332]	; (8009c20 <_vfprintf_r+0xe28>)
 8009ad4:	f04f 0a10 	mov.w	sl, #16
 8009ad8:	2e10      	cmp	r6, #16
 8009ada:	6027      	str	r7, [r4, #0]
 8009adc:	dc5e      	bgt.n	8009b9c <_vfprintf_r+0xda4>
 8009ade:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8009ae0:	6066      	str	r6, [r4, #4]
 8009ae2:	441e      	add	r6, r3
 8009ae4:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8009ae6:	9621      	str	r6, [sp, #132]	; 0x84
 8009ae8:	3301      	adds	r3, #1
 8009aea:	2b07      	cmp	r3, #7
 8009aec:	9320      	str	r3, [sp, #128]	; 0x80
 8009aee:	dc6c      	bgt.n	8009bca <_vfprintf_r+0xdd2>
 8009af0:	3408      	adds	r4, #8
 8009af2:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8009af4:	9a03      	ldr	r2, [sp, #12]
 8009af6:	4293      	cmp	r3, r2
 8009af8:	db01      	blt.n	8009afe <_vfprintf_r+0xd06>
 8009afa:	07ef      	lsls	r7, r5, #31
 8009afc:	d50d      	bpl.n	8009b1a <_vfprintf_r+0xd22>
 8009afe:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8009b00:	6023      	str	r3, [r4, #0]
 8009b02:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8009b04:	6063      	str	r3, [r4, #4]
 8009b06:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8009b08:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8009b0a:	4413      	add	r3, r2
 8009b0c:	9321      	str	r3, [sp, #132]	; 0x84
 8009b0e:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8009b10:	3301      	adds	r3, #1
 8009b12:	2b07      	cmp	r3, #7
 8009b14:	9320      	str	r3, [sp, #128]	; 0x80
 8009b16:	dc62      	bgt.n	8009bde <_vfprintf_r+0xde6>
 8009b18:	3408      	adds	r4, #8
 8009b1a:	9b03      	ldr	r3, [sp, #12]
 8009b1c:	9a08      	ldr	r2, [sp, #32]
 8009b1e:	1a9e      	subs	r6, r3, r2
 8009b20:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8009b22:	9a03      	ldr	r2, [sp, #12]
 8009b24:	1ad3      	subs	r3, r2, r3
 8009b26:	429e      	cmp	r6, r3
 8009b28:	bfa8      	it	ge
 8009b2a:	461e      	movge	r6, r3
 8009b2c:	2e00      	cmp	r6, #0
 8009b2e:	dd0c      	ble.n	8009b4a <_vfprintf_r+0xd52>
 8009b30:	9b08      	ldr	r3, [sp, #32]
 8009b32:	444b      	add	r3, r9
 8009b34:	e884 0048 	stmia.w	r4, {r3, r6}
 8009b38:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8009b3a:	4433      	add	r3, r6
 8009b3c:	9321      	str	r3, [sp, #132]	; 0x84
 8009b3e:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8009b40:	3301      	adds	r3, #1
 8009b42:	2b07      	cmp	r3, #7
 8009b44:	9320      	str	r3, [sp, #128]	; 0x80
 8009b46:	dc54      	bgt.n	8009bf2 <_vfprintf_r+0xdfa>
 8009b48:	3408      	adds	r4, #8
 8009b4a:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8009b4c:	9a03      	ldr	r2, [sp, #12]
 8009b4e:	2e00      	cmp	r6, #0
 8009b50:	eba2 0303 	sub.w	r3, r2, r3
 8009b54:	bfac      	ite	ge
 8009b56:	1b9e      	subge	r6, r3, r6
 8009b58:	461e      	movlt	r6, r3
 8009b5a:	2e00      	cmp	r6, #0
 8009b5c:	f77f acd5 	ble.w	800950a <_vfprintf_r+0x712>
 8009b60:	4f2f      	ldr	r7, [pc, #188]	; (8009c20 <_vfprintf_r+0xe28>)
 8009b62:	f04f 0910 	mov.w	r9, #16
 8009b66:	2e10      	cmp	r6, #16
 8009b68:	6027      	str	r7, [r4, #0]
 8009b6a:	f77f aee3 	ble.w	8009934 <_vfprintf_r+0xb3c>
 8009b6e:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8009b70:	f8c4 9004 	str.w	r9, [r4, #4]
 8009b74:	3310      	adds	r3, #16
 8009b76:	9321      	str	r3, [sp, #132]	; 0x84
 8009b78:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8009b7a:	3301      	adds	r3, #1
 8009b7c:	2b07      	cmp	r3, #7
 8009b7e:	9320      	str	r3, [sp, #128]	; 0x80
 8009b80:	dc41      	bgt.n	8009c06 <_vfprintf_r+0xe0e>
 8009b82:	3408      	adds	r4, #8
 8009b84:	3e10      	subs	r6, #16
 8009b86:	e7ee      	b.n	8009b66 <_vfprintf_r+0xd6e>
 8009b88:	aa1f      	add	r2, sp, #124	; 0x7c
 8009b8a:	4641      	mov	r1, r8
 8009b8c:	4658      	mov	r0, fp
 8009b8e:	f002 fa66 	bl	800c05e <__sprint_r>
 8009b92:	2800      	cmp	r0, #0
 8009b94:	f040 80eb 	bne.w	8009d6e <_vfprintf_r+0xf76>
 8009b98:	ac2c      	add	r4, sp, #176	; 0xb0
 8009b9a:	e793      	b.n	8009ac4 <_vfprintf_r+0xccc>
 8009b9c:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8009b9e:	f8c4 a004 	str.w	sl, [r4, #4]
 8009ba2:	3310      	adds	r3, #16
 8009ba4:	9321      	str	r3, [sp, #132]	; 0x84
 8009ba6:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8009ba8:	3301      	adds	r3, #1
 8009baa:	2b07      	cmp	r3, #7
 8009bac:	9320      	str	r3, [sp, #128]	; 0x80
 8009bae:	dc02      	bgt.n	8009bb6 <_vfprintf_r+0xdbe>
 8009bb0:	3408      	adds	r4, #8
 8009bb2:	3e10      	subs	r6, #16
 8009bb4:	e790      	b.n	8009ad8 <_vfprintf_r+0xce0>
 8009bb6:	aa1f      	add	r2, sp, #124	; 0x7c
 8009bb8:	4641      	mov	r1, r8
 8009bba:	4658      	mov	r0, fp
 8009bbc:	f002 fa4f 	bl	800c05e <__sprint_r>
 8009bc0:	2800      	cmp	r0, #0
 8009bc2:	f040 80d4 	bne.w	8009d6e <_vfprintf_r+0xf76>
 8009bc6:	ac2c      	add	r4, sp, #176	; 0xb0
 8009bc8:	e7f3      	b.n	8009bb2 <_vfprintf_r+0xdba>
 8009bca:	aa1f      	add	r2, sp, #124	; 0x7c
 8009bcc:	4641      	mov	r1, r8
 8009bce:	4658      	mov	r0, fp
 8009bd0:	f002 fa45 	bl	800c05e <__sprint_r>
 8009bd4:	2800      	cmp	r0, #0
 8009bd6:	f040 80ca 	bne.w	8009d6e <_vfprintf_r+0xf76>
 8009bda:	ac2c      	add	r4, sp, #176	; 0xb0
 8009bdc:	e789      	b.n	8009af2 <_vfprintf_r+0xcfa>
 8009bde:	aa1f      	add	r2, sp, #124	; 0x7c
 8009be0:	4641      	mov	r1, r8
 8009be2:	4658      	mov	r0, fp
 8009be4:	f002 fa3b 	bl	800c05e <__sprint_r>
 8009be8:	2800      	cmp	r0, #0
 8009bea:	f040 80c0 	bne.w	8009d6e <_vfprintf_r+0xf76>
 8009bee:	ac2c      	add	r4, sp, #176	; 0xb0
 8009bf0:	e793      	b.n	8009b1a <_vfprintf_r+0xd22>
 8009bf2:	aa1f      	add	r2, sp, #124	; 0x7c
 8009bf4:	4641      	mov	r1, r8
 8009bf6:	4658      	mov	r0, fp
 8009bf8:	f002 fa31 	bl	800c05e <__sprint_r>
 8009bfc:	2800      	cmp	r0, #0
 8009bfe:	f040 80b6 	bne.w	8009d6e <_vfprintf_r+0xf76>
 8009c02:	ac2c      	add	r4, sp, #176	; 0xb0
 8009c04:	e7a1      	b.n	8009b4a <_vfprintf_r+0xd52>
 8009c06:	aa1f      	add	r2, sp, #124	; 0x7c
 8009c08:	4641      	mov	r1, r8
 8009c0a:	4658      	mov	r0, fp
 8009c0c:	f002 fa27 	bl	800c05e <__sprint_r>
 8009c10:	2800      	cmp	r0, #0
 8009c12:	f040 80ac 	bne.w	8009d6e <_vfprintf_r+0xf76>
 8009c16:	ac2c      	add	r4, sp, #176	; 0xb0
 8009c18:	e7b4      	b.n	8009b84 <_vfprintf_r+0xd8c>
 8009c1a:	bf00      	nop
 8009c1c:	0800d21e 	.word	0x0800d21e
 8009c20:	0800d250 	.word	0x0800d250
 8009c24:	9b03      	ldr	r3, [sp, #12]
 8009c26:	2b01      	cmp	r3, #1
 8009c28:	dc01      	bgt.n	8009c2e <_vfprintf_r+0xe36>
 8009c2a:	07ee      	lsls	r6, r5, #31
 8009c2c:	d576      	bpl.n	8009d1c <_vfprintf_r+0xf24>
 8009c2e:	2301      	movs	r3, #1
 8009c30:	6063      	str	r3, [r4, #4]
 8009c32:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8009c34:	f8c4 9000 	str.w	r9, [r4]
 8009c38:	3301      	adds	r3, #1
 8009c3a:	9321      	str	r3, [sp, #132]	; 0x84
 8009c3c:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8009c3e:	3301      	adds	r3, #1
 8009c40:	2b07      	cmp	r3, #7
 8009c42:	9320      	str	r3, [sp, #128]	; 0x80
 8009c44:	dc36      	bgt.n	8009cb4 <_vfprintf_r+0xebc>
 8009c46:	3408      	adds	r4, #8
 8009c48:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8009c4a:	6023      	str	r3, [r4, #0]
 8009c4c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8009c4e:	6063      	str	r3, [r4, #4]
 8009c50:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8009c52:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8009c54:	4413      	add	r3, r2
 8009c56:	9321      	str	r3, [sp, #132]	; 0x84
 8009c58:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8009c5a:	3301      	adds	r3, #1
 8009c5c:	2b07      	cmp	r3, #7
 8009c5e:	9320      	str	r3, [sp, #128]	; 0x80
 8009c60:	dc31      	bgt.n	8009cc6 <_vfprintf_r+0xece>
 8009c62:	3408      	adds	r4, #8
 8009c64:	2300      	movs	r3, #0
 8009c66:	2200      	movs	r2, #0
 8009c68:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 8009c6c:	f7f6 ff38 	bl	8000ae0 <__aeabi_dcmpeq>
 8009c70:	9b03      	ldr	r3, [sp, #12]
 8009c72:	1e5e      	subs	r6, r3, #1
 8009c74:	2800      	cmp	r0, #0
 8009c76:	d12f      	bne.n	8009cd8 <_vfprintf_r+0xee0>
 8009c78:	f109 0301 	add.w	r3, r9, #1
 8009c7c:	e884 0048 	stmia.w	r4, {r3, r6}
 8009c80:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8009c82:	9a03      	ldr	r2, [sp, #12]
 8009c84:	3b01      	subs	r3, #1
 8009c86:	4413      	add	r3, r2
 8009c88:	9321      	str	r3, [sp, #132]	; 0x84
 8009c8a:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8009c8c:	3301      	adds	r3, #1
 8009c8e:	2b07      	cmp	r3, #7
 8009c90:	9320      	str	r3, [sp, #128]	; 0x80
 8009c92:	dd4a      	ble.n	8009d2a <_vfprintf_r+0xf32>
 8009c94:	aa1f      	add	r2, sp, #124	; 0x7c
 8009c96:	4641      	mov	r1, r8
 8009c98:	4658      	mov	r0, fp
 8009c9a:	f002 f9e0 	bl	800c05e <__sprint_r>
 8009c9e:	2800      	cmp	r0, #0
 8009ca0:	d165      	bne.n	8009d6e <_vfprintf_r+0xf76>
 8009ca2:	ac2c      	add	r4, sp, #176	; 0xb0
 8009ca4:	ab1b      	add	r3, sp, #108	; 0x6c
 8009ca6:	6023      	str	r3, [r4, #0]
 8009ca8:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8009caa:	6063      	str	r3, [r4, #4]
 8009cac:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8009cae:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8009cb0:	4413      	add	r3, r2
 8009cb2:	e41a      	b.n	80094ea <_vfprintf_r+0x6f2>
 8009cb4:	aa1f      	add	r2, sp, #124	; 0x7c
 8009cb6:	4641      	mov	r1, r8
 8009cb8:	4658      	mov	r0, fp
 8009cba:	f002 f9d0 	bl	800c05e <__sprint_r>
 8009cbe:	2800      	cmp	r0, #0
 8009cc0:	d155      	bne.n	8009d6e <_vfprintf_r+0xf76>
 8009cc2:	ac2c      	add	r4, sp, #176	; 0xb0
 8009cc4:	e7c0      	b.n	8009c48 <_vfprintf_r+0xe50>
 8009cc6:	aa1f      	add	r2, sp, #124	; 0x7c
 8009cc8:	4641      	mov	r1, r8
 8009cca:	4658      	mov	r0, fp
 8009ccc:	f002 f9c7 	bl	800c05e <__sprint_r>
 8009cd0:	2800      	cmp	r0, #0
 8009cd2:	d14c      	bne.n	8009d6e <_vfprintf_r+0xf76>
 8009cd4:	ac2c      	add	r4, sp, #176	; 0xb0
 8009cd6:	e7c5      	b.n	8009c64 <_vfprintf_r+0xe6c>
 8009cd8:	2e00      	cmp	r6, #0
 8009cda:	dde3      	ble.n	8009ca4 <_vfprintf_r+0xeac>
 8009cdc:	4f60      	ldr	r7, [pc, #384]	; (8009e60 <_vfprintf_r+0x1068>)
 8009cde:	f04f 0910 	mov.w	r9, #16
 8009ce2:	2e10      	cmp	r6, #16
 8009ce4:	6027      	str	r7, [r4, #0]
 8009ce6:	dc04      	bgt.n	8009cf2 <_vfprintf_r+0xefa>
 8009ce8:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8009cea:	6066      	str	r6, [r4, #4]
 8009cec:	441e      	add	r6, r3
 8009cee:	9621      	str	r6, [sp, #132]	; 0x84
 8009cf0:	e7cb      	b.n	8009c8a <_vfprintf_r+0xe92>
 8009cf2:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8009cf4:	f8c4 9004 	str.w	r9, [r4, #4]
 8009cf8:	3310      	adds	r3, #16
 8009cfa:	9321      	str	r3, [sp, #132]	; 0x84
 8009cfc:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8009cfe:	3301      	adds	r3, #1
 8009d00:	2b07      	cmp	r3, #7
 8009d02:	9320      	str	r3, [sp, #128]	; 0x80
 8009d04:	dc02      	bgt.n	8009d0c <_vfprintf_r+0xf14>
 8009d06:	3408      	adds	r4, #8
 8009d08:	3e10      	subs	r6, #16
 8009d0a:	e7ea      	b.n	8009ce2 <_vfprintf_r+0xeea>
 8009d0c:	aa1f      	add	r2, sp, #124	; 0x7c
 8009d0e:	4641      	mov	r1, r8
 8009d10:	4658      	mov	r0, fp
 8009d12:	f002 f9a4 	bl	800c05e <__sprint_r>
 8009d16:	bb50      	cbnz	r0, 8009d6e <_vfprintf_r+0xf76>
 8009d18:	ac2c      	add	r4, sp, #176	; 0xb0
 8009d1a:	e7f5      	b.n	8009d08 <_vfprintf_r+0xf10>
 8009d1c:	2301      	movs	r3, #1
 8009d1e:	6063      	str	r3, [r4, #4]
 8009d20:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8009d22:	f8c4 9000 	str.w	r9, [r4]
 8009d26:	3301      	adds	r3, #1
 8009d28:	e7ae      	b.n	8009c88 <_vfprintf_r+0xe90>
 8009d2a:	3408      	adds	r4, #8
 8009d2c:	e7ba      	b.n	8009ca4 <_vfprintf_r+0xeac>
 8009d2e:	3408      	adds	r4, #8
 8009d30:	f7ff bbeb 	b.w	800950a <_vfprintf_r+0x712>
 8009d34:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8009d36:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8009d38:	1a9d      	subs	r5, r3, r2
 8009d3a:	2d00      	cmp	r5, #0
 8009d3c:	f77f abe8 	ble.w	8009510 <_vfprintf_r+0x718>
 8009d40:	2610      	movs	r6, #16
 8009d42:	4b48      	ldr	r3, [pc, #288]	; (8009e64 <_vfprintf_r+0x106c>)
 8009d44:	6023      	str	r3, [r4, #0]
 8009d46:	2d10      	cmp	r5, #16
 8009d48:	dc24      	bgt.n	8009d94 <_vfprintf_r+0xf9c>
 8009d4a:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8009d4c:	6065      	str	r5, [r4, #4]
 8009d4e:	441d      	add	r5, r3
 8009d50:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8009d52:	9521      	str	r5, [sp, #132]	; 0x84
 8009d54:	3301      	adds	r3, #1
 8009d56:	2b07      	cmp	r3, #7
 8009d58:	9320      	str	r3, [sp, #128]	; 0x80
 8009d5a:	f77f abd9 	ble.w	8009510 <_vfprintf_r+0x718>
 8009d5e:	aa1f      	add	r2, sp, #124	; 0x7c
 8009d60:	4641      	mov	r1, r8
 8009d62:	4658      	mov	r0, fp
 8009d64:	f002 f97b 	bl	800c05e <__sprint_r>
 8009d68:	2800      	cmp	r0, #0
 8009d6a:	f43f abd1 	beq.w	8009510 <_vfprintf_r+0x718>
 8009d6e:	f8d8 3064 	ldr.w	r3, [r8, #100]	; 0x64
 8009d72:	07d9      	lsls	r1, r3, #31
 8009d74:	d407      	bmi.n	8009d86 <_vfprintf_r+0xf8e>
 8009d76:	f8b8 300c 	ldrh.w	r3, [r8, #12]
 8009d7a:	059a      	lsls	r2, r3, #22
 8009d7c:	d403      	bmi.n	8009d86 <_vfprintf_r+0xf8e>
 8009d7e:	f8d8 0058 	ldr.w	r0, [r8, #88]	; 0x58
 8009d82:	f001 fbc6 	bl	800b512 <__retarget_lock_release_recursive>
 8009d86:	f8b8 300c 	ldrh.w	r3, [r8, #12]
 8009d8a:	065b      	lsls	r3, r3, #25
 8009d8c:	f57f a8af 	bpl.w	8008eee <_vfprintf_r+0xf6>
 8009d90:	f7ff b882 	b.w	8008e98 <_vfprintf_r+0xa0>
 8009d94:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8009d96:	6066      	str	r6, [r4, #4]
 8009d98:	3310      	adds	r3, #16
 8009d9a:	9321      	str	r3, [sp, #132]	; 0x84
 8009d9c:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8009d9e:	3301      	adds	r3, #1
 8009da0:	2b07      	cmp	r3, #7
 8009da2:	9320      	str	r3, [sp, #128]	; 0x80
 8009da4:	dc02      	bgt.n	8009dac <_vfprintf_r+0xfb4>
 8009da6:	3408      	adds	r4, #8
 8009da8:	3d10      	subs	r5, #16
 8009daa:	e7ca      	b.n	8009d42 <_vfprintf_r+0xf4a>
 8009dac:	aa1f      	add	r2, sp, #124	; 0x7c
 8009dae:	4641      	mov	r1, r8
 8009db0:	4658      	mov	r0, fp
 8009db2:	f002 f954 	bl	800c05e <__sprint_r>
 8009db6:	2800      	cmp	r0, #0
 8009db8:	d1d9      	bne.n	8009d6e <_vfprintf_r+0xf76>
 8009dba:	ac2c      	add	r4, sp, #176	; 0xb0
 8009dbc:	e7f4      	b.n	8009da8 <_vfprintf_r+0xfb0>
 8009dbe:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8009dc0:	b913      	cbnz	r3, 8009dc8 <_vfprintf_r+0xfd0>
 8009dc2:	2300      	movs	r3, #0
 8009dc4:	9320      	str	r3, [sp, #128]	; 0x80
 8009dc6:	e7d2      	b.n	8009d6e <_vfprintf_r+0xf76>
 8009dc8:	aa1f      	add	r2, sp, #124	; 0x7c
 8009dca:	4641      	mov	r1, r8
 8009dcc:	4658      	mov	r0, fp
 8009dce:	f002 f946 	bl	800c05e <__sprint_r>
 8009dd2:	2800      	cmp	r0, #0
 8009dd4:	d0f5      	beq.n	8009dc2 <_vfprintf_r+0xfca>
 8009dd6:	e7ca      	b.n	8009d6e <_vfprintf_r+0xf76>
 8009dd8:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 8009ddc:	4610      	mov	r0, r2
 8009dde:	4619      	mov	r1, r3
 8009de0:	f7f6 feb0 	bl	8000b44 <__aeabi_dcmpun>
 8009de4:	2800      	cmp	r0, #0
 8009de6:	f43f aa36 	beq.w	8009256 <_vfprintf_r+0x45e>
 8009dea:	4b1f      	ldr	r3, [pc, #124]	; (8009e68 <_vfprintf_r+0x1070>)
 8009dec:	4a1f      	ldr	r2, [pc, #124]	; (8009e6c <_vfprintf_r+0x1074>)
 8009dee:	f7ff ba26 	b.w	800923e <_vfprintf_r+0x446>
 8009df2:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8009df4:	1a1b      	subs	r3, r3, r0
 8009df6:	9303      	str	r3, [sp, #12]
 8009df8:	f7ff baa9 	b.w	800934e <_vfprintf_r+0x556>
 8009dfc:	ea56 0207 	orrs.w	r2, r6, r7
 8009e00:	9508      	str	r5, [sp, #32]
 8009e02:	f43f ac1e 	beq.w	8009642 <_vfprintf_r+0x84a>
 8009e06:	2b01      	cmp	r3, #1
 8009e08:	f43f ac8f 	beq.w	800972a <_vfprintf_r+0x932>
 8009e0c:	2b02      	cmp	r3, #2
 8009e0e:	f43f acaf 	beq.w	8009770 <_vfprintf_r+0x978>
 8009e12:	ab2c      	add	r3, sp, #176	; 0xb0
 8009e14:	08f1      	lsrs	r1, r6, #3
 8009e16:	ea41 7147 	orr.w	r1, r1, r7, lsl #29
 8009e1a:	08f8      	lsrs	r0, r7, #3
 8009e1c:	f006 0207 	and.w	r2, r6, #7
 8009e20:	4607      	mov	r7, r0
 8009e22:	460e      	mov	r6, r1
 8009e24:	3230      	adds	r2, #48	; 0x30
 8009e26:	ea56 0107 	orrs.w	r1, r6, r7
 8009e2a:	f103 39ff 	add.w	r9, r3, #4294967295
 8009e2e:	f803 2c01 	strb.w	r2, [r3, #-1]
 8009e32:	f47f ac78 	bne.w	8009726 <_vfprintf_r+0x92e>
 8009e36:	9908      	ldr	r1, [sp, #32]
 8009e38:	07cd      	lsls	r5, r1, #31
 8009e3a:	d506      	bpl.n	8009e4a <_vfprintf_r+0x1052>
 8009e3c:	2a30      	cmp	r2, #48	; 0x30
 8009e3e:	d004      	beq.n	8009e4a <_vfprintf_r+0x1052>
 8009e40:	2230      	movs	r2, #48	; 0x30
 8009e42:	f809 2c01 	strb.w	r2, [r9, #-1]
 8009e46:	f1a3 0902 	sub.w	r9, r3, #2
 8009e4a:	4656      	mov	r6, sl
 8009e4c:	2300      	movs	r3, #0
 8009e4e:	f10d 0ab0 	add.w	sl, sp, #176	; 0xb0
 8009e52:	9d08      	ldr	r5, [sp, #32]
 8009e54:	9308      	str	r3, [sp, #32]
 8009e56:	ebaa 0a09 	sub.w	sl, sl, r9
 8009e5a:	f7ff bac6 	b.w	80093ea <_vfprintf_r+0x5f2>
 8009e5e:	bf00      	nop
 8009e60:	0800d250 	.word	0x0800d250
 8009e64:	0800d240 	.word	0x0800d240
 8009e68:	0800d1f4 	.word	0x0800d1f4
 8009e6c:	0800d1f8 	.word	0x0800d1f8

08009e70 <__sbprintf>:
 8009e70:	b5f0      	push	{r4, r5, r6, r7, lr}
 8009e72:	460c      	mov	r4, r1
 8009e74:	f2ad 4d6c 	subw	sp, sp, #1132	; 0x46c
 8009e78:	461f      	mov	r7, r3
 8009e7a:	8989      	ldrh	r1, [r1, #12]
 8009e7c:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8009e7e:	9319      	str	r3, [sp, #100]	; 0x64
 8009e80:	89e3      	ldrh	r3, [r4, #14]
 8009e82:	f8ad 300e 	strh.w	r3, [sp, #14]
 8009e86:	f021 0102 	bic.w	r1, r1, #2
 8009e8a:	6a23      	ldr	r3, [r4, #32]
 8009e8c:	f8ad 100c 	strh.w	r1, [sp, #12]
 8009e90:	9308      	str	r3, [sp, #32]
 8009e92:	a91a      	add	r1, sp, #104	; 0x68
 8009e94:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8009e96:	930a      	str	r3, [sp, #40]	; 0x28
 8009e98:	4615      	mov	r5, r2
 8009e9a:	2300      	movs	r3, #0
 8009e9c:	4606      	mov	r6, r0
 8009e9e:	9100      	str	r1, [sp, #0]
 8009ea0:	9104      	str	r1, [sp, #16]
 8009ea2:	a816      	add	r0, sp, #88	; 0x58
 8009ea4:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8009ea8:	9102      	str	r1, [sp, #8]
 8009eaa:	9105      	str	r1, [sp, #20]
 8009eac:	9306      	str	r3, [sp, #24]
 8009eae:	f001 fb2d 	bl	800b50c <__retarget_lock_init_recursive>
 8009eb2:	462a      	mov	r2, r5
 8009eb4:	463b      	mov	r3, r7
 8009eb6:	4669      	mov	r1, sp
 8009eb8:	4630      	mov	r0, r6
 8009eba:	f7fe ff9d 	bl	8008df8 <_vfprintf_r>
 8009ebe:	1e05      	subs	r5, r0, #0
 8009ec0:	db07      	blt.n	8009ed2 <__sbprintf+0x62>
 8009ec2:	4669      	mov	r1, sp
 8009ec4:	4630      	mov	r0, r6
 8009ec6:	f000 ff6f 	bl	800ada8 <_fflush_r>
 8009eca:	2800      	cmp	r0, #0
 8009ecc:	bf18      	it	ne
 8009ece:	f04f 35ff 	movne.w	r5, #4294967295
 8009ed2:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 8009ed6:	9816      	ldr	r0, [sp, #88]	; 0x58
 8009ed8:	065b      	lsls	r3, r3, #25
 8009eda:	bf42      	ittt	mi
 8009edc:	89a3      	ldrhmi	r3, [r4, #12]
 8009ede:	f043 0340 	orrmi.w	r3, r3, #64	; 0x40
 8009ee2:	81a3      	strhmi	r3, [r4, #12]
 8009ee4:	f001 fb13 	bl	800b50e <__retarget_lock_close_recursive>
 8009ee8:	4628      	mov	r0, r5
 8009eea:	f20d 4d6c 	addw	sp, sp, #1132	; 0x46c
 8009eee:	bdf0      	pop	{r4, r5, r6, r7, pc}

08009ef0 <__swsetup_r>:
 8009ef0:	4b32      	ldr	r3, [pc, #200]	; (8009fbc <__swsetup_r+0xcc>)
 8009ef2:	b570      	push	{r4, r5, r6, lr}
 8009ef4:	681d      	ldr	r5, [r3, #0]
 8009ef6:	4606      	mov	r6, r0
 8009ef8:	460c      	mov	r4, r1
 8009efa:	b125      	cbz	r5, 8009f06 <__swsetup_r+0x16>
 8009efc:	69ab      	ldr	r3, [r5, #24]
 8009efe:	b913      	cbnz	r3, 8009f06 <__swsetup_r+0x16>
 8009f00:	4628      	mov	r0, r5
 8009f02:	f000 ffe5 	bl	800aed0 <__sinit>
 8009f06:	4b2e      	ldr	r3, [pc, #184]	; (8009fc0 <__swsetup_r+0xd0>)
 8009f08:	429c      	cmp	r4, r3
 8009f0a:	d10f      	bne.n	8009f2c <__swsetup_r+0x3c>
 8009f0c:	686c      	ldr	r4, [r5, #4]
 8009f0e:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8009f12:	b29a      	uxth	r2, r3
 8009f14:	0715      	lsls	r5, r2, #28
 8009f16:	d42c      	bmi.n	8009f72 <__swsetup_r+0x82>
 8009f18:	06d0      	lsls	r0, r2, #27
 8009f1a:	d411      	bmi.n	8009f40 <__swsetup_r+0x50>
 8009f1c:	2209      	movs	r2, #9
 8009f1e:	6032      	str	r2, [r6, #0]
 8009f20:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8009f24:	81a3      	strh	r3, [r4, #12]
 8009f26:	f04f 30ff 	mov.w	r0, #4294967295
 8009f2a:	bd70      	pop	{r4, r5, r6, pc}
 8009f2c:	4b25      	ldr	r3, [pc, #148]	; (8009fc4 <__swsetup_r+0xd4>)
 8009f2e:	429c      	cmp	r4, r3
 8009f30:	d101      	bne.n	8009f36 <__swsetup_r+0x46>
 8009f32:	68ac      	ldr	r4, [r5, #8]
 8009f34:	e7eb      	b.n	8009f0e <__swsetup_r+0x1e>
 8009f36:	4b24      	ldr	r3, [pc, #144]	; (8009fc8 <__swsetup_r+0xd8>)
 8009f38:	429c      	cmp	r4, r3
 8009f3a:	bf08      	it	eq
 8009f3c:	68ec      	ldreq	r4, [r5, #12]
 8009f3e:	e7e6      	b.n	8009f0e <__swsetup_r+0x1e>
 8009f40:	0751      	lsls	r1, r2, #29
 8009f42:	d512      	bpl.n	8009f6a <__swsetup_r+0x7a>
 8009f44:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8009f46:	b141      	cbz	r1, 8009f5a <__swsetup_r+0x6a>
 8009f48:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8009f4c:	4299      	cmp	r1, r3
 8009f4e:	d002      	beq.n	8009f56 <__swsetup_r+0x66>
 8009f50:	4630      	mov	r0, r6
 8009f52:	f001 f893 	bl	800b07c <_free_r>
 8009f56:	2300      	movs	r3, #0
 8009f58:	6363      	str	r3, [r4, #52]	; 0x34
 8009f5a:	89a3      	ldrh	r3, [r4, #12]
 8009f5c:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 8009f60:	81a3      	strh	r3, [r4, #12]
 8009f62:	2300      	movs	r3, #0
 8009f64:	6063      	str	r3, [r4, #4]
 8009f66:	6923      	ldr	r3, [r4, #16]
 8009f68:	6023      	str	r3, [r4, #0]
 8009f6a:	89a3      	ldrh	r3, [r4, #12]
 8009f6c:	f043 0308 	orr.w	r3, r3, #8
 8009f70:	81a3      	strh	r3, [r4, #12]
 8009f72:	6923      	ldr	r3, [r4, #16]
 8009f74:	b94b      	cbnz	r3, 8009f8a <__swsetup_r+0x9a>
 8009f76:	89a3      	ldrh	r3, [r4, #12]
 8009f78:	f403 7320 	and.w	r3, r3, #640	; 0x280
 8009f7c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8009f80:	d003      	beq.n	8009f8a <__swsetup_r+0x9a>
 8009f82:	4621      	mov	r1, r4
 8009f84:	4630      	mov	r0, r6
 8009f86:	f001 faf1 	bl	800b56c <__smakebuf_r>
 8009f8a:	89a2      	ldrh	r2, [r4, #12]
 8009f8c:	f012 0301 	ands.w	r3, r2, #1
 8009f90:	d00c      	beq.n	8009fac <__swsetup_r+0xbc>
 8009f92:	2300      	movs	r3, #0
 8009f94:	60a3      	str	r3, [r4, #8]
 8009f96:	6963      	ldr	r3, [r4, #20]
 8009f98:	425b      	negs	r3, r3
 8009f9a:	61a3      	str	r3, [r4, #24]
 8009f9c:	6923      	ldr	r3, [r4, #16]
 8009f9e:	b953      	cbnz	r3, 8009fb6 <__swsetup_r+0xc6>
 8009fa0:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8009fa4:	f013 0080 	ands.w	r0, r3, #128	; 0x80
 8009fa8:	d1ba      	bne.n	8009f20 <__swsetup_r+0x30>
 8009faa:	bd70      	pop	{r4, r5, r6, pc}
 8009fac:	0792      	lsls	r2, r2, #30
 8009fae:	bf58      	it	pl
 8009fb0:	6963      	ldrpl	r3, [r4, #20]
 8009fb2:	60a3      	str	r3, [r4, #8]
 8009fb4:	e7f2      	b.n	8009f9c <__swsetup_r+0xac>
 8009fb6:	2000      	movs	r0, #0
 8009fb8:	e7f7      	b.n	8009faa <__swsetup_r+0xba>
 8009fba:	bf00      	nop
 8009fbc:	2000005c 	.word	0x2000005c
 8009fc0:	0800d290 	.word	0x0800d290
 8009fc4:	0800d2b0 	.word	0x0800d2b0
 8009fc8:	0800d270 	.word	0x0800d270

08009fcc <quorem>:
 8009fcc:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009fd0:	6903      	ldr	r3, [r0, #16]
 8009fd2:	690c      	ldr	r4, [r1, #16]
 8009fd4:	429c      	cmp	r4, r3
 8009fd6:	4680      	mov	r8, r0
 8009fd8:	f300 8082 	bgt.w	800a0e0 <quorem+0x114>
 8009fdc:	3c01      	subs	r4, #1
 8009fde:	f101 0714 	add.w	r7, r1, #20
 8009fe2:	ea4f 0e84 	mov.w	lr, r4, lsl #2
 8009fe6:	f100 0614 	add.w	r6, r0, #20
 8009fea:	f857 5024 	ldr.w	r5, [r7, r4, lsl #2]
 8009fee:	f856 0024 	ldr.w	r0, [r6, r4, lsl #2]
 8009ff2:	eb06 030e 	add.w	r3, r6, lr
 8009ff6:	3501      	adds	r5, #1
 8009ff8:	eb07 090e 	add.w	r9, r7, lr
 8009ffc:	9301      	str	r3, [sp, #4]
 8009ffe:	fbb0 f5f5 	udiv	r5, r0, r5
 800a002:	b395      	cbz	r5, 800a06a <quorem+0x9e>
 800a004:	f04f 0a00 	mov.w	sl, #0
 800a008:	4638      	mov	r0, r7
 800a00a:	46b4      	mov	ip, r6
 800a00c:	46d3      	mov	fp, sl
 800a00e:	f850 2b04 	ldr.w	r2, [r0], #4
 800a012:	b293      	uxth	r3, r2
 800a014:	fb05 a303 	mla	r3, r5, r3, sl
 800a018:	ea4f 4a13 	mov.w	sl, r3, lsr #16
 800a01c:	b29b      	uxth	r3, r3
 800a01e:	ebab 0303 	sub.w	r3, fp, r3
 800a022:	0c12      	lsrs	r2, r2, #16
 800a024:	f8bc b000 	ldrh.w	fp, [ip]
 800a028:	fb05 a202 	mla	r2, r5, r2, sl
 800a02c:	fa13 f38b 	uxtah	r3, r3, fp
 800a030:	ea4f 4a12 	mov.w	sl, r2, lsr #16
 800a034:	fa1f fb82 	uxth.w	fp, r2
 800a038:	f8dc 2000 	ldr.w	r2, [ip]
 800a03c:	ebcb 4212 	rsb	r2, fp, r2, lsr #16
 800a040:	eb02 4223 	add.w	r2, r2, r3, asr #16
 800a044:	b29b      	uxth	r3, r3
 800a046:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 800a04a:	4581      	cmp	r9, r0
 800a04c:	ea4f 4b22 	mov.w	fp, r2, asr #16
 800a050:	f84c 3b04 	str.w	r3, [ip], #4
 800a054:	d2db      	bcs.n	800a00e <quorem+0x42>
 800a056:	f856 300e 	ldr.w	r3, [r6, lr]
 800a05a:	b933      	cbnz	r3, 800a06a <quorem+0x9e>
 800a05c:	9b01      	ldr	r3, [sp, #4]
 800a05e:	3b04      	subs	r3, #4
 800a060:	429e      	cmp	r6, r3
 800a062:	461a      	mov	r2, r3
 800a064:	d330      	bcc.n	800a0c8 <quorem+0xfc>
 800a066:	f8c8 4010 	str.w	r4, [r8, #16]
 800a06a:	4640      	mov	r0, r8
 800a06c:	f001 fcf3 	bl	800ba56 <__mcmp>
 800a070:	2800      	cmp	r0, #0
 800a072:	db25      	blt.n	800a0c0 <quorem+0xf4>
 800a074:	3501      	adds	r5, #1
 800a076:	4630      	mov	r0, r6
 800a078:	f04f 0e00 	mov.w	lr, #0
 800a07c:	f857 2b04 	ldr.w	r2, [r7], #4
 800a080:	f8d0 c000 	ldr.w	ip, [r0]
 800a084:	b293      	uxth	r3, r2
 800a086:	ebae 0303 	sub.w	r3, lr, r3
 800a08a:	0c12      	lsrs	r2, r2, #16
 800a08c:	fa13 f38c 	uxtah	r3, r3, ip
 800a090:	ebc2 421c 	rsb	r2, r2, ip, lsr #16
 800a094:	eb02 4223 	add.w	r2, r2, r3, asr #16
 800a098:	b29b      	uxth	r3, r3
 800a09a:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 800a09e:	45b9      	cmp	r9, r7
 800a0a0:	ea4f 4e22 	mov.w	lr, r2, asr #16
 800a0a4:	f840 3b04 	str.w	r3, [r0], #4
 800a0a8:	d2e8      	bcs.n	800a07c <quorem+0xb0>
 800a0aa:	f856 2024 	ldr.w	r2, [r6, r4, lsl #2]
 800a0ae:	eb06 0384 	add.w	r3, r6, r4, lsl #2
 800a0b2:	b92a      	cbnz	r2, 800a0c0 <quorem+0xf4>
 800a0b4:	3b04      	subs	r3, #4
 800a0b6:	429e      	cmp	r6, r3
 800a0b8:	461a      	mov	r2, r3
 800a0ba:	d30b      	bcc.n	800a0d4 <quorem+0x108>
 800a0bc:	f8c8 4010 	str.w	r4, [r8, #16]
 800a0c0:	4628      	mov	r0, r5
 800a0c2:	b003      	add	sp, #12
 800a0c4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800a0c8:	6812      	ldr	r2, [r2, #0]
 800a0ca:	3b04      	subs	r3, #4
 800a0cc:	2a00      	cmp	r2, #0
 800a0ce:	d1ca      	bne.n	800a066 <quorem+0x9a>
 800a0d0:	3c01      	subs	r4, #1
 800a0d2:	e7c5      	b.n	800a060 <quorem+0x94>
 800a0d4:	6812      	ldr	r2, [r2, #0]
 800a0d6:	3b04      	subs	r3, #4
 800a0d8:	2a00      	cmp	r2, #0
 800a0da:	d1ef      	bne.n	800a0bc <quorem+0xf0>
 800a0dc:	3c01      	subs	r4, #1
 800a0de:	e7ea      	b.n	800a0b6 <quorem+0xea>
 800a0e0:	2000      	movs	r0, #0
 800a0e2:	e7ee      	b.n	800a0c2 <quorem+0xf6>
 800a0e4:	0000      	movs	r0, r0
	...

0800a0e8 <_dtoa_r>:
 800a0e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a0ec:	ec57 6b10 	vmov	r6, r7, d0
 800a0f0:	b097      	sub	sp, #92	; 0x5c
 800a0f2:	e9cd 6700 	strd	r6, r7, [sp]
 800a0f6:	6a46      	ldr	r6, [r0, #36]	; 0x24
 800a0f8:	9107      	str	r1, [sp, #28]
 800a0fa:	4604      	mov	r4, r0
 800a0fc:	920a      	str	r2, [sp, #40]	; 0x28
 800a0fe:	930f      	str	r3, [sp, #60]	; 0x3c
 800a100:	9d20      	ldr	r5, [sp, #128]	; 0x80
 800a102:	b93e      	cbnz	r6, 800a114 <_dtoa_r+0x2c>
 800a104:	2010      	movs	r0, #16
 800a106:	f7fd fb1b 	bl	8007740 <malloc>
 800a10a:	6260      	str	r0, [r4, #36]	; 0x24
 800a10c:	6046      	str	r6, [r0, #4]
 800a10e:	6086      	str	r6, [r0, #8]
 800a110:	6006      	str	r6, [r0, #0]
 800a112:	60c6      	str	r6, [r0, #12]
 800a114:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800a116:	6819      	ldr	r1, [r3, #0]
 800a118:	b151      	cbz	r1, 800a130 <_dtoa_r+0x48>
 800a11a:	685a      	ldr	r2, [r3, #4]
 800a11c:	604a      	str	r2, [r1, #4]
 800a11e:	2301      	movs	r3, #1
 800a120:	4093      	lsls	r3, r2
 800a122:	608b      	str	r3, [r1, #8]
 800a124:	4620      	mov	r0, r4
 800a126:	f001 fac1 	bl	800b6ac <_Bfree>
 800a12a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800a12c:	2200      	movs	r2, #0
 800a12e:	601a      	str	r2, [r3, #0]
 800a130:	9b01      	ldr	r3, [sp, #4]
 800a132:	2b00      	cmp	r3, #0
 800a134:	bfbf      	itttt	lt
 800a136:	2301      	movlt	r3, #1
 800a138:	602b      	strlt	r3, [r5, #0]
 800a13a:	9b01      	ldrlt	r3, [sp, #4]
 800a13c:	f023 4300 	biclt.w	r3, r3, #2147483648	; 0x80000000
 800a140:	bfb2      	itee	lt
 800a142:	9301      	strlt	r3, [sp, #4]
 800a144:	2300      	movge	r3, #0
 800a146:	602b      	strge	r3, [r5, #0]
 800a148:	f8dd 8004 	ldr.w	r8, [sp, #4]
 800a14c:	4ba8      	ldr	r3, [pc, #672]	; (800a3f0 <_dtoa_r+0x308>)
 800a14e:	ea33 0308 	bics.w	r3, r3, r8
 800a152:	d11b      	bne.n	800a18c <_dtoa_r+0xa4>
 800a154:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800a156:	f242 730f 	movw	r3, #9999	; 0x270f
 800a15a:	6013      	str	r3, [r2, #0]
 800a15c:	9b00      	ldr	r3, [sp, #0]
 800a15e:	b923      	cbnz	r3, 800a16a <_dtoa_r+0x82>
 800a160:	f3c8 0013 	ubfx	r0, r8, #0, #20
 800a164:	2800      	cmp	r0, #0
 800a166:	f000 8578 	beq.w	800ac5a <_dtoa_r+0xb72>
 800a16a:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800a16c:	b953      	cbnz	r3, 800a184 <_dtoa_r+0x9c>
 800a16e:	4ba1      	ldr	r3, [pc, #644]	; (800a3f4 <_dtoa_r+0x30c>)
 800a170:	e021      	b.n	800a1b6 <_dtoa_r+0xce>
 800a172:	4ba1      	ldr	r3, [pc, #644]	; (800a3f8 <_dtoa_r+0x310>)
 800a174:	9302      	str	r3, [sp, #8]
 800a176:	3308      	adds	r3, #8
 800a178:	9a21      	ldr	r2, [sp, #132]	; 0x84
 800a17a:	6013      	str	r3, [r2, #0]
 800a17c:	9802      	ldr	r0, [sp, #8]
 800a17e:	b017      	add	sp, #92	; 0x5c
 800a180:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800a184:	4b9b      	ldr	r3, [pc, #620]	; (800a3f4 <_dtoa_r+0x30c>)
 800a186:	9302      	str	r3, [sp, #8]
 800a188:	3303      	adds	r3, #3
 800a18a:	e7f5      	b.n	800a178 <_dtoa_r+0x90>
 800a18c:	e9dd 6700 	ldrd	r6, r7, [sp]
 800a190:	2200      	movs	r2, #0
 800a192:	2300      	movs	r3, #0
 800a194:	4630      	mov	r0, r6
 800a196:	4639      	mov	r1, r7
 800a198:	f7f6 fca2 	bl	8000ae0 <__aeabi_dcmpeq>
 800a19c:	4681      	mov	r9, r0
 800a19e:	b160      	cbz	r0, 800a1ba <_dtoa_r+0xd2>
 800a1a0:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800a1a2:	2301      	movs	r3, #1
 800a1a4:	6013      	str	r3, [r2, #0]
 800a1a6:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800a1a8:	2b00      	cmp	r3, #0
 800a1aa:	f000 8553 	beq.w	800ac54 <_dtoa_r+0xb6c>
 800a1ae:	4b93      	ldr	r3, [pc, #588]	; (800a3fc <_dtoa_r+0x314>)
 800a1b0:	9a21      	ldr	r2, [sp, #132]	; 0x84
 800a1b2:	6013      	str	r3, [r2, #0]
 800a1b4:	3b01      	subs	r3, #1
 800a1b6:	9302      	str	r3, [sp, #8]
 800a1b8:	e7e0      	b.n	800a17c <_dtoa_r+0x94>
 800a1ba:	aa14      	add	r2, sp, #80	; 0x50
 800a1bc:	a915      	add	r1, sp, #84	; 0x54
 800a1be:	ec47 6b10 	vmov	d0, r6, r7
 800a1c2:	4620      	mov	r0, r4
 800a1c4:	f001 fcbf 	bl	800bb46 <__d2b>
 800a1c8:	f3c8 550a 	ubfx	r5, r8, #20, #11
 800a1cc:	4682      	mov	sl, r0
 800a1ce:	2d00      	cmp	r5, #0
 800a1d0:	d07e      	beq.n	800a2d0 <_dtoa_r+0x1e8>
 800a1d2:	f3c7 0313 	ubfx	r3, r7, #0, #20
 800a1d6:	f043 517f 	orr.w	r1, r3, #1069547520	; 0x3fc00000
 800a1da:	4630      	mov	r0, r6
 800a1dc:	f441 1140 	orr.w	r1, r1, #3145728	; 0x300000
 800a1e0:	f2a5 35ff 	subw	r5, r5, #1023	; 0x3ff
 800a1e4:	f8cd 9048 	str.w	r9, [sp, #72]	; 0x48
 800a1e8:	2200      	movs	r2, #0
 800a1ea:	4b85      	ldr	r3, [pc, #532]	; (800a400 <_dtoa_r+0x318>)
 800a1ec:	f7f6 f85c 	bl	80002a8 <__aeabi_dsub>
 800a1f0:	a379      	add	r3, pc, #484	; (adr r3, 800a3d8 <_dtoa_r+0x2f0>)
 800a1f2:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a1f6:	f7f6 fa0b 	bl	8000610 <__aeabi_dmul>
 800a1fa:	a379      	add	r3, pc, #484	; (adr r3, 800a3e0 <_dtoa_r+0x2f8>)
 800a1fc:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a200:	f7f6 f854 	bl	80002ac <__adddf3>
 800a204:	4606      	mov	r6, r0
 800a206:	4628      	mov	r0, r5
 800a208:	460f      	mov	r7, r1
 800a20a:	f7f6 f99b 	bl	8000544 <__aeabi_i2d>
 800a20e:	a376      	add	r3, pc, #472	; (adr r3, 800a3e8 <_dtoa_r+0x300>)
 800a210:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a214:	f7f6 f9fc 	bl	8000610 <__aeabi_dmul>
 800a218:	4602      	mov	r2, r0
 800a21a:	460b      	mov	r3, r1
 800a21c:	4630      	mov	r0, r6
 800a21e:	4639      	mov	r1, r7
 800a220:	f7f6 f844 	bl	80002ac <__adddf3>
 800a224:	4606      	mov	r6, r0
 800a226:	460f      	mov	r7, r1
 800a228:	f7f6 fca2 	bl	8000b70 <__aeabi_d2iz>
 800a22c:	2200      	movs	r2, #0
 800a22e:	4683      	mov	fp, r0
 800a230:	2300      	movs	r3, #0
 800a232:	4630      	mov	r0, r6
 800a234:	4639      	mov	r1, r7
 800a236:	f7f6 fc5d 	bl	8000af4 <__aeabi_dcmplt>
 800a23a:	b158      	cbz	r0, 800a254 <_dtoa_r+0x16c>
 800a23c:	4658      	mov	r0, fp
 800a23e:	f7f6 f981 	bl	8000544 <__aeabi_i2d>
 800a242:	4602      	mov	r2, r0
 800a244:	460b      	mov	r3, r1
 800a246:	4630      	mov	r0, r6
 800a248:	4639      	mov	r1, r7
 800a24a:	f7f6 fc49 	bl	8000ae0 <__aeabi_dcmpeq>
 800a24e:	b908      	cbnz	r0, 800a254 <_dtoa_r+0x16c>
 800a250:	f10b 3bff 	add.w	fp, fp, #4294967295
 800a254:	f1bb 0f16 	cmp.w	fp, #22
 800a258:	d859      	bhi.n	800a30e <_dtoa_r+0x226>
 800a25a:	496a      	ldr	r1, [pc, #424]	; (800a404 <_dtoa_r+0x31c>)
 800a25c:	eb01 01cb 	add.w	r1, r1, fp, lsl #3
 800a260:	e9dd 2300 	ldrd	r2, r3, [sp]
 800a264:	e9d1 0100 	ldrd	r0, r1, [r1]
 800a268:	f7f6 fc62 	bl	8000b30 <__aeabi_dcmpgt>
 800a26c:	2800      	cmp	r0, #0
 800a26e:	d050      	beq.n	800a312 <_dtoa_r+0x22a>
 800a270:	f10b 3bff 	add.w	fp, fp, #4294967295
 800a274:	2300      	movs	r3, #0
 800a276:	930e      	str	r3, [sp, #56]	; 0x38
 800a278:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800a27a:	1b5d      	subs	r5, r3, r5
 800a27c:	1e6b      	subs	r3, r5, #1
 800a27e:	9306      	str	r3, [sp, #24]
 800a280:	bf45      	ittet	mi
 800a282:	f1c5 0301 	rsbmi	r3, r5, #1
 800a286:	9305      	strmi	r3, [sp, #20]
 800a288:	2300      	movpl	r3, #0
 800a28a:	2300      	movmi	r3, #0
 800a28c:	bf4c      	ite	mi
 800a28e:	9306      	strmi	r3, [sp, #24]
 800a290:	9305      	strpl	r3, [sp, #20]
 800a292:	f1bb 0f00 	cmp.w	fp, #0
 800a296:	db3e      	blt.n	800a316 <_dtoa_r+0x22e>
 800a298:	9b06      	ldr	r3, [sp, #24]
 800a29a:	f8cd b02c 	str.w	fp, [sp, #44]	; 0x2c
 800a29e:	445b      	add	r3, fp
 800a2a0:	9306      	str	r3, [sp, #24]
 800a2a2:	2300      	movs	r3, #0
 800a2a4:	9308      	str	r3, [sp, #32]
 800a2a6:	9b07      	ldr	r3, [sp, #28]
 800a2a8:	2b09      	cmp	r3, #9
 800a2aa:	f200 80af 	bhi.w	800a40c <_dtoa_r+0x324>
 800a2ae:	2b05      	cmp	r3, #5
 800a2b0:	bfc4      	itt	gt
 800a2b2:	3b04      	subgt	r3, #4
 800a2b4:	9307      	strgt	r3, [sp, #28]
 800a2b6:	9b07      	ldr	r3, [sp, #28]
 800a2b8:	f1a3 0302 	sub.w	r3, r3, #2
 800a2bc:	bfcc      	ite	gt
 800a2be:	2600      	movgt	r6, #0
 800a2c0:	2601      	movle	r6, #1
 800a2c2:	2b03      	cmp	r3, #3
 800a2c4:	f200 80ae 	bhi.w	800a424 <_dtoa_r+0x33c>
 800a2c8:	e8df f003 	tbb	[pc, r3]
 800a2cc:	772f8482 	.word	0x772f8482
 800a2d0:	9b15      	ldr	r3, [sp, #84]	; 0x54
 800a2d2:	9d14      	ldr	r5, [sp, #80]	; 0x50
 800a2d4:	441d      	add	r5, r3
 800a2d6:	f205 4332 	addw	r3, r5, #1074	; 0x432
 800a2da:	2b20      	cmp	r3, #32
 800a2dc:	dd11      	ble.n	800a302 <_dtoa_r+0x21a>
 800a2de:	9a00      	ldr	r2, [sp, #0]
 800a2e0:	f205 4012 	addw	r0, r5, #1042	; 0x412
 800a2e4:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
 800a2e8:	fa22 f000 	lsr.w	r0, r2, r0
 800a2ec:	fa08 f303 	lsl.w	r3, r8, r3
 800a2f0:	4318      	orrs	r0, r3
 800a2f2:	f7f6 f917 	bl	8000524 <__aeabi_ui2d>
 800a2f6:	2301      	movs	r3, #1
 800a2f8:	f1a1 71f8 	sub.w	r1, r1, #32505856	; 0x1f00000
 800a2fc:	3d01      	subs	r5, #1
 800a2fe:	9312      	str	r3, [sp, #72]	; 0x48
 800a300:	e772      	b.n	800a1e8 <_dtoa_r+0x100>
 800a302:	f1c3 0020 	rsb	r0, r3, #32
 800a306:	9b00      	ldr	r3, [sp, #0]
 800a308:	fa03 f000 	lsl.w	r0, r3, r0
 800a30c:	e7f1      	b.n	800a2f2 <_dtoa_r+0x20a>
 800a30e:	2301      	movs	r3, #1
 800a310:	e7b1      	b.n	800a276 <_dtoa_r+0x18e>
 800a312:	900e      	str	r0, [sp, #56]	; 0x38
 800a314:	e7b0      	b.n	800a278 <_dtoa_r+0x190>
 800a316:	9b05      	ldr	r3, [sp, #20]
 800a318:	eba3 030b 	sub.w	r3, r3, fp
 800a31c:	9305      	str	r3, [sp, #20]
 800a31e:	f1cb 0300 	rsb	r3, fp, #0
 800a322:	9308      	str	r3, [sp, #32]
 800a324:	2300      	movs	r3, #0
 800a326:	930b      	str	r3, [sp, #44]	; 0x2c
 800a328:	e7bd      	b.n	800a2a6 <_dtoa_r+0x1be>
 800a32a:	2301      	movs	r3, #1
 800a32c:	9309      	str	r3, [sp, #36]	; 0x24
 800a32e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800a330:	2b00      	cmp	r3, #0
 800a332:	dd7a      	ble.n	800a42a <_dtoa_r+0x342>
 800a334:	9304      	str	r3, [sp, #16]
 800a336:	9303      	str	r3, [sp, #12]
 800a338:	6a65      	ldr	r5, [r4, #36]	; 0x24
 800a33a:	2200      	movs	r2, #0
 800a33c:	606a      	str	r2, [r5, #4]
 800a33e:	2104      	movs	r1, #4
 800a340:	f101 0214 	add.w	r2, r1, #20
 800a344:	429a      	cmp	r2, r3
 800a346:	d975      	bls.n	800a434 <_dtoa_r+0x34c>
 800a348:	6869      	ldr	r1, [r5, #4]
 800a34a:	4620      	mov	r0, r4
 800a34c:	f001 f97a 	bl	800b644 <_Balloc>
 800a350:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800a352:	6028      	str	r0, [r5, #0]
 800a354:	681b      	ldr	r3, [r3, #0]
 800a356:	9302      	str	r3, [sp, #8]
 800a358:	9b03      	ldr	r3, [sp, #12]
 800a35a:	2b0e      	cmp	r3, #14
 800a35c:	f200 80e5 	bhi.w	800a52a <_dtoa_r+0x442>
 800a360:	2e00      	cmp	r6, #0
 800a362:	f000 80e2 	beq.w	800a52a <_dtoa_r+0x442>
 800a366:	ed9d 7b00 	vldr	d7, [sp]
 800a36a:	f1bb 0f00 	cmp.w	fp, #0
 800a36e:	ed8d 7b0c 	vstr	d7, [sp, #48]	; 0x30
 800a372:	dd74      	ble.n	800a45e <_dtoa_r+0x376>
 800a374:	4a23      	ldr	r2, [pc, #140]	; (800a404 <_dtoa_r+0x31c>)
 800a376:	f00b 030f 	and.w	r3, fp, #15
 800a37a:	ea4f 162b 	mov.w	r6, fp, asr #4
 800a37e:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 800a382:	06f0      	lsls	r0, r6, #27
 800a384:	e9d3 8900 	ldrd	r8, r9, [r3]
 800a388:	d559      	bpl.n	800a43e <_dtoa_r+0x356>
 800a38a:	4b1f      	ldr	r3, [pc, #124]	; (800a408 <_dtoa_r+0x320>)
 800a38c:	ec51 0b17 	vmov	r0, r1, d7
 800a390:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 800a394:	f7f6 fa66 	bl	8000864 <__aeabi_ddiv>
 800a398:	e9cd 0100 	strd	r0, r1, [sp]
 800a39c:	f006 060f 	and.w	r6, r6, #15
 800a3a0:	2503      	movs	r5, #3
 800a3a2:	4f19      	ldr	r7, [pc, #100]	; (800a408 <_dtoa_r+0x320>)
 800a3a4:	2e00      	cmp	r6, #0
 800a3a6:	d14c      	bne.n	800a442 <_dtoa_r+0x35a>
 800a3a8:	4642      	mov	r2, r8
 800a3aa:	464b      	mov	r3, r9
 800a3ac:	e9dd 0100 	ldrd	r0, r1, [sp]
 800a3b0:	f7f6 fa58 	bl	8000864 <__aeabi_ddiv>
 800a3b4:	e9cd 0100 	strd	r0, r1, [sp]
 800a3b8:	e06a      	b.n	800a490 <_dtoa_r+0x3a8>
 800a3ba:	2301      	movs	r3, #1
 800a3bc:	9309      	str	r3, [sp, #36]	; 0x24
 800a3be:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800a3c0:	445b      	add	r3, fp
 800a3c2:	9304      	str	r3, [sp, #16]
 800a3c4:	3301      	adds	r3, #1
 800a3c6:	2b01      	cmp	r3, #1
 800a3c8:	9303      	str	r3, [sp, #12]
 800a3ca:	bfb8      	it	lt
 800a3cc:	2301      	movlt	r3, #1
 800a3ce:	e7b3      	b.n	800a338 <_dtoa_r+0x250>
 800a3d0:	2300      	movs	r3, #0
 800a3d2:	e7ab      	b.n	800a32c <_dtoa_r+0x244>
 800a3d4:	2300      	movs	r3, #0
 800a3d6:	e7f1      	b.n	800a3bc <_dtoa_r+0x2d4>
 800a3d8:	636f4361 	.word	0x636f4361
 800a3dc:	3fd287a7 	.word	0x3fd287a7
 800a3e0:	8b60c8b3 	.word	0x8b60c8b3
 800a3e4:	3fc68a28 	.word	0x3fc68a28
 800a3e8:	509f79fb 	.word	0x509f79fb
 800a3ec:	3fd34413 	.word	0x3fd34413
 800a3f0:	7ff00000 	.word	0x7ff00000
 800a3f4:	0800d269 	.word	0x0800d269
 800a3f8:	0800d260 	.word	0x0800d260
 800a3fc:	0800d21f 	.word	0x0800d21f
 800a400:	3ff80000 	.word	0x3ff80000
 800a404:	0800d300 	.word	0x0800d300
 800a408:	0800d2d8 	.word	0x0800d2d8
 800a40c:	2601      	movs	r6, #1
 800a40e:	2300      	movs	r3, #0
 800a410:	9307      	str	r3, [sp, #28]
 800a412:	9609      	str	r6, [sp, #36]	; 0x24
 800a414:	f04f 33ff 	mov.w	r3, #4294967295
 800a418:	9304      	str	r3, [sp, #16]
 800a41a:	9303      	str	r3, [sp, #12]
 800a41c:	2200      	movs	r2, #0
 800a41e:	2312      	movs	r3, #18
 800a420:	920a      	str	r2, [sp, #40]	; 0x28
 800a422:	e789      	b.n	800a338 <_dtoa_r+0x250>
 800a424:	2301      	movs	r3, #1
 800a426:	9309      	str	r3, [sp, #36]	; 0x24
 800a428:	e7f4      	b.n	800a414 <_dtoa_r+0x32c>
 800a42a:	2301      	movs	r3, #1
 800a42c:	9304      	str	r3, [sp, #16]
 800a42e:	9303      	str	r3, [sp, #12]
 800a430:	461a      	mov	r2, r3
 800a432:	e7f5      	b.n	800a420 <_dtoa_r+0x338>
 800a434:	686a      	ldr	r2, [r5, #4]
 800a436:	3201      	adds	r2, #1
 800a438:	606a      	str	r2, [r5, #4]
 800a43a:	0049      	lsls	r1, r1, #1
 800a43c:	e780      	b.n	800a340 <_dtoa_r+0x258>
 800a43e:	2502      	movs	r5, #2
 800a440:	e7af      	b.n	800a3a2 <_dtoa_r+0x2ba>
 800a442:	07f1      	lsls	r1, r6, #31
 800a444:	d508      	bpl.n	800a458 <_dtoa_r+0x370>
 800a446:	4640      	mov	r0, r8
 800a448:	4649      	mov	r1, r9
 800a44a:	e9d7 2300 	ldrd	r2, r3, [r7]
 800a44e:	f7f6 f8df 	bl	8000610 <__aeabi_dmul>
 800a452:	3501      	adds	r5, #1
 800a454:	4680      	mov	r8, r0
 800a456:	4689      	mov	r9, r1
 800a458:	1076      	asrs	r6, r6, #1
 800a45a:	3708      	adds	r7, #8
 800a45c:	e7a2      	b.n	800a3a4 <_dtoa_r+0x2bc>
 800a45e:	f000 809d 	beq.w	800a59c <_dtoa_r+0x4b4>
 800a462:	f1cb 0600 	rsb	r6, fp, #0
 800a466:	4b9f      	ldr	r3, [pc, #636]	; (800a6e4 <_dtoa_r+0x5fc>)
 800a468:	4f9f      	ldr	r7, [pc, #636]	; (800a6e8 <_dtoa_r+0x600>)
 800a46a:	f006 020f 	and.w	r2, r6, #15
 800a46e:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800a472:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a476:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 800a47a:	f7f6 f8c9 	bl	8000610 <__aeabi_dmul>
 800a47e:	e9cd 0100 	strd	r0, r1, [sp]
 800a482:	1136      	asrs	r6, r6, #4
 800a484:	2300      	movs	r3, #0
 800a486:	2502      	movs	r5, #2
 800a488:	2e00      	cmp	r6, #0
 800a48a:	d17c      	bne.n	800a586 <_dtoa_r+0x49e>
 800a48c:	2b00      	cmp	r3, #0
 800a48e:	d191      	bne.n	800a3b4 <_dtoa_r+0x2cc>
 800a490:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800a492:	2b00      	cmp	r3, #0
 800a494:	f000 8084 	beq.w	800a5a0 <_dtoa_r+0x4b8>
 800a498:	e9dd 8900 	ldrd	r8, r9, [sp]
 800a49c:	2200      	movs	r2, #0
 800a49e:	4b93      	ldr	r3, [pc, #588]	; (800a6ec <_dtoa_r+0x604>)
 800a4a0:	4640      	mov	r0, r8
 800a4a2:	4649      	mov	r1, r9
 800a4a4:	f7f6 fb26 	bl	8000af4 <__aeabi_dcmplt>
 800a4a8:	2800      	cmp	r0, #0
 800a4aa:	d079      	beq.n	800a5a0 <_dtoa_r+0x4b8>
 800a4ac:	9b03      	ldr	r3, [sp, #12]
 800a4ae:	2b00      	cmp	r3, #0
 800a4b0:	d076      	beq.n	800a5a0 <_dtoa_r+0x4b8>
 800a4b2:	9b04      	ldr	r3, [sp, #16]
 800a4b4:	2b00      	cmp	r3, #0
 800a4b6:	dd34      	ble.n	800a522 <_dtoa_r+0x43a>
 800a4b8:	2200      	movs	r2, #0
 800a4ba:	4b8d      	ldr	r3, [pc, #564]	; (800a6f0 <_dtoa_r+0x608>)
 800a4bc:	4640      	mov	r0, r8
 800a4be:	4649      	mov	r1, r9
 800a4c0:	f7f6 f8a6 	bl	8000610 <__aeabi_dmul>
 800a4c4:	e9cd 0100 	strd	r0, r1, [sp]
 800a4c8:	9e04      	ldr	r6, [sp, #16]
 800a4ca:	f10b 37ff 	add.w	r7, fp, #4294967295
 800a4ce:	3501      	adds	r5, #1
 800a4d0:	4628      	mov	r0, r5
 800a4d2:	f7f6 f837 	bl	8000544 <__aeabi_i2d>
 800a4d6:	e9dd 2300 	ldrd	r2, r3, [sp]
 800a4da:	f7f6 f899 	bl	8000610 <__aeabi_dmul>
 800a4de:	2200      	movs	r2, #0
 800a4e0:	4b84      	ldr	r3, [pc, #528]	; (800a6f4 <_dtoa_r+0x60c>)
 800a4e2:	f7f5 fee3 	bl	80002ac <__adddf3>
 800a4e6:	4680      	mov	r8, r0
 800a4e8:	f1a1 7950 	sub.w	r9, r1, #54525952	; 0x3400000
 800a4ec:	2e00      	cmp	r6, #0
 800a4ee:	d15a      	bne.n	800a5a6 <_dtoa_r+0x4be>
 800a4f0:	2200      	movs	r2, #0
 800a4f2:	4b81      	ldr	r3, [pc, #516]	; (800a6f8 <_dtoa_r+0x610>)
 800a4f4:	e9dd 0100 	ldrd	r0, r1, [sp]
 800a4f8:	f7f5 fed6 	bl	80002a8 <__aeabi_dsub>
 800a4fc:	4642      	mov	r2, r8
 800a4fe:	464b      	mov	r3, r9
 800a500:	e9cd 0100 	strd	r0, r1, [sp]
 800a504:	f7f6 fb14 	bl	8000b30 <__aeabi_dcmpgt>
 800a508:	2800      	cmp	r0, #0
 800a50a:	f040 829b 	bne.w	800aa44 <_dtoa_r+0x95c>
 800a50e:	4642      	mov	r2, r8
 800a510:	f109 4300 	add.w	r3, r9, #2147483648	; 0x80000000
 800a514:	e9dd 0100 	ldrd	r0, r1, [sp]
 800a518:	f7f6 faec 	bl	8000af4 <__aeabi_dcmplt>
 800a51c:	2800      	cmp	r0, #0
 800a51e:	f040 828f 	bne.w	800aa40 <_dtoa_r+0x958>
 800a522:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
 800a526:	e9cd 2300 	strd	r2, r3, [sp]
 800a52a:	9b15      	ldr	r3, [sp, #84]	; 0x54
 800a52c:	2b00      	cmp	r3, #0
 800a52e:	f2c0 8150 	blt.w	800a7d2 <_dtoa_r+0x6ea>
 800a532:	f1bb 0f0e 	cmp.w	fp, #14
 800a536:	f300 814c 	bgt.w	800a7d2 <_dtoa_r+0x6ea>
 800a53a:	4b6a      	ldr	r3, [pc, #424]	; (800a6e4 <_dtoa_r+0x5fc>)
 800a53c:	eb03 03cb 	add.w	r3, r3, fp, lsl #3
 800a540:	e9d3 8900 	ldrd	r8, r9, [r3]
 800a544:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800a546:	2b00      	cmp	r3, #0
 800a548:	f280 80da 	bge.w	800a700 <_dtoa_r+0x618>
 800a54c:	9b03      	ldr	r3, [sp, #12]
 800a54e:	2b00      	cmp	r3, #0
 800a550:	f300 80d6 	bgt.w	800a700 <_dtoa_r+0x618>
 800a554:	f040 8273 	bne.w	800aa3e <_dtoa_r+0x956>
 800a558:	2200      	movs	r2, #0
 800a55a:	4b67      	ldr	r3, [pc, #412]	; (800a6f8 <_dtoa_r+0x610>)
 800a55c:	4640      	mov	r0, r8
 800a55e:	4649      	mov	r1, r9
 800a560:	f7f6 f856 	bl	8000610 <__aeabi_dmul>
 800a564:	e9dd 2300 	ldrd	r2, r3, [sp]
 800a568:	f7f6 fad8 	bl	8000b1c <__aeabi_dcmpge>
 800a56c:	9e03      	ldr	r6, [sp, #12]
 800a56e:	4637      	mov	r7, r6
 800a570:	2800      	cmp	r0, #0
 800a572:	f040 824a 	bne.w	800aa0a <_dtoa_r+0x922>
 800a576:	9b02      	ldr	r3, [sp, #8]
 800a578:	9a02      	ldr	r2, [sp, #8]
 800a57a:	1c5d      	adds	r5, r3, #1
 800a57c:	2331      	movs	r3, #49	; 0x31
 800a57e:	7013      	strb	r3, [r2, #0]
 800a580:	f10b 0b01 	add.w	fp, fp, #1
 800a584:	e245      	b.n	800aa12 <_dtoa_r+0x92a>
 800a586:	07f2      	lsls	r2, r6, #31
 800a588:	d505      	bpl.n	800a596 <_dtoa_r+0x4ae>
 800a58a:	e9d7 2300 	ldrd	r2, r3, [r7]
 800a58e:	f7f6 f83f 	bl	8000610 <__aeabi_dmul>
 800a592:	3501      	adds	r5, #1
 800a594:	2301      	movs	r3, #1
 800a596:	1076      	asrs	r6, r6, #1
 800a598:	3708      	adds	r7, #8
 800a59a:	e775      	b.n	800a488 <_dtoa_r+0x3a0>
 800a59c:	2502      	movs	r5, #2
 800a59e:	e777      	b.n	800a490 <_dtoa_r+0x3a8>
 800a5a0:	465f      	mov	r7, fp
 800a5a2:	9e03      	ldr	r6, [sp, #12]
 800a5a4:	e794      	b.n	800a4d0 <_dtoa_r+0x3e8>
 800a5a6:	9a02      	ldr	r2, [sp, #8]
 800a5a8:	4b4e      	ldr	r3, [pc, #312]	; (800a6e4 <_dtoa_r+0x5fc>)
 800a5aa:	4432      	add	r2, r6
 800a5ac:	9213      	str	r2, [sp, #76]	; 0x4c
 800a5ae:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800a5b0:	1e71      	subs	r1, r6, #1
 800a5b2:	2a00      	cmp	r2, #0
 800a5b4:	d048      	beq.n	800a648 <_dtoa_r+0x560>
 800a5b6:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
 800a5ba:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a5be:	2000      	movs	r0, #0
 800a5c0:	494e      	ldr	r1, [pc, #312]	; (800a6fc <_dtoa_r+0x614>)
 800a5c2:	f7f6 f94f 	bl	8000864 <__aeabi_ddiv>
 800a5c6:	4642      	mov	r2, r8
 800a5c8:	464b      	mov	r3, r9
 800a5ca:	f7f5 fe6d 	bl	80002a8 <__aeabi_dsub>
 800a5ce:	9d02      	ldr	r5, [sp, #8]
 800a5d0:	4680      	mov	r8, r0
 800a5d2:	4689      	mov	r9, r1
 800a5d4:	e9dd 0100 	ldrd	r0, r1, [sp]
 800a5d8:	f7f6 faca 	bl	8000b70 <__aeabi_d2iz>
 800a5dc:	4606      	mov	r6, r0
 800a5de:	f7f5 ffb1 	bl	8000544 <__aeabi_i2d>
 800a5e2:	4602      	mov	r2, r0
 800a5e4:	460b      	mov	r3, r1
 800a5e6:	e9dd 0100 	ldrd	r0, r1, [sp]
 800a5ea:	f7f5 fe5d 	bl	80002a8 <__aeabi_dsub>
 800a5ee:	3630      	adds	r6, #48	; 0x30
 800a5f0:	f805 6b01 	strb.w	r6, [r5], #1
 800a5f4:	4642      	mov	r2, r8
 800a5f6:	464b      	mov	r3, r9
 800a5f8:	e9cd 0100 	strd	r0, r1, [sp]
 800a5fc:	f7f6 fa7a 	bl	8000af4 <__aeabi_dcmplt>
 800a600:	2800      	cmp	r0, #0
 800a602:	d165      	bne.n	800a6d0 <_dtoa_r+0x5e8>
 800a604:	e9dd 2300 	ldrd	r2, r3, [sp]
 800a608:	2000      	movs	r0, #0
 800a60a:	4938      	ldr	r1, [pc, #224]	; (800a6ec <_dtoa_r+0x604>)
 800a60c:	f7f5 fe4c 	bl	80002a8 <__aeabi_dsub>
 800a610:	4642      	mov	r2, r8
 800a612:	464b      	mov	r3, r9
 800a614:	f7f6 fa6e 	bl	8000af4 <__aeabi_dcmplt>
 800a618:	2800      	cmp	r0, #0
 800a61a:	f040 80ba 	bne.w	800a792 <_dtoa_r+0x6aa>
 800a61e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800a620:	429d      	cmp	r5, r3
 800a622:	f43f af7e 	beq.w	800a522 <_dtoa_r+0x43a>
 800a626:	2200      	movs	r2, #0
 800a628:	4b31      	ldr	r3, [pc, #196]	; (800a6f0 <_dtoa_r+0x608>)
 800a62a:	4640      	mov	r0, r8
 800a62c:	4649      	mov	r1, r9
 800a62e:	f7f5 ffef 	bl	8000610 <__aeabi_dmul>
 800a632:	2200      	movs	r2, #0
 800a634:	4680      	mov	r8, r0
 800a636:	4689      	mov	r9, r1
 800a638:	4b2d      	ldr	r3, [pc, #180]	; (800a6f0 <_dtoa_r+0x608>)
 800a63a:	e9dd 0100 	ldrd	r0, r1, [sp]
 800a63e:	f7f5 ffe7 	bl	8000610 <__aeabi_dmul>
 800a642:	e9cd 0100 	strd	r0, r1, [sp]
 800a646:	e7c5      	b.n	800a5d4 <_dtoa_r+0x4ec>
 800a648:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
 800a64c:	4642      	mov	r2, r8
 800a64e:	464b      	mov	r3, r9
 800a650:	e9d1 0100 	ldrd	r0, r1, [r1]
 800a654:	f7f5 ffdc 	bl	8000610 <__aeabi_dmul>
 800a658:	e9cd 0110 	strd	r0, r1, [sp, #64]	; 0x40
 800a65c:	9d02      	ldr	r5, [sp, #8]
 800a65e:	e9dd 0100 	ldrd	r0, r1, [sp]
 800a662:	f7f6 fa85 	bl	8000b70 <__aeabi_d2iz>
 800a666:	4606      	mov	r6, r0
 800a668:	f7f5 ff6c 	bl	8000544 <__aeabi_i2d>
 800a66c:	3630      	adds	r6, #48	; 0x30
 800a66e:	4602      	mov	r2, r0
 800a670:	460b      	mov	r3, r1
 800a672:	e9dd 0100 	ldrd	r0, r1, [sp]
 800a676:	f7f5 fe17 	bl	80002a8 <__aeabi_dsub>
 800a67a:	f805 6b01 	strb.w	r6, [r5], #1
 800a67e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800a680:	42ab      	cmp	r3, r5
 800a682:	4680      	mov	r8, r0
 800a684:	4689      	mov	r9, r1
 800a686:	f04f 0200 	mov.w	r2, #0
 800a68a:	d125      	bne.n	800a6d8 <_dtoa_r+0x5f0>
 800a68c:	4b1b      	ldr	r3, [pc, #108]	; (800a6fc <_dtoa_r+0x614>)
 800a68e:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
 800a692:	f7f5 fe0b 	bl	80002ac <__adddf3>
 800a696:	4602      	mov	r2, r0
 800a698:	460b      	mov	r3, r1
 800a69a:	4640      	mov	r0, r8
 800a69c:	4649      	mov	r1, r9
 800a69e:	f7f6 fa47 	bl	8000b30 <__aeabi_dcmpgt>
 800a6a2:	2800      	cmp	r0, #0
 800a6a4:	d175      	bne.n	800a792 <_dtoa_r+0x6aa>
 800a6a6:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	; 0x40
 800a6aa:	2000      	movs	r0, #0
 800a6ac:	4913      	ldr	r1, [pc, #76]	; (800a6fc <_dtoa_r+0x614>)
 800a6ae:	f7f5 fdfb 	bl	80002a8 <__aeabi_dsub>
 800a6b2:	4602      	mov	r2, r0
 800a6b4:	460b      	mov	r3, r1
 800a6b6:	4640      	mov	r0, r8
 800a6b8:	4649      	mov	r1, r9
 800a6ba:	f7f6 fa1b 	bl	8000af4 <__aeabi_dcmplt>
 800a6be:	2800      	cmp	r0, #0
 800a6c0:	f43f af2f 	beq.w	800a522 <_dtoa_r+0x43a>
 800a6c4:	f815 3c01 	ldrb.w	r3, [r5, #-1]
 800a6c8:	2b30      	cmp	r3, #48	; 0x30
 800a6ca:	f105 32ff 	add.w	r2, r5, #4294967295
 800a6ce:	d001      	beq.n	800a6d4 <_dtoa_r+0x5ec>
 800a6d0:	46bb      	mov	fp, r7
 800a6d2:	e04d      	b.n	800a770 <_dtoa_r+0x688>
 800a6d4:	4615      	mov	r5, r2
 800a6d6:	e7f5      	b.n	800a6c4 <_dtoa_r+0x5dc>
 800a6d8:	4b05      	ldr	r3, [pc, #20]	; (800a6f0 <_dtoa_r+0x608>)
 800a6da:	f7f5 ff99 	bl	8000610 <__aeabi_dmul>
 800a6de:	e9cd 0100 	strd	r0, r1, [sp]
 800a6e2:	e7bc      	b.n	800a65e <_dtoa_r+0x576>
 800a6e4:	0800d300 	.word	0x0800d300
 800a6e8:	0800d2d8 	.word	0x0800d2d8
 800a6ec:	3ff00000 	.word	0x3ff00000
 800a6f0:	40240000 	.word	0x40240000
 800a6f4:	401c0000 	.word	0x401c0000
 800a6f8:	40140000 	.word	0x40140000
 800a6fc:	3fe00000 	.word	0x3fe00000
 800a700:	e9dd 6700 	ldrd	r6, r7, [sp]
 800a704:	9d02      	ldr	r5, [sp, #8]
 800a706:	4642      	mov	r2, r8
 800a708:	464b      	mov	r3, r9
 800a70a:	4630      	mov	r0, r6
 800a70c:	4639      	mov	r1, r7
 800a70e:	f7f6 f8a9 	bl	8000864 <__aeabi_ddiv>
 800a712:	f7f6 fa2d 	bl	8000b70 <__aeabi_d2iz>
 800a716:	9000      	str	r0, [sp, #0]
 800a718:	f7f5 ff14 	bl	8000544 <__aeabi_i2d>
 800a71c:	4642      	mov	r2, r8
 800a71e:	464b      	mov	r3, r9
 800a720:	f7f5 ff76 	bl	8000610 <__aeabi_dmul>
 800a724:	4602      	mov	r2, r0
 800a726:	460b      	mov	r3, r1
 800a728:	4630      	mov	r0, r6
 800a72a:	4639      	mov	r1, r7
 800a72c:	f7f5 fdbc 	bl	80002a8 <__aeabi_dsub>
 800a730:	9e00      	ldr	r6, [sp, #0]
 800a732:	9f03      	ldr	r7, [sp, #12]
 800a734:	3630      	adds	r6, #48	; 0x30
 800a736:	f805 6b01 	strb.w	r6, [r5], #1
 800a73a:	9e02      	ldr	r6, [sp, #8]
 800a73c:	1bae      	subs	r6, r5, r6
 800a73e:	42b7      	cmp	r7, r6
 800a740:	4602      	mov	r2, r0
 800a742:	460b      	mov	r3, r1
 800a744:	d138      	bne.n	800a7b8 <_dtoa_r+0x6d0>
 800a746:	f7f5 fdb1 	bl	80002ac <__adddf3>
 800a74a:	4606      	mov	r6, r0
 800a74c:	460f      	mov	r7, r1
 800a74e:	4602      	mov	r2, r0
 800a750:	460b      	mov	r3, r1
 800a752:	4640      	mov	r0, r8
 800a754:	4649      	mov	r1, r9
 800a756:	f7f6 f9cd 	bl	8000af4 <__aeabi_dcmplt>
 800a75a:	b9c8      	cbnz	r0, 800a790 <_dtoa_r+0x6a8>
 800a75c:	4632      	mov	r2, r6
 800a75e:	463b      	mov	r3, r7
 800a760:	4640      	mov	r0, r8
 800a762:	4649      	mov	r1, r9
 800a764:	f7f6 f9bc 	bl	8000ae0 <__aeabi_dcmpeq>
 800a768:	b110      	cbz	r0, 800a770 <_dtoa_r+0x688>
 800a76a:	9b00      	ldr	r3, [sp, #0]
 800a76c:	07db      	lsls	r3, r3, #31
 800a76e:	d40f      	bmi.n	800a790 <_dtoa_r+0x6a8>
 800a770:	4651      	mov	r1, sl
 800a772:	4620      	mov	r0, r4
 800a774:	f000 ff9a 	bl	800b6ac <_Bfree>
 800a778:	2300      	movs	r3, #0
 800a77a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800a77c:	702b      	strb	r3, [r5, #0]
 800a77e:	f10b 0301 	add.w	r3, fp, #1
 800a782:	6013      	str	r3, [r2, #0]
 800a784:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800a786:	2b00      	cmp	r3, #0
 800a788:	f43f acf8 	beq.w	800a17c <_dtoa_r+0x94>
 800a78c:	601d      	str	r5, [r3, #0]
 800a78e:	e4f5      	b.n	800a17c <_dtoa_r+0x94>
 800a790:	465f      	mov	r7, fp
 800a792:	f815 2c01 	ldrb.w	r2, [r5, #-1]
 800a796:	2a39      	cmp	r2, #57	; 0x39
 800a798:	f105 33ff 	add.w	r3, r5, #4294967295
 800a79c:	d106      	bne.n	800a7ac <_dtoa_r+0x6c4>
 800a79e:	9a02      	ldr	r2, [sp, #8]
 800a7a0:	429a      	cmp	r2, r3
 800a7a2:	d107      	bne.n	800a7b4 <_dtoa_r+0x6cc>
 800a7a4:	2330      	movs	r3, #48	; 0x30
 800a7a6:	7013      	strb	r3, [r2, #0]
 800a7a8:	3701      	adds	r7, #1
 800a7aa:	4613      	mov	r3, r2
 800a7ac:	781a      	ldrb	r2, [r3, #0]
 800a7ae:	3201      	adds	r2, #1
 800a7b0:	701a      	strb	r2, [r3, #0]
 800a7b2:	e78d      	b.n	800a6d0 <_dtoa_r+0x5e8>
 800a7b4:	461d      	mov	r5, r3
 800a7b6:	e7ec      	b.n	800a792 <_dtoa_r+0x6aa>
 800a7b8:	2200      	movs	r2, #0
 800a7ba:	4ba4      	ldr	r3, [pc, #656]	; (800aa4c <_dtoa_r+0x964>)
 800a7bc:	f7f5 ff28 	bl	8000610 <__aeabi_dmul>
 800a7c0:	2200      	movs	r2, #0
 800a7c2:	2300      	movs	r3, #0
 800a7c4:	4606      	mov	r6, r0
 800a7c6:	460f      	mov	r7, r1
 800a7c8:	f7f6 f98a 	bl	8000ae0 <__aeabi_dcmpeq>
 800a7cc:	2800      	cmp	r0, #0
 800a7ce:	d09a      	beq.n	800a706 <_dtoa_r+0x61e>
 800a7d0:	e7ce      	b.n	800a770 <_dtoa_r+0x688>
 800a7d2:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800a7d4:	2a00      	cmp	r2, #0
 800a7d6:	f000 80cd 	beq.w	800a974 <_dtoa_r+0x88c>
 800a7da:	9a07      	ldr	r2, [sp, #28]
 800a7dc:	2a01      	cmp	r2, #1
 800a7de:	f300 80af 	bgt.w	800a940 <_dtoa_r+0x858>
 800a7e2:	9a12      	ldr	r2, [sp, #72]	; 0x48
 800a7e4:	2a00      	cmp	r2, #0
 800a7e6:	f000 80a7 	beq.w	800a938 <_dtoa_r+0x850>
 800a7ea:	f203 4333 	addw	r3, r3, #1075	; 0x433
 800a7ee:	9e08      	ldr	r6, [sp, #32]
 800a7f0:	9d05      	ldr	r5, [sp, #20]
 800a7f2:	9a05      	ldr	r2, [sp, #20]
 800a7f4:	441a      	add	r2, r3
 800a7f6:	9205      	str	r2, [sp, #20]
 800a7f8:	9a06      	ldr	r2, [sp, #24]
 800a7fa:	2101      	movs	r1, #1
 800a7fc:	441a      	add	r2, r3
 800a7fe:	4620      	mov	r0, r4
 800a800:	9206      	str	r2, [sp, #24]
 800a802:	f000 fff3 	bl	800b7ec <__i2b>
 800a806:	4607      	mov	r7, r0
 800a808:	2d00      	cmp	r5, #0
 800a80a:	dd0c      	ble.n	800a826 <_dtoa_r+0x73e>
 800a80c:	9b06      	ldr	r3, [sp, #24]
 800a80e:	2b00      	cmp	r3, #0
 800a810:	dd09      	ble.n	800a826 <_dtoa_r+0x73e>
 800a812:	42ab      	cmp	r3, r5
 800a814:	9a05      	ldr	r2, [sp, #20]
 800a816:	bfa8      	it	ge
 800a818:	462b      	movge	r3, r5
 800a81a:	1ad2      	subs	r2, r2, r3
 800a81c:	9205      	str	r2, [sp, #20]
 800a81e:	9a06      	ldr	r2, [sp, #24]
 800a820:	1aed      	subs	r5, r5, r3
 800a822:	1ad3      	subs	r3, r2, r3
 800a824:	9306      	str	r3, [sp, #24]
 800a826:	9b08      	ldr	r3, [sp, #32]
 800a828:	b1f3      	cbz	r3, 800a868 <_dtoa_r+0x780>
 800a82a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800a82c:	2b00      	cmp	r3, #0
 800a82e:	f000 80a5 	beq.w	800a97c <_dtoa_r+0x894>
 800a832:	2e00      	cmp	r6, #0
 800a834:	dd10      	ble.n	800a858 <_dtoa_r+0x770>
 800a836:	4639      	mov	r1, r7
 800a838:	4632      	mov	r2, r6
 800a83a:	4620      	mov	r0, r4
 800a83c:	f001 f86c 	bl	800b918 <__pow5mult>
 800a840:	4652      	mov	r2, sl
 800a842:	4601      	mov	r1, r0
 800a844:	4607      	mov	r7, r0
 800a846:	4620      	mov	r0, r4
 800a848:	f000 ffd9 	bl	800b7fe <__multiply>
 800a84c:	4651      	mov	r1, sl
 800a84e:	4680      	mov	r8, r0
 800a850:	4620      	mov	r0, r4
 800a852:	f000 ff2b 	bl	800b6ac <_Bfree>
 800a856:	46c2      	mov	sl, r8
 800a858:	9b08      	ldr	r3, [sp, #32]
 800a85a:	1b9a      	subs	r2, r3, r6
 800a85c:	d004      	beq.n	800a868 <_dtoa_r+0x780>
 800a85e:	4651      	mov	r1, sl
 800a860:	4620      	mov	r0, r4
 800a862:	f001 f859 	bl	800b918 <__pow5mult>
 800a866:	4682      	mov	sl, r0
 800a868:	2101      	movs	r1, #1
 800a86a:	4620      	mov	r0, r4
 800a86c:	f000 ffbe 	bl	800b7ec <__i2b>
 800a870:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800a872:	2b00      	cmp	r3, #0
 800a874:	4606      	mov	r6, r0
 800a876:	f340 8083 	ble.w	800a980 <_dtoa_r+0x898>
 800a87a:	461a      	mov	r2, r3
 800a87c:	4601      	mov	r1, r0
 800a87e:	4620      	mov	r0, r4
 800a880:	f001 f84a 	bl	800b918 <__pow5mult>
 800a884:	9b07      	ldr	r3, [sp, #28]
 800a886:	2b01      	cmp	r3, #1
 800a888:	4606      	mov	r6, r0
 800a88a:	dd7c      	ble.n	800a986 <_dtoa_r+0x89e>
 800a88c:	f04f 0800 	mov.w	r8, #0
 800a890:	6933      	ldr	r3, [r6, #16]
 800a892:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 800a896:	6918      	ldr	r0, [r3, #16]
 800a898:	f000 ff5a 	bl	800b750 <__hi0bits>
 800a89c:	f1c0 0020 	rsb	r0, r0, #32
 800a8a0:	9b06      	ldr	r3, [sp, #24]
 800a8a2:	4418      	add	r0, r3
 800a8a4:	f010 001f 	ands.w	r0, r0, #31
 800a8a8:	f000 8096 	beq.w	800a9d8 <_dtoa_r+0x8f0>
 800a8ac:	f1c0 0320 	rsb	r3, r0, #32
 800a8b0:	2b04      	cmp	r3, #4
 800a8b2:	f340 8087 	ble.w	800a9c4 <_dtoa_r+0x8dc>
 800a8b6:	9b05      	ldr	r3, [sp, #20]
 800a8b8:	f1c0 001c 	rsb	r0, r0, #28
 800a8bc:	4403      	add	r3, r0
 800a8be:	9305      	str	r3, [sp, #20]
 800a8c0:	9b06      	ldr	r3, [sp, #24]
 800a8c2:	4405      	add	r5, r0
 800a8c4:	4403      	add	r3, r0
 800a8c6:	9306      	str	r3, [sp, #24]
 800a8c8:	9b05      	ldr	r3, [sp, #20]
 800a8ca:	2b00      	cmp	r3, #0
 800a8cc:	dd05      	ble.n	800a8da <_dtoa_r+0x7f2>
 800a8ce:	4651      	mov	r1, sl
 800a8d0:	461a      	mov	r2, r3
 800a8d2:	4620      	mov	r0, r4
 800a8d4:	f001 f86e 	bl	800b9b4 <__lshift>
 800a8d8:	4682      	mov	sl, r0
 800a8da:	9b06      	ldr	r3, [sp, #24]
 800a8dc:	2b00      	cmp	r3, #0
 800a8de:	dd05      	ble.n	800a8ec <_dtoa_r+0x804>
 800a8e0:	4631      	mov	r1, r6
 800a8e2:	461a      	mov	r2, r3
 800a8e4:	4620      	mov	r0, r4
 800a8e6:	f001 f865 	bl	800b9b4 <__lshift>
 800a8ea:	4606      	mov	r6, r0
 800a8ec:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800a8ee:	2b00      	cmp	r3, #0
 800a8f0:	d074      	beq.n	800a9dc <_dtoa_r+0x8f4>
 800a8f2:	4631      	mov	r1, r6
 800a8f4:	4650      	mov	r0, sl
 800a8f6:	f001 f8ae 	bl	800ba56 <__mcmp>
 800a8fa:	2800      	cmp	r0, #0
 800a8fc:	da6e      	bge.n	800a9dc <_dtoa_r+0x8f4>
 800a8fe:	2300      	movs	r3, #0
 800a900:	4651      	mov	r1, sl
 800a902:	220a      	movs	r2, #10
 800a904:	4620      	mov	r0, r4
 800a906:	f000 fee8 	bl	800b6da <__multadd>
 800a90a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800a90c:	f10b 3bff 	add.w	fp, fp, #4294967295
 800a910:	4682      	mov	sl, r0
 800a912:	2b00      	cmp	r3, #0
 800a914:	f000 81a8 	beq.w	800ac68 <_dtoa_r+0xb80>
 800a918:	2300      	movs	r3, #0
 800a91a:	4639      	mov	r1, r7
 800a91c:	220a      	movs	r2, #10
 800a91e:	4620      	mov	r0, r4
 800a920:	f000 fedb 	bl	800b6da <__multadd>
 800a924:	9b04      	ldr	r3, [sp, #16]
 800a926:	2b00      	cmp	r3, #0
 800a928:	4607      	mov	r7, r0
 800a92a:	f300 80c8 	bgt.w	800aabe <_dtoa_r+0x9d6>
 800a92e:	9b07      	ldr	r3, [sp, #28]
 800a930:	2b02      	cmp	r3, #2
 800a932:	f340 80c4 	ble.w	800aabe <_dtoa_r+0x9d6>
 800a936:	e059      	b.n	800a9ec <_dtoa_r+0x904>
 800a938:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800a93a:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
 800a93e:	e756      	b.n	800a7ee <_dtoa_r+0x706>
 800a940:	9b03      	ldr	r3, [sp, #12]
 800a942:	1e5e      	subs	r6, r3, #1
 800a944:	9b08      	ldr	r3, [sp, #32]
 800a946:	42b3      	cmp	r3, r6
 800a948:	bfbf      	itttt	lt
 800a94a:	9b08      	ldrlt	r3, [sp, #32]
 800a94c:	9608      	strlt	r6, [sp, #32]
 800a94e:	1af2      	sublt	r2, r6, r3
 800a950:	9b0b      	ldrlt	r3, [sp, #44]	; 0x2c
 800a952:	bfb6      	itet	lt
 800a954:	189b      	addlt	r3, r3, r2
 800a956:	1b9e      	subge	r6, r3, r6
 800a958:	930b      	strlt	r3, [sp, #44]	; 0x2c
 800a95a:	9b03      	ldr	r3, [sp, #12]
 800a95c:	bfb8      	it	lt
 800a95e:	2600      	movlt	r6, #0
 800a960:	2b00      	cmp	r3, #0
 800a962:	bfb9      	ittee	lt
 800a964:	9b05      	ldrlt	r3, [sp, #20]
 800a966:	9a03      	ldrlt	r2, [sp, #12]
 800a968:	9d05      	ldrge	r5, [sp, #20]
 800a96a:	9b03      	ldrge	r3, [sp, #12]
 800a96c:	bfbc      	itt	lt
 800a96e:	1a9d      	sublt	r5, r3, r2
 800a970:	2300      	movlt	r3, #0
 800a972:	e73e      	b.n	800a7f2 <_dtoa_r+0x70a>
 800a974:	9e08      	ldr	r6, [sp, #32]
 800a976:	9d05      	ldr	r5, [sp, #20]
 800a978:	9f09      	ldr	r7, [sp, #36]	; 0x24
 800a97a:	e745      	b.n	800a808 <_dtoa_r+0x720>
 800a97c:	9a08      	ldr	r2, [sp, #32]
 800a97e:	e76e      	b.n	800a85e <_dtoa_r+0x776>
 800a980:	9b07      	ldr	r3, [sp, #28]
 800a982:	2b01      	cmp	r3, #1
 800a984:	dc19      	bgt.n	800a9ba <_dtoa_r+0x8d2>
 800a986:	9b00      	ldr	r3, [sp, #0]
 800a988:	b9bb      	cbnz	r3, 800a9ba <_dtoa_r+0x8d2>
 800a98a:	9b01      	ldr	r3, [sp, #4]
 800a98c:	f3c3 0313 	ubfx	r3, r3, #0, #20
 800a990:	b99b      	cbnz	r3, 800a9ba <_dtoa_r+0x8d2>
 800a992:	9b01      	ldr	r3, [sp, #4]
 800a994:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800a998:	0d1b      	lsrs	r3, r3, #20
 800a99a:	051b      	lsls	r3, r3, #20
 800a99c:	b183      	cbz	r3, 800a9c0 <_dtoa_r+0x8d8>
 800a99e:	9b05      	ldr	r3, [sp, #20]
 800a9a0:	3301      	adds	r3, #1
 800a9a2:	9305      	str	r3, [sp, #20]
 800a9a4:	9b06      	ldr	r3, [sp, #24]
 800a9a6:	3301      	adds	r3, #1
 800a9a8:	9306      	str	r3, [sp, #24]
 800a9aa:	f04f 0801 	mov.w	r8, #1
 800a9ae:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800a9b0:	2b00      	cmp	r3, #0
 800a9b2:	f47f af6d 	bne.w	800a890 <_dtoa_r+0x7a8>
 800a9b6:	2001      	movs	r0, #1
 800a9b8:	e772      	b.n	800a8a0 <_dtoa_r+0x7b8>
 800a9ba:	f04f 0800 	mov.w	r8, #0
 800a9be:	e7f6      	b.n	800a9ae <_dtoa_r+0x8c6>
 800a9c0:	4698      	mov	r8, r3
 800a9c2:	e7f4      	b.n	800a9ae <_dtoa_r+0x8c6>
 800a9c4:	d080      	beq.n	800a8c8 <_dtoa_r+0x7e0>
 800a9c6:	9a05      	ldr	r2, [sp, #20]
 800a9c8:	331c      	adds	r3, #28
 800a9ca:	441a      	add	r2, r3
 800a9cc:	9205      	str	r2, [sp, #20]
 800a9ce:	9a06      	ldr	r2, [sp, #24]
 800a9d0:	441a      	add	r2, r3
 800a9d2:	441d      	add	r5, r3
 800a9d4:	4613      	mov	r3, r2
 800a9d6:	e776      	b.n	800a8c6 <_dtoa_r+0x7de>
 800a9d8:	4603      	mov	r3, r0
 800a9da:	e7f4      	b.n	800a9c6 <_dtoa_r+0x8de>
 800a9dc:	9b03      	ldr	r3, [sp, #12]
 800a9de:	2b00      	cmp	r3, #0
 800a9e0:	dc36      	bgt.n	800aa50 <_dtoa_r+0x968>
 800a9e2:	9b07      	ldr	r3, [sp, #28]
 800a9e4:	2b02      	cmp	r3, #2
 800a9e6:	dd33      	ble.n	800aa50 <_dtoa_r+0x968>
 800a9e8:	9b03      	ldr	r3, [sp, #12]
 800a9ea:	9304      	str	r3, [sp, #16]
 800a9ec:	9b04      	ldr	r3, [sp, #16]
 800a9ee:	b963      	cbnz	r3, 800aa0a <_dtoa_r+0x922>
 800a9f0:	4631      	mov	r1, r6
 800a9f2:	2205      	movs	r2, #5
 800a9f4:	4620      	mov	r0, r4
 800a9f6:	f000 fe70 	bl	800b6da <__multadd>
 800a9fa:	4601      	mov	r1, r0
 800a9fc:	4606      	mov	r6, r0
 800a9fe:	4650      	mov	r0, sl
 800aa00:	f001 f829 	bl	800ba56 <__mcmp>
 800aa04:	2800      	cmp	r0, #0
 800aa06:	f73f adb6 	bgt.w	800a576 <_dtoa_r+0x48e>
 800aa0a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800aa0c:	9d02      	ldr	r5, [sp, #8]
 800aa0e:	ea6f 0b03 	mvn.w	fp, r3
 800aa12:	2300      	movs	r3, #0
 800aa14:	9303      	str	r3, [sp, #12]
 800aa16:	4631      	mov	r1, r6
 800aa18:	4620      	mov	r0, r4
 800aa1a:	f000 fe47 	bl	800b6ac <_Bfree>
 800aa1e:	2f00      	cmp	r7, #0
 800aa20:	f43f aea6 	beq.w	800a770 <_dtoa_r+0x688>
 800aa24:	9b03      	ldr	r3, [sp, #12]
 800aa26:	b12b      	cbz	r3, 800aa34 <_dtoa_r+0x94c>
 800aa28:	42bb      	cmp	r3, r7
 800aa2a:	d003      	beq.n	800aa34 <_dtoa_r+0x94c>
 800aa2c:	4619      	mov	r1, r3
 800aa2e:	4620      	mov	r0, r4
 800aa30:	f000 fe3c 	bl	800b6ac <_Bfree>
 800aa34:	4639      	mov	r1, r7
 800aa36:	4620      	mov	r0, r4
 800aa38:	f000 fe38 	bl	800b6ac <_Bfree>
 800aa3c:	e698      	b.n	800a770 <_dtoa_r+0x688>
 800aa3e:	2600      	movs	r6, #0
 800aa40:	4637      	mov	r7, r6
 800aa42:	e7e2      	b.n	800aa0a <_dtoa_r+0x922>
 800aa44:	46bb      	mov	fp, r7
 800aa46:	4637      	mov	r7, r6
 800aa48:	e595      	b.n	800a576 <_dtoa_r+0x48e>
 800aa4a:	bf00      	nop
 800aa4c:	40240000 	.word	0x40240000
 800aa50:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800aa52:	bb93      	cbnz	r3, 800aaba <_dtoa_r+0x9d2>
 800aa54:	9b03      	ldr	r3, [sp, #12]
 800aa56:	9304      	str	r3, [sp, #16]
 800aa58:	9d02      	ldr	r5, [sp, #8]
 800aa5a:	4631      	mov	r1, r6
 800aa5c:	4650      	mov	r0, sl
 800aa5e:	f7ff fab5 	bl	8009fcc <quorem>
 800aa62:	f100 0930 	add.w	r9, r0, #48	; 0x30
 800aa66:	f805 9b01 	strb.w	r9, [r5], #1
 800aa6a:	9b02      	ldr	r3, [sp, #8]
 800aa6c:	9a04      	ldr	r2, [sp, #16]
 800aa6e:	1aeb      	subs	r3, r5, r3
 800aa70:	429a      	cmp	r2, r3
 800aa72:	f300 80dc 	bgt.w	800ac2e <_dtoa_r+0xb46>
 800aa76:	9b02      	ldr	r3, [sp, #8]
 800aa78:	2a01      	cmp	r2, #1
 800aa7a:	bfac      	ite	ge
 800aa7c:	189b      	addge	r3, r3, r2
 800aa7e:	3301      	addlt	r3, #1
 800aa80:	4698      	mov	r8, r3
 800aa82:	2300      	movs	r3, #0
 800aa84:	9303      	str	r3, [sp, #12]
 800aa86:	4651      	mov	r1, sl
 800aa88:	2201      	movs	r2, #1
 800aa8a:	4620      	mov	r0, r4
 800aa8c:	f000 ff92 	bl	800b9b4 <__lshift>
 800aa90:	4631      	mov	r1, r6
 800aa92:	4682      	mov	sl, r0
 800aa94:	f000 ffdf 	bl	800ba56 <__mcmp>
 800aa98:	2800      	cmp	r0, #0
 800aa9a:	f300 808d 	bgt.w	800abb8 <_dtoa_r+0xad0>
 800aa9e:	d103      	bne.n	800aaa8 <_dtoa_r+0x9c0>
 800aaa0:	f019 0f01 	tst.w	r9, #1
 800aaa4:	f040 8088 	bne.w	800abb8 <_dtoa_r+0xad0>
 800aaa8:	4645      	mov	r5, r8
 800aaaa:	f815 3c01 	ldrb.w	r3, [r5, #-1]
 800aaae:	2b30      	cmp	r3, #48	; 0x30
 800aab0:	f105 32ff 	add.w	r2, r5, #4294967295
 800aab4:	d1af      	bne.n	800aa16 <_dtoa_r+0x92e>
 800aab6:	4615      	mov	r5, r2
 800aab8:	e7f7      	b.n	800aaaa <_dtoa_r+0x9c2>
 800aaba:	9b03      	ldr	r3, [sp, #12]
 800aabc:	9304      	str	r3, [sp, #16]
 800aabe:	2d00      	cmp	r5, #0
 800aac0:	dd05      	ble.n	800aace <_dtoa_r+0x9e6>
 800aac2:	4639      	mov	r1, r7
 800aac4:	462a      	mov	r2, r5
 800aac6:	4620      	mov	r0, r4
 800aac8:	f000 ff74 	bl	800b9b4 <__lshift>
 800aacc:	4607      	mov	r7, r0
 800aace:	f1b8 0f00 	cmp.w	r8, #0
 800aad2:	d04c      	beq.n	800ab6e <_dtoa_r+0xa86>
 800aad4:	6879      	ldr	r1, [r7, #4]
 800aad6:	4620      	mov	r0, r4
 800aad8:	f000 fdb4 	bl	800b644 <_Balloc>
 800aadc:	693a      	ldr	r2, [r7, #16]
 800aade:	3202      	adds	r2, #2
 800aae0:	4605      	mov	r5, r0
 800aae2:	0092      	lsls	r2, r2, #2
 800aae4:	f107 010c 	add.w	r1, r7, #12
 800aae8:	300c      	adds	r0, #12
 800aaea:	f7fd f83f 	bl	8007b6c <memcpy>
 800aaee:	2201      	movs	r2, #1
 800aaf0:	4629      	mov	r1, r5
 800aaf2:	4620      	mov	r0, r4
 800aaf4:	f000 ff5e 	bl	800b9b4 <__lshift>
 800aaf8:	9b00      	ldr	r3, [sp, #0]
 800aafa:	f8dd 8008 	ldr.w	r8, [sp, #8]
 800aafe:	9703      	str	r7, [sp, #12]
 800ab00:	f003 0301 	and.w	r3, r3, #1
 800ab04:	4607      	mov	r7, r0
 800ab06:	9305      	str	r3, [sp, #20]
 800ab08:	4631      	mov	r1, r6
 800ab0a:	4650      	mov	r0, sl
 800ab0c:	f7ff fa5e 	bl	8009fcc <quorem>
 800ab10:	9903      	ldr	r1, [sp, #12]
 800ab12:	4605      	mov	r5, r0
 800ab14:	f100 0930 	add.w	r9, r0, #48	; 0x30
 800ab18:	4650      	mov	r0, sl
 800ab1a:	f000 ff9c 	bl	800ba56 <__mcmp>
 800ab1e:	463a      	mov	r2, r7
 800ab20:	9000      	str	r0, [sp, #0]
 800ab22:	4631      	mov	r1, r6
 800ab24:	4620      	mov	r0, r4
 800ab26:	f000 ffb0 	bl	800ba8a <__mdiff>
 800ab2a:	68c3      	ldr	r3, [r0, #12]
 800ab2c:	4602      	mov	r2, r0
 800ab2e:	bb03      	cbnz	r3, 800ab72 <_dtoa_r+0xa8a>
 800ab30:	4601      	mov	r1, r0
 800ab32:	9006      	str	r0, [sp, #24]
 800ab34:	4650      	mov	r0, sl
 800ab36:	f000 ff8e 	bl	800ba56 <__mcmp>
 800ab3a:	9a06      	ldr	r2, [sp, #24]
 800ab3c:	4603      	mov	r3, r0
 800ab3e:	4611      	mov	r1, r2
 800ab40:	4620      	mov	r0, r4
 800ab42:	9306      	str	r3, [sp, #24]
 800ab44:	f000 fdb2 	bl	800b6ac <_Bfree>
 800ab48:	9b06      	ldr	r3, [sp, #24]
 800ab4a:	b9a3      	cbnz	r3, 800ab76 <_dtoa_r+0xa8e>
 800ab4c:	9a07      	ldr	r2, [sp, #28]
 800ab4e:	b992      	cbnz	r2, 800ab76 <_dtoa_r+0xa8e>
 800ab50:	9a05      	ldr	r2, [sp, #20]
 800ab52:	b982      	cbnz	r2, 800ab76 <_dtoa_r+0xa8e>
 800ab54:	f1b9 0f39 	cmp.w	r9, #57	; 0x39
 800ab58:	d029      	beq.n	800abae <_dtoa_r+0xac6>
 800ab5a:	9b00      	ldr	r3, [sp, #0]
 800ab5c:	2b00      	cmp	r3, #0
 800ab5e:	dd01      	ble.n	800ab64 <_dtoa_r+0xa7c>
 800ab60:	f105 0931 	add.w	r9, r5, #49	; 0x31
 800ab64:	f108 0501 	add.w	r5, r8, #1
 800ab68:	f888 9000 	strb.w	r9, [r8]
 800ab6c:	e753      	b.n	800aa16 <_dtoa_r+0x92e>
 800ab6e:	4638      	mov	r0, r7
 800ab70:	e7c2      	b.n	800aaf8 <_dtoa_r+0xa10>
 800ab72:	2301      	movs	r3, #1
 800ab74:	e7e3      	b.n	800ab3e <_dtoa_r+0xa56>
 800ab76:	9a00      	ldr	r2, [sp, #0]
 800ab78:	2a00      	cmp	r2, #0
 800ab7a:	db04      	blt.n	800ab86 <_dtoa_r+0xa9e>
 800ab7c:	d125      	bne.n	800abca <_dtoa_r+0xae2>
 800ab7e:	9a07      	ldr	r2, [sp, #28]
 800ab80:	bb1a      	cbnz	r2, 800abca <_dtoa_r+0xae2>
 800ab82:	9a05      	ldr	r2, [sp, #20]
 800ab84:	bb0a      	cbnz	r2, 800abca <_dtoa_r+0xae2>
 800ab86:	2b00      	cmp	r3, #0
 800ab88:	ddec      	ble.n	800ab64 <_dtoa_r+0xa7c>
 800ab8a:	4651      	mov	r1, sl
 800ab8c:	2201      	movs	r2, #1
 800ab8e:	4620      	mov	r0, r4
 800ab90:	f000 ff10 	bl	800b9b4 <__lshift>
 800ab94:	4631      	mov	r1, r6
 800ab96:	4682      	mov	sl, r0
 800ab98:	f000 ff5d 	bl	800ba56 <__mcmp>
 800ab9c:	2800      	cmp	r0, #0
 800ab9e:	dc03      	bgt.n	800aba8 <_dtoa_r+0xac0>
 800aba0:	d1e0      	bne.n	800ab64 <_dtoa_r+0xa7c>
 800aba2:	f019 0f01 	tst.w	r9, #1
 800aba6:	d0dd      	beq.n	800ab64 <_dtoa_r+0xa7c>
 800aba8:	f1b9 0f39 	cmp.w	r9, #57	; 0x39
 800abac:	d1d8      	bne.n	800ab60 <_dtoa_r+0xa78>
 800abae:	2339      	movs	r3, #57	; 0x39
 800abb0:	f888 3000 	strb.w	r3, [r8]
 800abb4:	f108 0801 	add.w	r8, r8, #1
 800abb8:	4645      	mov	r5, r8
 800abba:	f815 3c01 	ldrb.w	r3, [r5, #-1]
 800abbe:	2b39      	cmp	r3, #57	; 0x39
 800abc0:	f105 32ff 	add.w	r2, r5, #4294967295
 800abc4:	d03b      	beq.n	800ac3e <_dtoa_r+0xb56>
 800abc6:	3301      	adds	r3, #1
 800abc8:	e040      	b.n	800ac4c <_dtoa_r+0xb64>
 800abca:	2b00      	cmp	r3, #0
 800abcc:	f108 0501 	add.w	r5, r8, #1
 800abd0:	dd05      	ble.n	800abde <_dtoa_r+0xaf6>
 800abd2:	f1b9 0f39 	cmp.w	r9, #57	; 0x39
 800abd6:	d0ea      	beq.n	800abae <_dtoa_r+0xac6>
 800abd8:	f109 0901 	add.w	r9, r9, #1
 800abdc:	e7c4      	b.n	800ab68 <_dtoa_r+0xa80>
 800abde:	9b02      	ldr	r3, [sp, #8]
 800abe0:	9a04      	ldr	r2, [sp, #16]
 800abe2:	f805 9c01 	strb.w	r9, [r5, #-1]
 800abe6:	1aeb      	subs	r3, r5, r3
 800abe8:	4293      	cmp	r3, r2
 800abea:	46a8      	mov	r8, r5
 800abec:	f43f af4b 	beq.w	800aa86 <_dtoa_r+0x99e>
 800abf0:	4651      	mov	r1, sl
 800abf2:	2300      	movs	r3, #0
 800abf4:	220a      	movs	r2, #10
 800abf6:	4620      	mov	r0, r4
 800abf8:	f000 fd6f 	bl	800b6da <__multadd>
 800abfc:	9b03      	ldr	r3, [sp, #12]
 800abfe:	9903      	ldr	r1, [sp, #12]
 800ac00:	42bb      	cmp	r3, r7
 800ac02:	4682      	mov	sl, r0
 800ac04:	f04f 0300 	mov.w	r3, #0
 800ac08:	f04f 020a 	mov.w	r2, #10
 800ac0c:	4620      	mov	r0, r4
 800ac0e:	d104      	bne.n	800ac1a <_dtoa_r+0xb32>
 800ac10:	f000 fd63 	bl	800b6da <__multadd>
 800ac14:	9003      	str	r0, [sp, #12]
 800ac16:	4607      	mov	r7, r0
 800ac18:	e776      	b.n	800ab08 <_dtoa_r+0xa20>
 800ac1a:	f000 fd5e 	bl	800b6da <__multadd>
 800ac1e:	2300      	movs	r3, #0
 800ac20:	9003      	str	r0, [sp, #12]
 800ac22:	220a      	movs	r2, #10
 800ac24:	4639      	mov	r1, r7
 800ac26:	4620      	mov	r0, r4
 800ac28:	f000 fd57 	bl	800b6da <__multadd>
 800ac2c:	e7f3      	b.n	800ac16 <_dtoa_r+0xb2e>
 800ac2e:	4651      	mov	r1, sl
 800ac30:	2300      	movs	r3, #0
 800ac32:	220a      	movs	r2, #10
 800ac34:	4620      	mov	r0, r4
 800ac36:	f000 fd50 	bl	800b6da <__multadd>
 800ac3a:	4682      	mov	sl, r0
 800ac3c:	e70d      	b.n	800aa5a <_dtoa_r+0x972>
 800ac3e:	9b02      	ldr	r3, [sp, #8]
 800ac40:	4293      	cmp	r3, r2
 800ac42:	d105      	bne.n	800ac50 <_dtoa_r+0xb68>
 800ac44:	9a02      	ldr	r2, [sp, #8]
 800ac46:	f10b 0b01 	add.w	fp, fp, #1
 800ac4a:	2331      	movs	r3, #49	; 0x31
 800ac4c:	7013      	strb	r3, [r2, #0]
 800ac4e:	e6e2      	b.n	800aa16 <_dtoa_r+0x92e>
 800ac50:	4615      	mov	r5, r2
 800ac52:	e7b2      	b.n	800abba <_dtoa_r+0xad2>
 800ac54:	4b09      	ldr	r3, [pc, #36]	; (800ac7c <_dtoa_r+0xb94>)
 800ac56:	f7ff baae 	b.w	800a1b6 <_dtoa_r+0xce>
 800ac5a:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800ac5c:	2b00      	cmp	r3, #0
 800ac5e:	f47f aa88 	bne.w	800a172 <_dtoa_r+0x8a>
 800ac62:	4b07      	ldr	r3, [pc, #28]	; (800ac80 <_dtoa_r+0xb98>)
 800ac64:	f7ff baa7 	b.w	800a1b6 <_dtoa_r+0xce>
 800ac68:	9b04      	ldr	r3, [sp, #16]
 800ac6a:	2b00      	cmp	r3, #0
 800ac6c:	f73f aef4 	bgt.w	800aa58 <_dtoa_r+0x970>
 800ac70:	9b07      	ldr	r3, [sp, #28]
 800ac72:	2b02      	cmp	r3, #2
 800ac74:	f77f aef0 	ble.w	800aa58 <_dtoa_r+0x970>
 800ac78:	e6b8      	b.n	800a9ec <_dtoa_r+0x904>
 800ac7a:	bf00      	nop
 800ac7c:	0800d21e 	.word	0x0800d21e
 800ac80:	0800d260 	.word	0x0800d260

0800ac84 <__sflush_r>:
 800ac84:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 800ac88:	b293      	uxth	r3, r2
 800ac8a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800ac8e:	4605      	mov	r5, r0
 800ac90:	0718      	lsls	r0, r3, #28
 800ac92:	460c      	mov	r4, r1
 800ac94:	d461      	bmi.n	800ad5a <__sflush_r+0xd6>
 800ac96:	684b      	ldr	r3, [r1, #4]
 800ac98:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 800ac9c:	2b00      	cmp	r3, #0
 800ac9e:	818a      	strh	r2, [r1, #12]
 800aca0:	dc05      	bgt.n	800acae <__sflush_r+0x2a>
 800aca2:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 800aca4:	2b00      	cmp	r3, #0
 800aca6:	dc02      	bgt.n	800acae <__sflush_r+0x2a>
 800aca8:	2000      	movs	r0, #0
 800acaa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800acae:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 800acb0:	2e00      	cmp	r6, #0
 800acb2:	d0f9      	beq.n	800aca8 <__sflush_r+0x24>
 800acb4:	2300      	movs	r3, #0
 800acb6:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 800acba:	682f      	ldr	r7, [r5, #0]
 800acbc:	602b      	str	r3, [r5, #0]
 800acbe:	d037      	beq.n	800ad30 <__sflush_r+0xac>
 800acc0:	6d60      	ldr	r0, [r4, #84]	; 0x54
 800acc2:	89a3      	ldrh	r3, [r4, #12]
 800acc4:	075a      	lsls	r2, r3, #29
 800acc6:	d505      	bpl.n	800acd4 <__sflush_r+0x50>
 800acc8:	6863      	ldr	r3, [r4, #4]
 800acca:	1ac0      	subs	r0, r0, r3
 800accc:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800acce:	b10b      	cbz	r3, 800acd4 <__sflush_r+0x50>
 800acd0:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800acd2:	1ac0      	subs	r0, r0, r3
 800acd4:	2300      	movs	r3, #0
 800acd6:	4602      	mov	r2, r0
 800acd8:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 800acda:	6a21      	ldr	r1, [r4, #32]
 800acdc:	4628      	mov	r0, r5
 800acde:	47b0      	blx	r6
 800ace0:	1c43      	adds	r3, r0, #1
 800ace2:	89a3      	ldrh	r3, [r4, #12]
 800ace4:	d106      	bne.n	800acf4 <__sflush_r+0x70>
 800ace6:	6829      	ldr	r1, [r5, #0]
 800ace8:	291d      	cmp	r1, #29
 800acea:	d84f      	bhi.n	800ad8c <__sflush_r+0x108>
 800acec:	4a2d      	ldr	r2, [pc, #180]	; (800ada4 <__sflush_r+0x120>)
 800acee:	40ca      	lsrs	r2, r1
 800acf0:	07d6      	lsls	r6, r2, #31
 800acf2:	d54b      	bpl.n	800ad8c <__sflush_r+0x108>
 800acf4:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800acf8:	b21b      	sxth	r3, r3
 800acfa:	2200      	movs	r2, #0
 800acfc:	6062      	str	r2, [r4, #4]
 800acfe:	04d9      	lsls	r1, r3, #19
 800ad00:	6922      	ldr	r2, [r4, #16]
 800ad02:	81a3      	strh	r3, [r4, #12]
 800ad04:	6022      	str	r2, [r4, #0]
 800ad06:	d504      	bpl.n	800ad12 <__sflush_r+0x8e>
 800ad08:	1c42      	adds	r2, r0, #1
 800ad0a:	d101      	bne.n	800ad10 <__sflush_r+0x8c>
 800ad0c:	682b      	ldr	r3, [r5, #0]
 800ad0e:	b903      	cbnz	r3, 800ad12 <__sflush_r+0x8e>
 800ad10:	6560      	str	r0, [r4, #84]	; 0x54
 800ad12:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800ad14:	602f      	str	r7, [r5, #0]
 800ad16:	2900      	cmp	r1, #0
 800ad18:	d0c6      	beq.n	800aca8 <__sflush_r+0x24>
 800ad1a:	f104 0344 	add.w	r3, r4, #68	; 0x44
 800ad1e:	4299      	cmp	r1, r3
 800ad20:	d002      	beq.n	800ad28 <__sflush_r+0xa4>
 800ad22:	4628      	mov	r0, r5
 800ad24:	f000 f9aa 	bl	800b07c <_free_r>
 800ad28:	2000      	movs	r0, #0
 800ad2a:	6360      	str	r0, [r4, #52]	; 0x34
 800ad2c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800ad30:	6a21      	ldr	r1, [r4, #32]
 800ad32:	2301      	movs	r3, #1
 800ad34:	4628      	mov	r0, r5
 800ad36:	47b0      	blx	r6
 800ad38:	1c41      	adds	r1, r0, #1
 800ad3a:	d1c2      	bne.n	800acc2 <__sflush_r+0x3e>
 800ad3c:	682b      	ldr	r3, [r5, #0]
 800ad3e:	2b00      	cmp	r3, #0
 800ad40:	d0bf      	beq.n	800acc2 <__sflush_r+0x3e>
 800ad42:	2b1d      	cmp	r3, #29
 800ad44:	d001      	beq.n	800ad4a <__sflush_r+0xc6>
 800ad46:	2b16      	cmp	r3, #22
 800ad48:	d101      	bne.n	800ad4e <__sflush_r+0xca>
 800ad4a:	602f      	str	r7, [r5, #0]
 800ad4c:	e7ac      	b.n	800aca8 <__sflush_r+0x24>
 800ad4e:	89a3      	ldrh	r3, [r4, #12]
 800ad50:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800ad54:	81a3      	strh	r3, [r4, #12]
 800ad56:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800ad5a:	690f      	ldr	r7, [r1, #16]
 800ad5c:	2f00      	cmp	r7, #0
 800ad5e:	d0a3      	beq.n	800aca8 <__sflush_r+0x24>
 800ad60:	079b      	lsls	r3, r3, #30
 800ad62:	680e      	ldr	r6, [r1, #0]
 800ad64:	bf08      	it	eq
 800ad66:	694b      	ldreq	r3, [r1, #20]
 800ad68:	600f      	str	r7, [r1, #0]
 800ad6a:	bf18      	it	ne
 800ad6c:	2300      	movne	r3, #0
 800ad6e:	eba6 0807 	sub.w	r8, r6, r7
 800ad72:	608b      	str	r3, [r1, #8]
 800ad74:	f1b8 0f00 	cmp.w	r8, #0
 800ad78:	dd96      	ble.n	800aca8 <__sflush_r+0x24>
 800ad7a:	4643      	mov	r3, r8
 800ad7c:	463a      	mov	r2, r7
 800ad7e:	6a21      	ldr	r1, [r4, #32]
 800ad80:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 800ad82:	4628      	mov	r0, r5
 800ad84:	47b0      	blx	r6
 800ad86:	2800      	cmp	r0, #0
 800ad88:	dc07      	bgt.n	800ad9a <__sflush_r+0x116>
 800ad8a:	89a3      	ldrh	r3, [r4, #12]
 800ad8c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800ad90:	81a3      	strh	r3, [r4, #12]
 800ad92:	f04f 30ff 	mov.w	r0, #4294967295
 800ad96:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800ad9a:	4407      	add	r7, r0
 800ad9c:	eba8 0800 	sub.w	r8, r8, r0
 800ada0:	e7e8      	b.n	800ad74 <__sflush_r+0xf0>
 800ada2:	bf00      	nop
 800ada4:	20400001 	.word	0x20400001

0800ada8 <_fflush_r>:
 800ada8:	b538      	push	{r3, r4, r5, lr}
 800adaa:	690b      	ldr	r3, [r1, #16]
 800adac:	4605      	mov	r5, r0
 800adae:	460c      	mov	r4, r1
 800adb0:	b913      	cbnz	r3, 800adb8 <_fflush_r+0x10>
 800adb2:	2500      	movs	r5, #0
 800adb4:	4628      	mov	r0, r5
 800adb6:	bd38      	pop	{r3, r4, r5, pc}
 800adb8:	b118      	cbz	r0, 800adc2 <_fflush_r+0x1a>
 800adba:	6983      	ldr	r3, [r0, #24]
 800adbc:	b90b      	cbnz	r3, 800adc2 <_fflush_r+0x1a>
 800adbe:	f000 f887 	bl	800aed0 <__sinit>
 800adc2:	4b14      	ldr	r3, [pc, #80]	; (800ae14 <_fflush_r+0x6c>)
 800adc4:	429c      	cmp	r4, r3
 800adc6:	d11b      	bne.n	800ae00 <_fflush_r+0x58>
 800adc8:	686c      	ldr	r4, [r5, #4]
 800adca:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800adce:	2b00      	cmp	r3, #0
 800add0:	d0ef      	beq.n	800adb2 <_fflush_r+0xa>
 800add2:	6e62      	ldr	r2, [r4, #100]	; 0x64
 800add4:	07d0      	lsls	r0, r2, #31
 800add6:	d404      	bmi.n	800ade2 <_fflush_r+0x3a>
 800add8:	0599      	lsls	r1, r3, #22
 800adda:	d402      	bmi.n	800ade2 <_fflush_r+0x3a>
 800addc:	6da0      	ldr	r0, [r4, #88]	; 0x58
 800adde:	f000 fb97 	bl	800b510 <__retarget_lock_acquire_recursive>
 800ade2:	4628      	mov	r0, r5
 800ade4:	4621      	mov	r1, r4
 800ade6:	f7ff ff4d 	bl	800ac84 <__sflush_r>
 800adea:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800adec:	07da      	lsls	r2, r3, #31
 800adee:	4605      	mov	r5, r0
 800adf0:	d4e0      	bmi.n	800adb4 <_fflush_r+0xc>
 800adf2:	89a3      	ldrh	r3, [r4, #12]
 800adf4:	059b      	lsls	r3, r3, #22
 800adf6:	d4dd      	bmi.n	800adb4 <_fflush_r+0xc>
 800adf8:	6da0      	ldr	r0, [r4, #88]	; 0x58
 800adfa:	f000 fb8a 	bl	800b512 <__retarget_lock_release_recursive>
 800adfe:	e7d9      	b.n	800adb4 <_fflush_r+0xc>
 800ae00:	4b05      	ldr	r3, [pc, #20]	; (800ae18 <_fflush_r+0x70>)
 800ae02:	429c      	cmp	r4, r3
 800ae04:	d101      	bne.n	800ae0a <_fflush_r+0x62>
 800ae06:	68ac      	ldr	r4, [r5, #8]
 800ae08:	e7df      	b.n	800adca <_fflush_r+0x22>
 800ae0a:	4b04      	ldr	r3, [pc, #16]	; (800ae1c <_fflush_r+0x74>)
 800ae0c:	429c      	cmp	r4, r3
 800ae0e:	bf08      	it	eq
 800ae10:	68ec      	ldreq	r4, [r5, #12]
 800ae12:	e7da      	b.n	800adca <_fflush_r+0x22>
 800ae14:	0800d290 	.word	0x0800d290
 800ae18:	0800d2b0 	.word	0x0800d2b0
 800ae1c:	0800d270 	.word	0x0800d270

0800ae20 <_cleanup_r>:
 800ae20:	4901      	ldr	r1, [pc, #4]	; (800ae28 <_cleanup_r+0x8>)
 800ae22:	f000 bb35 	b.w	800b490 <_fwalk_reent>
 800ae26:	bf00      	nop
 800ae28:	0800c185 	.word	0x0800c185

0800ae2c <std.isra.0>:
 800ae2c:	2300      	movs	r3, #0
 800ae2e:	b510      	push	{r4, lr}
 800ae30:	4604      	mov	r4, r0
 800ae32:	6003      	str	r3, [r0, #0]
 800ae34:	6043      	str	r3, [r0, #4]
 800ae36:	6083      	str	r3, [r0, #8]
 800ae38:	8181      	strh	r1, [r0, #12]
 800ae3a:	6643      	str	r3, [r0, #100]	; 0x64
 800ae3c:	81c2      	strh	r2, [r0, #14]
 800ae3e:	6103      	str	r3, [r0, #16]
 800ae40:	6143      	str	r3, [r0, #20]
 800ae42:	6183      	str	r3, [r0, #24]
 800ae44:	4619      	mov	r1, r3
 800ae46:	2208      	movs	r2, #8
 800ae48:	305c      	adds	r0, #92	; 0x5c
 800ae4a:	f7fc fe9a 	bl	8007b82 <memset>
 800ae4e:	4b05      	ldr	r3, [pc, #20]	; (800ae64 <std.isra.0+0x38>)
 800ae50:	6263      	str	r3, [r4, #36]	; 0x24
 800ae52:	4b05      	ldr	r3, [pc, #20]	; (800ae68 <std.isra.0+0x3c>)
 800ae54:	62a3      	str	r3, [r4, #40]	; 0x28
 800ae56:	4b05      	ldr	r3, [pc, #20]	; (800ae6c <std.isra.0+0x40>)
 800ae58:	62e3      	str	r3, [r4, #44]	; 0x2c
 800ae5a:	4b05      	ldr	r3, [pc, #20]	; (800ae70 <std.isra.0+0x44>)
 800ae5c:	6224      	str	r4, [r4, #32]
 800ae5e:	6323      	str	r3, [r4, #48]	; 0x30
 800ae60:	bd10      	pop	{r4, pc}
 800ae62:	bf00      	nop
 800ae64:	0800bee5 	.word	0x0800bee5
 800ae68:	0800bf07 	.word	0x0800bf07
 800ae6c:	0800bf3f 	.word	0x0800bf3f
 800ae70:	0800bf63 	.word	0x0800bf63

0800ae74 <__sfmoreglue>:
 800ae74:	b570      	push	{r4, r5, r6, lr}
 800ae76:	1e4a      	subs	r2, r1, #1
 800ae78:	2568      	movs	r5, #104	; 0x68
 800ae7a:	4355      	muls	r5, r2
 800ae7c:	460e      	mov	r6, r1
 800ae7e:	f105 0174 	add.w	r1, r5, #116	; 0x74
 800ae82:	f7fc fc65 	bl	8007750 <_malloc_r>
 800ae86:	4604      	mov	r4, r0
 800ae88:	b140      	cbz	r0, 800ae9c <__sfmoreglue+0x28>
 800ae8a:	2100      	movs	r1, #0
 800ae8c:	e880 0042 	stmia.w	r0, {r1, r6}
 800ae90:	300c      	adds	r0, #12
 800ae92:	60a0      	str	r0, [r4, #8]
 800ae94:	f105 0268 	add.w	r2, r5, #104	; 0x68
 800ae98:	f7fc fe73 	bl	8007b82 <memset>
 800ae9c:	4620      	mov	r0, r4
 800ae9e:	bd70      	pop	{r4, r5, r6, pc}

0800aea0 <__sfp_lock_acquire>:
 800aea0:	4801      	ldr	r0, [pc, #4]	; (800aea8 <__sfp_lock_acquire+0x8>)
 800aea2:	f000 bb35 	b.w	800b510 <__retarget_lock_acquire_recursive>
 800aea6:	bf00      	nop
 800aea8:	20008d74 	.word	0x20008d74

0800aeac <__sfp_lock_release>:
 800aeac:	4801      	ldr	r0, [pc, #4]	; (800aeb4 <__sfp_lock_release+0x8>)
 800aeae:	f000 bb30 	b.w	800b512 <__retarget_lock_release_recursive>
 800aeb2:	bf00      	nop
 800aeb4:	20008d74 	.word	0x20008d74

0800aeb8 <__sinit_lock_acquire>:
 800aeb8:	4801      	ldr	r0, [pc, #4]	; (800aec0 <__sinit_lock_acquire+0x8>)
 800aeba:	f000 bb29 	b.w	800b510 <__retarget_lock_acquire_recursive>
 800aebe:	bf00      	nop
 800aec0:	20008d6f 	.word	0x20008d6f

0800aec4 <__sinit_lock_release>:
 800aec4:	4801      	ldr	r0, [pc, #4]	; (800aecc <__sinit_lock_release+0x8>)
 800aec6:	f000 bb24 	b.w	800b512 <__retarget_lock_release_recursive>
 800aeca:	bf00      	nop
 800aecc:	20008d6f 	.word	0x20008d6f

0800aed0 <__sinit>:
 800aed0:	b510      	push	{r4, lr}
 800aed2:	4604      	mov	r4, r0
 800aed4:	f7ff fff0 	bl	800aeb8 <__sinit_lock_acquire>
 800aed8:	69a3      	ldr	r3, [r4, #24]
 800aeda:	b11b      	cbz	r3, 800aee4 <__sinit+0x14>
 800aedc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800aee0:	f7ff bff0 	b.w	800aec4 <__sinit_lock_release>
 800aee4:	f8c4 30d8 	str.w	r3, [r4, #216]	; 0xd8
 800aee8:	f8c4 30dc 	str.w	r3, [r4, #220]	; 0xdc
 800aeec:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
 800aef0:	4b12      	ldr	r3, [pc, #72]	; (800af3c <__sinit+0x6c>)
 800aef2:	4a13      	ldr	r2, [pc, #76]	; (800af40 <__sinit+0x70>)
 800aef4:	681b      	ldr	r3, [r3, #0]
 800aef6:	62a2      	str	r2, [r4, #40]	; 0x28
 800aef8:	429c      	cmp	r4, r3
 800aefa:	bf04      	itt	eq
 800aefc:	2301      	moveq	r3, #1
 800aefe:	61a3      	streq	r3, [r4, #24]
 800af00:	4620      	mov	r0, r4
 800af02:	f000 f81f 	bl	800af44 <__sfp>
 800af06:	6060      	str	r0, [r4, #4]
 800af08:	4620      	mov	r0, r4
 800af0a:	f000 f81b 	bl	800af44 <__sfp>
 800af0e:	60a0      	str	r0, [r4, #8]
 800af10:	4620      	mov	r0, r4
 800af12:	f000 f817 	bl	800af44 <__sfp>
 800af16:	2200      	movs	r2, #0
 800af18:	60e0      	str	r0, [r4, #12]
 800af1a:	2104      	movs	r1, #4
 800af1c:	6860      	ldr	r0, [r4, #4]
 800af1e:	f7ff ff85 	bl	800ae2c <std.isra.0>
 800af22:	2201      	movs	r2, #1
 800af24:	2109      	movs	r1, #9
 800af26:	68a0      	ldr	r0, [r4, #8]
 800af28:	f7ff ff80 	bl	800ae2c <std.isra.0>
 800af2c:	2202      	movs	r2, #2
 800af2e:	2112      	movs	r1, #18
 800af30:	68e0      	ldr	r0, [r4, #12]
 800af32:	f7ff ff7b 	bl	800ae2c <std.isra.0>
 800af36:	2301      	movs	r3, #1
 800af38:	61a3      	str	r3, [r4, #24]
 800af3a:	e7cf      	b.n	800aedc <__sinit+0xc>
 800af3c:	0800d1e8 	.word	0x0800d1e8
 800af40:	0800ae21 	.word	0x0800ae21

0800af44 <__sfp>:
 800af44:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800af46:	4607      	mov	r7, r0
 800af48:	f7ff ffaa 	bl	800aea0 <__sfp_lock_acquire>
 800af4c:	4b1f      	ldr	r3, [pc, #124]	; (800afcc <__sfp+0x88>)
 800af4e:	681e      	ldr	r6, [r3, #0]
 800af50:	69b3      	ldr	r3, [r6, #24]
 800af52:	b913      	cbnz	r3, 800af5a <__sfp+0x16>
 800af54:	4630      	mov	r0, r6
 800af56:	f7ff ffbb 	bl	800aed0 <__sinit>
 800af5a:	36d8      	adds	r6, #216	; 0xd8
 800af5c:	68b4      	ldr	r4, [r6, #8]
 800af5e:	6873      	ldr	r3, [r6, #4]
 800af60:	3b01      	subs	r3, #1
 800af62:	d503      	bpl.n	800af6c <__sfp+0x28>
 800af64:	6833      	ldr	r3, [r6, #0]
 800af66:	b133      	cbz	r3, 800af76 <__sfp+0x32>
 800af68:	6836      	ldr	r6, [r6, #0]
 800af6a:	e7f7      	b.n	800af5c <__sfp+0x18>
 800af6c:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
 800af70:	b17d      	cbz	r5, 800af92 <__sfp+0x4e>
 800af72:	3468      	adds	r4, #104	; 0x68
 800af74:	e7f4      	b.n	800af60 <__sfp+0x1c>
 800af76:	2104      	movs	r1, #4
 800af78:	4638      	mov	r0, r7
 800af7a:	f7ff ff7b 	bl	800ae74 <__sfmoreglue>
 800af7e:	4604      	mov	r4, r0
 800af80:	6030      	str	r0, [r6, #0]
 800af82:	2800      	cmp	r0, #0
 800af84:	d1f0      	bne.n	800af68 <__sfp+0x24>
 800af86:	f7ff ff91 	bl	800aeac <__sfp_lock_release>
 800af8a:	230c      	movs	r3, #12
 800af8c:	603b      	str	r3, [r7, #0]
 800af8e:	4620      	mov	r0, r4
 800af90:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800af92:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800af96:	81e3      	strh	r3, [r4, #14]
 800af98:	2301      	movs	r3, #1
 800af9a:	81a3      	strh	r3, [r4, #12]
 800af9c:	f104 0058 	add.w	r0, r4, #88	; 0x58
 800afa0:	6665      	str	r5, [r4, #100]	; 0x64
 800afa2:	f000 fab3 	bl	800b50c <__retarget_lock_init_recursive>
 800afa6:	f7ff ff81 	bl	800aeac <__sfp_lock_release>
 800afaa:	6025      	str	r5, [r4, #0]
 800afac:	60a5      	str	r5, [r4, #8]
 800afae:	6065      	str	r5, [r4, #4]
 800afb0:	6125      	str	r5, [r4, #16]
 800afb2:	6165      	str	r5, [r4, #20]
 800afb4:	61a5      	str	r5, [r4, #24]
 800afb6:	2208      	movs	r2, #8
 800afb8:	4629      	mov	r1, r5
 800afba:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 800afbe:	f7fc fde0 	bl	8007b82 <memset>
 800afc2:	6365      	str	r5, [r4, #52]	; 0x34
 800afc4:	63a5      	str	r5, [r4, #56]	; 0x38
 800afc6:	64a5      	str	r5, [r4, #72]	; 0x48
 800afc8:	64e5      	str	r5, [r4, #76]	; 0x4c
 800afca:	e7e0      	b.n	800af8e <__sfp+0x4a>
 800afcc:	0800d1e8 	.word	0x0800d1e8

0800afd0 <_malloc_trim_r>:
 800afd0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800afd4:	4f25      	ldr	r7, [pc, #148]	; (800b06c <_malloc_trim_r+0x9c>)
 800afd6:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 800b078 <_malloc_trim_r+0xa8>
 800afda:	4689      	mov	r9, r1
 800afdc:	4606      	mov	r6, r0
 800afde:	f7fc fdd9 	bl	8007b94 <__malloc_lock>
 800afe2:	68bb      	ldr	r3, [r7, #8]
 800afe4:	685d      	ldr	r5, [r3, #4]
 800afe6:	f1a8 0411 	sub.w	r4, r8, #17
 800afea:	f025 0503 	bic.w	r5, r5, #3
 800afee:	eba4 0409 	sub.w	r4, r4, r9
 800aff2:	442c      	add	r4, r5
 800aff4:	fbb4 f4f8 	udiv	r4, r4, r8
 800aff8:	3c01      	subs	r4, #1
 800affa:	fb08 f404 	mul.w	r4, r8, r4
 800affe:	4544      	cmp	r4, r8
 800b000:	da05      	bge.n	800b00e <_malloc_trim_r+0x3e>
 800b002:	4630      	mov	r0, r6
 800b004:	f7fc fdcc 	bl	8007ba0 <__malloc_unlock>
 800b008:	2000      	movs	r0, #0
 800b00a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800b00e:	2100      	movs	r1, #0
 800b010:	4630      	mov	r0, r6
 800b012:	f7fc fe4b 	bl	8007cac <_sbrk_r>
 800b016:	68bb      	ldr	r3, [r7, #8]
 800b018:	442b      	add	r3, r5
 800b01a:	4298      	cmp	r0, r3
 800b01c:	d1f1      	bne.n	800b002 <_malloc_trim_r+0x32>
 800b01e:	4261      	negs	r1, r4
 800b020:	4630      	mov	r0, r6
 800b022:	f7fc fe43 	bl	8007cac <_sbrk_r>
 800b026:	3001      	adds	r0, #1
 800b028:	d110      	bne.n	800b04c <_malloc_trim_r+0x7c>
 800b02a:	2100      	movs	r1, #0
 800b02c:	4630      	mov	r0, r6
 800b02e:	f7fc fe3d 	bl	8007cac <_sbrk_r>
 800b032:	68ba      	ldr	r2, [r7, #8]
 800b034:	1a83      	subs	r3, r0, r2
 800b036:	2b0f      	cmp	r3, #15
 800b038:	dde3      	ble.n	800b002 <_malloc_trim_r+0x32>
 800b03a:	490d      	ldr	r1, [pc, #52]	; (800b070 <_malloc_trim_r+0xa0>)
 800b03c:	6809      	ldr	r1, [r1, #0]
 800b03e:	1a40      	subs	r0, r0, r1
 800b040:	490c      	ldr	r1, [pc, #48]	; (800b074 <_malloc_trim_r+0xa4>)
 800b042:	f043 0301 	orr.w	r3, r3, #1
 800b046:	6008      	str	r0, [r1, #0]
 800b048:	6053      	str	r3, [r2, #4]
 800b04a:	e7da      	b.n	800b002 <_malloc_trim_r+0x32>
 800b04c:	68bb      	ldr	r3, [r7, #8]
 800b04e:	4a09      	ldr	r2, [pc, #36]	; (800b074 <_malloc_trim_r+0xa4>)
 800b050:	1b2d      	subs	r5, r5, r4
 800b052:	f045 0501 	orr.w	r5, r5, #1
 800b056:	605d      	str	r5, [r3, #4]
 800b058:	6813      	ldr	r3, [r2, #0]
 800b05a:	4630      	mov	r0, r6
 800b05c:	1b1c      	subs	r4, r3, r4
 800b05e:	6014      	str	r4, [r2, #0]
 800b060:	f7fc fd9e 	bl	8007ba0 <__malloc_unlock>
 800b064:	2001      	movs	r0, #1
 800b066:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800b06a:	bf00      	nop
 800b06c:	20000150 	.word	0x20000150
 800b070:	20000558 	.word	0x20000558
 800b074:	200084c8 	.word	0x200084c8
 800b078:	00000080 	.word	0x00000080

0800b07c <_free_r>:
 800b07c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800b080:	4604      	mov	r4, r0
 800b082:	4688      	mov	r8, r1
 800b084:	2900      	cmp	r1, #0
 800b086:	f000 80ab 	beq.w	800b1e0 <_free_r+0x164>
 800b08a:	f7fc fd83 	bl	8007b94 <__malloc_lock>
 800b08e:	f858 2c04 	ldr.w	r2, [r8, #-4]
 800b092:	4d54      	ldr	r5, [pc, #336]	; (800b1e4 <_free_r+0x168>)
 800b094:	f022 0001 	bic.w	r0, r2, #1
 800b098:	f1a8 0308 	sub.w	r3, r8, #8
 800b09c:	181f      	adds	r7, r3, r0
 800b09e:	68a9      	ldr	r1, [r5, #8]
 800b0a0:	687e      	ldr	r6, [r7, #4]
 800b0a2:	428f      	cmp	r7, r1
 800b0a4:	f026 0603 	bic.w	r6, r6, #3
 800b0a8:	f002 0201 	and.w	r2, r2, #1
 800b0ac:	d11b      	bne.n	800b0e6 <_free_r+0x6a>
 800b0ae:	4430      	add	r0, r6
 800b0b0:	b93a      	cbnz	r2, 800b0c2 <_free_r+0x46>
 800b0b2:	f858 2c08 	ldr.w	r2, [r8, #-8]
 800b0b6:	1a9b      	subs	r3, r3, r2
 800b0b8:	4410      	add	r0, r2
 800b0ba:	6899      	ldr	r1, [r3, #8]
 800b0bc:	68da      	ldr	r2, [r3, #12]
 800b0be:	60ca      	str	r2, [r1, #12]
 800b0c0:	6091      	str	r1, [r2, #8]
 800b0c2:	f040 0201 	orr.w	r2, r0, #1
 800b0c6:	605a      	str	r2, [r3, #4]
 800b0c8:	60ab      	str	r3, [r5, #8]
 800b0ca:	4b47      	ldr	r3, [pc, #284]	; (800b1e8 <_free_r+0x16c>)
 800b0cc:	681b      	ldr	r3, [r3, #0]
 800b0ce:	4298      	cmp	r0, r3
 800b0d0:	d304      	bcc.n	800b0dc <_free_r+0x60>
 800b0d2:	4b46      	ldr	r3, [pc, #280]	; (800b1ec <_free_r+0x170>)
 800b0d4:	4620      	mov	r0, r4
 800b0d6:	6819      	ldr	r1, [r3, #0]
 800b0d8:	f7ff ff7a 	bl	800afd0 <_malloc_trim_r>
 800b0dc:	4620      	mov	r0, r4
 800b0de:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 800b0e2:	f7fc bd5d 	b.w	8007ba0 <__malloc_unlock>
 800b0e6:	607e      	str	r6, [r7, #4]
 800b0e8:	2a00      	cmp	r2, #0
 800b0ea:	d139      	bne.n	800b160 <_free_r+0xe4>
 800b0ec:	f858 1c08 	ldr.w	r1, [r8, #-8]
 800b0f0:	1a5b      	subs	r3, r3, r1
 800b0f2:	4408      	add	r0, r1
 800b0f4:	6899      	ldr	r1, [r3, #8]
 800b0f6:	f105 0e08 	add.w	lr, r5, #8
 800b0fa:	4571      	cmp	r1, lr
 800b0fc:	d032      	beq.n	800b164 <_free_r+0xe8>
 800b0fe:	f8d3 e00c 	ldr.w	lr, [r3, #12]
 800b102:	f8c1 e00c 	str.w	lr, [r1, #12]
 800b106:	f8ce 1008 	str.w	r1, [lr, #8]
 800b10a:	19b9      	adds	r1, r7, r6
 800b10c:	6849      	ldr	r1, [r1, #4]
 800b10e:	07c9      	lsls	r1, r1, #31
 800b110:	d40a      	bmi.n	800b128 <_free_r+0xac>
 800b112:	4430      	add	r0, r6
 800b114:	68b9      	ldr	r1, [r7, #8]
 800b116:	bb3a      	cbnz	r2, 800b168 <_free_r+0xec>
 800b118:	4e35      	ldr	r6, [pc, #212]	; (800b1f0 <_free_r+0x174>)
 800b11a:	42b1      	cmp	r1, r6
 800b11c:	d124      	bne.n	800b168 <_free_r+0xec>
 800b11e:	616b      	str	r3, [r5, #20]
 800b120:	612b      	str	r3, [r5, #16]
 800b122:	2201      	movs	r2, #1
 800b124:	60d9      	str	r1, [r3, #12]
 800b126:	6099      	str	r1, [r3, #8]
 800b128:	f040 0101 	orr.w	r1, r0, #1
 800b12c:	6059      	str	r1, [r3, #4]
 800b12e:	5018      	str	r0, [r3, r0]
 800b130:	2a00      	cmp	r2, #0
 800b132:	d1d3      	bne.n	800b0dc <_free_r+0x60>
 800b134:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 800b138:	d21a      	bcs.n	800b170 <_free_r+0xf4>
 800b13a:	08c0      	lsrs	r0, r0, #3
 800b13c:	1081      	asrs	r1, r0, #2
 800b13e:	2201      	movs	r2, #1
 800b140:	408a      	lsls	r2, r1
 800b142:	6869      	ldr	r1, [r5, #4]
 800b144:	3001      	adds	r0, #1
 800b146:	430a      	orrs	r2, r1
 800b148:	606a      	str	r2, [r5, #4]
 800b14a:	eb05 02c0 	add.w	r2, r5, r0, lsl #3
 800b14e:	f855 1030 	ldr.w	r1, [r5, r0, lsl #3]
 800b152:	6099      	str	r1, [r3, #8]
 800b154:	3a08      	subs	r2, #8
 800b156:	60da      	str	r2, [r3, #12]
 800b158:	f845 3030 	str.w	r3, [r5, r0, lsl #3]
 800b15c:	60cb      	str	r3, [r1, #12]
 800b15e:	e7bd      	b.n	800b0dc <_free_r+0x60>
 800b160:	2200      	movs	r2, #0
 800b162:	e7d2      	b.n	800b10a <_free_r+0x8e>
 800b164:	2201      	movs	r2, #1
 800b166:	e7d0      	b.n	800b10a <_free_r+0x8e>
 800b168:	68fe      	ldr	r6, [r7, #12]
 800b16a:	60ce      	str	r6, [r1, #12]
 800b16c:	60b1      	str	r1, [r6, #8]
 800b16e:	e7db      	b.n	800b128 <_free_r+0xac>
 800b170:	0a42      	lsrs	r2, r0, #9
 800b172:	2a04      	cmp	r2, #4
 800b174:	d813      	bhi.n	800b19e <_free_r+0x122>
 800b176:	0982      	lsrs	r2, r0, #6
 800b178:	3238      	adds	r2, #56	; 0x38
 800b17a:	1c51      	adds	r1, r2, #1
 800b17c:	eb05 06c2 	add.w	r6, r5, r2, lsl #3
 800b180:	f855 1031 	ldr.w	r1, [r5, r1, lsl #3]
 800b184:	428e      	cmp	r6, r1
 800b186:	d124      	bne.n	800b1d2 <_free_r+0x156>
 800b188:	2001      	movs	r0, #1
 800b18a:	1092      	asrs	r2, r2, #2
 800b18c:	fa00 f202 	lsl.w	r2, r0, r2
 800b190:	6868      	ldr	r0, [r5, #4]
 800b192:	4302      	orrs	r2, r0
 800b194:	606a      	str	r2, [r5, #4]
 800b196:	60de      	str	r6, [r3, #12]
 800b198:	6099      	str	r1, [r3, #8]
 800b19a:	60b3      	str	r3, [r6, #8]
 800b19c:	e7de      	b.n	800b15c <_free_r+0xe0>
 800b19e:	2a14      	cmp	r2, #20
 800b1a0:	d801      	bhi.n	800b1a6 <_free_r+0x12a>
 800b1a2:	325b      	adds	r2, #91	; 0x5b
 800b1a4:	e7e9      	b.n	800b17a <_free_r+0xfe>
 800b1a6:	2a54      	cmp	r2, #84	; 0x54
 800b1a8:	d802      	bhi.n	800b1b0 <_free_r+0x134>
 800b1aa:	0b02      	lsrs	r2, r0, #12
 800b1ac:	326e      	adds	r2, #110	; 0x6e
 800b1ae:	e7e4      	b.n	800b17a <_free_r+0xfe>
 800b1b0:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 800b1b4:	d802      	bhi.n	800b1bc <_free_r+0x140>
 800b1b6:	0bc2      	lsrs	r2, r0, #15
 800b1b8:	3277      	adds	r2, #119	; 0x77
 800b1ba:	e7de      	b.n	800b17a <_free_r+0xfe>
 800b1bc:	f240 5154 	movw	r1, #1364	; 0x554
 800b1c0:	428a      	cmp	r2, r1
 800b1c2:	bf9a      	itte	ls
 800b1c4:	0c82      	lsrls	r2, r0, #18
 800b1c6:	327c      	addls	r2, #124	; 0x7c
 800b1c8:	227e      	movhi	r2, #126	; 0x7e
 800b1ca:	e7d6      	b.n	800b17a <_free_r+0xfe>
 800b1cc:	6889      	ldr	r1, [r1, #8]
 800b1ce:	428e      	cmp	r6, r1
 800b1d0:	d004      	beq.n	800b1dc <_free_r+0x160>
 800b1d2:	684a      	ldr	r2, [r1, #4]
 800b1d4:	f022 0203 	bic.w	r2, r2, #3
 800b1d8:	4290      	cmp	r0, r2
 800b1da:	d3f7      	bcc.n	800b1cc <_free_r+0x150>
 800b1dc:	68ce      	ldr	r6, [r1, #12]
 800b1de:	e7da      	b.n	800b196 <_free_r+0x11a>
 800b1e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800b1e4:	20000150 	.word	0x20000150
 800b1e8:	2000055c 	.word	0x2000055c
 800b1ec:	200084f8 	.word	0x200084f8
 800b1f0:	20000158 	.word	0x20000158

0800b1f4 <__sfvwrite_r>:
 800b1f4:	6893      	ldr	r3, [r2, #8]
 800b1f6:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b1fa:	4607      	mov	r7, r0
 800b1fc:	460c      	mov	r4, r1
 800b1fe:	4690      	mov	r8, r2
 800b200:	b91b      	cbnz	r3, 800b20a <__sfvwrite_r+0x16>
 800b202:	2000      	movs	r0, #0
 800b204:	b003      	add	sp, #12
 800b206:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800b20a:	898b      	ldrh	r3, [r1, #12]
 800b20c:	0718      	lsls	r0, r3, #28
 800b20e:	d526      	bpl.n	800b25e <__sfvwrite_r+0x6a>
 800b210:	690b      	ldr	r3, [r1, #16]
 800b212:	b323      	cbz	r3, 800b25e <__sfvwrite_r+0x6a>
 800b214:	89a3      	ldrh	r3, [r4, #12]
 800b216:	f8d8 6000 	ldr.w	r6, [r8]
 800b21a:	f013 0902 	ands.w	r9, r3, #2
 800b21e:	d02d      	beq.n	800b27c <__sfvwrite_r+0x88>
 800b220:	f04f 0a00 	mov.w	sl, #0
 800b224:	f8df b264 	ldr.w	fp, [pc, #612]	; 800b48c <__sfvwrite_r+0x298>
 800b228:	46d1      	mov	r9, sl
 800b22a:	f1b9 0f00 	cmp.w	r9, #0
 800b22e:	d01f      	beq.n	800b270 <__sfvwrite_r+0x7c>
 800b230:	45d9      	cmp	r9, fp
 800b232:	464b      	mov	r3, r9
 800b234:	4652      	mov	r2, sl
 800b236:	bf28      	it	cs
 800b238:	465b      	movcs	r3, fp
 800b23a:	6a21      	ldr	r1, [r4, #32]
 800b23c:	6aa5      	ldr	r5, [r4, #40]	; 0x28
 800b23e:	4638      	mov	r0, r7
 800b240:	47a8      	blx	r5
 800b242:	2800      	cmp	r0, #0
 800b244:	f340 8089 	ble.w	800b35a <__sfvwrite_r+0x166>
 800b248:	f8d8 3008 	ldr.w	r3, [r8, #8]
 800b24c:	4482      	add	sl, r0
 800b24e:	eba9 0900 	sub.w	r9, r9, r0
 800b252:	1a18      	subs	r0, r3, r0
 800b254:	f8c8 0008 	str.w	r0, [r8, #8]
 800b258:	2800      	cmp	r0, #0
 800b25a:	d1e6      	bne.n	800b22a <__sfvwrite_r+0x36>
 800b25c:	e7d1      	b.n	800b202 <__sfvwrite_r+0xe>
 800b25e:	4621      	mov	r1, r4
 800b260:	4638      	mov	r0, r7
 800b262:	f7fe fe45 	bl	8009ef0 <__swsetup_r>
 800b266:	2800      	cmp	r0, #0
 800b268:	d0d4      	beq.n	800b214 <__sfvwrite_r+0x20>
 800b26a:	f04f 30ff 	mov.w	r0, #4294967295
 800b26e:	e7c9      	b.n	800b204 <__sfvwrite_r+0x10>
 800b270:	f8d6 a000 	ldr.w	sl, [r6]
 800b274:	f8d6 9004 	ldr.w	r9, [r6, #4]
 800b278:	3608      	adds	r6, #8
 800b27a:	e7d6      	b.n	800b22a <__sfvwrite_r+0x36>
 800b27c:	f013 0301 	ands.w	r3, r3, #1
 800b280:	d043      	beq.n	800b30a <__sfvwrite_r+0x116>
 800b282:	4648      	mov	r0, r9
 800b284:	46ca      	mov	sl, r9
 800b286:	46cb      	mov	fp, r9
 800b288:	f1bb 0f00 	cmp.w	fp, #0
 800b28c:	f000 80d9 	beq.w	800b442 <__sfvwrite_r+0x24e>
 800b290:	b950      	cbnz	r0, 800b2a8 <__sfvwrite_r+0xb4>
 800b292:	465a      	mov	r2, fp
 800b294:	210a      	movs	r1, #10
 800b296:	4650      	mov	r0, sl
 800b298:	f7f4 ffb2 	bl	8000200 <memchr>
 800b29c:	2800      	cmp	r0, #0
 800b29e:	f000 80d5 	beq.w	800b44c <__sfvwrite_r+0x258>
 800b2a2:	3001      	adds	r0, #1
 800b2a4:	eba0 090a 	sub.w	r9, r0, sl
 800b2a8:	6820      	ldr	r0, [r4, #0]
 800b2aa:	6921      	ldr	r1, [r4, #16]
 800b2ac:	6962      	ldr	r2, [r4, #20]
 800b2ae:	45d9      	cmp	r9, fp
 800b2b0:	464b      	mov	r3, r9
 800b2b2:	bf28      	it	cs
 800b2b4:	465b      	movcs	r3, fp
 800b2b6:	4288      	cmp	r0, r1
 800b2b8:	f240 80cb 	bls.w	800b452 <__sfvwrite_r+0x25e>
 800b2bc:	68a5      	ldr	r5, [r4, #8]
 800b2be:	4415      	add	r5, r2
 800b2c0:	42ab      	cmp	r3, r5
 800b2c2:	f340 80c6 	ble.w	800b452 <__sfvwrite_r+0x25e>
 800b2c6:	4651      	mov	r1, sl
 800b2c8:	462a      	mov	r2, r5
 800b2ca:	f000 f9a1 	bl	800b610 <memmove>
 800b2ce:	6823      	ldr	r3, [r4, #0]
 800b2d0:	442b      	add	r3, r5
 800b2d2:	6023      	str	r3, [r4, #0]
 800b2d4:	4621      	mov	r1, r4
 800b2d6:	4638      	mov	r0, r7
 800b2d8:	f7ff fd66 	bl	800ada8 <_fflush_r>
 800b2dc:	2800      	cmp	r0, #0
 800b2de:	d13c      	bne.n	800b35a <__sfvwrite_r+0x166>
 800b2e0:	ebb9 0905 	subs.w	r9, r9, r5
 800b2e4:	f040 80cf 	bne.w	800b486 <__sfvwrite_r+0x292>
 800b2e8:	4621      	mov	r1, r4
 800b2ea:	4638      	mov	r0, r7
 800b2ec:	f7ff fd5c 	bl	800ada8 <_fflush_r>
 800b2f0:	2800      	cmp	r0, #0
 800b2f2:	d132      	bne.n	800b35a <__sfvwrite_r+0x166>
 800b2f4:	f8d8 3008 	ldr.w	r3, [r8, #8]
 800b2f8:	44aa      	add	sl, r5
 800b2fa:	ebab 0b05 	sub.w	fp, fp, r5
 800b2fe:	1b5d      	subs	r5, r3, r5
 800b300:	f8c8 5008 	str.w	r5, [r8, #8]
 800b304:	2d00      	cmp	r5, #0
 800b306:	d1bf      	bne.n	800b288 <__sfvwrite_r+0x94>
 800b308:	e77b      	b.n	800b202 <__sfvwrite_r+0xe>
 800b30a:	4699      	mov	r9, r3
 800b30c:	469a      	mov	sl, r3
 800b30e:	f1ba 0f00 	cmp.w	sl, #0
 800b312:	d027      	beq.n	800b364 <__sfvwrite_r+0x170>
 800b314:	89a2      	ldrh	r2, [r4, #12]
 800b316:	68a5      	ldr	r5, [r4, #8]
 800b318:	0591      	lsls	r1, r2, #22
 800b31a:	d565      	bpl.n	800b3e8 <__sfvwrite_r+0x1f4>
 800b31c:	45aa      	cmp	sl, r5
 800b31e:	d33b      	bcc.n	800b398 <__sfvwrite_r+0x1a4>
 800b320:	f412 6f90 	tst.w	r2, #1152	; 0x480
 800b324:	d036      	beq.n	800b394 <__sfvwrite_r+0x1a0>
 800b326:	6921      	ldr	r1, [r4, #16]
 800b328:	6823      	ldr	r3, [r4, #0]
 800b32a:	1a5b      	subs	r3, r3, r1
 800b32c:	9301      	str	r3, [sp, #4]
 800b32e:	6963      	ldr	r3, [r4, #20]
 800b330:	2002      	movs	r0, #2
 800b332:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800b336:	fb93 fbf0 	sdiv	fp, r3, r0
 800b33a:	9b01      	ldr	r3, [sp, #4]
 800b33c:	1c58      	adds	r0, r3, #1
 800b33e:	4450      	add	r0, sl
 800b340:	4583      	cmp	fp, r0
 800b342:	bf38      	it	cc
 800b344:	4683      	movcc	fp, r0
 800b346:	0553      	lsls	r3, r2, #21
 800b348:	d53e      	bpl.n	800b3c8 <__sfvwrite_r+0x1d4>
 800b34a:	4659      	mov	r1, fp
 800b34c:	4638      	mov	r0, r7
 800b34e:	f7fc f9ff 	bl	8007750 <_malloc_r>
 800b352:	4605      	mov	r5, r0
 800b354:	b950      	cbnz	r0, 800b36c <__sfvwrite_r+0x178>
 800b356:	230c      	movs	r3, #12
 800b358:	603b      	str	r3, [r7, #0]
 800b35a:	89a3      	ldrh	r3, [r4, #12]
 800b35c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800b360:	81a3      	strh	r3, [r4, #12]
 800b362:	e782      	b.n	800b26a <__sfvwrite_r+0x76>
 800b364:	e896 0600 	ldmia.w	r6, {r9, sl}
 800b368:	3608      	adds	r6, #8
 800b36a:	e7d0      	b.n	800b30e <__sfvwrite_r+0x11a>
 800b36c:	9a01      	ldr	r2, [sp, #4]
 800b36e:	6921      	ldr	r1, [r4, #16]
 800b370:	f7fc fbfc 	bl	8007b6c <memcpy>
 800b374:	89a2      	ldrh	r2, [r4, #12]
 800b376:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
 800b37a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800b37e:	81a2      	strh	r2, [r4, #12]
 800b380:	9b01      	ldr	r3, [sp, #4]
 800b382:	6125      	str	r5, [r4, #16]
 800b384:	441d      	add	r5, r3
 800b386:	ebab 0303 	sub.w	r3, fp, r3
 800b38a:	6025      	str	r5, [r4, #0]
 800b38c:	f8c4 b014 	str.w	fp, [r4, #20]
 800b390:	4655      	mov	r5, sl
 800b392:	60a3      	str	r3, [r4, #8]
 800b394:	45aa      	cmp	sl, r5
 800b396:	d200      	bcs.n	800b39a <__sfvwrite_r+0x1a6>
 800b398:	4655      	mov	r5, sl
 800b39a:	462a      	mov	r2, r5
 800b39c:	4649      	mov	r1, r9
 800b39e:	6820      	ldr	r0, [r4, #0]
 800b3a0:	f000 f936 	bl	800b610 <memmove>
 800b3a4:	68a3      	ldr	r3, [r4, #8]
 800b3a6:	1b5b      	subs	r3, r3, r5
 800b3a8:	60a3      	str	r3, [r4, #8]
 800b3aa:	6823      	ldr	r3, [r4, #0]
 800b3ac:	441d      	add	r5, r3
 800b3ae:	6025      	str	r5, [r4, #0]
 800b3b0:	4655      	mov	r5, sl
 800b3b2:	f8d8 3008 	ldr.w	r3, [r8, #8]
 800b3b6:	44a9      	add	r9, r5
 800b3b8:	ebaa 0a05 	sub.w	sl, sl, r5
 800b3bc:	1b5d      	subs	r5, r3, r5
 800b3be:	f8c8 5008 	str.w	r5, [r8, #8]
 800b3c2:	2d00      	cmp	r5, #0
 800b3c4:	d1a3      	bne.n	800b30e <__sfvwrite_r+0x11a>
 800b3c6:	e71c      	b.n	800b202 <__sfvwrite_r+0xe>
 800b3c8:	465a      	mov	r2, fp
 800b3ca:	4638      	mov	r0, r7
 800b3cc:	f000 fc0a 	bl	800bbe4 <_realloc_r>
 800b3d0:	4605      	mov	r5, r0
 800b3d2:	2800      	cmp	r0, #0
 800b3d4:	d1d4      	bne.n	800b380 <__sfvwrite_r+0x18c>
 800b3d6:	6921      	ldr	r1, [r4, #16]
 800b3d8:	4638      	mov	r0, r7
 800b3da:	f7ff fe4f 	bl	800b07c <_free_r>
 800b3de:	89a3      	ldrh	r3, [r4, #12]
 800b3e0:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800b3e4:	81a3      	strh	r3, [r4, #12]
 800b3e6:	e7b6      	b.n	800b356 <__sfvwrite_r+0x162>
 800b3e8:	6820      	ldr	r0, [r4, #0]
 800b3ea:	6923      	ldr	r3, [r4, #16]
 800b3ec:	4298      	cmp	r0, r3
 800b3ee:	d802      	bhi.n	800b3f6 <__sfvwrite_r+0x202>
 800b3f0:	6962      	ldr	r2, [r4, #20]
 800b3f2:	4592      	cmp	sl, r2
 800b3f4:	d215      	bcs.n	800b422 <__sfvwrite_r+0x22e>
 800b3f6:	4555      	cmp	r5, sl
 800b3f8:	bf28      	it	cs
 800b3fa:	4655      	movcs	r5, sl
 800b3fc:	462a      	mov	r2, r5
 800b3fe:	4649      	mov	r1, r9
 800b400:	f000 f906 	bl	800b610 <memmove>
 800b404:	68a3      	ldr	r3, [r4, #8]
 800b406:	6822      	ldr	r2, [r4, #0]
 800b408:	1b5b      	subs	r3, r3, r5
 800b40a:	442a      	add	r2, r5
 800b40c:	60a3      	str	r3, [r4, #8]
 800b40e:	6022      	str	r2, [r4, #0]
 800b410:	2b00      	cmp	r3, #0
 800b412:	d1ce      	bne.n	800b3b2 <__sfvwrite_r+0x1be>
 800b414:	4621      	mov	r1, r4
 800b416:	4638      	mov	r0, r7
 800b418:	f7ff fcc6 	bl	800ada8 <_fflush_r>
 800b41c:	2800      	cmp	r0, #0
 800b41e:	d0c8      	beq.n	800b3b2 <__sfvwrite_r+0x1be>
 800b420:	e79b      	b.n	800b35a <__sfvwrite_r+0x166>
 800b422:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 800b426:	4553      	cmp	r3, sl
 800b428:	bf28      	it	cs
 800b42a:	4653      	movcs	r3, sl
 800b42c:	6aa5      	ldr	r5, [r4, #40]	; 0x28
 800b42e:	fb93 f3f2 	sdiv	r3, r3, r2
 800b432:	6a21      	ldr	r1, [r4, #32]
 800b434:	4353      	muls	r3, r2
 800b436:	4638      	mov	r0, r7
 800b438:	464a      	mov	r2, r9
 800b43a:	47a8      	blx	r5
 800b43c:	1e05      	subs	r5, r0, #0
 800b43e:	dcb8      	bgt.n	800b3b2 <__sfvwrite_r+0x1be>
 800b440:	e78b      	b.n	800b35a <__sfvwrite_r+0x166>
 800b442:	e896 0c00 	ldmia.w	r6, {sl, fp}
 800b446:	2000      	movs	r0, #0
 800b448:	3608      	adds	r6, #8
 800b44a:	e71d      	b.n	800b288 <__sfvwrite_r+0x94>
 800b44c:	f10b 0901 	add.w	r9, fp, #1
 800b450:	e72a      	b.n	800b2a8 <__sfvwrite_r+0xb4>
 800b452:	4293      	cmp	r3, r2
 800b454:	db09      	blt.n	800b46a <__sfvwrite_r+0x276>
 800b456:	6aa5      	ldr	r5, [r4, #40]	; 0x28
 800b458:	6a21      	ldr	r1, [r4, #32]
 800b45a:	4613      	mov	r3, r2
 800b45c:	4638      	mov	r0, r7
 800b45e:	4652      	mov	r2, sl
 800b460:	47a8      	blx	r5
 800b462:	1e05      	subs	r5, r0, #0
 800b464:	f73f af3c 	bgt.w	800b2e0 <__sfvwrite_r+0xec>
 800b468:	e777      	b.n	800b35a <__sfvwrite_r+0x166>
 800b46a:	461a      	mov	r2, r3
 800b46c:	4651      	mov	r1, sl
 800b46e:	9301      	str	r3, [sp, #4]
 800b470:	f000 f8ce 	bl	800b610 <memmove>
 800b474:	9b01      	ldr	r3, [sp, #4]
 800b476:	68a2      	ldr	r2, [r4, #8]
 800b478:	1ad2      	subs	r2, r2, r3
 800b47a:	60a2      	str	r2, [r4, #8]
 800b47c:	6822      	ldr	r2, [r4, #0]
 800b47e:	441a      	add	r2, r3
 800b480:	6022      	str	r2, [r4, #0]
 800b482:	461d      	mov	r5, r3
 800b484:	e72c      	b.n	800b2e0 <__sfvwrite_r+0xec>
 800b486:	2001      	movs	r0, #1
 800b488:	e734      	b.n	800b2f4 <__sfvwrite_r+0x100>
 800b48a:	bf00      	nop
 800b48c:	7ffffc00 	.word	0x7ffffc00

0800b490 <_fwalk_reent>:
 800b490:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800b494:	4680      	mov	r8, r0
 800b496:	4689      	mov	r9, r1
 800b498:	f100 04d8 	add.w	r4, r0, #216	; 0xd8
 800b49c:	2600      	movs	r6, #0
 800b49e:	b914      	cbnz	r4, 800b4a6 <_fwalk_reent+0x16>
 800b4a0:	4630      	mov	r0, r6
 800b4a2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800b4a6:	68a5      	ldr	r5, [r4, #8]
 800b4a8:	6867      	ldr	r7, [r4, #4]
 800b4aa:	3f01      	subs	r7, #1
 800b4ac:	d501      	bpl.n	800b4b2 <_fwalk_reent+0x22>
 800b4ae:	6824      	ldr	r4, [r4, #0]
 800b4b0:	e7f5      	b.n	800b49e <_fwalk_reent+0xe>
 800b4b2:	89ab      	ldrh	r3, [r5, #12]
 800b4b4:	2b01      	cmp	r3, #1
 800b4b6:	d907      	bls.n	800b4c8 <_fwalk_reent+0x38>
 800b4b8:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 800b4bc:	3301      	adds	r3, #1
 800b4be:	d003      	beq.n	800b4c8 <_fwalk_reent+0x38>
 800b4c0:	4629      	mov	r1, r5
 800b4c2:	4640      	mov	r0, r8
 800b4c4:	47c8      	blx	r9
 800b4c6:	4306      	orrs	r6, r0
 800b4c8:	3568      	adds	r5, #104	; 0x68
 800b4ca:	e7ee      	b.n	800b4aa <_fwalk_reent+0x1a>

0800b4cc <__locale_mb_cur_max>:
 800b4cc:	4b04      	ldr	r3, [pc, #16]	; (800b4e0 <__locale_mb_cur_max+0x14>)
 800b4ce:	4a05      	ldr	r2, [pc, #20]	; (800b4e4 <__locale_mb_cur_max+0x18>)
 800b4d0:	681b      	ldr	r3, [r3, #0]
 800b4d2:	6a1b      	ldr	r3, [r3, #32]
 800b4d4:	2b00      	cmp	r3, #0
 800b4d6:	bf08      	it	eq
 800b4d8:	4613      	moveq	r3, r2
 800b4da:	f893 0128 	ldrb.w	r0, [r3, #296]	; 0x128
 800b4de:	4770      	bx	lr
 800b4e0:	2000005c 	.word	0x2000005c
 800b4e4:	20000560 	.word	0x20000560

0800b4e8 <__locale_ctype_ptr_l>:
 800b4e8:	f8d0 00ec 	ldr.w	r0, [r0, #236]	; 0xec
 800b4ec:	4770      	bx	lr
	...

0800b4f0 <_localeconv_r>:
 800b4f0:	4b04      	ldr	r3, [pc, #16]	; (800b504 <_localeconv_r+0x14>)
 800b4f2:	681b      	ldr	r3, [r3, #0]
 800b4f4:	6a18      	ldr	r0, [r3, #32]
 800b4f6:	4b04      	ldr	r3, [pc, #16]	; (800b508 <_localeconv_r+0x18>)
 800b4f8:	2800      	cmp	r0, #0
 800b4fa:	bf08      	it	eq
 800b4fc:	4618      	moveq	r0, r3
 800b4fe:	30f0      	adds	r0, #240	; 0xf0
 800b500:	4770      	bx	lr
 800b502:	bf00      	nop
 800b504:	2000005c 	.word	0x2000005c
 800b508:	20000560 	.word	0x20000560

0800b50c <__retarget_lock_init_recursive>:
 800b50c:	4770      	bx	lr

0800b50e <__retarget_lock_close_recursive>:
 800b50e:	4770      	bx	lr

0800b510 <__retarget_lock_acquire_recursive>:
 800b510:	4770      	bx	lr

0800b512 <__retarget_lock_release_recursive>:
 800b512:	4770      	bx	lr

0800b514 <__swhatbuf_r>:
 800b514:	b570      	push	{r4, r5, r6, lr}
 800b516:	460e      	mov	r6, r1
 800b518:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800b51c:	2900      	cmp	r1, #0
 800b51e:	b090      	sub	sp, #64	; 0x40
 800b520:	4614      	mov	r4, r2
 800b522:	461d      	mov	r5, r3
 800b524:	da09      	bge.n	800b53a <__swhatbuf_r+0x26>
 800b526:	89b3      	ldrh	r3, [r6, #12]
 800b528:	2200      	movs	r2, #0
 800b52a:	f013 0080 	ands.w	r0, r3, #128	; 0x80
 800b52e:	602a      	str	r2, [r5, #0]
 800b530:	d116      	bne.n	800b560 <__swhatbuf_r+0x4c>
 800b532:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800b536:	6023      	str	r3, [r4, #0]
 800b538:	e015      	b.n	800b566 <__swhatbuf_r+0x52>
 800b53a:	aa01      	add	r2, sp, #4
 800b53c:	f000 fef8 	bl	800c330 <_fstat_r>
 800b540:	2800      	cmp	r0, #0
 800b542:	dbf0      	blt.n	800b526 <__swhatbuf_r+0x12>
 800b544:	9a02      	ldr	r2, [sp, #8]
 800b546:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
 800b54a:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
 800b54e:	425a      	negs	r2, r3
 800b550:	415a      	adcs	r2, r3
 800b552:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800b556:	602a      	str	r2, [r5, #0]
 800b558:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800b55c:	6023      	str	r3, [r4, #0]
 800b55e:	e002      	b.n	800b566 <__swhatbuf_r+0x52>
 800b560:	2340      	movs	r3, #64	; 0x40
 800b562:	6023      	str	r3, [r4, #0]
 800b564:	4610      	mov	r0, r2
 800b566:	b010      	add	sp, #64	; 0x40
 800b568:	bd70      	pop	{r4, r5, r6, pc}
	...

0800b56c <__smakebuf_r>:
 800b56c:	898b      	ldrh	r3, [r1, #12]
 800b56e:	b573      	push	{r0, r1, r4, r5, r6, lr}
 800b570:	079d      	lsls	r5, r3, #30
 800b572:	4606      	mov	r6, r0
 800b574:	460c      	mov	r4, r1
 800b576:	d507      	bpl.n	800b588 <__smakebuf_r+0x1c>
 800b578:	f104 0347 	add.w	r3, r4, #71	; 0x47
 800b57c:	6023      	str	r3, [r4, #0]
 800b57e:	6123      	str	r3, [r4, #16]
 800b580:	2301      	movs	r3, #1
 800b582:	6163      	str	r3, [r4, #20]
 800b584:	b002      	add	sp, #8
 800b586:	bd70      	pop	{r4, r5, r6, pc}
 800b588:	ab01      	add	r3, sp, #4
 800b58a:	466a      	mov	r2, sp
 800b58c:	f7ff ffc2 	bl	800b514 <__swhatbuf_r>
 800b590:	9900      	ldr	r1, [sp, #0]
 800b592:	4605      	mov	r5, r0
 800b594:	4630      	mov	r0, r6
 800b596:	f7fc f8db 	bl	8007750 <_malloc_r>
 800b59a:	b948      	cbnz	r0, 800b5b0 <__smakebuf_r+0x44>
 800b59c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800b5a0:	059a      	lsls	r2, r3, #22
 800b5a2:	d4ef      	bmi.n	800b584 <__smakebuf_r+0x18>
 800b5a4:	f023 0303 	bic.w	r3, r3, #3
 800b5a8:	f043 0302 	orr.w	r3, r3, #2
 800b5ac:	81a3      	strh	r3, [r4, #12]
 800b5ae:	e7e3      	b.n	800b578 <__smakebuf_r+0xc>
 800b5b0:	4b0d      	ldr	r3, [pc, #52]	; (800b5e8 <__smakebuf_r+0x7c>)
 800b5b2:	62b3      	str	r3, [r6, #40]	; 0x28
 800b5b4:	89a3      	ldrh	r3, [r4, #12]
 800b5b6:	6020      	str	r0, [r4, #0]
 800b5b8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800b5bc:	81a3      	strh	r3, [r4, #12]
 800b5be:	9b00      	ldr	r3, [sp, #0]
 800b5c0:	6163      	str	r3, [r4, #20]
 800b5c2:	9b01      	ldr	r3, [sp, #4]
 800b5c4:	6120      	str	r0, [r4, #16]
 800b5c6:	b15b      	cbz	r3, 800b5e0 <__smakebuf_r+0x74>
 800b5c8:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 800b5cc:	4630      	mov	r0, r6
 800b5ce:	f000 fec1 	bl	800c354 <_isatty_r>
 800b5d2:	b128      	cbz	r0, 800b5e0 <__smakebuf_r+0x74>
 800b5d4:	89a3      	ldrh	r3, [r4, #12]
 800b5d6:	f023 0303 	bic.w	r3, r3, #3
 800b5da:	f043 0301 	orr.w	r3, r3, #1
 800b5de:	81a3      	strh	r3, [r4, #12]
 800b5e0:	89a3      	ldrh	r3, [r4, #12]
 800b5e2:	431d      	orrs	r5, r3
 800b5e4:	81a5      	strh	r5, [r4, #12]
 800b5e6:	e7cd      	b.n	800b584 <__smakebuf_r+0x18>
 800b5e8:	0800ae21 	.word	0x0800ae21

0800b5ec <__ascii_mbtowc>:
 800b5ec:	b082      	sub	sp, #8
 800b5ee:	b901      	cbnz	r1, 800b5f2 <__ascii_mbtowc+0x6>
 800b5f0:	a901      	add	r1, sp, #4
 800b5f2:	b142      	cbz	r2, 800b606 <__ascii_mbtowc+0x1a>
 800b5f4:	b14b      	cbz	r3, 800b60a <__ascii_mbtowc+0x1e>
 800b5f6:	7813      	ldrb	r3, [r2, #0]
 800b5f8:	600b      	str	r3, [r1, #0]
 800b5fa:	7812      	ldrb	r2, [r2, #0]
 800b5fc:	1c10      	adds	r0, r2, #0
 800b5fe:	bf18      	it	ne
 800b600:	2001      	movne	r0, #1
 800b602:	b002      	add	sp, #8
 800b604:	4770      	bx	lr
 800b606:	4610      	mov	r0, r2
 800b608:	e7fb      	b.n	800b602 <__ascii_mbtowc+0x16>
 800b60a:	f06f 0001 	mvn.w	r0, #1
 800b60e:	e7f8      	b.n	800b602 <__ascii_mbtowc+0x16>

0800b610 <memmove>:
 800b610:	4288      	cmp	r0, r1
 800b612:	b510      	push	{r4, lr}
 800b614:	eb01 0302 	add.w	r3, r1, r2
 800b618:	d803      	bhi.n	800b622 <memmove+0x12>
 800b61a:	1e42      	subs	r2, r0, #1
 800b61c:	4299      	cmp	r1, r3
 800b61e:	d10c      	bne.n	800b63a <memmove+0x2a>
 800b620:	bd10      	pop	{r4, pc}
 800b622:	4298      	cmp	r0, r3
 800b624:	d2f9      	bcs.n	800b61a <memmove+0xa>
 800b626:	1881      	adds	r1, r0, r2
 800b628:	1ad2      	subs	r2, r2, r3
 800b62a:	42d3      	cmn	r3, r2
 800b62c:	d100      	bne.n	800b630 <memmove+0x20>
 800b62e:	bd10      	pop	{r4, pc}
 800b630:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 800b634:	f801 4d01 	strb.w	r4, [r1, #-1]!
 800b638:	e7f7      	b.n	800b62a <memmove+0x1a>
 800b63a:	f811 4b01 	ldrb.w	r4, [r1], #1
 800b63e:	f802 4f01 	strb.w	r4, [r2, #1]!
 800b642:	e7eb      	b.n	800b61c <memmove+0xc>

0800b644 <_Balloc>:
 800b644:	b570      	push	{r4, r5, r6, lr}
 800b646:	6a45      	ldr	r5, [r0, #36]	; 0x24
 800b648:	4604      	mov	r4, r0
 800b64a:	460e      	mov	r6, r1
 800b64c:	b93d      	cbnz	r5, 800b65e <_Balloc+0x1a>
 800b64e:	2010      	movs	r0, #16
 800b650:	f7fc f876 	bl	8007740 <malloc>
 800b654:	6260      	str	r0, [r4, #36]	; 0x24
 800b656:	6045      	str	r5, [r0, #4]
 800b658:	6085      	str	r5, [r0, #8]
 800b65a:	6005      	str	r5, [r0, #0]
 800b65c:	60c5      	str	r5, [r0, #12]
 800b65e:	6a65      	ldr	r5, [r4, #36]	; 0x24
 800b660:	68eb      	ldr	r3, [r5, #12]
 800b662:	b183      	cbz	r3, 800b686 <_Balloc+0x42>
 800b664:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800b666:	68db      	ldr	r3, [r3, #12]
 800b668:	f853 0026 	ldr.w	r0, [r3, r6, lsl #2]
 800b66c:	b9b8      	cbnz	r0, 800b69e <_Balloc+0x5a>
 800b66e:	2101      	movs	r1, #1
 800b670:	fa01 f506 	lsl.w	r5, r1, r6
 800b674:	1d6a      	adds	r2, r5, #5
 800b676:	0092      	lsls	r2, r2, #2
 800b678:	4620      	mov	r0, r4
 800b67a:	f000 fd45 	bl	800c108 <_calloc_r>
 800b67e:	b160      	cbz	r0, 800b69a <_Balloc+0x56>
 800b680:	6046      	str	r6, [r0, #4]
 800b682:	6085      	str	r5, [r0, #8]
 800b684:	e00e      	b.n	800b6a4 <_Balloc+0x60>
 800b686:	2221      	movs	r2, #33	; 0x21
 800b688:	2104      	movs	r1, #4
 800b68a:	4620      	mov	r0, r4
 800b68c:	f000 fd3c 	bl	800c108 <_calloc_r>
 800b690:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800b692:	60e8      	str	r0, [r5, #12]
 800b694:	68db      	ldr	r3, [r3, #12]
 800b696:	2b00      	cmp	r3, #0
 800b698:	d1e4      	bne.n	800b664 <_Balloc+0x20>
 800b69a:	2000      	movs	r0, #0
 800b69c:	bd70      	pop	{r4, r5, r6, pc}
 800b69e:	6802      	ldr	r2, [r0, #0]
 800b6a0:	f843 2026 	str.w	r2, [r3, r6, lsl #2]
 800b6a4:	2300      	movs	r3, #0
 800b6a6:	6103      	str	r3, [r0, #16]
 800b6a8:	60c3      	str	r3, [r0, #12]
 800b6aa:	bd70      	pop	{r4, r5, r6, pc}

0800b6ac <_Bfree>:
 800b6ac:	b570      	push	{r4, r5, r6, lr}
 800b6ae:	6a44      	ldr	r4, [r0, #36]	; 0x24
 800b6b0:	4606      	mov	r6, r0
 800b6b2:	460d      	mov	r5, r1
 800b6b4:	b93c      	cbnz	r4, 800b6c6 <_Bfree+0x1a>
 800b6b6:	2010      	movs	r0, #16
 800b6b8:	f7fc f842 	bl	8007740 <malloc>
 800b6bc:	6270      	str	r0, [r6, #36]	; 0x24
 800b6be:	6044      	str	r4, [r0, #4]
 800b6c0:	6084      	str	r4, [r0, #8]
 800b6c2:	6004      	str	r4, [r0, #0]
 800b6c4:	60c4      	str	r4, [r0, #12]
 800b6c6:	b13d      	cbz	r5, 800b6d8 <_Bfree+0x2c>
 800b6c8:	6a73      	ldr	r3, [r6, #36]	; 0x24
 800b6ca:	686a      	ldr	r2, [r5, #4]
 800b6cc:	68db      	ldr	r3, [r3, #12]
 800b6ce:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 800b6d2:	6029      	str	r1, [r5, #0]
 800b6d4:	f843 5022 	str.w	r5, [r3, r2, lsl #2]
 800b6d8:	bd70      	pop	{r4, r5, r6, pc}

0800b6da <__multadd>:
 800b6da:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800b6de:	690d      	ldr	r5, [r1, #16]
 800b6e0:	461f      	mov	r7, r3
 800b6e2:	4606      	mov	r6, r0
 800b6e4:	460c      	mov	r4, r1
 800b6e6:	f101 0e14 	add.w	lr, r1, #20
 800b6ea:	2300      	movs	r3, #0
 800b6ec:	f8de 0000 	ldr.w	r0, [lr]
 800b6f0:	b281      	uxth	r1, r0
 800b6f2:	fb02 7101 	mla	r1, r2, r1, r7
 800b6f6:	0c0f      	lsrs	r7, r1, #16
 800b6f8:	0c00      	lsrs	r0, r0, #16
 800b6fa:	fb02 7000 	mla	r0, r2, r0, r7
 800b6fe:	b289      	uxth	r1, r1
 800b700:	3301      	adds	r3, #1
 800b702:	eb01 4100 	add.w	r1, r1, r0, lsl #16
 800b706:	429d      	cmp	r5, r3
 800b708:	ea4f 4710 	mov.w	r7, r0, lsr #16
 800b70c:	f84e 1b04 	str.w	r1, [lr], #4
 800b710:	dcec      	bgt.n	800b6ec <__multadd+0x12>
 800b712:	b1d7      	cbz	r7, 800b74a <__multadd+0x70>
 800b714:	68a3      	ldr	r3, [r4, #8]
 800b716:	429d      	cmp	r5, r3
 800b718:	db12      	blt.n	800b740 <__multadd+0x66>
 800b71a:	6861      	ldr	r1, [r4, #4]
 800b71c:	4630      	mov	r0, r6
 800b71e:	3101      	adds	r1, #1
 800b720:	f7ff ff90 	bl	800b644 <_Balloc>
 800b724:	6922      	ldr	r2, [r4, #16]
 800b726:	3202      	adds	r2, #2
 800b728:	f104 010c 	add.w	r1, r4, #12
 800b72c:	4680      	mov	r8, r0
 800b72e:	0092      	lsls	r2, r2, #2
 800b730:	300c      	adds	r0, #12
 800b732:	f7fc fa1b 	bl	8007b6c <memcpy>
 800b736:	4621      	mov	r1, r4
 800b738:	4630      	mov	r0, r6
 800b73a:	f7ff ffb7 	bl	800b6ac <_Bfree>
 800b73e:	4644      	mov	r4, r8
 800b740:	eb04 0385 	add.w	r3, r4, r5, lsl #2
 800b744:	3501      	adds	r5, #1
 800b746:	615f      	str	r7, [r3, #20]
 800b748:	6125      	str	r5, [r4, #16]
 800b74a:	4620      	mov	r0, r4
 800b74c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800b750 <__hi0bits>:
 800b750:	0c02      	lsrs	r2, r0, #16
 800b752:	0412      	lsls	r2, r2, #16
 800b754:	4603      	mov	r3, r0
 800b756:	b9b2      	cbnz	r2, 800b786 <__hi0bits+0x36>
 800b758:	0403      	lsls	r3, r0, #16
 800b75a:	2010      	movs	r0, #16
 800b75c:	f013 4f7f 	tst.w	r3, #4278190080	; 0xff000000
 800b760:	bf04      	itt	eq
 800b762:	021b      	lsleq	r3, r3, #8
 800b764:	3008      	addeq	r0, #8
 800b766:	f013 4f70 	tst.w	r3, #4026531840	; 0xf0000000
 800b76a:	bf04      	itt	eq
 800b76c:	011b      	lsleq	r3, r3, #4
 800b76e:	3004      	addeq	r0, #4
 800b770:	f013 4f40 	tst.w	r3, #3221225472	; 0xc0000000
 800b774:	bf04      	itt	eq
 800b776:	009b      	lsleq	r3, r3, #2
 800b778:	3002      	addeq	r0, #2
 800b77a:	2b00      	cmp	r3, #0
 800b77c:	db06      	blt.n	800b78c <__hi0bits+0x3c>
 800b77e:	005b      	lsls	r3, r3, #1
 800b780:	d503      	bpl.n	800b78a <__hi0bits+0x3a>
 800b782:	3001      	adds	r0, #1
 800b784:	4770      	bx	lr
 800b786:	2000      	movs	r0, #0
 800b788:	e7e8      	b.n	800b75c <__hi0bits+0xc>
 800b78a:	2020      	movs	r0, #32
 800b78c:	4770      	bx	lr

0800b78e <__lo0bits>:
 800b78e:	6803      	ldr	r3, [r0, #0]
 800b790:	f013 0207 	ands.w	r2, r3, #7
 800b794:	4601      	mov	r1, r0
 800b796:	d00b      	beq.n	800b7b0 <__lo0bits+0x22>
 800b798:	07da      	lsls	r2, r3, #31
 800b79a:	d423      	bmi.n	800b7e4 <__lo0bits+0x56>
 800b79c:	0798      	lsls	r0, r3, #30
 800b79e:	bf49      	itett	mi
 800b7a0:	085b      	lsrmi	r3, r3, #1
 800b7a2:	089b      	lsrpl	r3, r3, #2
 800b7a4:	2001      	movmi	r0, #1
 800b7a6:	600b      	strmi	r3, [r1, #0]
 800b7a8:	bf5c      	itt	pl
 800b7aa:	600b      	strpl	r3, [r1, #0]
 800b7ac:	2002      	movpl	r0, #2
 800b7ae:	4770      	bx	lr
 800b7b0:	b298      	uxth	r0, r3
 800b7b2:	b9a8      	cbnz	r0, 800b7e0 <__lo0bits+0x52>
 800b7b4:	0c1b      	lsrs	r3, r3, #16
 800b7b6:	2010      	movs	r0, #16
 800b7b8:	f013 0fff 	tst.w	r3, #255	; 0xff
 800b7bc:	bf04      	itt	eq
 800b7be:	0a1b      	lsreq	r3, r3, #8
 800b7c0:	3008      	addeq	r0, #8
 800b7c2:	071a      	lsls	r2, r3, #28
 800b7c4:	bf04      	itt	eq
 800b7c6:	091b      	lsreq	r3, r3, #4
 800b7c8:	3004      	addeq	r0, #4
 800b7ca:	079a      	lsls	r2, r3, #30
 800b7cc:	bf04      	itt	eq
 800b7ce:	089b      	lsreq	r3, r3, #2
 800b7d0:	3002      	addeq	r0, #2
 800b7d2:	07da      	lsls	r2, r3, #31
 800b7d4:	d402      	bmi.n	800b7dc <__lo0bits+0x4e>
 800b7d6:	085b      	lsrs	r3, r3, #1
 800b7d8:	d006      	beq.n	800b7e8 <__lo0bits+0x5a>
 800b7da:	3001      	adds	r0, #1
 800b7dc:	600b      	str	r3, [r1, #0]
 800b7de:	4770      	bx	lr
 800b7e0:	4610      	mov	r0, r2
 800b7e2:	e7e9      	b.n	800b7b8 <__lo0bits+0x2a>
 800b7e4:	2000      	movs	r0, #0
 800b7e6:	4770      	bx	lr
 800b7e8:	2020      	movs	r0, #32
 800b7ea:	4770      	bx	lr

0800b7ec <__i2b>:
 800b7ec:	b510      	push	{r4, lr}
 800b7ee:	460c      	mov	r4, r1
 800b7f0:	2101      	movs	r1, #1
 800b7f2:	f7ff ff27 	bl	800b644 <_Balloc>
 800b7f6:	2201      	movs	r2, #1
 800b7f8:	6144      	str	r4, [r0, #20]
 800b7fa:	6102      	str	r2, [r0, #16]
 800b7fc:	bd10      	pop	{r4, pc}

0800b7fe <__multiply>:
 800b7fe:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b802:	4614      	mov	r4, r2
 800b804:	690a      	ldr	r2, [r1, #16]
 800b806:	6923      	ldr	r3, [r4, #16]
 800b808:	429a      	cmp	r2, r3
 800b80a:	bfb8      	it	lt
 800b80c:	460b      	movlt	r3, r1
 800b80e:	4689      	mov	r9, r1
 800b810:	bfbc      	itt	lt
 800b812:	46a1      	movlt	r9, r4
 800b814:	461c      	movlt	r4, r3
 800b816:	f8d9 7010 	ldr.w	r7, [r9, #16]
 800b81a:	f8d4 a010 	ldr.w	sl, [r4, #16]
 800b81e:	f8d9 3008 	ldr.w	r3, [r9, #8]
 800b822:	f8d9 1004 	ldr.w	r1, [r9, #4]
 800b826:	eb07 060a 	add.w	r6, r7, sl
 800b82a:	429e      	cmp	r6, r3
 800b82c:	bfc8      	it	gt
 800b82e:	3101      	addgt	r1, #1
 800b830:	f7ff ff08 	bl	800b644 <_Balloc>
 800b834:	f100 0514 	add.w	r5, r0, #20
 800b838:	eb05 0886 	add.w	r8, r5, r6, lsl #2
 800b83c:	462b      	mov	r3, r5
 800b83e:	2200      	movs	r2, #0
 800b840:	4543      	cmp	r3, r8
 800b842:	d316      	bcc.n	800b872 <__multiply+0x74>
 800b844:	f104 0214 	add.w	r2, r4, #20
 800b848:	f109 0114 	add.w	r1, r9, #20
 800b84c:	eb02 038a 	add.w	r3, r2, sl, lsl #2
 800b850:	eb01 0787 	add.w	r7, r1, r7, lsl #2
 800b854:	9301      	str	r3, [sp, #4]
 800b856:	9c01      	ldr	r4, [sp, #4]
 800b858:	4294      	cmp	r4, r2
 800b85a:	4613      	mov	r3, r2
 800b85c:	d80c      	bhi.n	800b878 <__multiply+0x7a>
 800b85e:	2e00      	cmp	r6, #0
 800b860:	dd03      	ble.n	800b86a <__multiply+0x6c>
 800b862:	f858 3d04 	ldr.w	r3, [r8, #-4]!
 800b866:	2b00      	cmp	r3, #0
 800b868:	d054      	beq.n	800b914 <__multiply+0x116>
 800b86a:	6106      	str	r6, [r0, #16]
 800b86c:	b003      	add	sp, #12
 800b86e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800b872:	f843 2b04 	str.w	r2, [r3], #4
 800b876:	e7e3      	b.n	800b840 <__multiply+0x42>
 800b878:	f8b3 a000 	ldrh.w	sl, [r3]
 800b87c:	3204      	adds	r2, #4
 800b87e:	f1ba 0f00 	cmp.w	sl, #0
 800b882:	d020      	beq.n	800b8c6 <__multiply+0xc8>
 800b884:	46ae      	mov	lr, r5
 800b886:	4689      	mov	r9, r1
 800b888:	f04f 0c00 	mov.w	ip, #0
 800b88c:	f859 4b04 	ldr.w	r4, [r9], #4
 800b890:	f8be b000 	ldrh.w	fp, [lr]
 800b894:	b2a3      	uxth	r3, r4
 800b896:	fb0a b303 	mla	r3, sl, r3, fp
 800b89a:	ea4f 4b14 	mov.w	fp, r4, lsr #16
 800b89e:	f8de 4000 	ldr.w	r4, [lr]
 800b8a2:	4463      	add	r3, ip
 800b8a4:	ea4f 4c14 	mov.w	ip, r4, lsr #16
 800b8a8:	fb0a c40b 	mla	r4, sl, fp, ip
 800b8ac:	eb04 4413 	add.w	r4, r4, r3, lsr #16
 800b8b0:	b29b      	uxth	r3, r3
 800b8b2:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
 800b8b6:	454f      	cmp	r7, r9
 800b8b8:	ea4f 4c14 	mov.w	ip, r4, lsr #16
 800b8bc:	f84e 3b04 	str.w	r3, [lr], #4
 800b8c0:	d8e4      	bhi.n	800b88c <__multiply+0x8e>
 800b8c2:	f8ce c000 	str.w	ip, [lr]
 800b8c6:	f832 9c02 	ldrh.w	r9, [r2, #-2]
 800b8ca:	f1b9 0f00 	cmp.w	r9, #0
 800b8ce:	d01f      	beq.n	800b910 <__multiply+0x112>
 800b8d0:	682b      	ldr	r3, [r5, #0]
 800b8d2:	46ae      	mov	lr, r5
 800b8d4:	468c      	mov	ip, r1
 800b8d6:	f04f 0a00 	mov.w	sl, #0
 800b8da:	f8bc 4000 	ldrh.w	r4, [ip]
 800b8de:	f8be b002 	ldrh.w	fp, [lr, #2]
 800b8e2:	fb09 b404 	mla	r4, r9, r4, fp
 800b8e6:	44a2      	add	sl, r4
 800b8e8:	b29b      	uxth	r3, r3
 800b8ea:	ea43 430a 	orr.w	r3, r3, sl, lsl #16
 800b8ee:	f84e 3b04 	str.w	r3, [lr], #4
 800b8f2:	f85c 3b04 	ldr.w	r3, [ip], #4
 800b8f6:	f8be 4000 	ldrh.w	r4, [lr]
 800b8fa:	0c1b      	lsrs	r3, r3, #16
 800b8fc:	fb09 4303 	mla	r3, r9, r3, r4
 800b900:	eb03 431a 	add.w	r3, r3, sl, lsr #16
 800b904:	4567      	cmp	r7, ip
 800b906:	ea4f 4a13 	mov.w	sl, r3, lsr #16
 800b90a:	d8e6      	bhi.n	800b8da <__multiply+0xdc>
 800b90c:	f8ce 3000 	str.w	r3, [lr]
 800b910:	3504      	adds	r5, #4
 800b912:	e7a0      	b.n	800b856 <__multiply+0x58>
 800b914:	3e01      	subs	r6, #1
 800b916:	e7a2      	b.n	800b85e <__multiply+0x60>

0800b918 <__pow5mult>:
 800b918:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800b91c:	4615      	mov	r5, r2
 800b91e:	f012 0203 	ands.w	r2, r2, #3
 800b922:	4606      	mov	r6, r0
 800b924:	460f      	mov	r7, r1
 800b926:	d007      	beq.n	800b938 <__pow5mult+0x20>
 800b928:	3a01      	subs	r2, #1
 800b92a:	4c21      	ldr	r4, [pc, #132]	; (800b9b0 <__pow5mult+0x98>)
 800b92c:	2300      	movs	r3, #0
 800b92e:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
 800b932:	f7ff fed2 	bl	800b6da <__multadd>
 800b936:	4607      	mov	r7, r0
 800b938:	10ad      	asrs	r5, r5, #2
 800b93a:	d035      	beq.n	800b9a8 <__pow5mult+0x90>
 800b93c:	6a74      	ldr	r4, [r6, #36]	; 0x24
 800b93e:	b93c      	cbnz	r4, 800b950 <__pow5mult+0x38>
 800b940:	2010      	movs	r0, #16
 800b942:	f7fb fefd 	bl	8007740 <malloc>
 800b946:	6270      	str	r0, [r6, #36]	; 0x24
 800b948:	6044      	str	r4, [r0, #4]
 800b94a:	6084      	str	r4, [r0, #8]
 800b94c:	6004      	str	r4, [r0, #0]
 800b94e:	60c4      	str	r4, [r0, #12]
 800b950:	f8d6 8024 	ldr.w	r8, [r6, #36]	; 0x24
 800b954:	f8d8 4008 	ldr.w	r4, [r8, #8]
 800b958:	b94c      	cbnz	r4, 800b96e <__pow5mult+0x56>
 800b95a:	f240 2171 	movw	r1, #625	; 0x271
 800b95e:	4630      	mov	r0, r6
 800b960:	f7ff ff44 	bl	800b7ec <__i2b>
 800b964:	2300      	movs	r3, #0
 800b966:	f8c8 0008 	str.w	r0, [r8, #8]
 800b96a:	4604      	mov	r4, r0
 800b96c:	6003      	str	r3, [r0, #0]
 800b96e:	f04f 0800 	mov.w	r8, #0
 800b972:	07eb      	lsls	r3, r5, #31
 800b974:	d50a      	bpl.n	800b98c <__pow5mult+0x74>
 800b976:	4639      	mov	r1, r7
 800b978:	4622      	mov	r2, r4
 800b97a:	4630      	mov	r0, r6
 800b97c:	f7ff ff3f 	bl	800b7fe <__multiply>
 800b980:	4639      	mov	r1, r7
 800b982:	4681      	mov	r9, r0
 800b984:	4630      	mov	r0, r6
 800b986:	f7ff fe91 	bl	800b6ac <_Bfree>
 800b98a:	464f      	mov	r7, r9
 800b98c:	106d      	asrs	r5, r5, #1
 800b98e:	d00b      	beq.n	800b9a8 <__pow5mult+0x90>
 800b990:	6820      	ldr	r0, [r4, #0]
 800b992:	b938      	cbnz	r0, 800b9a4 <__pow5mult+0x8c>
 800b994:	4622      	mov	r2, r4
 800b996:	4621      	mov	r1, r4
 800b998:	4630      	mov	r0, r6
 800b99a:	f7ff ff30 	bl	800b7fe <__multiply>
 800b99e:	6020      	str	r0, [r4, #0]
 800b9a0:	f8c0 8000 	str.w	r8, [r0]
 800b9a4:	4604      	mov	r4, r0
 800b9a6:	e7e4      	b.n	800b972 <__pow5mult+0x5a>
 800b9a8:	4638      	mov	r0, r7
 800b9aa:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800b9ae:	bf00      	nop
 800b9b0:	0800d3c8 	.word	0x0800d3c8

0800b9b4 <__lshift>:
 800b9b4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800b9b8:	460c      	mov	r4, r1
 800b9ba:	ea4f 1a62 	mov.w	sl, r2, asr #5
 800b9be:	6923      	ldr	r3, [r4, #16]
 800b9c0:	6849      	ldr	r1, [r1, #4]
 800b9c2:	eb0a 0903 	add.w	r9, sl, r3
 800b9c6:	68a3      	ldr	r3, [r4, #8]
 800b9c8:	4607      	mov	r7, r0
 800b9ca:	4616      	mov	r6, r2
 800b9cc:	f109 0501 	add.w	r5, r9, #1
 800b9d0:	42ab      	cmp	r3, r5
 800b9d2:	db31      	blt.n	800ba38 <__lshift+0x84>
 800b9d4:	4638      	mov	r0, r7
 800b9d6:	f7ff fe35 	bl	800b644 <_Balloc>
 800b9da:	2200      	movs	r2, #0
 800b9dc:	4680      	mov	r8, r0
 800b9de:	f100 0314 	add.w	r3, r0, #20
 800b9e2:	4611      	mov	r1, r2
 800b9e4:	4552      	cmp	r2, sl
 800b9e6:	db2a      	blt.n	800ba3e <__lshift+0x8a>
 800b9e8:	6920      	ldr	r0, [r4, #16]
 800b9ea:	ea2a 7aea 	bic.w	sl, sl, sl, asr #31
 800b9ee:	f104 0114 	add.w	r1, r4, #20
 800b9f2:	f016 021f 	ands.w	r2, r6, #31
 800b9f6:	eb03 038a 	add.w	r3, r3, sl, lsl #2
 800b9fa:	eb01 0e80 	add.w	lr, r1, r0, lsl #2
 800b9fe:	d022      	beq.n	800ba46 <__lshift+0x92>
 800ba00:	f1c2 0c20 	rsb	ip, r2, #32
 800ba04:	2000      	movs	r0, #0
 800ba06:	680e      	ldr	r6, [r1, #0]
 800ba08:	4096      	lsls	r6, r2
 800ba0a:	4330      	orrs	r0, r6
 800ba0c:	f843 0b04 	str.w	r0, [r3], #4
 800ba10:	f851 0b04 	ldr.w	r0, [r1], #4
 800ba14:	458e      	cmp	lr, r1
 800ba16:	fa20 f00c 	lsr.w	r0, r0, ip
 800ba1a:	d8f4      	bhi.n	800ba06 <__lshift+0x52>
 800ba1c:	6018      	str	r0, [r3, #0]
 800ba1e:	b108      	cbz	r0, 800ba24 <__lshift+0x70>
 800ba20:	f109 0502 	add.w	r5, r9, #2
 800ba24:	3d01      	subs	r5, #1
 800ba26:	4638      	mov	r0, r7
 800ba28:	f8c8 5010 	str.w	r5, [r8, #16]
 800ba2c:	4621      	mov	r1, r4
 800ba2e:	f7ff fe3d 	bl	800b6ac <_Bfree>
 800ba32:	4640      	mov	r0, r8
 800ba34:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800ba38:	3101      	adds	r1, #1
 800ba3a:	005b      	lsls	r3, r3, #1
 800ba3c:	e7c8      	b.n	800b9d0 <__lshift+0x1c>
 800ba3e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 800ba42:	3201      	adds	r2, #1
 800ba44:	e7ce      	b.n	800b9e4 <__lshift+0x30>
 800ba46:	3b04      	subs	r3, #4
 800ba48:	f851 2b04 	ldr.w	r2, [r1], #4
 800ba4c:	f843 2f04 	str.w	r2, [r3, #4]!
 800ba50:	458e      	cmp	lr, r1
 800ba52:	d8f9      	bhi.n	800ba48 <__lshift+0x94>
 800ba54:	e7e6      	b.n	800ba24 <__lshift+0x70>

0800ba56 <__mcmp>:
 800ba56:	6903      	ldr	r3, [r0, #16]
 800ba58:	690a      	ldr	r2, [r1, #16]
 800ba5a:	1a9b      	subs	r3, r3, r2
 800ba5c:	b530      	push	{r4, r5, lr}
 800ba5e:	d10c      	bne.n	800ba7a <__mcmp+0x24>
 800ba60:	0092      	lsls	r2, r2, #2
 800ba62:	3014      	adds	r0, #20
 800ba64:	3114      	adds	r1, #20
 800ba66:	1884      	adds	r4, r0, r2
 800ba68:	4411      	add	r1, r2
 800ba6a:	f854 5d04 	ldr.w	r5, [r4, #-4]!
 800ba6e:	f851 2d04 	ldr.w	r2, [r1, #-4]!
 800ba72:	4295      	cmp	r5, r2
 800ba74:	d003      	beq.n	800ba7e <__mcmp+0x28>
 800ba76:	d305      	bcc.n	800ba84 <__mcmp+0x2e>
 800ba78:	2301      	movs	r3, #1
 800ba7a:	4618      	mov	r0, r3
 800ba7c:	bd30      	pop	{r4, r5, pc}
 800ba7e:	42a0      	cmp	r0, r4
 800ba80:	d3f3      	bcc.n	800ba6a <__mcmp+0x14>
 800ba82:	e7fa      	b.n	800ba7a <__mcmp+0x24>
 800ba84:	f04f 33ff 	mov.w	r3, #4294967295
 800ba88:	e7f7      	b.n	800ba7a <__mcmp+0x24>

0800ba8a <__mdiff>:
 800ba8a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800ba8e:	460d      	mov	r5, r1
 800ba90:	4607      	mov	r7, r0
 800ba92:	4611      	mov	r1, r2
 800ba94:	4628      	mov	r0, r5
 800ba96:	4614      	mov	r4, r2
 800ba98:	f7ff ffdd 	bl	800ba56 <__mcmp>
 800ba9c:	1e06      	subs	r6, r0, #0
 800ba9e:	d108      	bne.n	800bab2 <__mdiff+0x28>
 800baa0:	4631      	mov	r1, r6
 800baa2:	4638      	mov	r0, r7
 800baa4:	f7ff fdce 	bl	800b644 <_Balloc>
 800baa8:	2301      	movs	r3, #1
 800baaa:	6103      	str	r3, [r0, #16]
 800baac:	6146      	str	r6, [r0, #20]
 800baae:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800bab2:	bfa4      	itt	ge
 800bab4:	4623      	movge	r3, r4
 800bab6:	462c      	movge	r4, r5
 800bab8:	4638      	mov	r0, r7
 800baba:	6861      	ldr	r1, [r4, #4]
 800babc:	bfa6      	itte	ge
 800babe:	461d      	movge	r5, r3
 800bac0:	2600      	movge	r6, #0
 800bac2:	2601      	movlt	r6, #1
 800bac4:	f7ff fdbe 	bl	800b644 <_Balloc>
 800bac8:	692b      	ldr	r3, [r5, #16]
 800baca:	60c6      	str	r6, [r0, #12]
 800bacc:	6926      	ldr	r6, [r4, #16]
 800bace:	f105 0914 	add.w	r9, r5, #20
 800bad2:	f104 0214 	add.w	r2, r4, #20
 800bad6:	eb02 0786 	add.w	r7, r2, r6, lsl #2
 800bada:	eb09 0883 	add.w	r8, r9, r3, lsl #2
 800bade:	f100 0514 	add.w	r5, r0, #20
 800bae2:	f04f 0c00 	mov.w	ip, #0
 800bae6:	f852 ab04 	ldr.w	sl, [r2], #4
 800baea:	f859 4b04 	ldr.w	r4, [r9], #4
 800baee:	fa1c f18a 	uxtah	r1, ip, sl
 800baf2:	b2a3      	uxth	r3, r4
 800baf4:	1ac9      	subs	r1, r1, r3
 800baf6:	0c23      	lsrs	r3, r4, #16
 800baf8:	ebc3 431a 	rsb	r3, r3, sl, lsr #16
 800bafc:	eb03 4321 	add.w	r3, r3, r1, asr #16
 800bb00:	b289      	uxth	r1, r1
 800bb02:	ea4f 4c23 	mov.w	ip, r3, asr #16
 800bb06:	45c8      	cmp	r8, r9
 800bb08:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
 800bb0c:	4696      	mov	lr, r2
 800bb0e:	f845 3b04 	str.w	r3, [r5], #4
 800bb12:	d8e8      	bhi.n	800bae6 <__mdiff+0x5c>
 800bb14:	45be      	cmp	lr, r7
 800bb16:	d305      	bcc.n	800bb24 <__mdiff+0x9a>
 800bb18:	f855 3d04 	ldr.w	r3, [r5, #-4]!
 800bb1c:	b18b      	cbz	r3, 800bb42 <__mdiff+0xb8>
 800bb1e:	6106      	str	r6, [r0, #16]
 800bb20:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800bb24:	f85e 1b04 	ldr.w	r1, [lr], #4
 800bb28:	fa1c f381 	uxtah	r3, ip, r1
 800bb2c:	141a      	asrs	r2, r3, #16
 800bb2e:	eb02 4211 	add.w	r2, r2, r1, lsr #16
 800bb32:	b29b      	uxth	r3, r3
 800bb34:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 800bb38:	ea4f 4c22 	mov.w	ip, r2, asr #16
 800bb3c:	f845 3b04 	str.w	r3, [r5], #4
 800bb40:	e7e8      	b.n	800bb14 <__mdiff+0x8a>
 800bb42:	3e01      	subs	r6, #1
 800bb44:	e7e8      	b.n	800bb18 <__mdiff+0x8e>

0800bb46 <__d2b>:
 800bb46:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 800bb4a:	460e      	mov	r6, r1
 800bb4c:	2101      	movs	r1, #1
 800bb4e:	ec59 8b10 	vmov	r8, r9, d0
 800bb52:	4615      	mov	r5, r2
 800bb54:	f7ff fd76 	bl	800b644 <_Balloc>
 800bb58:	f3c9 540a 	ubfx	r4, r9, #20, #11
 800bb5c:	4607      	mov	r7, r0
 800bb5e:	f3c9 0313 	ubfx	r3, r9, #0, #20
 800bb62:	bb34      	cbnz	r4, 800bbb2 <__d2b+0x6c>
 800bb64:	9301      	str	r3, [sp, #4]
 800bb66:	f1b8 0f00 	cmp.w	r8, #0
 800bb6a:	d027      	beq.n	800bbbc <__d2b+0x76>
 800bb6c:	a802      	add	r0, sp, #8
 800bb6e:	f840 8d08 	str.w	r8, [r0, #-8]!
 800bb72:	f7ff fe0c 	bl	800b78e <__lo0bits>
 800bb76:	9900      	ldr	r1, [sp, #0]
 800bb78:	b1f0      	cbz	r0, 800bbb8 <__d2b+0x72>
 800bb7a:	9a01      	ldr	r2, [sp, #4]
 800bb7c:	f1c0 0320 	rsb	r3, r0, #32
 800bb80:	fa02 f303 	lsl.w	r3, r2, r3
 800bb84:	430b      	orrs	r3, r1
 800bb86:	40c2      	lsrs	r2, r0
 800bb88:	617b      	str	r3, [r7, #20]
 800bb8a:	9201      	str	r2, [sp, #4]
 800bb8c:	9b01      	ldr	r3, [sp, #4]
 800bb8e:	61bb      	str	r3, [r7, #24]
 800bb90:	2b00      	cmp	r3, #0
 800bb92:	bf14      	ite	ne
 800bb94:	2102      	movne	r1, #2
 800bb96:	2101      	moveq	r1, #1
 800bb98:	6139      	str	r1, [r7, #16]
 800bb9a:	b1c4      	cbz	r4, 800bbce <__d2b+0x88>
 800bb9c:	f2a4 4433 	subw	r4, r4, #1075	; 0x433
 800bba0:	4404      	add	r4, r0
 800bba2:	6034      	str	r4, [r6, #0]
 800bba4:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
 800bba8:	6028      	str	r0, [r5, #0]
 800bbaa:	4638      	mov	r0, r7
 800bbac:	b003      	add	sp, #12
 800bbae:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800bbb2:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800bbb6:	e7d5      	b.n	800bb64 <__d2b+0x1e>
 800bbb8:	6179      	str	r1, [r7, #20]
 800bbba:	e7e7      	b.n	800bb8c <__d2b+0x46>
 800bbbc:	a801      	add	r0, sp, #4
 800bbbe:	f7ff fde6 	bl	800b78e <__lo0bits>
 800bbc2:	9b01      	ldr	r3, [sp, #4]
 800bbc4:	617b      	str	r3, [r7, #20]
 800bbc6:	2101      	movs	r1, #1
 800bbc8:	6139      	str	r1, [r7, #16]
 800bbca:	3020      	adds	r0, #32
 800bbcc:	e7e5      	b.n	800bb9a <__d2b+0x54>
 800bbce:	eb07 0381 	add.w	r3, r7, r1, lsl #2
 800bbd2:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
 800bbd6:	6030      	str	r0, [r6, #0]
 800bbd8:	6918      	ldr	r0, [r3, #16]
 800bbda:	f7ff fdb9 	bl	800b750 <__hi0bits>
 800bbde:	ebc0 1041 	rsb	r0, r0, r1, lsl #5
 800bbe2:	e7e1      	b.n	800bba8 <__d2b+0x62>

0800bbe4 <_realloc_r>:
 800bbe4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800bbe8:	4682      	mov	sl, r0
 800bbea:	460c      	mov	r4, r1
 800bbec:	b929      	cbnz	r1, 800bbfa <_realloc_r+0x16>
 800bbee:	4611      	mov	r1, r2
 800bbf0:	b003      	add	sp, #12
 800bbf2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800bbf6:	f7fb bdab 	b.w	8007750 <_malloc_r>
 800bbfa:	9201      	str	r2, [sp, #4]
 800bbfc:	f7fb ffca 	bl	8007b94 <__malloc_lock>
 800bc00:	9a01      	ldr	r2, [sp, #4]
 800bc02:	f854 5c04 	ldr.w	r5, [r4, #-4]
 800bc06:	f102 080b 	add.w	r8, r2, #11
 800bc0a:	f1b8 0f16 	cmp.w	r8, #22
 800bc0e:	f1a4 0908 	sub.w	r9, r4, #8
 800bc12:	f025 0603 	bic.w	r6, r5, #3
 800bc16:	d90a      	bls.n	800bc2e <_realloc_r+0x4a>
 800bc18:	f038 0807 	bics.w	r8, r8, #7
 800bc1c:	d509      	bpl.n	800bc32 <_realloc_r+0x4e>
 800bc1e:	230c      	movs	r3, #12
 800bc20:	f8ca 3000 	str.w	r3, [sl]
 800bc24:	2700      	movs	r7, #0
 800bc26:	4638      	mov	r0, r7
 800bc28:	b003      	add	sp, #12
 800bc2a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800bc2e:	f04f 0810 	mov.w	r8, #16
 800bc32:	4590      	cmp	r8, r2
 800bc34:	d3f3      	bcc.n	800bc1e <_realloc_r+0x3a>
 800bc36:	45b0      	cmp	r8, r6
 800bc38:	f340 8145 	ble.w	800bec6 <_realloc_r+0x2e2>
 800bc3c:	4ba8      	ldr	r3, [pc, #672]	; (800bee0 <_realloc_r+0x2fc>)
 800bc3e:	f8d3 e008 	ldr.w	lr, [r3, #8]
 800bc42:	eb09 0106 	add.w	r1, r9, r6
 800bc46:	4571      	cmp	r1, lr
 800bc48:	469b      	mov	fp, r3
 800bc4a:	684b      	ldr	r3, [r1, #4]
 800bc4c:	d005      	beq.n	800bc5a <_realloc_r+0x76>
 800bc4e:	f023 0001 	bic.w	r0, r3, #1
 800bc52:	4408      	add	r0, r1
 800bc54:	6840      	ldr	r0, [r0, #4]
 800bc56:	07c7      	lsls	r7, r0, #31
 800bc58:	d447      	bmi.n	800bcea <_realloc_r+0x106>
 800bc5a:	f023 0303 	bic.w	r3, r3, #3
 800bc5e:	4571      	cmp	r1, lr
 800bc60:	eb06 0703 	add.w	r7, r6, r3
 800bc64:	d119      	bne.n	800bc9a <_realloc_r+0xb6>
 800bc66:	f108 0010 	add.w	r0, r8, #16
 800bc6a:	4287      	cmp	r7, r0
 800bc6c:	db3f      	blt.n	800bcee <_realloc_r+0x10a>
 800bc6e:	eb09 0308 	add.w	r3, r9, r8
 800bc72:	eba7 0708 	sub.w	r7, r7, r8
 800bc76:	f047 0701 	orr.w	r7, r7, #1
 800bc7a:	f8cb 3008 	str.w	r3, [fp, #8]
 800bc7e:	605f      	str	r7, [r3, #4]
 800bc80:	f854 3c04 	ldr.w	r3, [r4, #-4]
 800bc84:	f003 0301 	and.w	r3, r3, #1
 800bc88:	ea43 0308 	orr.w	r3, r3, r8
 800bc8c:	f844 3c04 	str.w	r3, [r4, #-4]
 800bc90:	4650      	mov	r0, sl
 800bc92:	f7fb ff85 	bl	8007ba0 <__malloc_unlock>
 800bc96:	4627      	mov	r7, r4
 800bc98:	e7c5      	b.n	800bc26 <_realloc_r+0x42>
 800bc9a:	45b8      	cmp	r8, r7
 800bc9c:	dc27      	bgt.n	800bcee <_realloc_r+0x10a>
 800bc9e:	68cb      	ldr	r3, [r1, #12]
 800bca0:	688a      	ldr	r2, [r1, #8]
 800bca2:	60d3      	str	r3, [r2, #12]
 800bca4:	609a      	str	r2, [r3, #8]
 800bca6:	eba7 0008 	sub.w	r0, r7, r8
 800bcaa:	280f      	cmp	r0, #15
 800bcac:	f8d9 3004 	ldr.w	r3, [r9, #4]
 800bcb0:	eb09 0207 	add.w	r2, r9, r7
 800bcb4:	f240 8109 	bls.w	800beca <_realloc_r+0x2e6>
 800bcb8:	eb09 0108 	add.w	r1, r9, r8
 800bcbc:	f003 0301 	and.w	r3, r3, #1
 800bcc0:	ea43 0308 	orr.w	r3, r3, r8
 800bcc4:	f040 0001 	orr.w	r0, r0, #1
 800bcc8:	f8c9 3004 	str.w	r3, [r9, #4]
 800bccc:	6048      	str	r0, [r1, #4]
 800bcce:	6853      	ldr	r3, [r2, #4]
 800bcd0:	f043 0301 	orr.w	r3, r3, #1
 800bcd4:	6053      	str	r3, [r2, #4]
 800bcd6:	3108      	adds	r1, #8
 800bcd8:	4650      	mov	r0, sl
 800bcda:	f7ff f9cf 	bl	800b07c <_free_r>
 800bcde:	4650      	mov	r0, sl
 800bce0:	f7fb ff5e 	bl	8007ba0 <__malloc_unlock>
 800bce4:	f109 0708 	add.w	r7, r9, #8
 800bce8:	e79d      	b.n	800bc26 <_realloc_r+0x42>
 800bcea:	2300      	movs	r3, #0
 800bcec:	4619      	mov	r1, r3
 800bcee:	07e8      	lsls	r0, r5, #31
 800bcf0:	f100 8084 	bmi.w	800bdfc <_realloc_r+0x218>
 800bcf4:	f854 5c08 	ldr.w	r5, [r4, #-8]
 800bcf8:	eba9 0505 	sub.w	r5, r9, r5
 800bcfc:	6868      	ldr	r0, [r5, #4]
 800bcfe:	f020 0003 	bic.w	r0, r0, #3
 800bd02:	4430      	add	r0, r6
 800bd04:	2900      	cmp	r1, #0
 800bd06:	d076      	beq.n	800bdf6 <_realloc_r+0x212>
 800bd08:	4571      	cmp	r1, lr
 800bd0a:	d150      	bne.n	800bdae <_realloc_r+0x1ca>
 800bd0c:	4403      	add	r3, r0
 800bd0e:	f108 0110 	add.w	r1, r8, #16
 800bd12:	428b      	cmp	r3, r1
 800bd14:	db6f      	blt.n	800bdf6 <_realloc_r+0x212>
 800bd16:	462f      	mov	r7, r5
 800bd18:	68ea      	ldr	r2, [r5, #12]
 800bd1a:	f857 1f08 	ldr.w	r1, [r7, #8]!
 800bd1e:	60ca      	str	r2, [r1, #12]
 800bd20:	6091      	str	r1, [r2, #8]
 800bd22:	1f32      	subs	r2, r6, #4
 800bd24:	2a24      	cmp	r2, #36	; 0x24
 800bd26:	d83b      	bhi.n	800bda0 <_realloc_r+0x1bc>
 800bd28:	2a13      	cmp	r2, #19
 800bd2a:	d936      	bls.n	800bd9a <_realloc_r+0x1b6>
 800bd2c:	6821      	ldr	r1, [r4, #0]
 800bd2e:	60a9      	str	r1, [r5, #8]
 800bd30:	6861      	ldr	r1, [r4, #4]
 800bd32:	60e9      	str	r1, [r5, #12]
 800bd34:	2a1b      	cmp	r2, #27
 800bd36:	d81c      	bhi.n	800bd72 <_realloc_r+0x18e>
 800bd38:	f105 0210 	add.w	r2, r5, #16
 800bd3c:	f104 0108 	add.w	r1, r4, #8
 800bd40:	6808      	ldr	r0, [r1, #0]
 800bd42:	6010      	str	r0, [r2, #0]
 800bd44:	6848      	ldr	r0, [r1, #4]
 800bd46:	6050      	str	r0, [r2, #4]
 800bd48:	6889      	ldr	r1, [r1, #8]
 800bd4a:	6091      	str	r1, [r2, #8]
 800bd4c:	eb05 0208 	add.w	r2, r5, r8
 800bd50:	eba3 0308 	sub.w	r3, r3, r8
 800bd54:	f043 0301 	orr.w	r3, r3, #1
 800bd58:	f8cb 2008 	str.w	r2, [fp, #8]
 800bd5c:	6053      	str	r3, [r2, #4]
 800bd5e:	686b      	ldr	r3, [r5, #4]
 800bd60:	f003 0301 	and.w	r3, r3, #1
 800bd64:	ea43 0308 	orr.w	r3, r3, r8
 800bd68:	606b      	str	r3, [r5, #4]
 800bd6a:	4650      	mov	r0, sl
 800bd6c:	f7fb ff18 	bl	8007ba0 <__malloc_unlock>
 800bd70:	e759      	b.n	800bc26 <_realloc_r+0x42>
 800bd72:	68a1      	ldr	r1, [r4, #8]
 800bd74:	6129      	str	r1, [r5, #16]
 800bd76:	68e1      	ldr	r1, [r4, #12]
 800bd78:	6169      	str	r1, [r5, #20]
 800bd7a:	2a24      	cmp	r2, #36	; 0x24
 800bd7c:	bf01      	itttt	eq
 800bd7e:	6922      	ldreq	r2, [r4, #16]
 800bd80:	61aa      	streq	r2, [r5, #24]
 800bd82:	6960      	ldreq	r0, [r4, #20]
 800bd84:	61e8      	streq	r0, [r5, #28]
 800bd86:	bf19      	ittee	ne
 800bd88:	f105 0218 	addne.w	r2, r5, #24
 800bd8c:	f104 0110 	addne.w	r1, r4, #16
 800bd90:	f105 0220 	addeq.w	r2, r5, #32
 800bd94:	f104 0118 	addeq.w	r1, r4, #24
 800bd98:	e7d2      	b.n	800bd40 <_realloc_r+0x15c>
 800bd9a:	463a      	mov	r2, r7
 800bd9c:	4621      	mov	r1, r4
 800bd9e:	e7cf      	b.n	800bd40 <_realloc_r+0x15c>
 800bda0:	4621      	mov	r1, r4
 800bda2:	4638      	mov	r0, r7
 800bda4:	9301      	str	r3, [sp, #4]
 800bda6:	f7ff fc33 	bl	800b610 <memmove>
 800bdaa:	9b01      	ldr	r3, [sp, #4]
 800bdac:	e7ce      	b.n	800bd4c <_realloc_r+0x168>
 800bdae:	18c7      	adds	r7, r0, r3
 800bdb0:	45b8      	cmp	r8, r7
 800bdb2:	dc20      	bgt.n	800bdf6 <_realloc_r+0x212>
 800bdb4:	68cb      	ldr	r3, [r1, #12]
 800bdb6:	688a      	ldr	r2, [r1, #8]
 800bdb8:	60d3      	str	r3, [r2, #12]
 800bdba:	609a      	str	r2, [r3, #8]
 800bdbc:	4628      	mov	r0, r5
 800bdbe:	68eb      	ldr	r3, [r5, #12]
 800bdc0:	f850 2f08 	ldr.w	r2, [r0, #8]!
 800bdc4:	60d3      	str	r3, [r2, #12]
 800bdc6:	609a      	str	r2, [r3, #8]
 800bdc8:	1f32      	subs	r2, r6, #4
 800bdca:	2a24      	cmp	r2, #36	; 0x24
 800bdcc:	d842      	bhi.n	800be54 <_realloc_r+0x270>
 800bdce:	2a13      	cmp	r2, #19
 800bdd0:	d93e      	bls.n	800be50 <_realloc_r+0x26c>
 800bdd2:	6823      	ldr	r3, [r4, #0]
 800bdd4:	60ab      	str	r3, [r5, #8]
 800bdd6:	6863      	ldr	r3, [r4, #4]
 800bdd8:	60eb      	str	r3, [r5, #12]
 800bdda:	2a1b      	cmp	r2, #27
 800bddc:	d824      	bhi.n	800be28 <_realloc_r+0x244>
 800bdde:	f105 0010 	add.w	r0, r5, #16
 800bde2:	f104 0308 	add.w	r3, r4, #8
 800bde6:	681a      	ldr	r2, [r3, #0]
 800bde8:	6002      	str	r2, [r0, #0]
 800bdea:	685a      	ldr	r2, [r3, #4]
 800bdec:	6042      	str	r2, [r0, #4]
 800bdee:	689b      	ldr	r3, [r3, #8]
 800bdf0:	6083      	str	r3, [r0, #8]
 800bdf2:	46a9      	mov	r9, r5
 800bdf4:	e757      	b.n	800bca6 <_realloc_r+0xc2>
 800bdf6:	4580      	cmp	r8, r0
 800bdf8:	4607      	mov	r7, r0
 800bdfa:	dddf      	ble.n	800bdbc <_realloc_r+0x1d8>
 800bdfc:	4611      	mov	r1, r2
 800bdfe:	4650      	mov	r0, sl
 800be00:	f7fb fca6 	bl	8007750 <_malloc_r>
 800be04:	4607      	mov	r7, r0
 800be06:	2800      	cmp	r0, #0
 800be08:	d0af      	beq.n	800bd6a <_realloc_r+0x186>
 800be0a:	f854 3c04 	ldr.w	r3, [r4, #-4]
 800be0e:	f023 0301 	bic.w	r3, r3, #1
 800be12:	f1a0 0208 	sub.w	r2, r0, #8
 800be16:	444b      	add	r3, r9
 800be18:	429a      	cmp	r2, r3
 800be1a:	d11f      	bne.n	800be5c <_realloc_r+0x278>
 800be1c:	f850 7c04 	ldr.w	r7, [r0, #-4]
 800be20:	f027 0703 	bic.w	r7, r7, #3
 800be24:	4437      	add	r7, r6
 800be26:	e73e      	b.n	800bca6 <_realloc_r+0xc2>
 800be28:	68a3      	ldr	r3, [r4, #8]
 800be2a:	612b      	str	r3, [r5, #16]
 800be2c:	68e3      	ldr	r3, [r4, #12]
 800be2e:	616b      	str	r3, [r5, #20]
 800be30:	2a24      	cmp	r2, #36	; 0x24
 800be32:	bf01      	itttt	eq
 800be34:	6923      	ldreq	r3, [r4, #16]
 800be36:	61ab      	streq	r3, [r5, #24]
 800be38:	6962      	ldreq	r2, [r4, #20]
 800be3a:	61ea      	streq	r2, [r5, #28]
 800be3c:	bf19      	ittee	ne
 800be3e:	f105 0018 	addne.w	r0, r5, #24
 800be42:	f104 0310 	addne.w	r3, r4, #16
 800be46:	f105 0020 	addeq.w	r0, r5, #32
 800be4a:	f104 0318 	addeq.w	r3, r4, #24
 800be4e:	e7ca      	b.n	800bde6 <_realloc_r+0x202>
 800be50:	4623      	mov	r3, r4
 800be52:	e7c8      	b.n	800bde6 <_realloc_r+0x202>
 800be54:	4621      	mov	r1, r4
 800be56:	f7ff fbdb 	bl	800b610 <memmove>
 800be5a:	e7ca      	b.n	800bdf2 <_realloc_r+0x20e>
 800be5c:	1f32      	subs	r2, r6, #4
 800be5e:	2a24      	cmp	r2, #36	; 0x24
 800be60:	d82d      	bhi.n	800bebe <_realloc_r+0x2da>
 800be62:	2a13      	cmp	r2, #19
 800be64:	d928      	bls.n	800beb8 <_realloc_r+0x2d4>
 800be66:	6823      	ldr	r3, [r4, #0]
 800be68:	6003      	str	r3, [r0, #0]
 800be6a:	6863      	ldr	r3, [r4, #4]
 800be6c:	6043      	str	r3, [r0, #4]
 800be6e:	2a1b      	cmp	r2, #27
 800be70:	d80e      	bhi.n	800be90 <_realloc_r+0x2ac>
 800be72:	f100 0308 	add.w	r3, r0, #8
 800be76:	f104 0208 	add.w	r2, r4, #8
 800be7a:	6811      	ldr	r1, [r2, #0]
 800be7c:	6019      	str	r1, [r3, #0]
 800be7e:	6851      	ldr	r1, [r2, #4]
 800be80:	6059      	str	r1, [r3, #4]
 800be82:	6892      	ldr	r2, [r2, #8]
 800be84:	609a      	str	r2, [r3, #8]
 800be86:	4621      	mov	r1, r4
 800be88:	4650      	mov	r0, sl
 800be8a:	f7ff f8f7 	bl	800b07c <_free_r>
 800be8e:	e76c      	b.n	800bd6a <_realloc_r+0x186>
 800be90:	68a3      	ldr	r3, [r4, #8]
 800be92:	6083      	str	r3, [r0, #8]
 800be94:	68e3      	ldr	r3, [r4, #12]
 800be96:	60c3      	str	r3, [r0, #12]
 800be98:	2a24      	cmp	r2, #36	; 0x24
 800be9a:	bf01      	itttt	eq
 800be9c:	6923      	ldreq	r3, [r4, #16]
 800be9e:	6103      	streq	r3, [r0, #16]
 800bea0:	6961      	ldreq	r1, [r4, #20]
 800bea2:	6141      	streq	r1, [r0, #20]
 800bea4:	bf19      	ittee	ne
 800bea6:	f100 0310 	addne.w	r3, r0, #16
 800beaa:	f104 0210 	addne.w	r2, r4, #16
 800beae:	f100 0318 	addeq.w	r3, r0, #24
 800beb2:	f104 0218 	addeq.w	r2, r4, #24
 800beb6:	e7e0      	b.n	800be7a <_realloc_r+0x296>
 800beb8:	4603      	mov	r3, r0
 800beba:	4622      	mov	r2, r4
 800bebc:	e7dd      	b.n	800be7a <_realloc_r+0x296>
 800bebe:	4621      	mov	r1, r4
 800bec0:	f7ff fba6 	bl	800b610 <memmove>
 800bec4:	e7df      	b.n	800be86 <_realloc_r+0x2a2>
 800bec6:	4637      	mov	r7, r6
 800bec8:	e6ed      	b.n	800bca6 <_realloc_r+0xc2>
 800beca:	f003 0301 	and.w	r3, r3, #1
 800bece:	431f      	orrs	r7, r3
 800bed0:	f8c9 7004 	str.w	r7, [r9, #4]
 800bed4:	6853      	ldr	r3, [r2, #4]
 800bed6:	f043 0301 	orr.w	r3, r3, #1
 800beda:	6053      	str	r3, [r2, #4]
 800bedc:	e6ff      	b.n	800bcde <_realloc_r+0xfa>
 800bede:	bf00      	nop
 800bee0:	20000150 	.word	0x20000150

0800bee4 <__sread>:
 800bee4:	b510      	push	{r4, lr}
 800bee6:	460c      	mov	r4, r1
 800bee8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800beec:	f000 fa54 	bl	800c398 <_read_r>
 800bef0:	2800      	cmp	r0, #0
 800bef2:	bfab      	itete	ge
 800bef4:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 800bef6:	89a3      	ldrhlt	r3, [r4, #12]
 800bef8:	181b      	addge	r3, r3, r0
 800befa:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 800befe:	bfac      	ite	ge
 800bf00:	6563      	strge	r3, [r4, #84]	; 0x54
 800bf02:	81a3      	strhlt	r3, [r4, #12]
 800bf04:	bd10      	pop	{r4, pc}

0800bf06 <__swrite>:
 800bf06:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800bf0a:	461f      	mov	r7, r3
 800bf0c:	898b      	ldrh	r3, [r1, #12]
 800bf0e:	05db      	lsls	r3, r3, #23
 800bf10:	4605      	mov	r5, r0
 800bf12:	460c      	mov	r4, r1
 800bf14:	4616      	mov	r6, r2
 800bf16:	d505      	bpl.n	800bf24 <__swrite+0x1e>
 800bf18:	2302      	movs	r3, #2
 800bf1a:	2200      	movs	r2, #0
 800bf1c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800bf20:	f000 fa28 	bl	800c374 <_lseek_r>
 800bf24:	89a3      	ldrh	r3, [r4, #12]
 800bf26:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 800bf2a:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800bf2e:	81a3      	strh	r3, [r4, #12]
 800bf30:	4632      	mov	r2, r6
 800bf32:	463b      	mov	r3, r7
 800bf34:	4628      	mov	r0, r5
 800bf36:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 800bf3a:	f000 b8d3 	b.w	800c0e4 <_write_r>

0800bf3e <__sseek>:
 800bf3e:	b510      	push	{r4, lr}
 800bf40:	460c      	mov	r4, r1
 800bf42:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800bf46:	f000 fa15 	bl	800c374 <_lseek_r>
 800bf4a:	1c43      	adds	r3, r0, #1
 800bf4c:	89a3      	ldrh	r3, [r4, #12]
 800bf4e:	bf15      	itete	ne
 800bf50:	6560      	strne	r0, [r4, #84]	; 0x54
 800bf52:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 800bf56:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 800bf5a:	81a3      	strheq	r3, [r4, #12]
 800bf5c:	bf18      	it	ne
 800bf5e:	81a3      	strhne	r3, [r4, #12]
 800bf60:	bd10      	pop	{r4, pc}

0800bf62 <__sclose>:
 800bf62:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800bf66:	f000 b8fd 	b.w	800c164 <_close_r>

0800bf6a <__ssprint_r>:
 800bf6a:	6893      	ldr	r3, [r2, #8]
 800bf6c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800bf70:	4681      	mov	r9, r0
 800bf72:	460c      	mov	r4, r1
 800bf74:	4617      	mov	r7, r2
 800bf76:	2b00      	cmp	r3, #0
 800bf78:	d060      	beq.n	800c03c <__ssprint_r+0xd2>
 800bf7a:	f04f 0b00 	mov.w	fp, #0
 800bf7e:	f8d2 a000 	ldr.w	sl, [r2]
 800bf82:	465e      	mov	r6, fp
 800bf84:	b356      	cbz	r6, 800bfdc <__ssprint_r+0x72>
 800bf86:	68a3      	ldr	r3, [r4, #8]
 800bf88:	429e      	cmp	r6, r3
 800bf8a:	d344      	bcc.n	800c016 <__ssprint_r+0xac>
 800bf8c:	89a2      	ldrh	r2, [r4, #12]
 800bf8e:	f412 6f90 	tst.w	r2, #1152	; 0x480
 800bf92:	d03e      	beq.n	800c012 <__ssprint_r+0xa8>
 800bf94:	6825      	ldr	r5, [r4, #0]
 800bf96:	6921      	ldr	r1, [r4, #16]
 800bf98:	eba5 0801 	sub.w	r8, r5, r1
 800bf9c:	6965      	ldr	r5, [r4, #20]
 800bf9e:	2302      	movs	r3, #2
 800bfa0:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 800bfa4:	fb95 f5f3 	sdiv	r5, r5, r3
 800bfa8:	f108 0301 	add.w	r3, r8, #1
 800bfac:	4433      	add	r3, r6
 800bfae:	429d      	cmp	r5, r3
 800bfb0:	bf38      	it	cc
 800bfb2:	461d      	movcc	r5, r3
 800bfb4:	0553      	lsls	r3, r2, #21
 800bfb6:	d546      	bpl.n	800c046 <__ssprint_r+0xdc>
 800bfb8:	4629      	mov	r1, r5
 800bfba:	4648      	mov	r0, r9
 800bfbc:	f7fb fbc8 	bl	8007750 <_malloc_r>
 800bfc0:	b998      	cbnz	r0, 800bfea <__ssprint_r+0x80>
 800bfc2:	230c      	movs	r3, #12
 800bfc4:	f8c9 3000 	str.w	r3, [r9]
 800bfc8:	89a3      	ldrh	r3, [r4, #12]
 800bfca:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800bfce:	81a3      	strh	r3, [r4, #12]
 800bfd0:	2300      	movs	r3, #0
 800bfd2:	60bb      	str	r3, [r7, #8]
 800bfd4:	607b      	str	r3, [r7, #4]
 800bfd6:	f04f 30ff 	mov.w	r0, #4294967295
 800bfda:	e031      	b.n	800c040 <__ssprint_r+0xd6>
 800bfdc:	f8da b000 	ldr.w	fp, [sl]
 800bfe0:	f8da 6004 	ldr.w	r6, [sl, #4]
 800bfe4:	f10a 0a08 	add.w	sl, sl, #8
 800bfe8:	e7cc      	b.n	800bf84 <__ssprint_r+0x1a>
 800bfea:	4642      	mov	r2, r8
 800bfec:	6921      	ldr	r1, [r4, #16]
 800bfee:	9001      	str	r0, [sp, #4]
 800bff0:	f7fb fdbc 	bl	8007b6c <memcpy>
 800bff4:	89a2      	ldrh	r2, [r4, #12]
 800bff6:	9b01      	ldr	r3, [sp, #4]
 800bff8:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
 800bffc:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800c000:	81a2      	strh	r2, [r4, #12]
 800c002:	6123      	str	r3, [r4, #16]
 800c004:	6165      	str	r5, [r4, #20]
 800c006:	4443      	add	r3, r8
 800c008:	eba5 0508 	sub.w	r5, r5, r8
 800c00c:	6023      	str	r3, [r4, #0]
 800c00e:	60a5      	str	r5, [r4, #8]
 800c010:	4633      	mov	r3, r6
 800c012:	429e      	cmp	r6, r3
 800c014:	d200      	bcs.n	800c018 <__ssprint_r+0xae>
 800c016:	4633      	mov	r3, r6
 800c018:	461a      	mov	r2, r3
 800c01a:	4659      	mov	r1, fp
 800c01c:	6820      	ldr	r0, [r4, #0]
 800c01e:	9301      	str	r3, [sp, #4]
 800c020:	f7ff faf6 	bl	800b610 <memmove>
 800c024:	68a2      	ldr	r2, [r4, #8]
 800c026:	9b01      	ldr	r3, [sp, #4]
 800c028:	1ad2      	subs	r2, r2, r3
 800c02a:	60a2      	str	r2, [r4, #8]
 800c02c:	6822      	ldr	r2, [r4, #0]
 800c02e:	4413      	add	r3, r2
 800c030:	6023      	str	r3, [r4, #0]
 800c032:	68bb      	ldr	r3, [r7, #8]
 800c034:	1b9e      	subs	r6, r3, r6
 800c036:	60be      	str	r6, [r7, #8]
 800c038:	2e00      	cmp	r6, #0
 800c03a:	d1cf      	bne.n	800bfdc <__ssprint_r+0x72>
 800c03c:	2000      	movs	r0, #0
 800c03e:	6078      	str	r0, [r7, #4]
 800c040:	b003      	add	sp, #12
 800c042:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800c046:	462a      	mov	r2, r5
 800c048:	4648      	mov	r0, r9
 800c04a:	f7ff fdcb 	bl	800bbe4 <_realloc_r>
 800c04e:	4603      	mov	r3, r0
 800c050:	2800      	cmp	r0, #0
 800c052:	d1d6      	bne.n	800c002 <__ssprint_r+0x98>
 800c054:	6921      	ldr	r1, [r4, #16]
 800c056:	4648      	mov	r0, r9
 800c058:	f7ff f810 	bl	800b07c <_free_r>
 800c05c:	e7b1      	b.n	800bfc2 <__ssprint_r+0x58>

0800c05e <__sprint_r>:
 800c05e:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c062:	6893      	ldr	r3, [r2, #8]
 800c064:	4680      	mov	r8, r0
 800c066:	460f      	mov	r7, r1
 800c068:	4614      	mov	r4, r2
 800c06a:	b91b      	cbnz	r3, 800c074 <__sprint_r+0x16>
 800c06c:	6053      	str	r3, [r2, #4]
 800c06e:	4618      	mov	r0, r3
 800c070:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800c074:	6e4b      	ldr	r3, [r1, #100]	; 0x64
 800c076:	049d      	lsls	r5, r3, #18
 800c078:	d523      	bpl.n	800c0c2 <__sprint_r+0x64>
 800c07a:	6815      	ldr	r5, [r2, #0]
 800c07c:	68a0      	ldr	r0, [r4, #8]
 800c07e:	3508      	adds	r5, #8
 800c080:	b920      	cbnz	r0, 800c08c <__sprint_r+0x2e>
 800c082:	2300      	movs	r3, #0
 800c084:	60a3      	str	r3, [r4, #8]
 800c086:	6063      	str	r3, [r4, #4]
 800c088:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800c08c:	f855 6c04 	ldr.w	r6, [r5, #-4]
 800c090:	f855 bc08 	ldr.w	fp, [r5, #-8]
 800c094:	ea4f 0a96 	mov.w	sl, r6, lsr #2
 800c098:	f04f 0900 	mov.w	r9, #0
 800c09c:	45ca      	cmp	sl, r9
 800c09e:	dc05      	bgt.n	800c0ac <__sprint_r+0x4e>
 800c0a0:	68a3      	ldr	r3, [r4, #8]
 800c0a2:	f026 0603 	bic.w	r6, r6, #3
 800c0a6:	1b9e      	subs	r6, r3, r6
 800c0a8:	60a6      	str	r6, [r4, #8]
 800c0aa:	e7e7      	b.n	800c07c <__sprint_r+0x1e>
 800c0ac:	463a      	mov	r2, r7
 800c0ae:	f85b 1029 	ldr.w	r1, [fp, r9, lsl #2]
 800c0b2:	4640      	mov	r0, r8
 800c0b4:	f000 f913 	bl	800c2de <_fputwc_r>
 800c0b8:	1c43      	adds	r3, r0, #1
 800c0ba:	d0e2      	beq.n	800c082 <__sprint_r+0x24>
 800c0bc:	f109 0901 	add.w	r9, r9, #1
 800c0c0:	e7ec      	b.n	800c09c <__sprint_r+0x3e>
 800c0c2:	f7ff f897 	bl	800b1f4 <__sfvwrite_r>
 800c0c6:	e7dc      	b.n	800c082 <__sprint_r+0x24>

0800c0c8 <__ascii_wctomb>:
 800c0c8:	b149      	cbz	r1, 800c0de <__ascii_wctomb+0x16>
 800c0ca:	2aff      	cmp	r2, #255	; 0xff
 800c0cc:	bf85      	ittet	hi
 800c0ce:	238a      	movhi	r3, #138	; 0x8a
 800c0d0:	6003      	strhi	r3, [r0, #0]
 800c0d2:	700a      	strbls	r2, [r1, #0]
 800c0d4:	f04f 30ff 	movhi.w	r0, #4294967295
 800c0d8:	bf98      	it	ls
 800c0da:	2001      	movls	r0, #1
 800c0dc:	4770      	bx	lr
 800c0de:	4608      	mov	r0, r1
 800c0e0:	4770      	bx	lr
	...

0800c0e4 <_write_r>:
 800c0e4:	b538      	push	{r3, r4, r5, lr}
 800c0e6:	4c07      	ldr	r4, [pc, #28]	; (800c104 <_write_r+0x20>)
 800c0e8:	4605      	mov	r5, r0
 800c0ea:	4608      	mov	r0, r1
 800c0ec:	4611      	mov	r1, r2
 800c0ee:	2200      	movs	r2, #0
 800c0f0:	6022      	str	r2, [r4, #0]
 800c0f2:	461a      	mov	r2, r3
 800c0f4:	f7fb fa73 	bl	80075de <_write>
 800c0f8:	1c43      	adds	r3, r0, #1
 800c0fa:	d102      	bne.n	800c102 <_write_r+0x1e>
 800c0fc:	6823      	ldr	r3, [r4, #0]
 800c0fe:	b103      	cbz	r3, 800c102 <_write_r+0x1e>
 800c100:	602b      	str	r3, [r5, #0]
 800c102:	bd38      	pop	{r3, r4, r5, pc}
 800c104:	20008d78 	.word	0x20008d78

0800c108 <_calloc_r>:
 800c108:	b510      	push	{r4, lr}
 800c10a:	4351      	muls	r1, r2
 800c10c:	f7fb fb20 	bl	8007750 <_malloc_r>
 800c110:	4604      	mov	r4, r0
 800c112:	b198      	cbz	r0, 800c13c <_calloc_r+0x34>
 800c114:	f850 2c04 	ldr.w	r2, [r0, #-4]
 800c118:	f022 0203 	bic.w	r2, r2, #3
 800c11c:	3a04      	subs	r2, #4
 800c11e:	2a24      	cmp	r2, #36	; 0x24
 800c120:	d81b      	bhi.n	800c15a <_calloc_r+0x52>
 800c122:	2a13      	cmp	r2, #19
 800c124:	d917      	bls.n	800c156 <_calloc_r+0x4e>
 800c126:	2100      	movs	r1, #0
 800c128:	2a1b      	cmp	r2, #27
 800c12a:	6001      	str	r1, [r0, #0]
 800c12c:	6041      	str	r1, [r0, #4]
 800c12e:	d807      	bhi.n	800c140 <_calloc_r+0x38>
 800c130:	f100 0308 	add.w	r3, r0, #8
 800c134:	2200      	movs	r2, #0
 800c136:	601a      	str	r2, [r3, #0]
 800c138:	605a      	str	r2, [r3, #4]
 800c13a:	609a      	str	r2, [r3, #8]
 800c13c:	4620      	mov	r0, r4
 800c13e:	bd10      	pop	{r4, pc}
 800c140:	2a24      	cmp	r2, #36	; 0x24
 800c142:	6081      	str	r1, [r0, #8]
 800c144:	60c1      	str	r1, [r0, #12]
 800c146:	bf11      	iteee	ne
 800c148:	f100 0310 	addne.w	r3, r0, #16
 800c14c:	6101      	streq	r1, [r0, #16]
 800c14e:	f100 0318 	addeq.w	r3, r0, #24
 800c152:	6141      	streq	r1, [r0, #20]
 800c154:	e7ee      	b.n	800c134 <_calloc_r+0x2c>
 800c156:	4603      	mov	r3, r0
 800c158:	e7ec      	b.n	800c134 <_calloc_r+0x2c>
 800c15a:	2100      	movs	r1, #0
 800c15c:	f7fb fd11 	bl	8007b82 <memset>
 800c160:	e7ec      	b.n	800c13c <_calloc_r+0x34>
	...

0800c164 <_close_r>:
 800c164:	b538      	push	{r3, r4, r5, lr}
 800c166:	4c06      	ldr	r4, [pc, #24]	; (800c180 <_close_r+0x1c>)
 800c168:	2300      	movs	r3, #0
 800c16a:	4605      	mov	r5, r0
 800c16c:	4608      	mov	r0, r1
 800c16e:	6023      	str	r3, [r4, #0]
 800c170:	f7fb fa5e 	bl	8007630 <_close>
 800c174:	1c43      	adds	r3, r0, #1
 800c176:	d102      	bne.n	800c17e <_close_r+0x1a>
 800c178:	6823      	ldr	r3, [r4, #0]
 800c17a:	b103      	cbz	r3, 800c17e <_close_r+0x1a>
 800c17c:	602b      	str	r3, [r5, #0]
 800c17e:	bd38      	pop	{r3, r4, r5, pc}
 800c180:	20008d78 	.word	0x20008d78

0800c184 <_fclose_r>:
 800c184:	b570      	push	{r4, r5, r6, lr}
 800c186:	4605      	mov	r5, r0
 800c188:	460c      	mov	r4, r1
 800c18a:	b911      	cbnz	r1, 800c192 <_fclose_r+0xe>
 800c18c:	2600      	movs	r6, #0
 800c18e:	4630      	mov	r0, r6
 800c190:	bd70      	pop	{r4, r5, r6, pc}
 800c192:	b118      	cbz	r0, 800c19c <_fclose_r+0x18>
 800c194:	6983      	ldr	r3, [r0, #24]
 800c196:	b90b      	cbnz	r3, 800c19c <_fclose_r+0x18>
 800c198:	f7fe fe9a 	bl	800aed0 <__sinit>
 800c19c:	4b2c      	ldr	r3, [pc, #176]	; (800c250 <_fclose_r+0xcc>)
 800c19e:	429c      	cmp	r4, r3
 800c1a0:	d114      	bne.n	800c1cc <_fclose_r+0x48>
 800c1a2:	686c      	ldr	r4, [r5, #4]
 800c1a4:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800c1a6:	07d8      	lsls	r0, r3, #31
 800c1a8:	d405      	bmi.n	800c1b6 <_fclose_r+0x32>
 800c1aa:	89a3      	ldrh	r3, [r4, #12]
 800c1ac:	0599      	lsls	r1, r3, #22
 800c1ae:	d402      	bmi.n	800c1b6 <_fclose_r+0x32>
 800c1b0:	6da0      	ldr	r0, [r4, #88]	; 0x58
 800c1b2:	f7ff f9ad 	bl	800b510 <__retarget_lock_acquire_recursive>
 800c1b6:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800c1ba:	b98b      	cbnz	r3, 800c1e0 <_fclose_r+0x5c>
 800c1bc:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c1be:	f016 0601 	ands.w	r6, r6, #1
 800c1c2:	d1e3      	bne.n	800c18c <_fclose_r+0x8>
 800c1c4:	6da0      	ldr	r0, [r4, #88]	; 0x58
 800c1c6:	f7ff f9a4 	bl	800b512 <__retarget_lock_release_recursive>
 800c1ca:	e7e0      	b.n	800c18e <_fclose_r+0xa>
 800c1cc:	4b21      	ldr	r3, [pc, #132]	; (800c254 <_fclose_r+0xd0>)
 800c1ce:	429c      	cmp	r4, r3
 800c1d0:	d101      	bne.n	800c1d6 <_fclose_r+0x52>
 800c1d2:	68ac      	ldr	r4, [r5, #8]
 800c1d4:	e7e6      	b.n	800c1a4 <_fclose_r+0x20>
 800c1d6:	4b20      	ldr	r3, [pc, #128]	; (800c258 <_fclose_r+0xd4>)
 800c1d8:	429c      	cmp	r4, r3
 800c1da:	bf08      	it	eq
 800c1dc:	68ec      	ldreq	r4, [r5, #12]
 800c1de:	e7e1      	b.n	800c1a4 <_fclose_r+0x20>
 800c1e0:	4621      	mov	r1, r4
 800c1e2:	4628      	mov	r0, r5
 800c1e4:	f7fe fd4e 	bl	800ac84 <__sflush_r>
 800c1e8:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800c1ea:	4606      	mov	r6, r0
 800c1ec:	b133      	cbz	r3, 800c1fc <_fclose_r+0x78>
 800c1ee:	6a21      	ldr	r1, [r4, #32]
 800c1f0:	4628      	mov	r0, r5
 800c1f2:	4798      	blx	r3
 800c1f4:	2800      	cmp	r0, #0
 800c1f6:	bfb8      	it	lt
 800c1f8:	f04f 36ff 	movlt.w	r6, #4294967295
 800c1fc:	89a3      	ldrh	r3, [r4, #12]
 800c1fe:	061a      	lsls	r2, r3, #24
 800c200:	d503      	bpl.n	800c20a <_fclose_r+0x86>
 800c202:	6921      	ldr	r1, [r4, #16]
 800c204:	4628      	mov	r0, r5
 800c206:	f7fe ff39 	bl	800b07c <_free_r>
 800c20a:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800c20c:	b141      	cbz	r1, 800c220 <_fclose_r+0x9c>
 800c20e:	f104 0344 	add.w	r3, r4, #68	; 0x44
 800c212:	4299      	cmp	r1, r3
 800c214:	d002      	beq.n	800c21c <_fclose_r+0x98>
 800c216:	4628      	mov	r0, r5
 800c218:	f7fe ff30 	bl	800b07c <_free_r>
 800c21c:	2300      	movs	r3, #0
 800c21e:	6363      	str	r3, [r4, #52]	; 0x34
 800c220:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 800c222:	b121      	cbz	r1, 800c22e <_fclose_r+0xaa>
 800c224:	4628      	mov	r0, r5
 800c226:	f7fe ff29 	bl	800b07c <_free_r>
 800c22a:	2300      	movs	r3, #0
 800c22c:	64a3      	str	r3, [r4, #72]	; 0x48
 800c22e:	f7fe fe37 	bl	800aea0 <__sfp_lock_acquire>
 800c232:	2300      	movs	r3, #0
 800c234:	81a3      	strh	r3, [r4, #12]
 800c236:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800c238:	07db      	lsls	r3, r3, #31
 800c23a:	d402      	bmi.n	800c242 <_fclose_r+0xbe>
 800c23c:	6da0      	ldr	r0, [r4, #88]	; 0x58
 800c23e:	f7ff f968 	bl	800b512 <__retarget_lock_release_recursive>
 800c242:	6da0      	ldr	r0, [r4, #88]	; 0x58
 800c244:	f7ff f963 	bl	800b50e <__retarget_lock_close_recursive>
 800c248:	f7fe fe30 	bl	800aeac <__sfp_lock_release>
 800c24c:	e79f      	b.n	800c18e <_fclose_r+0xa>
 800c24e:	bf00      	nop
 800c250:	0800d290 	.word	0x0800d290
 800c254:	0800d2b0 	.word	0x0800d2b0
 800c258:	0800d270 	.word	0x0800d270

0800c25c <__fputwc>:
 800c25c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 800c260:	4680      	mov	r8, r0
 800c262:	460e      	mov	r6, r1
 800c264:	4614      	mov	r4, r2
 800c266:	f7ff f931 	bl	800b4cc <__locale_mb_cur_max>
 800c26a:	2801      	cmp	r0, #1
 800c26c:	d11c      	bne.n	800c2a8 <__fputwc+0x4c>
 800c26e:	1e73      	subs	r3, r6, #1
 800c270:	2bfe      	cmp	r3, #254	; 0xfe
 800c272:	d819      	bhi.n	800c2a8 <__fputwc+0x4c>
 800c274:	f88d 6004 	strb.w	r6, [sp, #4]
 800c278:	4605      	mov	r5, r0
 800c27a:	2700      	movs	r7, #0
 800c27c:	f10d 0904 	add.w	r9, sp, #4
 800c280:	42af      	cmp	r7, r5
 800c282:	d020      	beq.n	800c2c6 <__fputwc+0x6a>
 800c284:	68a3      	ldr	r3, [r4, #8]
 800c286:	f817 1009 	ldrb.w	r1, [r7, r9]
 800c28a:	3b01      	subs	r3, #1
 800c28c:	2b00      	cmp	r3, #0
 800c28e:	60a3      	str	r3, [r4, #8]
 800c290:	da04      	bge.n	800c29c <__fputwc+0x40>
 800c292:	69a2      	ldr	r2, [r4, #24]
 800c294:	4293      	cmp	r3, r2
 800c296:	db1a      	blt.n	800c2ce <__fputwc+0x72>
 800c298:	290a      	cmp	r1, #10
 800c29a:	d018      	beq.n	800c2ce <__fputwc+0x72>
 800c29c:	6823      	ldr	r3, [r4, #0]
 800c29e:	1c5a      	adds	r2, r3, #1
 800c2a0:	6022      	str	r2, [r4, #0]
 800c2a2:	7019      	strb	r1, [r3, #0]
 800c2a4:	3701      	adds	r7, #1
 800c2a6:	e7eb      	b.n	800c280 <__fputwc+0x24>
 800c2a8:	4632      	mov	r2, r6
 800c2aa:	f104 035c 	add.w	r3, r4, #92	; 0x5c
 800c2ae:	a901      	add	r1, sp, #4
 800c2b0:	4640      	mov	r0, r8
 800c2b2:	f000 f8e1 	bl	800c478 <_wcrtomb_r>
 800c2b6:	1c42      	adds	r2, r0, #1
 800c2b8:	4605      	mov	r5, r0
 800c2ba:	d1de      	bne.n	800c27a <__fputwc+0x1e>
 800c2bc:	89a3      	ldrh	r3, [r4, #12]
 800c2be:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800c2c2:	81a3      	strh	r3, [r4, #12]
 800c2c4:	4606      	mov	r6, r0
 800c2c6:	4630      	mov	r0, r6
 800c2c8:	b003      	add	sp, #12
 800c2ca:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800c2ce:	4622      	mov	r2, r4
 800c2d0:	4640      	mov	r0, r8
 800c2d2:	f000 f873 	bl	800c3bc <__swbuf_r>
 800c2d6:	1c43      	adds	r3, r0, #1
 800c2d8:	d1e4      	bne.n	800c2a4 <__fputwc+0x48>
 800c2da:	4606      	mov	r6, r0
 800c2dc:	e7f3      	b.n	800c2c6 <__fputwc+0x6a>

0800c2de <_fputwc_r>:
 800c2de:	6e53      	ldr	r3, [r2, #100]	; 0x64
 800c2e0:	07db      	lsls	r3, r3, #31
 800c2e2:	b570      	push	{r4, r5, r6, lr}
 800c2e4:	4605      	mov	r5, r0
 800c2e6:	460e      	mov	r6, r1
 800c2e8:	4614      	mov	r4, r2
 800c2ea:	d405      	bmi.n	800c2f8 <_fputwc_r+0x1a>
 800c2ec:	8993      	ldrh	r3, [r2, #12]
 800c2ee:	0598      	lsls	r0, r3, #22
 800c2f0:	d402      	bmi.n	800c2f8 <_fputwc_r+0x1a>
 800c2f2:	6d90      	ldr	r0, [r2, #88]	; 0x58
 800c2f4:	f7ff f90c 	bl	800b510 <__retarget_lock_acquire_recursive>
 800c2f8:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800c2fc:	0499      	lsls	r1, r3, #18
 800c2fe:	d406      	bmi.n	800c30e <_fputwc_r+0x30>
 800c300:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800c304:	81a3      	strh	r3, [r4, #12]
 800c306:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800c308:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800c30c:	6663      	str	r3, [r4, #100]	; 0x64
 800c30e:	4622      	mov	r2, r4
 800c310:	4628      	mov	r0, r5
 800c312:	4631      	mov	r1, r6
 800c314:	f7ff ffa2 	bl	800c25c <__fputwc>
 800c318:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800c31a:	07da      	lsls	r2, r3, #31
 800c31c:	4605      	mov	r5, r0
 800c31e:	d405      	bmi.n	800c32c <_fputwc_r+0x4e>
 800c320:	89a3      	ldrh	r3, [r4, #12]
 800c322:	059b      	lsls	r3, r3, #22
 800c324:	d402      	bmi.n	800c32c <_fputwc_r+0x4e>
 800c326:	6da0      	ldr	r0, [r4, #88]	; 0x58
 800c328:	f7ff f8f3 	bl	800b512 <__retarget_lock_release_recursive>
 800c32c:	4628      	mov	r0, r5
 800c32e:	bd70      	pop	{r4, r5, r6, pc}

0800c330 <_fstat_r>:
 800c330:	b538      	push	{r3, r4, r5, lr}
 800c332:	4c07      	ldr	r4, [pc, #28]	; (800c350 <_fstat_r+0x20>)
 800c334:	2300      	movs	r3, #0
 800c336:	4605      	mov	r5, r0
 800c338:	4608      	mov	r0, r1
 800c33a:	4611      	mov	r1, r2
 800c33c:	6023      	str	r3, [r4, #0]
 800c33e:	f7fb f97a 	bl	8007636 <_fstat>
 800c342:	1c43      	adds	r3, r0, #1
 800c344:	d102      	bne.n	800c34c <_fstat_r+0x1c>
 800c346:	6823      	ldr	r3, [r4, #0]
 800c348:	b103      	cbz	r3, 800c34c <_fstat_r+0x1c>
 800c34a:	602b      	str	r3, [r5, #0]
 800c34c:	bd38      	pop	{r3, r4, r5, pc}
 800c34e:	bf00      	nop
 800c350:	20008d78 	.word	0x20008d78

0800c354 <_isatty_r>:
 800c354:	b538      	push	{r3, r4, r5, lr}
 800c356:	4c06      	ldr	r4, [pc, #24]	; (800c370 <_isatty_r+0x1c>)
 800c358:	2300      	movs	r3, #0
 800c35a:	4605      	mov	r5, r0
 800c35c:	4608      	mov	r0, r1
 800c35e:	6023      	str	r3, [r4, #0]
 800c360:	f7fb f96e 	bl	8007640 <_isatty>
 800c364:	1c43      	adds	r3, r0, #1
 800c366:	d102      	bne.n	800c36e <_isatty_r+0x1a>
 800c368:	6823      	ldr	r3, [r4, #0]
 800c36a:	b103      	cbz	r3, 800c36e <_isatty_r+0x1a>
 800c36c:	602b      	str	r3, [r5, #0]
 800c36e:	bd38      	pop	{r3, r4, r5, pc}
 800c370:	20008d78 	.word	0x20008d78

0800c374 <_lseek_r>:
 800c374:	b538      	push	{r3, r4, r5, lr}
 800c376:	4c07      	ldr	r4, [pc, #28]	; (800c394 <_lseek_r+0x20>)
 800c378:	4605      	mov	r5, r0
 800c37a:	4608      	mov	r0, r1
 800c37c:	4611      	mov	r1, r2
 800c37e:	2200      	movs	r2, #0
 800c380:	6022      	str	r2, [r4, #0]
 800c382:	461a      	mov	r2, r3
 800c384:	f7fb f95e 	bl	8007644 <_lseek>
 800c388:	1c43      	adds	r3, r0, #1
 800c38a:	d102      	bne.n	800c392 <_lseek_r+0x1e>
 800c38c:	6823      	ldr	r3, [r4, #0]
 800c38e:	b103      	cbz	r3, 800c392 <_lseek_r+0x1e>
 800c390:	602b      	str	r3, [r5, #0]
 800c392:	bd38      	pop	{r3, r4, r5, pc}
 800c394:	20008d78 	.word	0x20008d78

0800c398 <_read_r>:
 800c398:	b538      	push	{r3, r4, r5, lr}
 800c39a:	4c07      	ldr	r4, [pc, #28]	; (800c3b8 <_read_r+0x20>)
 800c39c:	4605      	mov	r5, r0
 800c39e:	4608      	mov	r0, r1
 800c3a0:	4611      	mov	r1, r2
 800c3a2:	2200      	movs	r2, #0
 800c3a4:	6022      	str	r2, [r4, #0]
 800c3a6:	461a      	mov	r2, r3
 800c3a8:	f7fb f90b 	bl	80075c2 <_read>
 800c3ac:	1c43      	adds	r3, r0, #1
 800c3ae:	d102      	bne.n	800c3b6 <_read_r+0x1e>
 800c3b0:	6823      	ldr	r3, [r4, #0]
 800c3b2:	b103      	cbz	r3, 800c3b6 <_read_r+0x1e>
 800c3b4:	602b      	str	r3, [r5, #0]
 800c3b6:	bd38      	pop	{r3, r4, r5, pc}
 800c3b8:	20008d78 	.word	0x20008d78

0800c3bc <__swbuf_r>:
 800c3bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c3be:	460e      	mov	r6, r1
 800c3c0:	4614      	mov	r4, r2
 800c3c2:	4605      	mov	r5, r0
 800c3c4:	b118      	cbz	r0, 800c3ce <__swbuf_r+0x12>
 800c3c6:	6983      	ldr	r3, [r0, #24]
 800c3c8:	b90b      	cbnz	r3, 800c3ce <__swbuf_r+0x12>
 800c3ca:	f7fe fd81 	bl	800aed0 <__sinit>
 800c3ce:	4b27      	ldr	r3, [pc, #156]	; (800c46c <__swbuf_r+0xb0>)
 800c3d0:	429c      	cmp	r4, r3
 800c3d2:	d12f      	bne.n	800c434 <__swbuf_r+0x78>
 800c3d4:	686c      	ldr	r4, [r5, #4]
 800c3d6:	69a3      	ldr	r3, [r4, #24]
 800c3d8:	60a3      	str	r3, [r4, #8]
 800c3da:	89a3      	ldrh	r3, [r4, #12]
 800c3dc:	0719      	lsls	r1, r3, #28
 800c3de:	d533      	bpl.n	800c448 <__swbuf_r+0x8c>
 800c3e0:	6923      	ldr	r3, [r4, #16]
 800c3e2:	2b00      	cmp	r3, #0
 800c3e4:	d030      	beq.n	800c448 <__swbuf_r+0x8c>
 800c3e6:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800c3ea:	b2f6      	uxtb	r6, r6
 800c3ec:	049a      	lsls	r2, r3, #18
 800c3ee:	4637      	mov	r7, r6
 800c3f0:	d534      	bpl.n	800c45c <__swbuf_r+0xa0>
 800c3f2:	6923      	ldr	r3, [r4, #16]
 800c3f4:	6820      	ldr	r0, [r4, #0]
 800c3f6:	1ac0      	subs	r0, r0, r3
 800c3f8:	6963      	ldr	r3, [r4, #20]
 800c3fa:	4298      	cmp	r0, r3
 800c3fc:	db04      	blt.n	800c408 <__swbuf_r+0x4c>
 800c3fe:	4621      	mov	r1, r4
 800c400:	4628      	mov	r0, r5
 800c402:	f7fe fcd1 	bl	800ada8 <_fflush_r>
 800c406:	bb28      	cbnz	r0, 800c454 <__swbuf_r+0x98>
 800c408:	68a3      	ldr	r3, [r4, #8]
 800c40a:	3b01      	subs	r3, #1
 800c40c:	60a3      	str	r3, [r4, #8]
 800c40e:	6823      	ldr	r3, [r4, #0]
 800c410:	1c5a      	adds	r2, r3, #1
 800c412:	6022      	str	r2, [r4, #0]
 800c414:	701e      	strb	r6, [r3, #0]
 800c416:	6963      	ldr	r3, [r4, #20]
 800c418:	3001      	adds	r0, #1
 800c41a:	4298      	cmp	r0, r3
 800c41c:	d004      	beq.n	800c428 <__swbuf_r+0x6c>
 800c41e:	89a3      	ldrh	r3, [r4, #12]
 800c420:	07db      	lsls	r3, r3, #31
 800c422:	d519      	bpl.n	800c458 <__swbuf_r+0x9c>
 800c424:	2e0a      	cmp	r6, #10
 800c426:	d117      	bne.n	800c458 <__swbuf_r+0x9c>
 800c428:	4621      	mov	r1, r4
 800c42a:	4628      	mov	r0, r5
 800c42c:	f7fe fcbc 	bl	800ada8 <_fflush_r>
 800c430:	b190      	cbz	r0, 800c458 <__swbuf_r+0x9c>
 800c432:	e00f      	b.n	800c454 <__swbuf_r+0x98>
 800c434:	4b0e      	ldr	r3, [pc, #56]	; (800c470 <__swbuf_r+0xb4>)
 800c436:	429c      	cmp	r4, r3
 800c438:	d101      	bne.n	800c43e <__swbuf_r+0x82>
 800c43a:	68ac      	ldr	r4, [r5, #8]
 800c43c:	e7cb      	b.n	800c3d6 <__swbuf_r+0x1a>
 800c43e:	4b0d      	ldr	r3, [pc, #52]	; (800c474 <__swbuf_r+0xb8>)
 800c440:	429c      	cmp	r4, r3
 800c442:	bf08      	it	eq
 800c444:	68ec      	ldreq	r4, [r5, #12]
 800c446:	e7c6      	b.n	800c3d6 <__swbuf_r+0x1a>
 800c448:	4621      	mov	r1, r4
 800c44a:	4628      	mov	r0, r5
 800c44c:	f7fd fd50 	bl	8009ef0 <__swsetup_r>
 800c450:	2800      	cmp	r0, #0
 800c452:	d0c8      	beq.n	800c3e6 <__swbuf_r+0x2a>
 800c454:	f04f 37ff 	mov.w	r7, #4294967295
 800c458:	4638      	mov	r0, r7
 800c45a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c45c:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800c460:	81a3      	strh	r3, [r4, #12]
 800c462:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800c464:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 800c468:	6663      	str	r3, [r4, #100]	; 0x64
 800c46a:	e7c2      	b.n	800c3f2 <__swbuf_r+0x36>
 800c46c:	0800d290 	.word	0x0800d290
 800c470:	0800d2b0 	.word	0x0800d2b0
 800c474:	0800d270 	.word	0x0800d270

0800c478 <_wcrtomb_r>:
 800c478:	b5f0      	push	{r4, r5, r6, r7, lr}
 800c47a:	4605      	mov	r5, r0
 800c47c:	b085      	sub	sp, #20
 800c47e:	461e      	mov	r6, r3
 800c480:	460f      	mov	r7, r1
 800c482:	4c0f      	ldr	r4, [pc, #60]	; (800c4c0 <_wcrtomb_r+0x48>)
 800c484:	b991      	cbnz	r1, 800c4ac <_wcrtomb_r+0x34>
 800c486:	6822      	ldr	r2, [r4, #0]
 800c488:	490e      	ldr	r1, [pc, #56]	; (800c4c4 <_wcrtomb_r+0x4c>)
 800c48a:	6a12      	ldr	r2, [r2, #32]
 800c48c:	2a00      	cmp	r2, #0
 800c48e:	bf08      	it	eq
 800c490:	460a      	moveq	r2, r1
 800c492:	a901      	add	r1, sp, #4
 800c494:	f8d2 40e0 	ldr.w	r4, [r2, #224]	; 0xe0
 800c498:	463a      	mov	r2, r7
 800c49a:	47a0      	blx	r4
 800c49c:	1c43      	adds	r3, r0, #1
 800c49e:	bf01      	itttt	eq
 800c4a0:	2300      	moveq	r3, #0
 800c4a2:	6033      	streq	r3, [r6, #0]
 800c4a4:	238a      	moveq	r3, #138	; 0x8a
 800c4a6:	602b      	streq	r3, [r5, #0]
 800c4a8:	b005      	add	sp, #20
 800c4aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800c4ac:	6824      	ldr	r4, [r4, #0]
 800c4ae:	4f05      	ldr	r7, [pc, #20]	; (800c4c4 <_wcrtomb_r+0x4c>)
 800c4b0:	6a24      	ldr	r4, [r4, #32]
 800c4b2:	2c00      	cmp	r4, #0
 800c4b4:	bf08      	it	eq
 800c4b6:	463c      	moveq	r4, r7
 800c4b8:	f8d4 40e0 	ldr.w	r4, [r4, #224]	; 0xe0
 800c4bc:	e7ed      	b.n	800c49a <_wcrtomb_r+0x22>
 800c4be:	bf00      	nop
 800c4c0:	2000005c 	.word	0x2000005c
 800c4c4:	20000560 	.word	0x20000560

0800c4c8 <_init>:
 800c4c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c4ca:	bf00      	nop
 800c4cc:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800c4ce:	bc08      	pop	{r3}
 800c4d0:	469e      	mov	lr, r3
 800c4d2:	4770      	bx	lr

0800c4d4 <_fini>:
 800c4d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c4d6:	bf00      	nop
 800c4d8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800c4da:	bc08      	pop	{r3}
 800c4dc:	469e      	mov	lr, r3
 800c4de:	4770      	bx	lr
